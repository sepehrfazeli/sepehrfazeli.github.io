"use strict";(self.webpackChunkwww=self.webpackChunkwww||[]).push([[737],{3456:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "ACESFilmicToneMapping": function() { return /* binding */ ACESFilmicToneMapping; },\n/* harmony export */   "AddEquation": function() { return /* binding */ AddEquation; },\n/* harmony export */   "AddOperation": function() { return /* binding */ AddOperation; },\n/* harmony export */   "AdditiveAnimationBlendMode": function() { return /* binding */ AdditiveAnimationBlendMode; },\n/* harmony export */   "AdditiveBlending": function() { return /* binding */ AdditiveBlending; },\n/* harmony export */   "AlphaFormat": function() { return /* binding */ AlphaFormat; },\n/* harmony export */   "AlwaysDepth": function() { return /* binding */ AlwaysDepth; },\n/* harmony export */   "AlwaysStencilFunc": function() { return /* binding */ AlwaysStencilFunc; },\n/* harmony export */   "AmbientLight": function() { return /* binding */ AmbientLight; },\n/* harmony export */   "AmbientLightProbe": function() { return /* binding */ AmbientLightProbe; },\n/* harmony export */   "AnimationClip": function() { return /* binding */ AnimationClip; },\n/* harmony export */   "AnimationLoader": function() { return /* binding */ AnimationLoader; },\n/* harmony export */   "AnimationMixer": function() { return /* binding */ AnimationMixer; },\n/* harmony export */   "AnimationObjectGroup": function() { return /* binding */ AnimationObjectGroup; },\n/* harmony export */   "AnimationUtils": function() { return /* binding */ AnimationUtils; },\n/* harmony export */   "ArcCurve": function() { return /* binding */ ArcCurve; },\n/* harmony export */   "ArrayCamera": function() { return /* binding */ ArrayCamera; },\n/* harmony export */   "ArrowHelper": function() { return /* binding */ ArrowHelper; },\n/* harmony export */   "Audio": function() { return /* binding */ Audio; },\n/* harmony export */   "AudioAnalyser": function() { return /* binding */ AudioAnalyser; },\n/* harmony export */   "AudioContext": function() { return /* binding */ AudioContext; },\n/* harmony export */   "AudioListener": function() { return /* binding */ AudioListener; },\n/* harmony export */   "AudioLoader": function() { return /* binding */ AudioLoader; },\n/* harmony export */   "AxesHelper": function() { return /* binding */ AxesHelper; },\n/* harmony export */   "BackSide": function() { return /* binding */ BackSide; },\n/* harmony export */   "BasicDepthPacking": function() { return /* binding */ BasicDepthPacking; },\n/* harmony export */   "BasicShadowMap": function() { return /* binding */ BasicShadowMap; },\n/* harmony export */   "Bone": function() { return /* binding */ Bone; },\n/* harmony export */   "BooleanKeyframeTrack": function() { return /* binding */ BooleanKeyframeTrack; },\n/* harmony export */   "Box2": function() { return /* binding */ Box2; },\n/* harmony export */   "Box3": function() { return /* binding */ Box3; },\n/* harmony export */   "Box3Helper": function() { return /* binding */ Box3Helper; },\n/* harmony export */   "BoxBufferGeometry": function() { return /* binding */ BoxGeometry; },\n/* harmony export */   "BoxGeometry": function() { return /* binding */ BoxGeometry; },\n/* harmony export */   "BoxHelper": function() { return /* binding */ BoxHelper; },\n/* harmony export */   "BufferAttribute": function() { return /* binding */ BufferAttribute; },\n/* harmony export */   "BufferGeometry": function() { return /* binding */ BufferGeometry; },\n/* harmony export */   "BufferGeometryLoader": function() { return /* binding */ BufferGeometryLoader; },\n/* harmony export */   "ByteType": function() { return /* binding */ ByteType; },\n/* harmony export */   "Cache": function() { return /* binding */ Cache; },\n/* harmony export */   "Camera": function() { return /* binding */ Camera; },\n/* harmony export */   "CameraHelper": function() { return /* binding */ CameraHelper; },\n/* harmony export */   "CanvasTexture": function() { return /* binding */ CanvasTexture; },\n/* harmony export */   "CapsuleBufferGeometry": function() { return /* binding */ CapsuleGeometry; },\n/* harmony export */   "CapsuleGeometry": function() { return /* binding */ CapsuleGeometry; },\n/* harmony export */   "CatmullRomCurve3": function() { return /* binding */ CatmullRomCurve3; },\n/* harmony export */   "CineonToneMapping": function() { return /* binding */ CineonToneMapping; },\n/* harmony export */   "CircleBufferGeometry": function() { return /* binding */ CircleGeometry; },\n/* harmony export */   "CircleGeometry": function() { return /* binding */ CircleGeometry; },\n/* harmony export */   "ClampToEdgeWrapping": function() { return /* binding */ ClampToEdgeWrapping; },\n/* harmony export */   "Clock": function() { return /* binding */ Clock; },\n/* harmony export */   "Color": function() { return /* binding */ Color; },\n/* harmony export */   "ColorKeyframeTrack": function() { return /* binding */ ColorKeyframeTrack; },\n/* harmony export */   "ColorManagement": function() { return /* binding */ ColorManagement; },\n/* harmony export */   "CompressedTexture": function() { return /* binding */ CompressedTexture; },\n/* harmony export */   "CompressedTextureLoader": function() { return /* binding */ CompressedTextureLoader; },\n/* harmony export */   "ConeBufferGeometry": function() { return /* binding */ ConeGeometry; },\n/* harmony export */   "ConeGeometry": function() { return /* binding */ ConeGeometry; },\n/* harmony export */   "CubeCamera": function() { return /* binding */ CubeCamera; },\n/* harmony export */   "CubeReflectionMapping": function() { return /* binding */ CubeReflectionMapping; },\n/* harmony export */   "CubeRefractionMapping": function() { return /* binding */ CubeRefractionMapping; },\n/* harmony export */   "CubeTexture": function() { return /* binding */ CubeTexture; },\n/* harmony export */   "CubeTextureLoader": function() { return /* binding */ CubeTextureLoader; },\n/* harmony export */   "CubeUVReflectionMapping": function() { return /* binding */ CubeUVReflectionMapping; },\n/* harmony export */   "CubicBezierCurve": function() { return /* binding */ CubicBezierCurve; },\n/* harmony export */   "CubicBezierCurve3": function() { return /* binding */ CubicBezierCurve3; },\n/* harmony export */   "CubicInterpolant": function() { return /* binding */ CubicInterpolant; },\n/* harmony export */   "CullFaceBack": function() { return /* binding */ CullFaceBack; },\n/* harmony export */   "CullFaceFront": function() { return /* binding */ CullFaceFront; },\n/* harmony export */   "CullFaceFrontBack": function() { return /* binding */ CullFaceFrontBack; },\n/* harmony export */   "CullFaceNone": function() { return /* binding */ CullFaceNone; },\n/* harmony export */   "Curve": function() { return /* binding */ Curve; },\n/* harmony export */   "CurvePath": function() { return /* binding */ CurvePath; },\n/* harmony export */   "CustomBlending": function() { return /* binding */ CustomBlending; },\n/* harmony export */   "CustomToneMapping": function() { return /* binding */ CustomToneMapping; },\n/* harmony export */   "CylinderBufferGeometry": function() { return /* binding */ CylinderGeometry; },\n/* harmony export */   "CylinderGeometry": function() { return /* binding */ CylinderGeometry; },\n/* harmony export */   "Cylindrical": function() { return /* binding */ Cylindrical; },\n/* harmony export */   "Data3DTexture": function() { return /* binding */ Data3DTexture; },\n/* harmony export */   "DataArrayTexture": function() { return /* binding */ DataArrayTexture; },\n/* harmony export */   "DataTexture": function() { return /* binding */ DataTexture; },\n/* harmony export */   "DataTexture2DArray": function() { return /* binding */ DataTexture2DArray; },\n/* harmony export */   "DataTexture3D": function() { return /* binding */ DataTexture3D; },\n/* harmony export */   "DataTextureLoader": function() { return /* binding */ DataTextureLoader; },\n/* harmony export */   "DataUtils": function() { return /* binding */ DataUtils; },\n/* harmony export */   "DecrementStencilOp": function() { return /* binding */ DecrementStencilOp; },\n/* harmony export */   "DecrementWrapStencilOp": function() { return /* binding */ DecrementWrapStencilOp; },\n/* harmony export */   "DefaultLoadingManager": function() { return /* binding */ DefaultLoadingManager; },\n/* harmony export */   "DepthFormat": function() { return /* binding */ DepthFormat; },\n/* harmony export */   "DepthStencilFormat": function() { return /* binding */ DepthStencilFormat; },\n/* harmony export */   "DepthTexture": function() { return /* binding */ DepthTexture; },\n/* harmony export */   "DirectionalLight": function() { return /* binding */ DirectionalLight; },\n/* harmony export */   "DirectionalLightHelper": function() { return /* binding */ DirectionalLightHelper; },\n/* harmony export */   "DiscreteInterpolant": function() { return /* binding */ DiscreteInterpolant; },\n/* harmony export */   "DodecahedronBufferGeometry": function() { return /* binding */ DodecahedronGeometry; },\n/* harmony export */   "DodecahedronGeometry": function() { return /* binding */ DodecahedronGeometry; },\n/* harmony export */   "DoubleSide": function() { return /* binding */ DoubleSide; },\n/* harmony export */   "DstAlphaFactor": function() { return /* binding */ DstAlphaFactor; },\n/* harmony export */   "DstColorFactor": function() { return /* binding */ DstColorFactor; },\n/* harmony export */   "DynamicCopyUsage": function() { return /* binding */ DynamicCopyUsage; },\n/* harmony export */   "DynamicDrawUsage": function() { return /* binding */ DynamicDrawUsage; },\n/* harmony export */   "DynamicReadUsage": function() { return /* binding */ DynamicReadUsage; },\n/* harmony export */   "EdgesGeometry": function() { return /* binding */ EdgesGeometry; },\n/* harmony export */   "EllipseCurve": function() { return /* binding */ EllipseCurve; },\n/* harmony export */   "EqualDepth": function() { return /* binding */ EqualDepth; },\n/* harmony export */   "EqualStencilFunc": function() { return /* binding */ EqualStencilFunc; },\n/* harmony export */   "EquirectangularReflectionMapping": function() { return /* binding */ EquirectangularReflectionMapping; },\n/* harmony export */   "EquirectangularRefractionMapping": function() { return /* binding */ EquirectangularRefractionMapping; },\n/* harmony export */   "Euler": function() { return /* binding */ Euler; },\n/* harmony export */   "EventDispatcher": function() { return /* binding */ EventDispatcher; },\n/* harmony export */   "ExtrudeBufferGeometry": function() { return /* binding */ ExtrudeGeometry; },\n/* harmony export */   "ExtrudeGeometry": function() { return /* binding */ ExtrudeGeometry; },\n/* harmony export */   "FileLoader": function() { return /* binding */ FileLoader; },\n/* harmony export */   "FlatShading": function() { return /* binding */ FlatShading; },\n/* harmony export */   "Float16BufferAttribute": function() { return /* binding */ Float16BufferAttribute; },\n/* harmony export */   "Float32BufferAttribute": function() { return /* binding */ Float32BufferAttribute; },\n/* harmony export */   "Float64BufferAttribute": function() { return /* binding */ Float64BufferAttribute; },\n/* harmony export */   "FloatType": function() { return /* binding */ FloatType; },\n/* harmony export */   "Fog": function() { return /* binding */ Fog; },\n/* harmony export */   "FogExp2": function() { return /* binding */ FogExp2; },\n/* harmony export */   "Font": function() { return /* binding */ Font; },\n/* harmony export */   "FontLoader": function() { return /* binding */ FontLoader; },\n/* harmony export */   "FramebufferTexture": function() { return /* binding */ FramebufferTexture; },\n/* harmony export */   "FrontSide": function() { return /* binding */ FrontSide; },\n/* harmony export */   "Frustum": function() { return /* binding */ Frustum; },\n/* harmony export */   "GLBufferAttribute": function() { return /* binding */ GLBufferAttribute; },\n/* harmony export */   "GLSL1": function() { return /* binding */ GLSL1; },\n/* harmony export */   "GLSL3": function() { return /* binding */ GLSL3; },\n/* harmony export */   "GreaterDepth": function() { return /* binding */ GreaterDepth; },\n/* harmony export */   "GreaterEqualDepth": function() { return /* binding */ GreaterEqualDepth; },\n/* harmony export */   "GreaterEqualStencilFunc": function() { return /* binding */ GreaterEqualStencilFunc; },\n/* harmony export */   "GreaterStencilFunc": function() { return /* binding */ GreaterStencilFunc; },\n/* harmony export */   "GridHelper": function() { return /* binding */ GridHelper; },\n/* harmony export */   "Group": function() { return /* binding */ Group; },\n/* harmony export */   "HalfFloatType": function() { return /* binding */ HalfFloatType; },\n/* harmony export */   "HemisphereLight": function() { return /* binding */ HemisphereLight; },\n/* harmony export */   "HemisphereLightHelper": function() { return /* binding */ HemisphereLightHelper; },\n/* harmony export */   "HemisphereLightProbe": function() { return /* binding */ HemisphereLightProbe; },\n/* harmony export */   "IcosahedronBufferGeometry": function() { return /* binding */ IcosahedronGeometry; },\n/* harmony export */   "IcosahedronGeometry": function() { return /* binding */ IcosahedronGeometry; },\n/* harmony export */   "ImageBitmapLoader": function() { return /* binding */ ImageBitmapLoader; },\n/* harmony export */   "ImageLoader": function() { return /* binding */ ImageLoader; },\n/* harmony export */   "ImageUtils": function() { return /* binding */ ImageUtils; },\n/* harmony export */   "ImmediateRenderObject": function() { return /* binding */ ImmediateRenderObject; },\n/* harmony export */   "IncrementStencilOp": function() { return /* binding */ IncrementStencilOp; },\n/* harmony export */   "IncrementWrapStencilOp": function() { return /* binding */ IncrementWrapStencilOp; },\n/* harmony export */   "InstancedBufferAttribute": function() { return /* binding */ InstancedBufferAttribute; },\n/* harmony export */   "InstancedBufferGeometry": function() { return /* binding */ InstancedBufferGeometry; },\n/* harmony export */   "InstancedInterleavedBuffer": function() { return /* binding */ InstancedInterleavedBuffer; },\n/* harmony export */   "InstancedMesh": function() { return /* binding */ InstancedMesh; },\n/* harmony export */   "Int16BufferAttribute": function() { return /* binding */ Int16BufferAttribute; },\n/* harmony export */   "Int32BufferAttribute": function() { return /* binding */ Int32BufferAttribute; },\n/* harmony export */   "Int8BufferAttribute": function() { return /* binding */ Int8BufferAttribute; },\n/* harmony export */   "IntType": function() { return /* binding */ IntType; },\n/* harmony export */   "InterleavedBuffer": function() { return /* binding */ InterleavedBuffer; },\n/* harmony export */   "InterleavedBufferAttribute": function() { return /* binding */ InterleavedBufferAttribute; },\n/* harmony export */   "Interpolant": function() { return /* binding */ Interpolant; },\n/* harmony export */   "InterpolateDiscrete": function() { return /* binding */ InterpolateDiscrete; },\n/* harmony export */   "InterpolateLinear": function() { return /* binding */ InterpolateLinear; },\n/* harmony export */   "InterpolateSmooth": function() { return /* binding */ InterpolateSmooth; },\n/* harmony export */   "InvertStencilOp": function() { return /* binding */ InvertStencilOp; },\n/* harmony export */   "KeepStencilOp": function() { return /* binding */ KeepStencilOp; },\n/* harmony export */   "KeyframeTrack": function() { return /* binding */ KeyframeTrack; },\n/* harmony export */   "LOD": function() { return /* binding */ LOD; },\n/* harmony export */   "LatheBufferGeometry": function() { return /* binding */ LatheGeometry; },\n/* harmony export */   "LatheGeometry": function() { return /* binding */ LatheGeometry; },\n/* harmony export */   "Layers": function() { return /* binding */ Layers; },\n/* harmony export */   "LessDepth": function() { return /* binding */ LessDepth; },\n/* harmony export */   "LessEqualDepth": function() { return /* binding */ LessEqualDepth; },\n/* harmony export */   "LessEqualStencilFunc": function() { return /* binding */ LessEqualStencilFunc; },\n/* harmony export */   "LessStencilFunc": function() { return /* binding */ LessStencilFunc; },\n/* harmony export */   "Light": function() { return /* binding */ Light; },\n/* harmony export */   "LightProbe": function() { return /* binding */ LightProbe; },\n/* harmony export */   "Line": function() { return /* binding */ Line; },\n/* harmony export */   "Line3": function() { return /* binding */ Line3; },\n/* harmony export */   "LineBasicMaterial": function() { return /* binding */ LineBasicMaterial; },\n/* harmony export */   "LineCurve": function() { return /* binding */ LineCurve; },\n/* harmony export */   "LineCurve3": function() { return /* binding */ LineCurve3; },\n/* harmony export */   "LineDashedMaterial": function() { return /* binding */ LineDashedMaterial; },\n/* harmony export */   "LineLoop": function() { return /* binding */ LineLoop; },\n/* harmony export */   "LineSegments": function() { return /* binding */ LineSegments; },\n/* harmony export */   "LinearEncoding": function() { return /* binding */ LinearEncoding; },\n/* harmony export */   "LinearFilter": function() { return /* binding */ LinearFilter; },\n/* harmony export */   "LinearInterpolant": function() { return /* binding */ LinearInterpolant; },\n/* harmony export */   "LinearMipMapLinearFilter": function() { return /* binding */ LinearMipMapLinearFilter; },\n/* harmony export */   "LinearMipMapNearestFilter": function() { return /* binding */ LinearMipMapNearestFilter; },\n/* harmony export */   "LinearMipmapLinearFilter": function() { return /* binding */ LinearMipmapLinearFilter; },\n/* harmony export */   "LinearMipmapNearestFilter": function() { return /* binding */ LinearMipmapNearestFilter; },\n/* harmony export */   "LinearSRGBColorSpace": function() { return /* binding */ LinearSRGBColorSpace; },\n/* harmony export */   "LinearToneMapping": function() { return /* binding */ LinearToneMapping; },\n/* harmony export */   "Loader": function() { return /* binding */ Loader; },\n/* harmony export */   "LoaderUtils": function() { return /* binding */ LoaderUtils; },\n/* harmony export */   "LoadingManager": function() { return /* binding */ LoadingManager; },\n/* harmony export */   "LoopOnce": function() { return /* binding */ LoopOnce; },\n/* harmony export */   "LoopPingPong": function() { return /* binding */ LoopPingPong; },\n/* harmony export */   "LoopRepeat": function() { return /* binding */ LoopRepeat; },\n/* harmony export */   "LuminanceAlphaFormat": function() { return /* binding */ LuminanceAlphaFormat; },\n/* harmony export */   "LuminanceFormat": function() { return /* binding */ LuminanceFormat; },\n/* harmony export */   "MOUSE": function() { return /* binding */ MOUSE; },\n/* harmony export */   "Material": function() { return /* binding */ Material; },\n/* harmony export */   "MaterialLoader": function() { return /* binding */ MaterialLoader; },\n/* harmony export */   "MathUtils": function() { return /* binding */ MathUtils; },\n/* harmony export */   "Matrix3": function() { return /* binding */ Matrix3; },\n/* harmony export */   "Matrix4": function() { return /* binding */ Matrix4; },\n/* harmony export */   "MaxEquation": function() { return /* binding */ MaxEquation; },\n/* harmony export */   "Mesh": function() { return /* binding */ Mesh; },\n/* harmony export */   "MeshBasicMaterial": function() { return /* binding */ MeshBasicMaterial; },\n/* harmony export */   "MeshDepthMaterial": function() { return /* binding */ MeshDepthMaterial; },\n/* harmony export */   "MeshDistanceMaterial": function() { return /* binding */ MeshDistanceMaterial; },\n/* harmony export */   "MeshLambertMaterial": function() { return /* binding */ MeshLambertMaterial; },\n/* harmony export */   "MeshMatcapMaterial": function() { return /* binding */ MeshMatcapMaterial; },\n/* harmony export */   "MeshNormalMaterial": function() { return /* binding */ MeshNormalMaterial; },\n/* harmony export */   "MeshPhongMaterial": function() { return /* binding */ MeshPhongMaterial; },\n/* harmony export */   "MeshPhysicalMaterial": function() { return /* binding */ MeshPhysicalMaterial; },\n/* harmony export */   "MeshStandardMaterial": function() { return /* binding */ MeshStandardMaterial; },\n/* harmony export */   "MeshToonMaterial": function() { return /* binding */ MeshToonMaterial; },\n/* harmony export */   "MinEquation": function() { return /* binding */ MinEquation; },\n/* harmony export */   "MirroredRepeatWrapping": function() { return /* binding */ MirroredRepeatWrapping; },\n/* harmony export */   "MixOperation": function() { return /* binding */ MixOperation; },\n/* harmony export */   "MultiplyBlending": function() { return /* binding */ MultiplyBlending; },\n/* harmony export */   "MultiplyOperation": function() { return /* binding */ MultiplyOperation; },\n/* harmony export */   "NearestFilter": function() { return /* binding */ NearestFilter; },\n/* harmony export */   "NearestMipMapLinearFilter": function() { return /* binding */ NearestMipMapLinearFilter; },\n/* harmony export */   "NearestMipMapNearestFilter": function() { return /* binding */ NearestMipMapNearestFilter; },\n/* harmony export */   "NearestMipmapLinearFilter": function() { return /* binding */ NearestMipmapLinearFilter; },\n/* harmony export */   "NearestMipmapNearestFilter": function() { return /* binding */ NearestMipmapNearestFilter; },\n/* harmony export */   "NeverDepth": function() { return /* binding */ NeverDepth; },\n/* harmony export */   "NeverStencilFunc": function() { return /* binding */ NeverStencilFunc; },\n/* harmony export */   "NoBlending": function() { return /* binding */ NoBlending; },\n/* harmony export */   "NoColorSpace": function() { return /* binding */ NoColorSpace; },\n/* harmony export */   "NoToneMapping": function() { return /* binding */ NoToneMapping; },\n/* harmony export */   "NormalAnimationBlendMode": function() { return /* binding */ NormalAnimationBlendMode; },\n/* harmony export */   "NormalBlending": function() { return /* binding */ NormalBlending; },\n/* harmony export */   "NotEqualDepth": function() { return /* binding */ NotEqualDepth; },\n/* harmony export */   "NotEqualStencilFunc": function() { return /* binding */ NotEqualStencilFunc; },\n/* harmony export */   "NumberKeyframeTrack": function() { return /* binding */ NumberKeyframeTrack; },\n/* harmony export */   "Object3D": function() { return /* binding */ Object3D; },\n/* harmony export */   "ObjectLoader": function() { return /* binding */ ObjectLoader; },\n/* harmony export */   "ObjectSpaceNormalMap": function() { return /* binding */ ObjectSpaceNormalMap; },\n/* harmony export */   "OctahedronBufferGeometry": function() { return /* binding */ OctahedronGeometry; },\n/* harmony export */   "OctahedronGeometry": function() { return /* binding */ OctahedronGeometry; },\n/* harmony export */   "OneFactor": function() { return /* binding */ OneFactor; },\n/* harmony export */   "OneMinusDstAlphaFactor": function() { return /* binding */ OneMinusDstAlphaFactor; },\n/* harmony export */   "OneMinusDstColorFactor": function() { return /* binding */ OneMinusDstColorFactor; },\n/* harmony export */   "OneMinusSrcAlphaFactor": function() { return /* binding */ OneMinusSrcAlphaFactor; },\n/* harmony export */   "OneMinusSrcColorFactor": function() { return /* binding */ OneMinusSrcColorFactor; },\n/* harmony export */   "OrthographicCamera": function() { return /* binding */ OrthographicCamera; },\n/* harmony export */   "PCFShadowMap": function() { return /* binding */ PCFShadowMap; },\n/* harmony export */   "PCFSoftShadowMap": function() { return /* binding */ PCFSoftShadowMap; },\n/* harmony export */   "PMREMGenerator": function() { return /* binding */ PMREMGenerator; },\n/* harmony export */   "ParametricGeometry": function() { return /* binding */ ParametricGeometry; },\n/* harmony export */   "Path": function() { return /* binding */ Path; },\n/* harmony export */   "PerspectiveCamera": function() { return /* binding */ PerspectiveCamera; },\n/* harmony export */   "Plane": function() { return /* binding */ Plane; },\n/* harmony export */   "PlaneBufferGeometry": function() { return /* binding */ PlaneGeometry; },\n/* harmony export */   "PlaneGeometry": function() { return /* binding */ PlaneGeometry; },\n/* harmony export */   "PlaneHelper": function() { return /* binding */ PlaneHelper; },\n/* harmony export */   "PointLight": function() { return /* binding */ PointLight; },\n/* harmony export */   "PointLightHelper": function() { return /* binding */ PointLightHelper; },\n/* harmony export */   "Points": function() { return /* binding */ Points; },\n/* harmony export */   "PointsMaterial": function() { return /* binding */ PointsMaterial; },\n/* harmony export */   "PolarGridHelper": function() { return /* binding */ PolarGridHelper; },\n/* harmony export */   "PolyhedronBufferGeometry": function() { return /* binding */ PolyhedronGeometry; },\n/* harmony export */   "PolyhedronGeometry": function() { return /* binding */ PolyhedronGeometry; },\n/* harmony export */   "PositionalAudio": function() { return /* binding */ PositionalAudio; },\n/* harmony export */   "PropertyBinding": function() { return /* binding */ PropertyBinding; },\n/* harmony export */   "PropertyMixer": function() { return /* binding */ PropertyMixer; },\n/* harmony export */   "QuadraticBezierCurve": function() { return /* binding */ QuadraticBezierCurve; },\n/* harmony export */   "QuadraticBezierCurve3": function() { return /* binding */ QuadraticBezierCurve3; },\n/* harmony export */   "Quaternion": function() { return /* binding */ Quaternion; },\n/* harmony export */   "QuaternionKeyframeTrack": function() { return /* binding */ QuaternionKeyframeTrack; },\n/* harmony export */   "QuaternionLinearInterpolant": function() { return /* binding */ QuaternionLinearInterpolant; },\n/* harmony export */   "REVISION": function() { return /* binding */ REVISION; },\n/* harmony export */   "RGBADepthPacking": function() { return /* binding */ RGBADepthPacking; },\n/* harmony export */   "RGBAFormat": function() { return /* binding */ RGBAFormat; },\n/* harmony export */   "RGBAIntegerFormat": function() { return /* binding */ RGBAIntegerFormat; },\n/* harmony export */   "RGBA_ASTC_10x10_Format": function() { return /* binding */ RGBA_ASTC_10x10_Format; },\n/* harmony export */   "RGBA_ASTC_10x5_Format": function() { return /* binding */ RGBA_ASTC_10x5_Format; },\n/* harmony export */   "RGBA_ASTC_10x6_Format": function() { return /* binding */ RGBA_ASTC_10x6_Format; },\n/* harmony export */   "RGBA_ASTC_10x8_Format": function() { return /* binding */ RGBA_ASTC_10x8_Format; },\n/* harmony export */   "RGBA_ASTC_12x10_Format": function() { return /* binding */ RGBA_ASTC_12x10_Format; },\n/* harmony export */   "RGBA_ASTC_12x12_Format": function() { return /* binding */ RGBA_ASTC_12x12_Format; },\n/* harmony export */   "RGBA_ASTC_4x4_Format": function() { return /* binding */ RGBA_ASTC_4x4_Format; },\n/* harmony export */   "RGBA_ASTC_5x4_Format": function() { return /* binding */ RGBA_ASTC_5x4_Format; },\n/* harmony export */   "RGBA_ASTC_5x5_Format": function() { return /* binding */ RGBA_ASTC_5x5_Format; },\n/* harmony export */   "RGBA_ASTC_6x5_Format": function() { return /* binding */ RGBA_ASTC_6x5_Format; },\n/* harmony export */   "RGBA_ASTC_6x6_Format": function() { return /* binding */ RGBA_ASTC_6x6_Format; },\n/* harmony export */   "RGBA_ASTC_8x5_Format": function() { return /* binding */ RGBA_ASTC_8x5_Format; },\n/* harmony export */   "RGBA_ASTC_8x6_Format": function() { return /* binding */ RGBA_ASTC_8x6_Format; },\n/* harmony export */   "RGBA_ASTC_8x8_Format": function() { return /* binding */ RGBA_ASTC_8x8_Format; },\n/* harmony export */   "RGBA_BPTC_Format": function() { return /* binding */ RGBA_BPTC_Format; },\n/* harmony export */   "RGBA_ETC2_EAC_Format": function() { return /* binding */ RGBA_ETC2_EAC_Format; },\n/* harmony export */   "RGBA_PVRTC_2BPPV1_Format": function() { return /* binding */ RGBA_PVRTC_2BPPV1_Format; },\n/* harmony export */   "RGBA_PVRTC_4BPPV1_Format": function() { return /* binding */ RGBA_PVRTC_4BPPV1_Format; },\n/* harmony export */   "RGBA_S3TC_DXT1_Format": function() { return /* binding */ RGBA_S3TC_DXT1_Format; },\n/* harmony export */   "RGBA_S3TC_DXT3_Format": function() { return /* binding */ RGBA_S3TC_DXT3_Format; },\n/* harmony export */   "RGBA_S3TC_DXT5_Format": function() { return /* binding */ RGBA_S3TC_DXT5_Format; },\n/* harmony export */   "RGBFormat": function() { return /* binding */ RGBFormat; },\n/* harmony export */   "RGB_ETC1_Format": function() { return /* binding */ RGB_ETC1_Format; },\n/* harmony export */   "RGB_ETC2_Format": function() { return /* binding */ RGB_ETC2_Format; },\n/* harmony export */   "RGB_PVRTC_2BPPV1_Format": function() { return /* binding */ RGB_PVRTC_2BPPV1_Format; },\n/* harmony export */   "RGB_PVRTC_4BPPV1_Format": function() { return /* binding */ RGB_PVRTC_4BPPV1_Format; },\n/* harmony export */   "RGB_S3TC_DXT1_Format": function() { return /* binding */ RGB_S3TC_DXT1_Format; },\n/* harmony export */   "RGFormat": function() { return /* binding */ RGFormat; },\n/* harmony export */   "RGIntegerFormat": function() { return /* binding */ RGIntegerFormat; },\n/* harmony export */   "RawShaderMaterial": function() { return /* binding */ RawShaderMaterial; },\n/* harmony export */   "Ray": function() { return /* binding */ Ray; },\n/* harmony export */   "Raycaster": function() { return /* binding */ Raycaster; },\n/* harmony export */   "RectAreaLight": function() { return /* binding */ RectAreaLight; },\n/* harmony export */   "RedFormat": function() { return /* binding */ RedFormat; },\n/* harmony export */   "RedIntegerFormat": function() { return /* binding */ RedIntegerFormat; },\n/* harmony export */   "ReinhardToneMapping": function() { return /* binding */ ReinhardToneMapping; },\n/* harmony export */   "RepeatWrapping": function() { return /* binding */ RepeatWrapping; },\n/* harmony export */   "ReplaceStencilOp": function() { return /* binding */ ReplaceStencilOp; },\n/* harmony export */   "ReverseSubtractEquation": function() { return /* binding */ ReverseSubtractEquation; },\n/* harmony export */   "RingBufferGeometry": function() { return /* binding */ RingGeometry; },\n/* harmony export */   "RingGeometry": function() { return /* binding */ RingGeometry; },\n/* harmony export */   "SRGBColorSpace": function() { return /* binding */ SRGBColorSpace; },\n/* harmony export */   "Scene": function() { return /* binding */ Scene; },\n/* harmony export */   "ShaderChunk": function() { return /* binding */ ShaderChunk; },\n/* harmony export */   "ShaderLib": function() { return /* binding */ ShaderLib; },\n/* harmony export */   "ShaderMaterial": function() { return /* binding */ ShaderMaterial; },\n/* harmony export */   "ShadowMaterial": function() { return /* binding */ ShadowMaterial; },\n/* harmony export */   "Shape": function() { return /* binding */ Shape; },\n/* harmony export */   "ShapeBufferGeometry": function() { return /* binding */ ShapeGeometry; },\n/* harmony export */   "ShapeGeometry": function() { return /* binding */ ShapeGeometry; },\n/* harmony export */   "ShapePath": function() { return /* binding */ ShapePath; },\n/* harmony export */   "ShapeUtils": function() { return /* binding */ ShapeUtils; },\n/* harmony export */   "ShortType": function() { return /* binding */ ShortType; },\n/* harmony export */   "Skeleton": function() { return /* binding */ Skeleton; },\n/* harmony export */   "SkeletonHelper": function() { return /* binding */ SkeletonHelper; },\n/* harmony export */   "SkinnedMesh": function() { return /* binding */ SkinnedMesh; },\n/* harmony export */   "SmoothShading": function() { return /* binding */ SmoothShading; },\n/* harmony export */   "Source": function() { return /* binding */ Source; },\n/* harmony export */   "Sphere": function() { return /* binding */ Sphere; },\n/* harmony export */   "SphereBufferGeometry": function() { return /* binding */ SphereGeometry; },\n/* harmony export */   "SphereGeometry": function() { return /* binding */ SphereGeometry; },\n/* harmony export */   "Spherical": function() { return /* binding */ Spherical; },\n/* harmony export */   "SphericalHarmonics3": function() { return /* binding */ SphericalHarmonics3; },\n/* harmony export */   "SplineCurve": function() { return /* binding */ SplineCurve; },\n/* harmony export */   "SpotLight": function() { return /* binding */ SpotLight; },\n/* harmony export */   "SpotLightHelper": function() { return /* binding */ SpotLightHelper; },\n/* harmony export */   "Sprite": function() { return /* binding */ Sprite; },\n/* harmony export */   "SpriteMaterial": function() { return /* binding */ SpriteMaterial; },\n/* harmony export */   "SrcAlphaFactor": function() { return /* binding */ SrcAlphaFactor; },\n/* harmony export */   "SrcAlphaSaturateFactor": function() { return /* binding */ SrcAlphaSaturateFactor; },\n/* harmony export */   "SrcColorFactor": function() { return /* binding */ SrcColorFactor; },\n/* harmony export */   "StaticCopyUsage": function() { return /* binding */ StaticCopyUsage; },\n/* harmony export */   "StaticDrawUsage": function() { return /* binding */ StaticDrawUsage; },\n/* harmony export */   "StaticReadUsage": function() { return /* binding */ StaticReadUsage; },\n/* harmony export */   "StereoCamera": function() { return /* binding */ StereoCamera; },\n/* harmony export */   "StreamCopyUsage": function() { return /* binding */ StreamCopyUsage; },\n/* harmony export */   "StreamDrawUsage": function() { return /* binding */ StreamDrawUsage; },\n/* harmony export */   "StreamReadUsage": function() { return /* binding */ StreamReadUsage; },\n/* harmony export */   "StringKeyframeTrack": function() { return /* binding */ StringKeyframeTrack; },\n/* harmony export */   "SubtractEquation": function() { return /* binding */ SubtractEquation; },\n/* harmony export */   "SubtractiveBlending": function() { return /* binding */ SubtractiveBlending; },\n/* harmony export */   "TOUCH": function() { return /* binding */ TOUCH; },\n/* harmony export */   "TangentSpaceNormalMap": function() { return /* binding */ TangentSpaceNormalMap; },\n/* harmony export */   "TetrahedronBufferGeometry": function() { return /* binding */ TetrahedronGeometry; },\n/* harmony export */   "TetrahedronGeometry": function() { return /* binding */ TetrahedronGeometry; },\n/* harmony export */   "TextGeometry": function() { return /* binding */ TextGeometry; },\n/* harmony export */   "Texture": function() { return /* binding */ Texture; },\n/* harmony export */   "TextureLoader": function() { return /* binding */ TextureLoader; },\n/* harmony export */   "TorusBufferGeometry": function() { return /* binding */ TorusGeometry; },\n/* harmony export */   "TorusGeometry": function() { return /* binding */ TorusGeometry; },\n/* harmony export */   "TorusKnotBufferGeometry": function() { return /* binding */ TorusKnotGeometry; },\n/* harmony export */   "TorusKnotGeometry": function() { return /* binding */ TorusKnotGeometry; },\n/* harmony export */   "Triangle": function() { return /* binding */ Triangle; },\n/* harmony export */   "TriangleFanDrawMode": function() { return /* binding */ TriangleFanDrawMode; },\n/* harmony export */   "TriangleStripDrawMode": function() { return /* binding */ TriangleStripDrawMode; },\n/* harmony export */   "TrianglesDrawMode": function() { return /* binding */ TrianglesDrawMode; },\n/* harmony export */   "TubeBufferGeometry": function() { return /* binding */ TubeGeometry; },\n/* harmony export */   "TubeGeometry": function() { return /* binding */ TubeGeometry; },\n/* harmony export */   "UVMapping": function() { return /* binding */ UVMapping; },\n/* harmony export */   "Uint16BufferAttribute": function() { return /* binding */ Uint16BufferAttribute; },\n/* harmony export */   "Uint32BufferAttribute": function() { return /* binding */ Uint32BufferAttribute; },\n/* harmony export */   "Uint8BufferAttribute": function() { return /* binding */ Uint8BufferAttribute; },\n/* harmony export */   "Uint8ClampedBufferAttribute": function() { return /* binding */ Uint8ClampedBufferAttribute; },\n/* harmony export */   "Uniform": function() { return /* binding */ Uniform; },\n/* harmony export */   "UniformsLib": function() { return /* binding */ UniformsLib; },\n/* harmony export */   "UniformsUtils": function() { return /* binding */ UniformsUtils; },\n/* harmony export */   "UnsignedByteType": function() { return /* binding */ UnsignedByteType; },\n/* harmony export */   "UnsignedInt248Type": function() { return /* binding */ UnsignedInt248Type; },\n/* harmony export */   "UnsignedIntType": function() { return /* binding */ UnsignedIntType; },\n/* harmony export */   "UnsignedShort4444Type": function() { return /* binding */ UnsignedShort4444Type; },\n/* harmony export */   "UnsignedShort5551Type": function() { return /* binding */ UnsignedShort5551Type; },\n/* harmony export */   "UnsignedShortType": function() { return /* binding */ UnsignedShortType; },\n/* harmony export */   "VSMShadowMap": function() { return /* binding */ VSMShadowMap; },\n/* harmony export */   "Vector2": function() { return /* binding */ Vector2; },\n/* harmony export */   "Vector3": function() { return /* binding */ Vector3; },\n/* harmony export */   "Vector4": function() { return /* binding */ Vector4; },\n/* harmony export */   "VectorKeyframeTrack": function() { return /* binding */ VectorKeyframeTrack; },\n/* harmony export */   "VideoTexture": function() { return /* binding */ VideoTexture; },\n/* harmony export */   "WebGL1Renderer": function() { return /* binding */ WebGL1Renderer; },\n/* harmony export */   "WebGL3DRenderTarget": function() { return /* binding */ WebGL3DRenderTarget; },\n/* harmony export */   "WebGLArrayRenderTarget": function() { return /* binding */ WebGLArrayRenderTarget; },\n/* harmony export */   "WebGLCubeRenderTarget": function() { return /* binding */ WebGLCubeRenderTarget; },\n/* harmony export */   "WebGLMultipleRenderTargets": function() { return /* binding */ WebGLMultipleRenderTargets; },\n/* harmony export */   "WebGLMultisampleRenderTarget": function() { return /* binding */ WebGLMultisampleRenderTarget; },\n/* harmony export */   "WebGLRenderTarget": function() { return /* binding */ WebGLRenderTarget; },\n/* harmony export */   "WebGLRenderer": function() { return /* binding */ WebGLRenderer; },\n/* harmony export */   "WebGLUtils": function() { return /* binding */ WebGLUtils; },\n/* harmony export */   "WireframeGeometry": function() { return /* binding */ WireframeGeometry; },\n/* harmony export */   "WrapAroundEnding": function() { return /* binding */ WrapAroundEnding; },\n/* harmony export */   "ZeroCurvatureEnding": function() { return /* binding */ ZeroCurvatureEnding; },\n/* harmony export */   "ZeroFactor": function() { return /* binding */ ZeroFactor; },\n/* harmony export */   "ZeroSlopeEnding": function() { return /* binding */ ZeroSlopeEnding; },\n/* harmony export */   "ZeroStencilOp": function() { return /* binding */ ZeroStencilOp; },\n/* harmony export */   "_SRGBAFormat": function() { return /* binding */ _SRGBAFormat; },\n/* harmony export */   "sRGBEncoding": function() { return /* binding */ sRGBEncoding; }\n/* harmony export */ });\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(3433);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(5861);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(9439);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6449);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(7326);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(136);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6215);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1120);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4942);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5671);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3144);\n/* harmony import */ var core_js_modules_es_promise_finally_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7727);\n/* harmony import */ var core_js_modules_es_promise_finally_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise_finally_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7757);\n/* harmony import */ var _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\n\n\n\n\n\nvar _FN;\n\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n\n\n/**\n * @license\n * Copyright 2010-2022 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nvar REVISION = \'141\';\nvar MOUSE = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2,\n  ROTATE: 0,\n  DOLLY: 1,\n  PAN: 2\n};\nvar TOUCH = {\n  ROTATE: 0,\n  PAN: 1,\n  DOLLY_PAN: 2,\n  DOLLY_ROTATE: 3\n};\nvar CullFaceNone = 0;\nvar CullFaceBack = 1;\nvar CullFaceFront = 2;\nvar CullFaceFrontBack = 3;\nvar BasicShadowMap = 0;\nvar PCFShadowMap = 1;\nvar PCFSoftShadowMap = 2;\nvar VSMShadowMap = 3;\nvar FrontSide = 0;\nvar BackSide = 1;\nvar DoubleSide = 2;\nvar FlatShading = 1;\nvar SmoothShading = 2;\nvar NoBlending = 0;\nvar NormalBlending = 1;\nvar AdditiveBlending = 2;\nvar SubtractiveBlending = 3;\nvar MultiplyBlending = 4;\nvar CustomBlending = 5;\nvar AddEquation = 100;\nvar SubtractEquation = 101;\nvar ReverseSubtractEquation = 102;\nvar MinEquation = 103;\nvar MaxEquation = 104;\nvar ZeroFactor = 200;\nvar OneFactor = 201;\nvar SrcColorFactor = 202;\nvar OneMinusSrcColorFactor = 203;\nvar SrcAlphaFactor = 204;\nvar OneMinusSrcAlphaFactor = 205;\nvar DstAlphaFactor = 206;\nvar OneMinusDstAlphaFactor = 207;\nvar DstColorFactor = 208;\nvar OneMinusDstColorFactor = 209;\nvar SrcAlphaSaturateFactor = 210;\nvar NeverDepth = 0;\nvar AlwaysDepth = 1;\nvar LessDepth = 2;\nvar LessEqualDepth = 3;\nvar EqualDepth = 4;\nvar GreaterEqualDepth = 5;\nvar GreaterDepth = 6;\nvar NotEqualDepth = 7;\nvar MultiplyOperation = 0;\nvar MixOperation = 1;\nvar AddOperation = 2;\nvar NoToneMapping = 0;\nvar LinearToneMapping = 1;\nvar ReinhardToneMapping = 2;\nvar CineonToneMapping = 3;\nvar ACESFilmicToneMapping = 4;\nvar CustomToneMapping = 5;\nvar UVMapping = 300;\nvar CubeReflectionMapping = 301;\nvar CubeRefractionMapping = 302;\nvar EquirectangularReflectionMapping = 303;\nvar EquirectangularRefractionMapping = 304;\nvar CubeUVReflectionMapping = 306;\nvar RepeatWrapping = 1000;\nvar ClampToEdgeWrapping = 1001;\nvar MirroredRepeatWrapping = 1002;\nvar NearestFilter = 1003;\nvar NearestMipmapNearestFilter = 1004;\nvar NearestMipMapNearestFilter = 1004;\nvar NearestMipmapLinearFilter = 1005;\nvar NearestMipMapLinearFilter = 1005;\nvar LinearFilter = 1006;\nvar LinearMipmapNearestFilter = 1007;\nvar LinearMipMapNearestFilter = 1007;\nvar LinearMipmapLinearFilter = 1008;\nvar LinearMipMapLinearFilter = 1008;\nvar UnsignedByteType = 1009;\nvar ByteType = 1010;\nvar ShortType = 1011;\nvar UnsignedShortType = 1012;\nvar IntType = 1013;\nvar UnsignedIntType = 1014;\nvar FloatType = 1015;\nvar HalfFloatType = 1016;\nvar UnsignedShort4444Type = 1017;\nvar UnsignedShort5551Type = 1018;\nvar UnsignedInt248Type = 1020;\nvar AlphaFormat = 1021;\nvar RGBFormat = 1022;\nvar RGBAFormat = 1023;\nvar LuminanceFormat = 1024;\nvar LuminanceAlphaFormat = 1025;\nvar DepthFormat = 1026;\nvar DepthStencilFormat = 1027;\nvar RedFormat = 1028;\nvar RedIntegerFormat = 1029;\nvar RGFormat = 1030;\nvar RGIntegerFormat = 1031;\nvar RGBAIntegerFormat = 1033;\nvar RGB_S3TC_DXT1_Format = 33776;\nvar RGBA_S3TC_DXT1_Format = 33777;\nvar RGBA_S3TC_DXT3_Format = 33778;\nvar RGBA_S3TC_DXT5_Format = 33779;\nvar RGB_PVRTC_4BPPV1_Format = 35840;\nvar RGB_PVRTC_2BPPV1_Format = 35841;\nvar RGBA_PVRTC_4BPPV1_Format = 35842;\nvar RGBA_PVRTC_2BPPV1_Format = 35843;\nvar RGB_ETC1_Format = 36196;\nvar RGB_ETC2_Format = 37492;\nvar RGBA_ETC2_EAC_Format = 37496;\nvar RGBA_ASTC_4x4_Format = 37808;\nvar RGBA_ASTC_5x4_Format = 37809;\nvar RGBA_ASTC_5x5_Format = 37810;\nvar RGBA_ASTC_6x5_Format = 37811;\nvar RGBA_ASTC_6x6_Format = 37812;\nvar RGBA_ASTC_8x5_Format = 37813;\nvar RGBA_ASTC_8x6_Format = 37814;\nvar RGBA_ASTC_8x8_Format = 37815;\nvar RGBA_ASTC_10x5_Format = 37816;\nvar RGBA_ASTC_10x6_Format = 37817;\nvar RGBA_ASTC_10x8_Format = 37818;\nvar RGBA_ASTC_10x10_Format = 37819;\nvar RGBA_ASTC_12x10_Format = 37820;\nvar RGBA_ASTC_12x12_Format = 37821;\nvar RGBA_BPTC_Format = 36492;\nvar LoopOnce = 2200;\nvar LoopRepeat = 2201;\nvar LoopPingPong = 2202;\nvar InterpolateDiscrete = 2300;\nvar InterpolateLinear = 2301;\nvar InterpolateSmooth = 2302;\nvar ZeroCurvatureEnding = 2400;\nvar ZeroSlopeEnding = 2401;\nvar WrapAroundEnding = 2402;\nvar NormalAnimationBlendMode = 2500;\nvar AdditiveAnimationBlendMode = 2501;\nvar TrianglesDrawMode = 0;\nvar TriangleStripDrawMode = 1;\nvar TriangleFanDrawMode = 2;\nvar LinearEncoding = 3000;\nvar sRGBEncoding = 3001;\nvar BasicDepthPacking = 3200;\nvar RGBADepthPacking = 3201;\nvar TangentSpaceNormalMap = 0;\nvar ObjectSpaceNormalMap = 1; // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\n\nvar NoColorSpace = \'\';\nvar SRGBColorSpace = \'srgb\';\nvar LinearSRGBColorSpace = \'srgb-linear\';\nvar ZeroStencilOp = 0;\nvar KeepStencilOp = 7680;\nvar ReplaceStencilOp = 7681;\nvar IncrementStencilOp = 7682;\nvar DecrementStencilOp = 7683;\nvar IncrementWrapStencilOp = 34055;\nvar DecrementWrapStencilOp = 34056;\nvar InvertStencilOp = 5386;\nvar NeverStencilFunc = 512;\nvar LessStencilFunc = 513;\nvar EqualStencilFunc = 514;\nvar LessEqualStencilFunc = 515;\nvar GreaterStencilFunc = 516;\nvar NotEqualStencilFunc = 517;\nvar GreaterEqualStencilFunc = 518;\nvar AlwaysStencilFunc = 519;\nvar StaticDrawUsage = 35044;\nvar DynamicDrawUsage = 35048;\nvar StreamDrawUsage = 35040;\nvar StaticReadUsage = 35045;\nvar DynamicReadUsage = 35049;\nvar StreamReadUsage = 35041;\nvar StaticCopyUsage = 35046;\nvar DynamicCopyUsage = 35050;\nvar StreamCopyUsage = 35042;\nvar GLSL1 = \'100\';\nvar GLSL3 = \'300 es\';\nvar _SRGBAFormat = 1035; // fallback for WebGL 1\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nvar EventDispatcher = /*#__PURE__*/function () {\n  function EventDispatcher() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, EventDispatcher);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(EventDispatcher, [{\n    key: "addEventListener",\n    value: function addEventListener(type, listener) {\n      if (this._listeners === undefined) this._listeners = {};\n      var listeners = this._listeners;\n\n      if (listeners[type] === undefined) {\n        listeners[type] = [];\n      }\n\n      if (listeners[type].indexOf(listener) === -1) {\n        listeners[type].push(listener);\n      }\n    }\n  }, {\n    key: "hasEventListener",\n    value: function hasEventListener(type, listener) {\n      if (this._listeners === undefined) return false;\n      var listeners = this._listeners;\n      return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n    }\n  }, {\n    key: "removeEventListener",\n    value: function removeEventListener(type, listener) {\n      if (this._listeners === undefined) return;\n      var listeners = this._listeners;\n      var listenerArray = listeners[type];\n\n      if (listenerArray !== undefined) {\n        var index = listenerArray.indexOf(listener);\n\n        if (index !== -1) {\n          listenerArray.splice(index, 1);\n        }\n      }\n    }\n  }, {\n    key: "dispatchEvent",\n    value: function dispatchEvent(event) {\n      if (this._listeners === undefined) return;\n      var listeners = this._listeners;\n      var listenerArray = listeners[event.type];\n\n      if (listenerArray !== undefined) {\n        event.target = this; // Make a copy, in case listeners are removed while iterating.\n\n        var array = listenerArray.slice(0);\n\n        for (var i = 0, l = array.length; i < l; i++) {\n          array[i].call(this, event);\n        }\n\n        event.target = null;\n      }\n    }\n  }]);\n\n  return EventDispatcher;\n}();\n\nvar _lut = [];\n\nfor (var i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? \'0\' : \'\') + i.toString(16);\n}\n\nvar _seed = 1234567;\nvar DEG2RAD = Math.PI / 180;\nvar RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\nfunction generateUUID() {\n  var d0 = Math.random() * 0xffffffff | 0;\n  var d1 = Math.random() * 0xffffffff | 0;\n  var d2 = Math.random() * 0xffffffff | 0;\n  var d3 = Math.random() * 0xffffffff | 0;\n  var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + \'-\' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + \'-\' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + \'-\' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + \'-\' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toLowerCase() here flattens concatenated strings to save heap memory space.\n\n  return uuid.toLowerCase();\n}\n\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n} // compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\n\n\nfunction euclideanModulo(n, m) {\n  return (n % m + m) % m;\n} // Linear mapping from range <a1, a2> to range <b1, b2>\n\n\nfunction mapLinear(x, a1, a2, b1, b2) {\n  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\n\n\nfunction inverseLerp(x, y, value) {\n  if (x !== y) {\n    return (value - x) / (y - x);\n  } else {\n    return 0;\n  }\n} // https://en.wikipedia.org/wiki/Linear_interpolation\n\n\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n\n\nfunction damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt));\n} // https://www.desmos.com/calculator/vcsjnyz7x4\n\n\nfunction pingpong(x) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return length - Math.abs(euclideanModulo(x, length * 2) - length);\n} // http://en.wikipedia.org/wiki/Smoothstep\n\n\nfunction smoothstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n  x = (x - min) / (max - min);\n  return x * x * (3 - 2 * x);\n}\n\nfunction smootherstep(x, min, max) {\n  if (x <= min) return 0;\n  if (x >= max) return 1;\n  x = (x - min) / (max - min);\n  return x * x * x * (x * (x * 6 - 15) + 10);\n} // Random integer from <low, high> interval\n\n\nfunction randInt(low, high) {\n  return low + Math.floor(Math.random() * (high - low + 1));\n} // Random float from <low, high> interval\n\n\nfunction randFloat(low, high) {\n  return low + Math.random() * (high - low);\n} // Random float from <-range/2, range/2> interval\n\n\nfunction randFloatSpread(range) {\n  return range * (0.5 - Math.random());\n} // Deterministic pseudo-random float in the interval [ 0, 1 ]\n\n\nfunction seededRandom(s) {\n  if (s !== undefined) _seed = s; // Mulberry32 generator\n\n  var t = _seed += 0x6D2B79F5;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\n\nfunction degToRad(degrees) {\n  return degrees * DEG2RAD;\n}\n\nfunction radToDeg(radians) {\n  return radians * RAD2DEG;\n}\n\nfunction isPowerOfTwo(value) {\n  return (value & value - 1) === 0 && value !== 0;\n}\n\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\n\nfunction floorPowerOfTwo(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\n\nfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n  // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n  // rotations are applied to the axes in the order specified by \'order\'\n  // rotation by angle \'a\' is applied first, then by angle \'b\', then by angle \'c\'\n  // angles are in radians\n  var cos = Math.cos;\n  var sin = Math.sin;\n  var c2 = cos(b / 2);\n  var s2 = sin(b / 2);\n  var c13 = cos((a + c) / 2);\n  var s13 = sin((a + c) / 2);\n  var c1_3 = cos((a - c) / 2);\n  var s1_3 = sin((a - c) / 2);\n  var c3_1 = cos((c - a) / 2);\n  var s3_1 = sin((c - a) / 2);\n\n  switch (order) {\n    case \'XYX\':\n      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n      break;\n\n    case \'YZY\':\n      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n      break;\n\n    case \'ZXZ\':\n      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n      break;\n\n    case \'XZX\':\n      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n      break;\n\n    case \'YXY\':\n      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n      break;\n\n    case \'ZYZ\':\n      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n      break;\n\n    default:\n      console.warn(\'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: \' + order);\n  }\n}\n\nfunction denormalize$1(value, array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return value;\n\n    case Uint16Array:\n      return value / 65535.0;\n\n    case Uint8Array:\n      return value / 255.0;\n\n    case Int16Array:\n      return Math.max(value / 32767.0, -1.0);\n\n    case Int8Array:\n      return Math.max(value / 127.0, -1.0);\n\n    default:\n      throw new Error(\'Invalid component type.\');\n  }\n}\n\nfunction normalize(value, array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return value;\n\n    case Uint16Array:\n      return Math.round(value * 65535.0);\n\n    case Uint8Array:\n      return Math.round(value * 255.0);\n\n    case Int16Array:\n      return Math.round(value * 32767.0);\n\n    case Int8Array:\n      return Math.round(value * 127.0);\n\n    default:\n      throw new Error(\'Invalid component type.\');\n  }\n}\n\nvar MathUtils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  DEG2RAD: DEG2RAD,\n  RAD2DEG: RAD2DEG,\n  generateUUID: generateUUID,\n  clamp: clamp,\n  euclideanModulo: euclideanModulo,\n  mapLinear: mapLinear,\n  inverseLerp: inverseLerp,\n  lerp: lerp,\n  damp: damp,\n  pingpong: pingpong,\n  smoothstep: smoothstep,\n  smootherstep: smootherstep,\n  randInt: randInt,\n  randFloat: randFloat,\n  randFloatSpread: randFloatSpread,\n  seededRandom: seededRandom,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  isPowerOfTwo: isPowerOfTwo,\n  ceilPowerOfTwo: ceilPowerOfTwo,\n  floorPowerOfTwo: floorPowerOfTwo,\n  setQuaternionFromProperEuler: setQuaternionFromProperEuler,\n  normalize: normalize,\n  denormalize: denormalize$1\n});\n\nvar Vector2 = /*#__PURE__*/function (_Symbol$iterator) {\n  function Vector2() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Vector2);\n\n    this.isVector2 = true;\n    this.x = x;\n    this.y = y;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Vector2, [{\n    key: "width",\n    get: function get() {\n      return this.x;\n    },\n    set: function set(value) {\n      this.x = value;\n    }\n  }, {\n    key: "height",\n    get: function get() {\n      return this.y;\n    },\n    set: function set(value) {\n      this.y = value;\n    }\n  }, {\n    key: "set",\n    value: function set(x, y) {\n      this.x = x;\n      this.y = y;\n      return this;\n    }\n  }, {\n    key: "setScalar",\n    value: function setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      return this;\n    }\n  }, {\n    key: "setX",\n    value: function setX(x) {\n      this.x = x;\n      return this;\n    }\n  }, {\n    key: "setY",\n    value: function setY(y) {\n      this.y = y;\n      return this;\n    }\n  }, {\n    key: "setComponent",\n    value: function setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n\n        case 1:\n          this.y = value;\n          break;\n\n        default:\n          throw new Error(\'index is out of range: \' + index);\n      }\n\n      return this;\n    }\n  }, {\n    key: "getComponent",\n    value: function getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n\n        case 1:\n          return this.y;\n\n        default:\n          throw new Error(\'index is out of range: \' + index);\n      }\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor(this.x, this.y);\n    }\n  }, {\n    key: "copy",\n    value: function copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      return this;\n    }\n  }, {\n    key: "add",\n    value: function add(v, w) {\n      if (w !== undefined) {\n        console.warn(\'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\');\n        return this.addVectors(v, w);\n      }\n\n      this.x += v.x;\n      this.y += v.y;\n      return this;\n    }\n  }, {\n    key: "addScalar",\n    value: function addScalar(s) {\n      this.x += s;\n      this.y += s;\n      return this;\n    }\n  }, {\n    key: "addVectors",\n    value: function addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      return this;\n    }\n  }, {\n    key: "addScaledVector",\n    value: function addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      return this;\n    }\n  }, {\n    key: "sub",\n    value: function sub(v, w) {\n      if (w !== undefined) {\n        console.warn(\'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\');\n        return this.subVectors(v, w);\n      }\n\n      this.x -= v.x;\n      this.y -= v.y;\n      return this;\n    }\n  }, {\n    key: "subScalar",\n    value: function subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      return this;\n    }\n  }, {\n    key: "subVectors",\n    value: function subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      return this;\n    }\n  }, {\n    key: "multiply",\n    value: function multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      return this;\n    }\n  }, {\n    key: "multiplyScalar",\n    value: function multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      return this;\n    }\n  }, {\n    key: "divide",\n    value: function divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      return this;\n    }\n  }, {\n    key: "divideScalar",\n    value: function divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n  }, {\n    key: "applyMatrix3",\n    value: function applyMatrix3(m) {\n      var x = this.x,\n          y = this.y;\n      var e = m.elements;\n      this.x = e[0] * x + e[3] * y + e[6];\n      this.y = e[1] * x + e[4] * y + e[7];\n      return this;\n    }\n  }, {\n    key: "min",\n    value: function min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      return this;\n    }\n  }, {\n    key: "max",\n    value: function max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      return this;\n    }\n  }, {\n    key: "clamp",\n    value: function clamp(min, max) {\n      // assumes min < max, componentwise\n      this.x = Math.max(min.x, Math.min(max.x, this.x));\n      this.y = Math.max(min.y, Math.min(max.y, this.y));\n      return this;\n    }\n  }, {\n    key: "clampScalar",\n    value: function clampScalar(minVal, maxVal) {\n      this.x = Math.max(minVal, Math.min(maxVal, this.x));\n      this.y = Math.max(minVal, Math.min(maxVal, this.y));\n      return this;\n    }\n  }, {\n    key: "clampLength",\n    value: function clampLength(min, max) {\n      var length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n    }\n  }, {\n    key: "floor",\n    value: function floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    }\n  }, {\n    key: "ceil",\n    value: function ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    }\n  }, {\n    key: "round",\n    value: function round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    }\n  }, {\n    key: "roundToZero",\n    value: function roundToZero() {\n      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n      return this;\n    }\n  }, {\n    key: "negate",\n    value: function negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      return this;\n    }\n  }, {\n    key: "dot",\n    value: function dot(v) {\n      return this.x * v.x + this.y * v.y;\n    }\n  }, {\n    key: "cross",\n    value: function cross(v) {\n      return this.x * v.y - this.y * v.x;\n    }\n  }, {\n    key: "lengthSq",\n    value: function lengthSq() {\n      return this.x * this.x + this.y * this.y;\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n  }, {\n    key: "manhattanLength",\n    value: function manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y);\n    }\n  }, {\n    key: "normalize",\n    value: function normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n  }, {\n    key: "angle",\n    value: function angle() {\n      // computes the angle in radians with respect to the positive x-axis\n      var angle = Math.atan2(-this.y, -this.x) + Math.PI;\n      return angle;\n    }\n  }, {\n    key: "distanceTo",\n    value: function distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n  }, {\n    key: "distanceToSquared",\n    value: function distanceToSquared(v) {\n      var dx = this.x - v.x,\n          dy = this.y - v.y;\n      return dx * dx + dy * dy;\n    }\n  }, {\n    key: "manhattanDistanceTo",\n    value: function manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n    }\n  }, {\n    key: "setLength",\n    value: function setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n  }, {\n    key: "lerp",\n    value: function lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      return this;\n    }\n  }, {\n    key: "lerpVectors",\n    value: function lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(v) {\n      return v.x === this.x && v.y === this.y;\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      return array;\n    }\n  }, {\n    key: "fromBufferAttribute",\n    value: function fromBufferAttribute(attribute, index, offset) {\n      if (offset !== undefined) {\n        console.warn(\'THREE.Vector2: offset has been removed from .fromBufferAttribute().\');\n      }\n\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      return this;\n    }\n  }, {\n    key: "rotateAround",\n    value: function rotateAround(center, angle) {\n      var c = Math.cos(angle),\n          s = Math.sin(angle);\n      var x = this.x - center.x;\n      var y = this.y - center.y;\n      this.x = x * c - y * s + center.x;\n      this.y = x * s + y * c + center.y;\n      return this;\n    }\n  }, {\n    key: "random",\n    value: function random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      return this;\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function value() {\n      return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function value$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.x;\n\n            case 2:\n              _context2.next = 4;\n              return this.y;\n\n            case 4:\n            case "end":\n              return _context2.stop();\n          }\n        }\n      }, value, this);\n    })\n  }]);\n\n  return Vector2;\n}(Symbol.iterator);\n\nvar Matrix3 = /*#__PURE__*/function () {\n  function Matrix3() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Matrix3);\n\n    this.isMatrix3 = true;\n    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n    if (arguments.length > 0) {\n      console.error(\'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.\');\n    }\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Matrix3, [{\n    key: "set",\n    value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      var te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n  }, {\n    key: "identity",\n    value: function identity() {\n      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(m) {\n      var te = this.elements;\n      var me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n  }, {\n    key: "extractBasis",\n    value: function extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n  }, {\n    key: "setFromMatrix4",\n    value: function setFromMatrix4(m) {\n      var me = m.elements;\n      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n      return this;\n    }\n  }, {\n    key: "multiply",\n    value: function multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n  }, {\n    key: "premultiply",\n    value: function premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n  }, {\n    key: "multiplyMatrices",\n    value: function multiplyMatrices(a, b) {\n      var ae = a.elements;\n      var be = b.elements;\n      var te = this.elements;\n      var a11 = ae[0],\n          a12 = ae[3],\n          a13 = ae[6];\n      var a21 = ae[1],\n          a22 = ae[4],\n          a23 = ae[7];\n      var a31 = ae[2],\n          a32 = ae[5],\n          a33 = ae[8];\n      var b11 = be[0],\n          b12 = be[3],\n          b13 = be[6];\n      var b21 = be[1],\n          b22 = be[4],\n          b23 = be[7];\n      var b31 = be[2],\n          b32 = be[5],\n          b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n  }, {\n    key: "multiplyScalar",\n    value: function multiplyScalar(s) {\n      var te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n  }, {\n    key: "determinant",\n    value: function determinant() {\n      var te = this.elements;\n      var a = te[0],\n          b = te[1],\n          c = te[2],\n          d = te[3],\n          e = te[4],\n          f = te[5],\n          g = te[6],\n          h = te[7],\n          i = te[8];\n      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n    }\n  }, {\n    key: "invert",\n    value: function invert() {\n      var te = this.elements,\n          n11 = te[0],\n          n21 = te[1],\n          n31 = te[2],\n          n12 = te[3],\n          n22 = te[4],\n          n32 = te[5],\n          n13 = te[6],\n          n23 = te[7],\n          n33 = te[8],\n          t11 = n33 * n22 - n32 * n23,\n          t12 = n32 * n13 - n33 * n12,\n          t13 = n23 * n12 - n22 * n13,\n          det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      var detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n  }, {\n    key: "transpose",\n    value: function transpose() {\n      var tmp;\n      var m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n  }, {\n    key: "getNormalMatrix",\n    value: function getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n  }, {\n    key: "transposeIntoArray",\n    value: function transposeIntoArray(r) {\n      var m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n  }, {\n    key: "setUvTransform",\n    value: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      var c = Math.cos(rotation);\n      var s = Math.sin(rotation);\n      this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "scale",\n    value: function scale(sx, sy) {\n      var te = this.elements;\n      te[0] *= sx;\n      te[3] *= sx;\n      te[6] *= sx;\n      te[1] *= sy;\n      te[4] *= sy;\n      te[7] *= sy;\n      return this;\n    }\n  }, {\n    key: "rotate",\n    value: function rotate(theta) {\n      var c = Math.cos(theta);\n      var s = Math.sin(theta);\n      var te = this.elements;\n      var a11 = te[0],\n          a12 = te[3],\n          a13 = te[6];\n      var a21 = te[1],\n          a22 = te[4],\n          a23 = te[7];\n      te[0] = c * a11 + s * a21;\n      te[3] = c * a12 + s * a22;\n      te[6] = c * a13 + s * a23;\n      te[1] = -s * a11 + c * a21;\n      te[4] = -s * a12 + c * a22;\n      te[7] = -s * a13 + c * a23;\n      return this;\n    }\n  }, {\n    key: "translate",\n    value: function translate(tx, ty) {\n      var te = this.elements;\n      te[0] += tx * te[2];\n      te[3] += tx * te[5];\n      te[6] += tx * te[8];\n      te[1] += ty * te[2];\n      te[4] += ty * te[5];\n      te[7] += ty * te[8];\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(matrix) {\n      var te = this.elements;\n      var me = matrix.elements;\n\n      for (var _i = 0; _i < 9; _i++) {\n        if (te[_i] !== me[_i]) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      for (var _i2 = 0; _i2 < 9; _i2++) {\n        this.elements[_i2] = array[_i2 + offset];\n      }\n\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }]);\n\n  return Matrix3;\n}();\n\nfunction arrayNeedsUint32(array) {\n  // assumes larger values usually on last\n  for (var _i3 = array.length - 1; _i3 >= 0; --_i3) {\n    if (array[_i3] > 65535) return true;\n  }\n\n  return false;\n}\n\nvar TYPED_ARRAYS = {\n  Int8Array: Int8Array,\n  Uint8Array: Uint8Array,\n  Uint8ClampedArray: Uint8ClampedArray,\n  Int16Array: Int16Array,\n  Uint16Array: Uint16Array,\n  Int32Array: Int32Array,\n  Uint32Array: Uint32Array,\n  Float32Array: Float32Array,\n  Float64Array: Float64Array\n};\n\nfunction getTypedArray(type, buffer) {\n  return new TYPED_ARRAYS[type](buffer);\n}\n\nfunction createElementNS(name) {\n  return document.createElementNS(\'http://www.w3.org/1999/xhtml\', name);\n}\n\nfunction SRGBToLinear(c) {\n  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n}\n\nfunction LinearToSRGB(c) {\n  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n} // JavaScript RGB-to-RGB transforms, defined as\n// FN[InputColorSpace][OutputColorSpace] callback functions.\n\n\nvar FN = (_FN = {}, (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_FN, SRGBColorSpace, (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)({}, LinearSRGBColorSpace, SRGBToLinear)), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_FN, LinearSRGBColorSpace, (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)({}, SRGBColorSpace, LinearToSRGB)), _FN);\nvar ColorManagement = {\n  legacyMode: true,\n\n  get workingColorSpace() {\n    return LinearSRGBColorSpace;\n  },\n\n  set workingColorSpace(colorSpace) {\n    console.warn(\'THREE.ColorManagement: .workingColorSpace is readonly.\');\n  },\n\n  convert: function convert(color, sourceColorSpace, targetColorSpace) {\n    if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n      return color;\n    }\n\n    if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== undefined) {\n      var fn = FN[sourceColorSpace][targetColorSpace];\n      color.r = fn(color.r);\n      color.g = fn(color.g);\n      color.b = fn(color.b);\n      return color;\n    }\n\n    throw new Error(\'Unsupported color space conversion.\');\n  },\n  fromWorkingColorSpace: function fromWorkingColorSpace(color, targetColorSpace) {\n    return this.convert(color, this.workingColorSpace, targetColorSpace);\n  },\n  toWorkingColorSpace: function toWorkingColorSpace(color, sourceColorSpace) {\n    return this.convert(color, sourceColorSpace, this.workingColorSpace);\n  }\n};\nvar _colorKeywords = {\n  \'aliceblue\': 0xF0F8FF,\n  \'antiquewhite\': 0xFAEBD7,\n  \'aqua\': 0x00FFFF,\n  \'aquamarine\': 0x7FFFD4,\n  \'azure\': 0xF0FFFF,\n  \'beige\': 0xF5F5DC,\n  \'bisque\': 0xFFE4C4,\n  \'black\': 0x000000,\n  \'blanchedalmond\': 0xFFEBCD,\n  \'blue\': 0x0000FF,\n  \'blueviolet\': 0x8A2BE2,\n  \'brown\': 0xA52A2A,\n  \'burlywood\': 0xDEB887,\n  \'cadetblue\': 0x5F9EA0,\n  \'chartreuse\': 0x7FFF00,\n  \'chocolate\': 0xD2691E,\n  \'coral\': 0xFF7F50,\n  \'cornflowerblue\': 0x6495ED,\n  \'cornsilk\': 0xFFF8DC,\n  \'crimson\': 0xDC143C,\n  \'cyan\': 0x00FFFF,\n  \'darkblue\': 0x00008B,\n  \'darkcyan\': 0x008B8B,\n  \'darkgoldenrod\': 0xB8860B,\n  \'darkgray\': 0xA9A9A9,\n  \'darkgreen\': 0x006400,\n  \'darkgrey\': 0xA9A9A9,\n  \'darkkhaki\': 0xBDB76B,\n  \'darkmagenta\': 0x8B008B,\n  \'darkolivegreen\': 0x556B2F,\n  \'darkorange\': 0xFF8C00,\n  \'darkorchid\': 0x9932CC,\n  \'darkred\': 0x8B0000,\n  \'darksalmon\': 0xE9967A,\n  \'darkseagreen\': 0x8FBC8F,\n  \'darkslateblue\': 0x483D8B,\n  \'darkslategray\': 0x2F4F4F,\n  \'darkslategrey\': 0x2F4F4F,\n  \'darkturquoise\': 0x00CED1,\n  \'darkviolet\': 0x9400D3,\n  \'deeppink\': 0xFF1493,\n  \'deepskyblue\': 0x00BFFF,\n  \'dimgray\': 0x696969,\n  \'dimgrey\': 0x696969,\n  \'dodgerblue\': 0x1E90FF,\n  \'firebrick\': 0xB22222,\n  \'floralwhite\': 0xFFFAF0,\n  \'forestgreen\': 0x228B22,\n  \'fuchsia\': 0xFF00FF,\n  \'gainsboro\': 0xDCDCDC,\n  \'ghostwhite\': 0xF8F8FF,\n  \'gold\': 0xFFD700,\n  \'goldenrod\': 0xDAA520,\n  \'gray\': 0x808080,\n  \'green\': 0x008000,\n  \'greenyellow\': 0xADFF2F,\n  \'grey\': 0x808080,\n  \'honeydew\': 0xF0FFF0,\n  \'hotpink\': 0xFF69B4,\n  \'indianred\': 0xCD5C5C,\n  \'indigo\': 0x4B0082,\n  \'ivory\': 0xFFFFF0,\n  \'khaki\': 0xF0E68C,\n  \'lavender\': 0xE6E6FA,\n  \'lavenderblush\': 0xFFF0F5,\n  \'lawngreen\': 0x7CFC00,\n  \'lemonchiffon\': 0xFFFACD,\n  \'lightblue\': 0xADD8E6,\n  \'lightcoral\': 0xF08080,\n  \'lightcyan\': 0xE0FFFF,\n  \'lightgoldenrodyellow\': 0xFAFAD2,\n  \'lightgray\': 0xD3D3D3,\n  \'lightgreen\': 0x90EE90,\n  \'lightgrey\': 0xD3D3D3,\n  \'lightpink\': 0xFFB6C1,\n  \'lightsalmon\': 0xFFA07A,\n  \'lightseagreen\': 0x20B2AA,\n  \'lightskyblue\': 0x87CEFA,\n  \'lightslategray\': 0x778899,\n  \'lightslategrey\': 0x778899,\n  \'lightsteelblue\': 0xB0C4DE,\n  \'lightyellow\': 0xFFFFE0,\n  \'lime\': 0x00FF00,\n  \'limegreen\': 0x32CD32,\n  \'linen\': 0xFAF0E6,\n  \'magenta\': 0xFF00FF,\n  \'maroon\': 0x800000,\n  \'mediumaquamarine\': 0x66CDAA,\n  \'mediumblue\': 0x0000CD,\n  \'mediumorchid\': 0xBA55D3,\n  \'mediumpurple\': 0x9370DB,\n  \'mediumseagreen\': 0x3CB371,\n  \'mediumslateblue\': 0x7B68EE,\n  \'mediumspringgreen\': 0x00FA9A,\n  \'mediumturquoise\': 0x48D1CC,\n  \'mediumvioletred\': 0xC71585,\n  \'midnightblue\': 0x191970,\n  \'mintcream\': 0xF5FFFA,\n  \'mistyrose\': 0xFFE4E1,\n  \'moccasin\': 0xFFE4B5,\n  \'navajowhite\': 0xFFDEAD,\n  \'navy\': 0x000080,\n  \'oldlace\': 0xFDF5E6,\n  \'olive\': 0x808000,\n  \'olivedrab\': 0x6B8E23,\n  \'orange\': 0xFFA500,\n  \'orangered\': 0xFF4500,\n  \'orchid\': 0xDA70D6,\n  \'palegoldenrod\': 0xEEE8AA,\n  \'palegreen\': 0x98FB98,\n  \'paleturquoise\': 0xAFEEEE,\n  \'palevioletred\': 0xDB7093,\n  \'papayawhip\': 0xFFEFD5,\n  \'peachpuff\': 0xFFDAB9,\n  \'peru\': 0xCD853F,\n  \'pink\': 0xFFC0CB,\n  \'plum\': 0xDDA0DD,\n  \'powderblue\': 0xB0E0E6,\n  \'purple\': 0x800080,\n  \'rebeccapurple\': 0x663399,\n  \'red\': 0xFF0000,\n  \'rosybrown\': 0xBC8F8F,\n  \'royalblue\': 0x4169E1,\n  \'saddlebrown\': 0x8B4513,\n  \'salmon\': 0xFA8072,\n  \'sandybrown\': 0xF4A460,\n  \'seagreen\': 0x2E8B57,\n  \'seashell\': 0xFFF5EE,\n  \'sienna\': 0xA0522D,\n  \'silver\': 0xC0C0C0,\n  \'skyblue\': 0x87CEEB,\n  \'slateblue\': 0x6A5ACD,\n  \'slategray\': 0x708090,\n  \'slategrey\': 0x708090,\n  \'snow\': 0xFFFAFA,\n  \'springgreen\': 0x00FF7F,\n  \'steelblue\': 0x4682B4,\n  \'tan\': 0xD2B48C,\n  \'teal\': 0x008080,\n  \'thistle\': 0xD8BFD8,\n  \'tomato\': 0xFF6347,\n  \'turquoise\': 0x40E0D0,\n  \'violet\': 0xEE82EE,\n  \'wheat\': 0xF5DEB3,\n  \'white\': 0xFFFFFF,\n  \'whitesmoke\': 0xF5F5F5,\n  \'yellow\': 0xFFFF00,\n  \'yellowgreen\': 0x9ACD32\n};\nvar _rgb = {\n  r: 0,\n  g: 0,\n  b: 0\n};\nvar _hslA = {\n  h: 0,\n  s: 0,\n  l: 0\n};\nvar _hslB = {\n  h: 0,\n  s: 0,\n  l: 0\n};\n\nfunction hue2rgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n  return p;\n}\n\nfunction toComponents(source, target) {\n  target.r = source.r;\n  target.g = source.g;\n  target.b = source.b;\n  return target;\n}\n\nvar Color = /*#__PURE__*/function (_Symbol$iterator2) {\n  function Color(r, g, b) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Color);\n\n    this.isColor = true;\n    this.r = 1;\n    this.g = 1;\n    this.b = 1;\n\n    if (g === undefined && b === undefined) {\n      // r is THREE.Color, hex or string\n      return this.set(r);\n    }\n\n    return this.setRGB(r, g, b);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Color, [{\n    key: "set",\n    value: function set(value) {\n      if (value && value.isColor) {\n        this.copy(value);\n      } else if (typeof value === \'number\') {\n        this.setHex(value);\n      } else if (typeof value === \'string\') {\n        this.setStyle(value);\n      }\n\n      return this;\n    }\n  }, {\n    key: "setScalar",\n    value: function setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n  }, {\n    key: "setHex",\n    value: function setHex(hex) {\n      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n  }, {\n    key: "setRGB",\n    value: function setRGB(r, g, b) {\n      var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : LinearSRGBColorSpace;\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n  }, {\n    key: "setHSL",\n    value: function setHSL(h, s, l) {\n      var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : LinearSRGBColorSpace;\n      // h,s,l ranges are in 0.0 - 1.0\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        var q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n  }, {\n    key: "setStyle",\n    value: function setStyle(style) {\n      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;\n\n      function handleAlpha(string) {\n        if (string === undefined) return;\n\n        if (parseFloat(string) < 1) {\n          console.warn(\'THREE.Color: Alpha component of \' + style + \' will be ignored.\');\n        }\n      }\n\n      var m;\n\n      if (m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(style)) {\n        // rgb / hsl\n        var color;\n        var name = m[1];\n        var components = m[2];\n\n        switch (name) {\n          case \'rgb\':\n          case \'rgba\':\n            if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              // rgb(255,0,0) rgba(255,0,0,0.5)\n              this.r = Math.min(255, parseInt(color[1], 10)) / 255;\n              this.g = Math.min(255, parseInt(color[2], 10)) / 255;\n              this.b = Math.min(255, parseInt(color[3], 10)) / 255;\n              ColorManagement.toWorkingColorSpace(this, colorSpace);\n              handleAlpha(color[4]);\n              return this;\n            }\n\n            if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n              this.r = Math.min(100, parseInt(color[1], 10)) / 100;\n              this.g = Math.min(100, parseInt(color[2], 10)) / 100;\n              this.b = Math.min(100, parseInt(color[3], 10)) / 100;\n              ColorManagement.toWorkingColorSpace(this, colorSpace);\n              handleAlpha(color[4]);\n              return this;\n            }\n\n            break;\n\n          case \'hsl\':\n          case \'hsla\':\n            if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n              // hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n              var h = parseFloat(color[1]) / 360;\n              var s = parseInt(color[2], 10) / 100;\n              var l = parseInt(color[3], 10) / 100;\n              handleAlpha(color[4]);\n              return this.setHSL(h, s, l, colorSpace);\n            }\n\n            break;\n        }\n      } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n        // hex color\n        var hex = m[1];\n        var size = hex.length;\n\n        if (size === 3) {\n          // #ff0\n          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n          ColorManagement.toWorkingColorSpace(this, colorSpace);\n          return this;\n        } else if (size === 6) {\n          // #ff0000\n          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n          ColorManagement.toWorkingColorSpace(this, colorSpace);\n          return this;\n        }\n      }\n\n      if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n\n      return this;\n    }\n  }, {\n    key: "setColorName",\n    value: function setColorName(style) {\n      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;\n\n      // color keywords\n      var hex = _colorKeywords[style.toLowerCase()];\n\n      if (hex !== undefined) {\n        // red\n        this.setHex(hex, colorSpace);\n      } else {\n        // unknown color\n        console.warn(\'THREE.Color: Unknown color \' + style);\n      }\n\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n  }, {\n    key: "copy",\n    value: function copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n  }, {\n    key: "copySRGBToLinear",\n    value: function copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n  }, {\n    key: "copyLinearToSRGB",\n    value: function copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n  }, {\n    key: "convertSRGBToLinear",\n    value: function convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n  }, {\n    key: "convertLinearToSRGB",\n    value: function convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n  }, {\n    key: "getHex",\n    value: function getHex() {\n      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;\n      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);\n      return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;\n    }\n  }, {\n    key: "getHexString",\n    value: function getHexString() {\n      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;\n      return (\'000000\' + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n  }, {\n    key: "getHSL",\n    value: function getHSL(target) {\n      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LinearSRGBColorSpace;\n      // h,s,l ranges are in 0.0 - 1.0\n      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);\n      var r = _rgb.r,\n          g = _rgb.g,\n          b = _rgb.b;\n      var max = Math.max(r, g, b);\n      var min = Math.min(r, g, b);\n      var hue, saturation;\n      var lightness = (min + max) / 2.0;\n\n      if (min === max) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        var delta = max - min;\n        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n        switch (max) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n\n        hue /= 6;\n      }\n\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n  }, {\n    key: "getRGB",\n    value: function getRGB(target) {\n      var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : LinearSRGBColorSpace;\n      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);\n      target.r = _rgb.r;\n      target.g = _rgb.g;\n      target.b = _rgb.b;\n      return target;\n    }\n  }, {\n    key: "getStyle",\n    value: function getStyle() {\n      var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;\n      ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);\n\n      if (colorSpace !== SRGBColorSpace) {\n        // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n        return "color(".concat(colorSpace, " ").concat(_rgb.r, " ").concat(_rgb.g, " ").concat(_rgb.b, ")");\n      }\n\n      return "rgb(".concat(_rgb.r * 255 | 0, ",").concat(_rgb.g * 255 | 0, ",").concat(_rgb.b * 255 | 0, ")");\n    }\n  }, {\n    key: "offsetHSL",\n    value: function offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      _hslA.h += h;\n      _hslA.s += s;\n      _hslA.l += l;\n      this.setHSL(_hslA.h, _hslA.s, _hslA.l);\n      return this;\n    }\n  }, {\n    key: "add",\n    value: function add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n  }, {\n    key: "addColors",\n    value: function addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n  }, {\n    key: "addScalar",\n    value: function addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n  }, {\n    key: "sub",\n    value: function sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n  }, {\n    key: "multiply",\n    value: function multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n  }, {\n    key: "multiplyScalar",\n    value: function multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n  }, {\n    key: "lerp",\n    value: function lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n  }, {\n    key: "lerpColors",\n    value: function lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n  }, {\n    key: "lerpHSL",\n    value: function lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      var h = lerp(_hslA.h, _hslB.h, alpha);\n      var s = lerp(_hslA.s, _hslB.s, alpha);\n      var l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n  }, {\n    key: "fromBufferAttribute",\n    value: function fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n\n      if (attribute.normalized === true) {\n        // assuming Uint8Array\n        this.r /= 255;\n        this.g /= 255;\n        this.b /= 255;\n      }\n\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      return this.getHex();\n    }\n  }, {\n    key: _Symbol$iterator2,\n    value: /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function value() {\n      return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function value$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.r;\n\n            case 2:\n              _context3.next = 4;\n              return this.g;\n\n            case 4:\n              _context3.next = 6;\n              return this.b;\n\n            case 6:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, value, this);\n    })\n  }]);\n\n  return Color;\n}(Symbol.iterator);\n\nColor.NAMES = _colorKeywords;\n\nvar _canvas;\n\nvar ImageUtils = /*#__PURE__*/function () {\n  function ImageUtils() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ImageUtils);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ImageUtils, null, [{\n    key: "getDataURL",\n    value: function getDataURL(image) {\n      if (/^data:/i.test(image.src)) {\n        return image.src;\n      }\n\n      if (typeof HTMLCanvasElement == \'undefined\') {\n        return image.src;\n      }\n\n      var canvas;\n\n      if (image instanceof HTMLCanvasElement) {\n        canvas = image;\n      } else {\n        if (_canvas === undefined) _canvas = createElementNS(\'canvas\');\n        _canvas.width = image.width;\n        _canvas.height = image.height;\n\n        var context = _canvas.getContext(\'2d\');\n\n        if (image instanceof ImageData) {\n          context.putImageData(image, 0, 0);\n        } else {\n          context.drawImage(image, 0, 0, image.width, image.height);\n        }\n\n        canvas = _canvas;\n      }\n\n      if (canvas.width > 2048 || canvas.height > 2048) {\n        console.warn(\'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons\', image);\n        return canvas.toDataURL(\'image/jpeg\', 0.6);\n      } else {\n        return canvas.toDataURL(\'image/png\');\n      }\n    }\n  }, {\n    key: "sRGBToLinear",\n    value: function sRGBToLinear(image) {\n      if (typeof HTMLImageElement !== \'undefined\' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \'undefined\' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \'undefined\' && image instanceof ImageBitmap) {\n        var canvas = createElementNS(\'canvas\');\n        canvas.width = image.width;\n        canvas.height = image.height;\n        var context = canvas.getContext(\'2d\');\n        context.drawImage(image, 0, 0, image.width, image.height);\n        var imageData = context.getImageData(0, 0, image.width, image.height);\n        var data = imageData.data;\n\n        for (var _i4 = 0; _i4 < data.length; _i4++) {\n          data[_i4] = SRGBToLinear(data[_i4] / 255) * 255;\n        }\n\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n      } else if (image.data) {\n        var _data = image.data.slice(0);\n\n        for (var _i5 = 0; _i5 < _data.length; _i5++) {\n          if (_data instanceof Uint8Array || _data instanceof Uint8ClampedArray) {\n            _data[_i5] = Math.floor(SRGBToLinear(_data[_i5] / 255) * 255);\n          } else {\n            // assuming float\n            _data[_i5] = SRGBToLinear(_data[_i5]);\n          }\n        }\n\n        return {\n          data: _data,\n          width: image.width,\n          height: image.height\n        };\n      } else {\n        console.warn(\'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.\');\n        return image;\n      }\n    }\n  }]);\n\n  return ImageUtils;\n}();\n\nvar Source = /*#__PURE__*/function () {\n  function Source() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Source);\n\n    this.isSource = true;\n    this.uuid = generateUUID();\n    this.data = data;\n    this.version = 0;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Source, [{\n    key: "needsUpdate",\n    set: function set(value) {\n      if (value === true) this.version++;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var isRootObject = meta === undefined || typeof meta === \'string\';\n\n      if (!isRootObject && meta.images[this.uuid] !== undefined) {\n        return meta.images[this.uuid];\n      }\n\n      var output = {\n        uuid: this.uuid,\n        url: \'\'\n      };\n      var data = this.data;\n\n      if (data !== null) {\n        var url;\n\n        if (Array.isArray(data)) {\n          // cube texture\n          url = [];\n\n          for (var _i6 = 0, l = data.length; _i6 < l; _i6++) {\n            if (data[_i6].isDataTexture) {\n              url.push(serializeImage(data[_i6].image));\n            } else {\n              url.push(serializeImage(data[_i6]));\n            }\n          }\n        } else {\n          // texture\n          url = serializeImage(data);\n        }\n\n        output.url = url;\n      }\n\n      if (!isRootObject) {\n        meta.images[this.uuid] = output;\n      }\n\n      return output;\n    }\n  }]);\n\n  return Source;\n}();\n\nfunction serializeImage(image) {\n  if (typeof HTMLImageElement !== \'undefined\' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \'undefined\' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \'undefined\' && image instanceof ImageBitmap) {\n    // default images\n    return ImageUtils.getDataURL(image);\n  } else {\n    if (image.data) {\n      // images of DataTexture\n      return {\n        data: Array.prototype.slice.call(image.data),\n        width: image.width,\n        height: image.height,\n        type: image.data.constructor.name\n      };\n    } else {\n      console.warn(\'THREE.Texture: Unable to serialize Texture.\');\n      return {};\n    }\n  }\n}\n\nvar textureId = 0;\n\nvar Texture = /*#__PURE__*/function (_EventDispatcher) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Texture, _EventDispatcher);\n\n  var _super = _createSuper(Texture);\n\n  function Texture() {\n    var _this2;\n\n    var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Texture.DEFAULT_IMAGE;\n    var mapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Texture.DEFAULT_MAPPING;\n    var wrapS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ClampToEdgeWrapping;\n    var wrapT = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ClampToEdgeWrapping;\n    var magFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LinearFilter;\n    var minFilter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : LinearMipmapLinearFilter;\n    var format = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : RGBAFormat;\n    var type = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : UnsignedByteType;\n    var anisotropy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;\n    var encoding = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : LinearEncoding;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Texture);\n\n    _this2 = _super.call(this);\n    _this2.isTexture = true;\n    Object.defineProperty((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this2), \'id\', {\n      value: textureId++\n    });\n    _this2.uuid = generateUUID();\n    _this2.name = \'\';\n    _this2.source = new Source(image);\n    _this2.mipmaps = [];\n    _this2.mapping = mapping;\n    _this2.wrapS = wrapS;\n    _this2.wrapT = wrapT;\n    _this2.magFilter = magFilter;\n    _this2.minFilter = minFilter;\n    _this2.anisotropy = anisotropy;\n    _this2.format = format;\n    _this2.internalFormat = null;\n    _this2.type = type;\n    _this2.offset = new Vector2(0, 0);\n    _this2.repeat = new Vector2(1, 1);\n    _this2.center = new Vector2(0, 0);\n    _this2.rotation = 0;\n    _this2.matrixAutoUpdate = true;\n    _this2.matrix = new Matrix3();\n    _this2.generateMipmaps = true;\n    _this2.premultiplyAlpha = false;\n    _this2.flipY = true;\n    _this2.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n    //\n    // Also changing the encoding after already used by a Material will not automatically make the Material\n    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n    _this2.encoding = encoding;\n    _this2.userData = {};\n    _this2.version = 0;\n    _this2.onUpdate = null;\n    _this2.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\n    _this2.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n    return _this2;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Texture, [{\n    key: "image",\n    get: function get() {\n      return this.source.data;\n    },\n    set: function set(value) {\n      this.source.data = value;\n    }\n  }, {\n    key: "updateMatrix",\n    value: function updateMatrix() {\n      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      this.name = source.name;\n      this.source = source.source;\n      this.mipmaps = source.mipmaps.slice(0);\n      this.mapping = source.mapping;\n      this.wrapS = source.wrapS;\n      this.wrapT = source.wrapT;\n      this.magFilter = source.magFilter;\n      this.minFilter = source.minFilter;\n      this.anisotropy = source.anisotropy;\n      this.format = source.format;\n      this.internalFormat = source.internalFormat;\n      this.type = source.type;\n      this.offset.copy(source.offset);\n      this.repeat.copy(source.repeat);\n      this.center.copy(source.center);\n      this.rotation = source.rotation;\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrix.copy(source.matrix);\n      this.generateMipmaps = source.generateMipmaps;\n      this.premultiplyAlpha = source.premultiplyAlpha;\n      this.flipY = source.flipY;\n      this.unpackAlignment = source.unpackAlignment;\n      this.encoding = source.encoding;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      this.needsUpdate = true;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var isRootObject = meta === undefined || typeof meta === \'string\';\n\n      if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n        return meta.textures[this.uuid];\n      }\n\n      var output = {\n        metadata: {\n          version: 4.5,\n          type: \'Texture\',\n          generator: \'Texture.toJSON\'\n        },\n        uuid: this.uuid,\n        name: this.name,\n        image: this.source.toJSON(meta).uuid,\n        mapping: this.mapping,\n        repeat: [this.repeat.x, this.repeat.y],\n        offset: [this.offset.x, this.offset.y],\n        center: [this.center.x, this.center.y],\n        rotation: this.rotation,\n        wrap: [this.wrapS, this.wrapT],\n        format: this.format,\n        type: this.type,\n        encoding: this.encoding,\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n        flipY: this.flipY,\n        premultiplyAlpha: this.premultiplyAlpha,\n        unpackAlignment: this.unpackAlignment\n      };\n      if (JSON.stringify(this.userData) !== \'{}\') output.userData = this.userData;\n\n      if (!isRootObject) {\n        meta.textures[this.uuid] = output;\n      }\n\n      return output;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: \'dispose\'\n      });\n    }\n  }, {\n    key: "transformUv",\n    value: function transformUv(uv) {\n      if (this.mapping !== UVMapping) return uv;\n      uv.applyMatrix3(this.matrix);\n\n      if (uv.x < 0 || uv.x > 1) {\n        switch (this.wrapS) {\n          case RepeatWrapping:\n            uv.x = uv.x - Math.floor(uv.x);\n            break;\n\n          case ClampToEdgeWrapping:\n            uv.x = uv.x < 0 ? 0 : 1;\n            break;\n\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n              uv.x = Math.ceil(uv.x) - uv.x;\n            } else {\n              uv.x = uv.x - Math.floor(uv.x);\n            }\n\n            break;\n        }\n      }\n\n      if (uv.y < 0 || uv.y > 1) {\n        switch (this.wrapT) {\n          case RepeatWrapping:\n            uv.y = uv.y - Math.floor(uv.y);\n            break;\n\n          case ClampToEdgeWrapping:\n            uv.y = uv.y < 0 ? 0 : 1;\n            break;\n\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n              uv.y = Math.ceil(uv.y) - uv.y;\n            } else {\n              uv.y = uv.y - Math.floor(uv.y);\n            }\n\n            break;\n        }\n      }\n\n      if (this.flipY) {\n        uv.y = 1 - uv.y;\n      }\n\n      return uv;\n    }\n  }, {\n    key: "needsUpdate",\n    set: function set(value) {\n      if (value === true) {\n        this.version++;\n        this.source.needsUpdate = true;\n      }\n    }\n  }]);\n\n  return Texture;\n}(EventDispatcher);\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nvar Vector4 = /*#__PURE__*/function (_Symbol$iterator3) {\n  function Vector4() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Vector4);\n\n    this.isVector4 = true;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Vector4, [{\n    key: "width",\n    get: function get() {\n      return this.z;\n    },\n    set: function set(value) {\n      this.z = value;\n    }\n  }, {\n    key: "height",\n    get: function get() {\n      return this.w;\n    },\n    set: function set(value) {\n      this.w = value;\n    }\n  }, {\n    key: "set",\n    value: function set(x, y, z, w) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n  }, {\n    key: "setScalar",\n    value: function setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      this.w = scalar;\n      return this;\n    }\n  }, {\n    key: "setX",\n    value: function setX(x) {\n      this.x = x;\n      return this;\n    }\n  }, {\n    key: "setY",\n    value: function setY(y) {\n      this.y = y;\n      return this;\n    }\n  }, {\n    key: "setZ",\n    value: function setZ(z) {\n      this.z = z;\n      return this;\n    }\n  }, {\n    key: "setW",\n    value: function setW(w) {\n      this.w = w;\n      return this;\n    }\n  }, {\n    key: "setComponent",\n    value: function setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n\n        case 1:\n          this.y = value;\n          break;\n\n        case 2:\n          this.z = value;\n          break;\n\n        case 3:\n          this.w = value;\n          break;\n\n        default:\n          throw new Error(\'index is out of range: \' + index);\n      }\n\n      return this;\n    }\n  }, {\n    key: "getComponent",\n    value: function getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n\n        case 1:\n          return this.y;\n\n        case 2:\n          return this.z;\n\n        case 3:\n          return this.w;\n\n        default:\n          throw new Error(\'index is out of range: \' + index);\n      }\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor(this.x, this.y, this.z, this.w);\n    }\n  }, {\n    key: "copy",\n    value: function copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      this.w = v.w !== undefined ? v.w : 1;\n      return this;\n    }\n  }, {\n    key: "add",\n    value: function add(v, w) {\n      if (w !== undefined) {\n        console.warn(\'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\');\n        return this.addVectors(v, w);\n      }\n\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      this.w += v.w;\n      return this;\n    }\n  }, {\n    key: "addScalar",\n    value: function addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      this.w += s;\n      return this;\n    }\n  }, {\n    key: "addVectors",\n    value: function addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      this.w = a.w + b.w;\n      return this;\n    }\n  }, {\n    key: "addScaledVector",\n    value: function addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      this.w += v.w * s;\n      return this;\n    }\n  }, {\n    key: "sub",\n    value: function sub(v, w) {\n      if (w !== undefined) {\n        console.warn(\'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\');\n        return this.subVectors(v, w);\n      }\n\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      this.w -= v.w;\n      return this;\n    }\n  }, {\n    key: "subScalar",\n    value: function subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      this.w -= s;\n      return this;\n    }\n  }, {\n    key: "subVectors",\n    value: function subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      this.w = a.w - b.w;\n      return this;\n    }\n  }, {\n    key: "multiply",\n    value: function multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      this.w *= v.w;\n      return this;\n    }\n  }, {\n    key: "multiplyScalar",\n    value: function multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(m) {\n      var x = this.x,\n          y = this.y,\n          z = this.z,\n          w = this.w;\n      var e = m.elements;\n      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n      return this;\n    }\n  }, {\n    key: "divideScalar",\n    value: function divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n  }, {\n    key: "setAxisAngleFromQuaternion",\n    value: function setAxisAngleFromQuaternion(q) {\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n      // q is assumed to be normalized\n      this.w = 2 * Math.acos(q.w);\n      var s = Math.sqrt(1 - q.w * q.w);\n\n      if (s < 0.0001) {\n        this.x = 1;\n        this.y = 0;\n        this.z = 0;\n      } else {\n        this.x = q.x / s;\n        this.y = q.y / s;\n        this.z = q.z / s;\n      }\n\n      return this;\n    }\n  }, {\n    key: "setAxisAngleFromRotationMatrix",\n    value: function setAxisAngleFromRotationMatrix(m) {\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n      var angle, x, y, z; // variables for result\n\n      var epsilon = 0.01,\n          // margin to allow for rounding errors\n      epsilon2 = 0.1,\n          // margin to distinguish between 0 and 180 degrees\n      te = m.elements,\n          m11 = te[0],\n          m12 = te[4],\n          m13 = te[8],\n          m21 = te[1],\n          m22 = te[5],\n          m23 = te[9],\n          m31 = te[2],\n          m32 = te[6],\n          m33 = te[10];\n\n      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n        // singularity found\n        // first check for identity matrix which must have +1 for all terms\n        // in leading diagonal and zero in other terms\n        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n          // this singularity is identity matrix so angle = 0\n          this.set(1, 0, 0, 0);\n          return this; // zero angle, arbitrary axis\n        } // otherwise this singularity is angle = 180\n\n\n        angle = Math.PI;\n        var xx = (m11 + 1) / 2;\n        var yy = (m22 + 1) / 2;\n        var zz = (m33 + 1) / 2;\n        var xy = (m12 + m21) / 4;\n        var xz = (m13 + m31) / 4;\n        var yz = (m23 + m32) / 4;\n\n        if (xx > yy && xx > zz) {\n          // m11 is the largest diagonal term\n          if (xx < epsilon) {\n            x = 0;\n            y = 0.707106781;\n            z = 0.707106781;\n          } else {\n            x = Math.sqrt(xx);\n            y = xy / x;\n            z = xz / x;\n          }\n        } else if (yy > zz) {\n          // m22 is the largest diagonal term\n          if (yy < epsilon) {\n            x = 0.707106781;\n            y = 0;\n            z = 0.707106781;\n          } else {\n            y = Math.sqrt(yy);\n            x = xy / y;\n            z = yz / y;\n          }\n        } else {\n          // m33 is the largest diagonal term so base result on this\n          if (zz < epsilon) {\n            x = 0.707106781;\n            y = 0.707106781;\n            z = 0;\n          } else {\n            z = Math.sqrt(zz);\n            x = xz / z;\n            y = yz / z;\n          }\n        }\n\n        this.set(x, y, z, angle);\n        return this; // return 180 deg rotation\n      } // as we have reached here there are no singularities so we can handle normally\n\n\n      var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n      if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be\n      // caught by singularity test above, but I\'ve left it in just in case\n\n      this.x = (m32 - m23) / s;\n      this.y = (m13 - m31) / s;\n      this.z = (m21 - m12) / s;\n      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n      return this;\n    }\n  }, {\n    key: "min",\n    value: function min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      this.w = Math.min(this.w, v.w);\n      return this;\n    }\n  }, {\n    key: "max",\n    value: function max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      this.w = Math.max(this.w, v.w);\n      return this;\n    }\n  }, {\n    key: "clamp",\n    value: function clamp(min, max) {\n      // assumes min < max, componentwise\n      this.x = Math.max(min.x, Math.min(max.x, this.x));\n      this.y = Math.max(min.y, Math.min(max.y, this.y));\n      this.z = Math.max(min.z, Math.min(max.z, this.z));\n      this.w = Math.max(min.w, Math.min(max.w, this.w));\n      return this;\n    }\n  }, {\n    key: "clampScalar",\n    value: function clampScalar(minVal, maxVal) {\n      this.x = Math.max(minVal, Math.min(maxVal, this.x));\n      this.y = Math.max(minVal, Math.min(maxVal, this.y));\n      this.z = Math.max(minVal, Math.min(maxVal, this.z));\n      this.w = Math.max(minVal, Math.min(maxVal, this.w));\n      return this;\n    }\n  }, {\n    key: "clampLength",\n    value: function clampLength(min, max) {\n      var length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n    }\n  }, {\n    key: "floor",\n    value: function floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      this.w = Math.floor(this.w);\n      return this;\n    }\n  }, {\n    key: "ceil",\n    value: function ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      this.w = Math.ceil(this.w);\n      return this;\n    }\n  }, {\n    key: "round",\n    value: function round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      this.w = Math.round(this.w);\n      return this;\n    }\n  }, {\n    key: "roundToZero",\n    value: function roundToZero() {\n      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n      return this;\n    }\n  }, {\n    key: "negate",\n    value: function negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      this.w = -this.w;\n      return this;\n    }\n  }, {\n    key: "dot",\n    value: function dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n  }, {\n    key: "lengthSq",\n    value: function lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n  }, {\n    key: "manhattanLength",\n    value: function manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    }\n  }, {\n    key: "normalize",\n    value: function normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n  }, {\n    key: "setLength",\n    value: function setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n  }, {\n    key: "lerp",\n    value: function lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      this.w += (v.w - this.w) * alpha;\n      return this;\n    }\n  }, {\n    key: "lerpVectors",\n    value: function lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      this.w = v1.w + (v2.w - v1.w) * alpha;\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      this.w = array[offset + 3];\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      array[offset + 3] = this.w;\n      return array;\n    }\n  }, {\n    key: "fromBufferAttribute",\n    value: function fromBufferAttribute(attribute, index, offset) {\n      if (offset !== undefined) {\n        console.warn(\'THREE.Vector4: offset has been removed from .fromBufferAttribute().\');\n      }\n\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      this.w = attribute.getW(index);\n      return this;\n    }\n  }, {\n    key: "random",\n    value: function random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      this.w = Math.random();\n      return this;\n    }\n  }, {\n    key: _Symbol$iterator3,\n    value: /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function value() {\n      return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function value$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.x;\n\n            case 2:\n              _context4.next = 4;\n              return this.y;\n\n            case 4:\n              _context4.next = 6;\n              return this.z;\n\n            case 6:\n              _context4.next = 8;\n              return this.w;\n\n            case 8:\n            case "end":\n              return _context4.stop();\n          }\n        }\n      }, value, this);\n    })\n  }]);\n\n  return Vector4;\n}(Symbol.iterator);\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\n\n\nvar WebGLRenderTarget = /*#__PURE__*/function (_EventDispatcher2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WebGLRenderTarget, _EventDispatcher2);\n\n  var _super2 = _createSuper(WebGLRenderTarget);\n\n  function WebGLRenderTarget(width, height) {\n    var _this3;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGLRenderTarget);\n\n    _this3 = _super2.call(this);\n    _this3.isWebGLRenderTarget = true;\n    _this3.width = width;\n    _this3.height = height;\n    _this3.depth = 1;\n    _this3.scissor = new Vector4(0, 0, width, height);\n    _this3.scissorTest = false;\n    _this3.viewport = new Vector4(0, 0, width, height);\n    var image = {\n      width: width,\n      height: height,\n      depth: 1\n    };\n    _this3.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n    _this3.texture.isRenderTargetTexture = true;\n    _this3.texture.flipY = false;\n    _this3.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    _this3.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;\n    _this3.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n    _this3.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n    _this3.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n    _this3.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n    _this3.samples = options.samples !== undefined ? options.samples : 0;\n    return _this3;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGLRenderTarget, [{\n    key: "setSize",\n    value: function setSize(width, height) {\n      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      if (this.width !== width || this.height !== height || this.depth !== depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.texture.image.width = width;\n        this.texture.image.height = height;\n        this.texture.image.depth = depth;\n        this.dispose();\n      }\n\n      this.viewport.set(0, 0, width, height);\n      this.scissor.set(0, 0, width, height);\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      this.width = source.width;\n      this.height = source.height;\n      this.depth = source.depth;\n      this.viewport.copy(source.viewport);\n      this.texture = source.texture.clone();\n      this.texture.isRenderTargetTexture = true; // ensure image object is not shared, see #20328\n\n      var image = Object.assign({}, source.texture.image);\n      this.texture.source = new Source(image);\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n      this.samples = source.samples;\n      return this;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: \'dispose\'\n      });\n    }\n  }]);\n\n  return WebGLRenderTarget;\n}(EventDispatcher);\n\nvar DataArrayTexture = /*#__PURE__*/function (_Texture) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DataArrayTexture, _Texture);\n\n  var _super3 = _createSuper(DataArrayTexture);\n\n  function DataArrayTexture() {\n    var _this4;\n\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DataArrayTexture);\n\n    _this4 = _super3.call(this, null);\n    _this4.isDataArrayTexture = true;\n    _this4.image = {\n      data: data,\n      width: width,\n      height: height,\n      depth: depth\n    };\n    _this4.magFilter = NearestFilter;\n    _this4.minFilter = NearestFilter;\n    _this4.wrapR = ClampToEdgeWrapping;\n    _this4.generateMipmaps = false;\n    _this4.flipY = false;\n    _this4.unpackAlignment = 1;\n    return _this4;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DataArrayTexture);\n}(Texture);\n\nvar WebGLArrayRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WebGLArrayRenderTarget, _WebGLRenderTarget);\n\n  var _super4 = _createSuper(WebGLArrayRenderTarget);\n\n  function WebGLArrayRenderTarget(width, height, depth) {\n    var _this5;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGLArrayRenderTarget);\n\n    _this5 = _super4.call(this, width, height);\n    _this5.isWebGLArrayRenderTarget = true;\n    _this5.depth = depth;\n    _this5.texture = new DataArrayTexture(null, width, height, depth);\n    _this5.texture.isRenderTargetTexture = true;\n    return _this5;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGLArrayRenderTarget);\n}(WebGLRenderTarget);\n\nvar Data3DTexture = /*#__PURE__*/function (_Texture2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Data3DTexture, _Texture2);\n\n  var _super5 = _createSuper(Data3DTexture);\n\n  function Data3DTexture() {\n    var _this6;\n\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Data3DTexture);\n\n    // We\'re going to add .setXXX() methods for setting properties later.\n    // Users can still set in DataTexture3D directly.\n    //\n    //\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n    // \ttexture.anisotropy = 16;\n    //\n    // See #14839\n    _this6 = _super5.call(this, null);\n    _this6.isData3DTexture = true;\n    _this6.image = {\n      data: data,\n      width: width,\n      height: height,\n      depth: depth\n    };\n    _this6.magFilter = NearestFilter;\n    _this6.minFilter = NearestFilter;\n    _this6.wrapR = ClampToEdgeWrapping;\n    _this6.generateMipmaps = false;\n    _this6.flipY = false;\n    _this6.unpackAlignment = 1;\n    return _this6;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Data3DTexture);\n}(Texture);\n\nvar WebGL3DRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WebGL3DRenderTarget, _WebGLRenderTarget2);\n\n  var _super6 = _createSuper(WebGL3DRenderTarget);\n\n  function WebGL3DRenderTarget(width, height, depth) {\n    var _this7;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGL3DRenderTarget);\n\n    _this7 = _super6.call(this, width, height);\n    _this7.isWebGL3DRenderTarget = true;\n    _this7.depth = depth;\n    _this7.texture = new Data3DTexture(null, width, height, depth);\n    _this7.texture.isRenderTargetTexture = true;\n    return _this7;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGL3DRenderTarget);\n}(WebGLRenderTarget);\n\nvar WebGLMultipleRenderTargets = /*#__PURE__*/function (_WebGLRenderTarget3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WebGLMultipleRenderTargets, _WebGLRenderTarget3);\n\n  var _super7 = _createSuper(WebGLMultipleRenderTargets);\n\n  function WebGLMultipleRenderTargets(width, height, count) {\n    var _this8;\n\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGLMultipleRenderTargets);\n\n    _this8 = _super7.call(this, width, height, options);\n    _this8.isWebGLMultipleRenderTargets = true;\n    var texture = _this8.texture;\n    _this8.texture = [];\n\n    for (var _i7 = 0; _i7 < count; _i7++) {\n      _this8.texture[_i7] = texture.clone();\n      _this8.texture[_i7].isRenderTargetTexture = true;\n    }\n\n    return _this8;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGLMultipleRenderTargets, [{\n    key: "setSize",\n    value: function setSize(width, height) {\n      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n      if (this.width !== width || this.height !== height || this.depth !== depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n\n        for (var _i8 = 0, il = this.texture.length; _i8 < il; _i8++) {\n          this.texture[_i8].image.width = width;\n          this.texture[_i8].image.height = height;\n          this.texture[_i8].image.depth = depth;\n        }\n\n        this.dispose();\n      }\n\n      this.viewport.set(0, 0, width, height);\n      this.scissor.set(0, 0, width, height);\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      this.dispose();\n      this.width = source.width;\n      this.height = source.height;\n      this.depth = source.depth;\n      this.viewport.set(0, 0, this.width, this.height);\n      this.scissor.set(0, 0, this.width, this.height);\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n      this.texture.length = 0;\n\n      for (var _i9 = 0, il = source.texture.length; _i9 < il; _i9++) {\n        this.texture[_i9] = source.texture[_i9].clone();\n        this.texture[_i9].isRenderTargetTexture = true;\n      }\n\n      return this;\n    }\n  }]);\n\n  return WebGLMultipleRenderTargets;\n}(WebGLRenderTarget);\n\nvar Quaternion = /*#__PURE__*/function (_Symbol$iterator4) {\n  function Quaternion() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Quaternion);\n\n    this.isQuaternion = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Quaternion, [{\n    key: "x",\n    get: function get() {\n      return this._x;\n    },\n    set: function set(value) {\n      this._x = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: "y",\n    get: function get() {\n      return this._y;\n    },\n    set: function set(value) {\n      this._y = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: "z",\n    get: function get() {\n      return this._z;\n    },\n    set: function set(value) {\n      this._z = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: "w",\n    get: function get() {\n      return this._w;\n    },\n    set: function set(value) {\n      this._w = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: "set",\n    value: function set(x, y, z, w) {\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n  }, {\n    key: "copy",\n    value: function copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "setFromEuler",\n    value: function setFromEuler(euler, update) {\n      if (!(euler && euler.isEuler)) {\n        throw new Error(\'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\');\n      }\n\n      var x = euler._x,\n          y = euler._y,\n          z = euler._z,\n          order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/\n      // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n      //\tcontent/SpinCalc.m\n\n      var cos = Math.cos;\n      var sin = Math.sin;\n      var c1 = cos(x / 2);\n      var c2 = cos(y / 2);\n      var c3 = cos(z / 2);\n      var s1 = sin(x / 2);\n      var s2 = sin(y / 2);\n      var s3 = sin(z / 2);\n\n      switch (order) {\n        case \'XYZ\':\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n\n        case \'YXZ\':\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n\n        case \'ZXY\':\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n\n        case \'ZYX\':\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n\n        case \'YZX\':\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n\n        case \'XZY\':\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n\n        default:\n          console.warn(\'THREE.Quaternion: .setFromEuler() encountered an unknown order: \' + order);\n      }\n\n      if (update !== false) this._onChangeCallback();\n      return this;\n    }\n  }, {\n    key: "setFromAxisAngle",\n    value: function setFromAxisAngle(axis, angle) {\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n      // assumes axis is normalized\n      var halfAngle = angle / 2,\n          s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "setFromRotationMatrix",\n    value: function setFromRotationMatrix(m) {\n      // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n      var te = m.elements,\n          m11 = te[0],\n          m12 = te[4],\n          m13 = te[8],\n          m21 = te[1],\n          m22 = te[5],\n          m23 = te[9],\n          m31 = te[2],\n          m32 = te[6],\n          m33 = te[10],\n          trace = m11 + m22 + m33;\n\n      if (trace > 0) {\n        var s = 0.5 / Math.sqrt(trace + 1.0);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n        this._w = (m32 - m23) / _s;\n        this._x = 0.25 * _s;\n        this._y = (m12 + m21) / _s;\n        this._z = (m13 + m31) / _s;\n      } else if (m22 > m33) {\n        var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n        this._w = (m13 - m31) / _s2;\n        this._x = (m12 + m21) / _s2;\n        this._y = 0.25 * _s2;\n        this._z = (m23 + m32) / _s2;\n      } else {\n        var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n        this._w = (m21 - m12) / _s3;\n        this._x = (m13 + m31) / _s3;\n        this._y = (m23 + m32) / _s3;\n        this._z = 0.25 * _s3;\n      }\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "setFromUnitVectors",\n    value: function setFromUnitVectors(vFrom, vTo) {\n      // assumes direction vectors vFrom and vTo are normalized\n      var r = vFrom.dot(vTo) + 1;\n\n      if (r < Number.EPSILON) {\n        // vFrom and vTo point in opposite directions\n        r = 0;\n\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n\n      return this.normalize();\n    }\n  }, {\n    key: "angleTo",\n    value: function angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n  }, {\n    key: "rotateTowards",\n    value: function rotateTowards(q, step) {\n      var angle = this.angleTo(q);\n      if (angle === 0) return this;\n      var t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n  }, {\n    key: "identity",\n    value: function identity() {\n      return this.set(0, 0, 0, 1);\n    }\n  }, {\n    key: "invert",\n    value: function invert() {\n      // quaternion is assumed to have unit length\n      return this.conjugate();\n    }\n  }, {\n    key: "conjugate",\n    value: function conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "dot",\n    value: function dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n  }, {\n    key: "lengthSq",\n    value: function lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n  }, {\n    key: "normalize",\n    value: function normalize() {\n      var l = this.length();\n\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "multiply",\n    value: function multiply(q, p) {\n      if (p !== undefined) {\n        console.warn(\'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\');\n        return this.multiplyQuaternions(q, p);\n      }\n\n      return this.multiplyQuaternions(this, q);\n    }\n  }, {\n    key: "premultiply",\n    value: function premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n  }, {\n    key: "multiplyQuaternions",\n    value: function multiplyQuaternions(a, b) {\n      // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n      var qax = a._x,\n          qay = a._y,\n          qaz = a._z,\n          qaw = a._w;\n      var qbx = b._x,\n          qby = b._y,\n          qbz = b._z,\n          qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "slerp",\n    value: function slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      var x = this._x,\n          y = this._y,\n          z = this._z,\n          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n\n      if (cosHalfTheta >= 1.0) {\n        this._w = w;\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n\n      var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        var s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n\n        this._onChangeCallback();\n\n        return this;\n      }\n\n      var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "slerpQuaternions",\n    value: function slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n  }, {\n    key: "random",\n    value: function random() {\n      // Derived from http://planning.cs.uiuc.edu/node198.html\n      // Note, this source uses w, x, y, z ordering,\n      // so we swap the order below.\n      var u1 = Math.random();\n      var sqrt1u1 = Math.sqrt(1 - u1);\n      var sqrtu1 = Math.sqrt(u1);\n      var u2 = 2 * Math.PI * Math.random();\n      var u3 = 2 * Math.PI * Math.random();\n      return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));\n    }\n  }, {\n    key: "equals",\n    value: function equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n  }, {\n    key: "fromBufferAttribute",\n    value: function fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      return this;\n    }\n  }, {\n    key: "_onChange",\n    value: function _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n  }, {\n    key: "_onChangeCallback",\n    value: function _onChangeCallback() {}\n  }, {\n    key: _Symbol$iterator4,\n    value: /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function value() {\n      return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function value$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return this._x;\n\n            case 2:\n              _context5.next = 4;\n              return this._y;\n\n            case 4:\n              _context5.next = 6;\n              return this._z;\n\n            case 6:\n              _context5.next = 8;\n              return this._w;\n\n            case 8:\n            case "end":\n              return _context5.stop();\n          }\n        }\n      }, value, this);\n    })\n  }], [{\n    key: "slerp",\n    value: function slerp(qa, qb, qm, t) {\n      console.warn(\'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.\');\n      return qm.slerpQuaternions(qa, qb, t);\n    }\n  }, {\n    key: "slerpFlat",\n    value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      // fuzz-free, array-based Quaternion SLERP operation\n      var x0 = src0[srcOffset0 + 0],\n          y0 = src0[srcOffset0 + 1],\n          z0 = src0[srcOffset0 + 2],\n          w0 = src0[srcOffset0 + 3];\n      var x1 = src1[srcOffset1 + 0],\n          y1 = src1[srcOffset1 + 1],\n          z1 = src1[srcOffset1 + 2],\n          w1 = src1[srcOffset1 + 3];\n\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        var s = 1 - t;\n        var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n            dir = cos >= 0 ? 1 : -1,\n            sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:\n\n        if (sqrSin > Number.EPSILON) {\n          var sin = Math.sqrt(sqrSin),\n              len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n\n        var tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:\n\n        if (s === 1 - t) {\n          var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n  }, {\n    key: "multiplyQuaternionsFlat",\n    value: function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      var x0 = src0[srcOffset0];\n      var y0 = src0[srcOffset0 + 1];\n      var z0 = src0[srcOffset0 + 2];\n      var w0 = src0[srcOffset0 + 3];\n      var x1 = src1[srcOffset1];\n      var y1 = src1[srcOffset1 + 1];\n      var z1 = src1[srcOffset1 + 2];\n      var w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n  }]);\n\n  return Quaternion;\n}(Symbol.iterator);\n\nvar Vector3 = /*#__PURE__*/function (_Symbol$iterator5) {\n  function Vector3() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Vector3);\n\n    this.isVector3 = true;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Vector3, [{\n    key: "set",\n    value: function set(x, y, z) {\n      if (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n  }, {\n    key: "setScalar",\n    value: function setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n  }, {\n    key: "setX",\n    value: function setX(x) {\n      this.x = x;\n      return this;\n    }\n  }, {\n    key: "setY",\n    value: function setY(y) {\n      this.y = y;\n      return this;\n    }\n  }, {\n    key: "setZ",\n    value: function setZ(z) {\n      this.z = z;\n      return this;\n    }\n  }, {\n    key: "setComponent",\n    value: function setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n\n        case 1:\n          this.y = value;\n          break;\n\n        case 2:\n          this.z = value;\n          break;\n\n        default:\n          throw new Error(\'index is out of range: \' + index);\n      }\n\n      return this;\n    }\n  }, {\n    key: "getComponent",\n    value: function getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n\n        case 1:\n          return this.y;\n\n        case 2:\n          return this.z;\n\n        default:\n          throw new Error(\'index is out of range: \' + index);\n      }\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n  }, {\n    key: "copy",\n    value: function copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n  }, {\n    key: "add",\n    value: function add(v, w) {\n      if (w !== undefined) {\n        console.warn(\'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\');\n        return this.addVectors(v, w);\n      }\n\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n  }, {\n    key: "addScalar",\n    value: function addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n  }, {\n    key: "addVectors",\n    value: function addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n  }, {\n    key: "addScaledVector",\n    value: function addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n  }, {\n    key: "sub",\n    value: function sub(v, w) {\n      if (w !== undefined) {\n        console.warn(\'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\');\n        return this.subVectors(v, w);\n      }\n\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n  }, {\n    key: "subScalar",\n    value: function subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n  }, {\n    key: "subVectors",\n    value: function subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n  }, {\n    key: "multiply",\n    value: function multiply(v, w) {\n      if (w !== undefined) {\n        console.warn(\'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\');\n        return this.multiplyVectors(v, w);\n      }\n\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n  }, {\n    key: "multiplyScalar",\n    value: function multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n  }, {\n    key: "multiplyVectors",\n    value: function multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n  }, {\n    key: "applyEuler",\n    value: function applyEuler(euler) {\n      if (!(euler && euler.isEuler)) {\n        console.error(\'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.\');\n      }\n\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n  }, {\n    key: "applyAxisAngle",\n    value: function applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n  }, {\n    key: "applyMatrix3",\n    value: function applyMatrix3(m) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var e = m.elements;\n      this.x = e[0] * x + e[3] * y + e[6] * z;\n      this.y = e[1] * x + e[4] * y + e[7] * z;\n      this.z = e[2] * x + e[5] * y + e[8] * z;\n      return this;\n    }\n  }, {\n    key: "applyNormalMatrix",\n    value: function applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(m) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var e = m.elements;\n      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n  }, {\n    key: "applyQuaternion",\n    value: function applyQuaternion(q) {\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var qx = q.x,\n          qy = q.y,\n          qz = q.z,\n          qw = q.w; // calculate quat * vector\n\n      var ix = qw * x + qy * z - qz * y;\n      var iy = qw * y + qz * x - qx * z;\n      var iz = qw * z + qx * y - qy * x;\n      var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n      return this;\n    }\n  }, {\n    key: "project",\n    value: function project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n  }, {\n    key: "unproject",\n    value: function unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n  }, {\n    key: "transformDirection",\n    value: function transformDirection(m) {\n      // input: THREE.Matrix4 affine matrix\n      // vector interpreted as a direction\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var e = m.elements;\n      this.x = e[0] * x + e[4] * y + e[8] * z;\n      this.y = e[1] * x + e[5] * y + e[9] * z;\n      this.z = e[2] * x + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n  }, {\n    key: "divide",\n    value: function divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n  }, {\n    key: "divideScalar",\n    value: function divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n  }, {\n    key: "min",\n    value: function min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n  }, {\n    key: "max",\n    value: function max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n  }, {\n    key: "clamp",\n    value: function clamp(min, max) {\n      // assumes min < max, componentwise\n      this.x = Math.max(min.x, Math.min(max.x, this.x));\n      this.y = Math.max(min.y, Math.min(max.y, this.y));\n      this.z = Math.max(min.z, Math.min(max.z, this.z));\n      return this;\n    }\n  }, {\n    key: "clampScalar",\n    value: function clampScalar(minVal, maxVal) {\n      this.x = Math.max(minVal, Math.min(maxVal, this.x));\n      this.y = Math.max(minVal, Math.min(maxVal, this.y));\n      this.z = Math.max(minVal, Math.min(maxVal, this.z));\n      return this;\n    }\n  }, {\n    key: "clampLength",\n    value: function clampLength(min, max) {\n      var length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n    }\n  }, {\n    key: "floor",\n    value: function floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n  }, {\n    key: "ceil",\n    value: function ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n  }, {\n    key: "round",\n    value: function round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n  }, {\n    key: "roundToZero",\n    value: function roundToZero() {\n      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n      return this;\n    }\n  }, {\n    key: "negate",\n    value: function negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n  }, {\n    key: "dot",\n    value: function dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    } // TODO lengthSquared?\n\n  }, {\n    key: "lengthSq",\n    value: function lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n  }, {\n    key: "length",\n    value: function length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n  }, {\n    key: "manhattanLength",\n    value: function manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n  }, {\n    key: "normalize",\n    value: function normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n  }, {\n    key: "setLength",\n    value: function setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n  }, {\n    key: "lerp",\n    value: function lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n  }, {\n    key: "lerpVectors",\n    value: function lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n  }, {\n    key: "cross",\n    value: function cross(v, w) {\n      if (w !== undefined) {\n        console.warn(\'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\');\n        return this.crossVectors(v, w);\n      }\n\n      return this.crossVectors(this, v);\n    }\n  }, {\n    key: "crossVectors",\n    value: function crossVectors(a, b) {\n      var ax = a.x,\n          ay = a.y,\n          az = a.z;\n      var bx = b.x,\n          by = b.y,\n          bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n  }, {\n    key: "projectOnVector",\n    value: function projectOnVector(v) {\n      var denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      var scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n  }, {\n    key: "projectOnPlane",\n    value: function projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n\n      return this.sub(_vector$c);\n    }\n  }, {\n    key: "reflect",\n    value: function reflect(normal) {\n      // reflect incident vector off plane orthogonal to normal\n      // normal is assumed to have unit length\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n  }, {\n    key: "angleTo",\n    value: function angleTo(v) {\n      var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      var theta = this.dot(v) / denominator; // clamp, to handle numerical problems\n\n      return Math.acos(clamp(theta, -1, 1));\n    }\n  }, {\n    key: "distanceTo",\n    value: function distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n  }, {\n    key: "distanceToSquared",\n    value: function distanceToSquared(v) {\n      var dx = this.x - v.x,\n          dy = this.y - v.y,\n          dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n  }, {\n    key: "manhattanDistanceTo",\n    value: function manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n  }, {\n    key: "setFromSpherical",\n    value: function setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n  }, {\n    key: "setFromSphericalCoords",\n    value: function setFromSphericalCoords(radius, phi, theta) {\n      var sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n  }, {\n    key: "setFromCylindrical",\n    value: function setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n  }, {\n    key: "setFromCylindricalCoords",\n    value: function setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n  }, {\n    key: "setFromMatrixPosition",\n    value: function setFromMatrixPosition(m) {\n      var e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n  }, {\n    key: "setFromMatrixScale",\n    value: function setFromMatrixScale(m) {\n      var sx = this.setFromMatrixColumn(m, 0).length();\n      var sy = this.setFromMatrixColumn(m, 1).length();\n      var sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n  }, {\n    key: "setFromMatrixColumn",\n    value: function setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n  }, {\n    key: "setFromMatrix3Column",\n    value: function setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n  }, {\n    key: "setFromEuler",\n    value: function setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n  }, {\n    key: "fromBufferAttribute",\n    value: function fromBufferAttribute(attribute, index, offset) {\n      if (offset !== undefined) {\n        console.warn(\'THREE.Vector3: offset has been removed from .fromBufferAttribute().\');\n      }\n\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n  }, {\n    key: "random",\n    value: function random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n  }, {\n    key: "randomDirection",\n    value: function randomDirection() {\n      // Derived from https://mathworld.wolfram.com/SpherePointPicking.html\n      var u = (Math.random() - 0.5) * 2;\n      var t = Math.random() * Math.PI * 2;\n      var f = Math.sqrt(1 - Math.pow(u, 2));\n      this.x = f * Math.cos(t);\n      this.y = f * Math.sin(t);\n      this.z = u;\n      return this;\n    }\n  }, {\n    key: _Symbol$iterator5,\n    value: /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function value() {\n      return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function value$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.x;\n\n            case 2:\n              _context6.next = 4;\n              return this.y;\n\n            case 4:\n              _context6.next = 6;\n              return this.z;\n\n            case 6:\n            case "end":\n              return _context6.stop();\n          }\n        }\n      }, value, this);\n    })\n  }]);\n\n  return Vector3;\n}(Symbol.iterator);\n\nvar _vector$c = /*@__PURE__*/new Vector3();\n\nvar _quaternion$4 = /*@__PURE__*/new Quaternion();\n\nvar Box3 = /*#__PURE__*/function () {\n  function Box3() {\n    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(+Infinity, +Infinity, +Infinity);\n    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(-Infinity, -Infinity, -Infinity);\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Box3);\n\n    this.isBox3 = true;\n    this.min = min;\n    this.max = max;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Box3, [{\n    key: "set",\n    value: function set(min, max) {\n      this.min.copy(min);\n      this.max.copy(max);\n      return this;\n    }\n  }, {\n    key: "setFromArray",\n    value: function setFromArray(array) {\n      var minX = +Infinity;\n      var minY = +Infinity;\n      var minZ = +Infinity;\n      var maxX = -Infinity;\n      var maxY = -Infinity;\n      var maxZ = -Infinity;\n\n      for (var _i10 = 0, l = array.length; _i10 < l; _i10 += 3) {\n        var x = array[_i10];\n        var y = array[_i10 + 1];\n        var z = array[_i10 + 2];\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (z < minZ) minZ = z;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        if (z > maxZ) maxZ = z;\n      }\n\n      this.min.set(minX, minY, minZ);\n      this.max.set(maxX, maxY, maxZ);\n      return this;\n    }\n  }, {\n    key: "setFromBufferAttribute",\n    value: function setFromBufferAttribute(attribute) {\n      var minX = +Infinity;\n      var minY = +Infinity;\n      var minZ = +Infinity;\n      var maxX = -Infinity;\n      var maxY = -Infinity;\n      var maxZ = -Infinity;\n\n      for (var _i11 = 0, l = attribute.count; _i11 < l; _i11++) {\n        var x = attribute.getX(_i11);\n        var y = attribute.getY(_i11);\n        var z = attribute.getZ(_i11);\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (z < minZ) minZ = z;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n        if (z > maxZ) maxZ = z;\n      }\n\n      this.min.set(minX, minY, minZ);\n      this.max.set(maxX, maxY, maxZ);\n      return this;\n    }\n  }, {\n    key: "setFromPoints",\n    value: function setFromPoints(points) {\n      this.makeEmpty();\n\n      for (var _i12 = 0, il = points.length; _i12 < il; _i12++) {\n        this.expandByPoint(points[_i12]);\n      }\n\n      return this;\n    }\n  }, {\n    key: "setFromCenterAndSize",\n    value: function setFromCenterAndSize(center, size) {\n      var halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n  }, {\n    key: "setFromObject",\n    value: function setFromObject(object) {\n      var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "copy",\n    value: function copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n  }, {\n    key: "makeEmpty",\n    value: function makeEmpty() {\n      this.min.x = this.min.y = this.min.z = +Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n  }, {\n    key: "isEmpty",\n    value: function isEmpty() {\n      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n  }, {\n    key: "getCenter",\n    value: function getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n  }, {\n    key: "getSize",\n    value: function getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n  }, {\n    key: "expandByPoint",\n    value: function expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n  }, {\n    key: "expandByVector",\n    value: function expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n  }, {\n    key: "expandByScalar",\n    value: function expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n  }, {\n    key: "expandByObject",\n    value: function expandByObject(object) {\n      var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // Computes the world-axis-aligned bounding box of an object (including its children),\n      // accounting for both the object\'s, and children\'s, world transforms\n      object.updateWorldMatrix(false, false);\n      var geometry = object.geometry;\n\n      if (geometry !== undefined) {\n        if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {\n          var position = geometry.attributes.position;\n\n          for (var _i13 = 0, l = position.count; _i13 < l; _i13++) {\n            _vector$b.fromBufferAttribute(position, _i13).applyMatrix4(object.matrixWorld);\n\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (geometry.boundingBox === null) {\n            geometry.computeBoundingBox();\n          }\n\n          _box$3.copy(geometry.boundingBox);\n\n          _box$3.applyMatrix4(object.matrixWorld);\n\n          this.union(_box$3);\n        }\n      }\n\n      var children = object.children;\n\n      for (var _i14 = 0, _l = children.length; _i14 < _l; _i14++) {\n        this.expandByObject(children[_i14], precise);\n      }\n\n      return this;\n    }\n  }, {\n    key: "containsPoint",\n    value: function containsPoint(point) {\n      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n    }\n  }, {\n    key: "containsBox",\n    value: function containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n  }, {\n    key: "getParameter",\n    value: function getParameter(point, target) {\n      // This can potentially have a divide by zero if the box\n      // has a size dimension of 0.\n      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n    }\n  }, {\n    key: "intersectsBox",\n    value: function intersectsBox(box) {\n      // using 6 splitting planes to rule out intersections.\n      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n    }\n  }, {\n    key: "intersectsSphere",\n    value: function intersectsSphere(sphere) {\n      // Find the point on the AABB closest to the sphere center.\n      this.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.\n\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n  }, {\n    key: "intersectsPlane",\n    value: function intersectsPlane(plane) {\n      // We compute the minimum and maximum dot product values. If those values\n      // are on the same side (back or front) of the plane, then there is no intersection.\n      var min, max;\n\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max = plane.normal.x * this.min.x;\n      }\n\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max += plane.normal.y * this.min.y;\n      }\n\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max += plane.normal.z * this.min.z;\n      }\n\n      return min <= -plane.constant && max >= -plane.constant;\n    }\n  }, {\n    key: "intersectsTriangle",\n    value: function intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      } // compute box center and extents\n\n\n      this.getCenter(_center);\n\n      _extents.subVectors(this.max, _center); // translate triangle to aabb origin\n\n\n      _v0$2.subVectors(triangle.a, _center);\n\n      _v1$7.subVectors(triangle.b, _center);\n\n      _v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle\n\n\n      _f0.subVectors(_v1$7, _v0$2);\n\n      _f1.subVectors(_v2$3, _v1$7);\n\n      _f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n      // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n      // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\n\n      var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];\n\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n        return false;\n      } // test 3 face normals from the aabb\n\n\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n        return false;\n      } // finally testing the face normal of the triangle\n      // use already existing triangle edge vectors here\n\n\n      _triangleNormal.crossVectors(_f0, _f1);\n\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);\n    }\n  }, {\n    key: "clampPoint",\n    value: function clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n  }, {\n    key: "distanceToPoint",\n    value: function distanceToPoint(point) {\n      var clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);\n\n      return clampedPoint.sub(point).length();\n    }\n  }, {\n    key: "getBoundingSphere",\n    value: function getBoundingSphere(target) {\n      this.getCenter(target.center);\n      target.radius = this.getSize(_vector$b).length() * 0.5;\n      return target;\n    }\n  }, {\n    key: "intersect",\n    value: function intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n  }, {\n    key: "union",\n    value: function union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(matrix) {\n      // transform of empty box is an empty box.\n      if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n\n\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n\n\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n\n\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n\n\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n\n\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n\n\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n\n\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n\n      this.setFromPoints(_points);\n      return this;\n    }\n  }, {\n    key: "translate",\n    value: function translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n  }]);\n\n  return Box3;\n}();\n\nvar _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];\n\nvar _vector$b = /*@__PURE__*/new Vector3();\n\nvar _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices\n\n\nvar _v0$2 = /*@__PURE__*/new Vector3();\n\nvar _v1$7 = /*@__PURE__*/new Vector3();\n\nvar _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors\n\n\nvar _f0 = /*@__PURE__*/new Vector3();\n\nvar _f1 = /*@__PURE__*/new Vector3();\n\nvar _f2 = /*@__PURE__*/new Vector3();\n\nvar _center = /*@__PURE__*/new Vector3();\n\nvar _extents = /*@__PURE__*/new Vector3();\n\nvar _triangleNormal = /*@__PURE__*/new Vector3();\n\nvar _testAxis = /*@__PURE__*/new Vector3();\n\nfunction satForAxes(axes, v0, v1, v2, extents) {\n  for (var _i15 = 0, j = axes.length - 3; _i15 <= j; _i15 += 3) {\n    _testAxis.fromArray(axes, _i15); // project the aabb onto the separating axis\n\n\n    var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the separating axis\n\n    var p0 = v0.dot(_testAxis);\n    var p1 = v1.dot(_testAxis);\n    var p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r\n\n    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      // points of the projected triangle are outside the projected half-length of the aabb\n      // the axis is separating and we can exit\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar _box$2 = /*@__PURE__*/new Box3();\n\nvar _v1$6 = /*@__PURE__*/new Vector3();\n\nvar _toFarthestPoint = /*@__PURE__*/new Vector3();\n\nvar _toPoint = /*@__PURE__*/new Vector3();\n\nvar Sphere = /*#__PURE__*/function () {\n  function Sphere() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Sphere);\n\n    this.center = center;\n    this.radius = radius;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Sphere, [{\n    key: "set",\n    value: function set(center, radius) {\n      this.center.copy(center);\n      this.radius = radius;\n      return this;\n    }\n  }, {\n    key: "setFromPoints",\n    value: function setFromPoints(points, optionalCenter) {\n      var center = this.center;\n\n      if (optionalCenter !== undefined) {\n        center.copy(optionalCenter);\n      } else {\n        _box$2.setFromPoints(points).getCenter(center);\n      }\n\n      var maxRadiusSq = 0;\n\n      for (var _i16 = 0, il = points.length; _i16 < il; _i16++) {\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[_i16]));\n      }\n\n      this.radius = Math.sqrt(maxRadiusSq);\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(sphere) {\n      this.center.copy(sphere.center);\n      this.radius = sphere.radius;\n      return this;\n    }\n  }, {\n    key: "isEmpty",\n    value: function isEmpty() {\n      return this.radius < 0;\n    }\n  }, {\n    key: "makeEmpty",\n    value: function makeEmpty() {\n      this.center.set(0, 0, 0);\n      this.radius = -1;\n      return this;\n    }\n  }, {\n    key: "containsPoint",\n    value: function containsPoint(point) {\n      return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    }\n  }, {\n    key: "distanceToPoint",\n    value: function distanceToPoint(point) {\n      return point.distanceTo(this.center) - this.radius;\n    }\n  }, {\n    key: "intersectsSphere",\n    value: function intersectsSphere(sphere) {\n      var radiusSum = this.radius + sphere.radius;\n      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    }\n  }, {\n    key: "intersectsBox",\n    value: function intersectsBox(box) {\n      return box.intersectsSphere(this);\n    }\n  }, {\n    key: "intersectsPlane",\n    value: function intersectsPlane(plane) {\n      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n  }, {\n    key: "clampPoint",\n    value: function clampPoint(point, target) {\n      var deltaLengthSq = this.center.distanceToSquared(point);\n      target.copy(point);\n\n      if (deltaLengthSq > this.radius * this.radius) {\n        target.sub(this.center).normalize();\n        target.multiplyScalar(this.radius).add(this.center);\n      }\n\n      return target;\n    }\n  }, {\n    key: "getBoundingBox",\n    value: function getBoundingBox(target) {\n      if (this.isEmpty()) {\n        // Empty sphere produces empty bounding box\n        target.makeEmpty();\n        return target;\n      }\n\n      target.set(this.center, this.center);\n      target.expandByScalar(this.radius);\n      return target;\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(matrix) {\n      this.center.applyMatrix4(matrix);\n      this.radius = this.radius * matrix.getMaxScaleOnAxis();\n      return this;\n    }\n  }, {\n    key: "translate",\n    value: function translate(offset) {\n      this.center.add(offset);\n      return this;\n    }\n  }, {\n    key: "expandByPoint",\n    value: function expandByPoint(point) {\n      // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n      _toPoint.subVectors(point, this.center);\n\n      var lengthSq = _toPoint.lengthSq();\n\n      if (lengthSq > this.radius * this.radius) {\n        var length = Math.sqrt(lengthSq);\n        var missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,\n        // and the other half to position. This gives a tighter enclosure, instead of if\n        // the whole missing distance were just added to radius.\n\n        this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n        this.radius += missingRadiusHalf;\n      }\n\n      return this;\n    }\n  }, {\n    key: "union",\n    value: function union(sphere) {\n      // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n      // To enclose another sphere into this sphere, we only need to enclose two points:\n      // 1) Enclose the farthest point on the other sphere into this sphere.\n      // 2) Enclose the opposite point of the farthest point into this sphere.\n      if (this.center.equals(sphere.center) === true) {\n        _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);\n      } else {\n        _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);\n      }\n\n      this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));\n      this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(sphere) {\n      return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }]);\n\n  return Sphere;\n}();\n\nvar _vector$a = /*@__PURE__*/new Vector3();\n\nvar _segCenter = /*@__PURE__*/new Vector3();\n\nvar _segDir = /*@__PURE__*/new Vector3();\n\nvar _diff = /*@__PURE__*/new Vector3();\n\nvar _edge1 = /*@__PURE__*/new Vector3();\n\nvar _edge2 = /*@__PURE__*/new Vector3();\n\nvar _normal$1 = /*@__PURE__*/new Vector3();\n\nvar Ray = /*#__PURE__*/function () {\n  function Ray() {\n    var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, -1);\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Ray);\n\n    this.origin = origin;\n    this.direction = direction;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Ray, [{\n    key: "set",\n    value: function set(origin, direction) {\n      this.origin.copy(origin);\n      this.direction.copy(direction);\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(ray) {\n      this.origin.copy(ray.origin);\n      this.direction.copy(ray.direction);\n      return this;\n    }\n  }, {\n    key: "at",\n    value: function at(t, target) {\n      return target.copy(this.direction).multiplyScalar(t).add(this.origin);\n    }\n  }, {\n    key: "lookAt",\n    value: function lookAt(v) {\n      this.direction.copy(v).sub(this.origin).normalize();\n      return this;\n    }\n  }, {\n    key: "recast",\n    value: function recast(t) {\n      this.origin.copy(this.at(t, _vector$a));\n      return this;\n    }\n  }, {\n    key: "closestPointToPoint",\n    value: function closestPointToPoint(point, target) {\n      target.subVectors(point, this.origin);\n      var directionDistance = target.dot(this.direction);\n\n      if (directionDistance < 0) {\n        return target.copy(this.origin);\n      }\n\n      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n    }\n  }, {\n    key: "distanceToPoint",\n    value: function distanceToPoint(point) {\n      return Math.sqrt(this.distanceSqToPoint(point));\n    }\n  }, {\n    key: "distanceSqToPoint",\n    value: function distanceSqToPoint(point) {\n      var directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray\n\n\n      if (directionDistance < 0) {\n        return this.origin.distanceToSquared(point);\n      }\n\n      _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\n      return _vector$a.distanceToSquared(point);\n    }\n  }, {\n    key: "distanceSqToSegment",\n    value: function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n      // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n      // It returns the min distance between the ray and the segment\n      // defined by v0 and v1\n      // It can also set two optional targets :\n      // - The closest point on the ray\n      // - The closest point on the segment\n      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n\n      _segDir.copy(v1).sub(v0).normalize();\n\n      _diff.copy(this.origin).sub(_segCenter);\n\n      var segExtent = v0.distanceTo(v1) * 0.5;\n      var a01 = -this.direction.dot(_segDir);\n\n      var b0 = _diff.dot(this.direction);\n\n      var b1 = -_diff.dot(_segDir);\n\n      var c = _diff.lengthSq();\n\n      var det = Math.abs(1 - a01 * a01);\n      var s0, s1, sqrDist, extDet;\n\n      if (det > 0) {\n        // The ray and segment are not parallel.\n        s0 = a01 * b1 - b0;\n        s1 = a01 * b0 - b1;\n        extDet = segExtent * det;\n\n        if (s0 >= 0) {\n          if (s1 >= -extDet) {\n            if (s1 <= extDet) {\n              // region 0\n              // Minimum at interior points of ray and segment.\n              var invDet = 1 / det;\n              s0 *= invDet;\n              s1 *= invDet;\n              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n            } else {\n              // region 1\n              s1 = segExtent;\n              s0 = Math.max(0, -(a01 * s1 + b0));\n              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n            }\n          } else {\n            // region 5\n            s1 = -segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          if (s1 <= -extDet) {\n            // region 4\n            s0 = Math.max(0, -(-a01 * segExtent + b0));\n            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          } else if (s1 <= extDet) {\n            // region 3\n            s0 = 0;\n            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = s1 * (s1 + 2 * b1) + c;\n          } else {\n            // region 2\n            s0 = Math.max(0, -(a01 * segExtent + b0));\n            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        }\n      } else {\n        // Ray and segment are parallel.\n        s1 = a01 > 0 ? -segExtent : segExtent;\n        s0 = Math.max(0, -(a01 * s1 + b0));\n        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n      }\n\n      if (optionalPointOnRay) {\n        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n      }\n\n      if (optionalPointOnSegment) {\n        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n      }\n\n      return sqrDist;\n    }\n  }, {\n    key: "intersectSphere",\n    value: function intersectSphere(sphere, target) {\n      _vector$a.subVectors(sphere.center, this.origin);\n\n      var tca = _vector$a.dot(this.direction);\n\n      var d2 = _vector$a.dot(_vector$a) - tca * tca;\n      var radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      var thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere\n\n      var t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere\n\n      var t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null\n\n      if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:\n      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n      // in order to always return an intersect point that is in front of the ray.\n\n      if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0\n\n      return this.at(t0, target);\n    }\n  }, {\n    key: "intersectsSphere",\n    value: function intersectsSphere(sphere) {\n      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n    }\n  }, {\n    key: "distanceToPlane",\n    value: function distanceToPlane(plane) {\n      var denominator = plane.normal.dot(this.direction);\n\n      if (denominator === 0) {\n        // line is coplanar, return origin\n        if (plane.distanceToPoint(this.origin) === 0) {\n          return 0;\n        } // Null is preferable to undefined since undefined means.... it is undefined\n\n\n        return null;\n      }\n\n      var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane\n\n      return t >= 0 ? t : null;\n    }\n  }, {\n    key: "intersectPlane",\n    value: function intersectPlane(plane, target) {\n      var t = this.distanceToPlane(plane);\n\n      if (t === null) {\n        return null;\n      }\n\n      return this.at(t, target);\n    }\n  }, {\n    key: "intersectsPlane",\n    value: function intersectsPlane(plane) {\n      // check if the ray lies on the plane first\n      var distToPoint = plane.distanceToPoint(this.origin);\n\n      if (distToPoint === 0) {\n        return true;\n      }\n\n      var denominator = plane.normal.dot(this.direction);\n\n      if (denominator * distToPoint < 0) {\n        return true;\n      } // ray origin is behind the plane (and is pointing behind it)\n\n\n      return false;\n    }\n  }, {\n    key: "intersectBox",\n    value: function intersectBox(box, target) {\n      var tmin, tmax, tymin, tymax, tzmin, tzmax;\n      var invdirx = 1 / this.direction.x,\n          invdiry = 1 / this.direction.y,\n          invdirz = 1 / this.direction.z;\n      var origin = this.origin;\n\n      if (invdirx >= 0) {\n        tmin = (box.min.x - origin.x) * invdirx;\n        tmax = (box.max.x - origin.x) * invdirx;\n      } else {\n        tmin = (box.max.x - origin.x) * invdirx;\n        tmax = (box.min.x - origin.x) * invdirx;\n      }\n\n      if (invdiry >= 0) {\n        tymin = (box.min.y - origin.y) * invdiry;\n        tymax = (box.max.y - origin.y) * invdiry;\n      } else {\n        tymin = (box.max.y - origin.y) * invdiry;\n        tymax = (box.min.y - origin.y) * invdiry;\n      }\n\n      if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN\n      // (result of 0 * Infinity). x !== x returns true if x is NaN\n\n      if (tymin > tmin || tmin !== tmin) tmin = tymin;\n      if (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n      if (invdirz >= 0) {\n        tzmin = (box.min.z - origin.z) * invdirz;\n        tzmax = (box.max.z - origin.z) * invdirz;\n      } else {\n        tzmin = (box.max.z - origin.z) * invdirz;\n        tzmax = (box.min.z - origin.z) * invdirz;\n      }\n\n      if (tmin > tzmax || tzmin > tmax) return null;\n      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n      if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)\n\n      if (tmax < 0) return null;\n      return this.at(tmin >= 0 ? tmin : tmax, target);\n    }\n  }, {\n    key: "intersectsBox",\n    value: function intersectsBox(box) {\n      return this.intersectBox(box, _vector$a) !== null;\n    }\n  }, {\n    key: "intersectTriangle",\n    value: function intersectTriangle(a, b, c, backfaceCulling, target) {\n      // Compute the offset origin, edges, and normal.\n      // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n      _edge1.subVectors(b, a);\n\n      _edge2.subVectors(c, a);\n\n      _normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\n\n      var DdN = this.direction.dot(_normal$1);\n      var sign;\n\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n\n      _diff.subVectors(this.origin, a);\n\n      var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection\n\n      if (DdQxE2 < 0) {\n        return null;\n      }\n\n      var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection\n\n      if (DdE1xQ < 0) {\n        return null;\n      } // b1+b2 > 1, no intersection\n\n\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      } // Line intersects triangle, check if ray does.\n\n\n      var QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection\n\n\n      if (QdN < 0) {\n        return null;\n      } // Ray intersects triangle.\n\n\n      return this.at(QdN / DdN, target);\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(matrix4) {\n      this.origin.applyMatrix4(matrix4);\n      this.direction.transformDirection(matrix4);\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(ray) {\n      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }]);\n\n  return Ray;\n}();\n\nvar Matrix4 = /*#__PURE__*/function () {\n  function Matrix4() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Matrix4);\n\n    this.isMatrix4 = true;\n    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n    if (arguments.length > 0) {\n      console.error(\'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.\');\n    }\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Matrix4, [{\n    key: "set",\n    value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      var te = this.elements;\n      te[0] = n11;\n      te[4] = n12;\n      te[8] = n13;\n      te[12] = n14;\n      te[1] = n21;\n      te[5] = n22;\n      te[9] = n23;\n      te[13] = n24;\n      te[2] = n31;\n      te[6] = n32;\n      te[10] = n33;\n      te[14] = n34;\n      te[3] = n41;\n      te[7] = n42;\n      te[11] = n43;\n      te[15] = n44;\n      return this;\n    }\n  }, {\n    key: "identity",\n    value: function identity() {\n      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new Matrix4().fromArray(this.elements);\n    }\n  }, {\n    key: "copy",\n    value: function copy(m) {\n      var te = this.elements;\n      var me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      te[9] = me[9];\n      te[10] = me[10];\n      te[11] = me[11];\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      te[15] = me[15];\n      return this;\n    }\n  }, {\n    key: "copyPosition",\n    value: function copyPosition(m) {\n      var te = this.elements,\n          me = m.elements;\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      return this;\n    }\n  }, {\n    key: "setFromMatrix3",\n    value: function setFromMatrix3(m) {\n      var me = m.elements;\n      this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "extractBasis",\n    value: function extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrixColumn(this, 0);\n      yAxis.setFromMatrixColumn(this, 1);\n      zAxis.setFromMatrixColumn(this, 2);\n      return this;\n    }\n  }, {\n    key: "makeBasis",\n    value: function makeBasis(xAxis, yAxis, zAxis) {\n      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "extractRotation",\n    value: function extractRotation(m) {\n      // this method does not support reflection matrices\n      var te = this.elements;\n      var me = m.elements;\n\n      var scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n\n      var scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n\n      var scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n      te[3] = 0;\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n      te[7] = 0;\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n  }, {\n    key: "makeRotationFromEuler",\n    value: function makeRotationFromEuler(euler) {\n      if (!(euler && euler.isEuler)) {\n        console.error(\'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\');\n      }\n\n      var te = this.elements;\n      var x = euler.x,\n          y = euler.y,\n          z = euler.z;\n      var a = Math.cos(x),\n          b = Math.sin(x);\n      var c = Math.cos(y),\n          d = Math.sin(y);\n      var e = Math.cos(z),\n          f = Math.sin(z);\n\n      if (euler.order === \'XYZ\') {\n        var ae = a * e,\n            af = a * f,\n            be = b * e,\n            bf = b * f;\n        te[0] = c * e;\n        te[4] = -c * f;\n        te[8] = d;\n        te[1] = af + be * d;\n        te[5] = ae - bf * d;\n        te[9] = -b * c;\n        te[2] = bf - ae * d;\n        te[6] = be + af * d;\n        te[10] = a * c;\n      } else if (euler.order === \'YXZ\') {\n        var ce = c * e,\n            cf = c * f,\n            de = d * e,\n            df = d * f;\n        te[0] = ce + df * b;\n        te[4] = de * b - cf;\n        te[8] = a * d;\n        te[1] = a * f;\n        te[5] = a * e;\n        te[9] = -b;\n        te[2] = cf * b - de;\n        te[6] = df + ce * b;\n        te[10] = a * c;\n      } else if (euler.order === \'ZXY\') {\n        var _ce = c * e,\n            _cf = c * f,\n            _de = d * e,\n            _df = d * f;\n\n        te[0] = _ce - _df * b;\n        te[4] = -a * f;\n        te[8] = _de + _cf * b;\n        te[1] = _cf + _de * b;\n        te[5] = a * e;\n        te[9] = _df - _ce * b;\n        te[2] = -a * d;\n        te[6] = b;\n        te[10] = a * c;\n      } else if (euler.order === \'ZYX\') {\n        var _ae = a * e,\n            _af = a * f,\n            _be = b * e,\n            _bf = b * f;\n\n        te[0] = c * e;\n        te[4] = _be * d - _af;\n        te[8] = _ae * d + _bf;\n        te[1] = c * f;\n        te[5] = _bf * d + _ae;\n        te[9] = _af * d - _be;\n        te[2] = -d;\n        te[6] = b * c;\n        te[10] = a * c;\n      } else if (euler.order === \'YZX\') {\n        var ac = a * c,\n            ad = a * d,\n            bc = b * c,\n            bd = b * d;\n        te[0] = c * e;\n        te[4] = bd - ac * f;\n        te[8] = bc * f + ad;\n        te[1] = f;\n        te[5] = a * e;\n        te[9] = -b * e;\n        te[2] = -d * e;\n        te[6] = ad * f + bc;\n        te[10] = ac - bd * f;\n      } else if (euler.order === \'XZY\') {\n        var _ac = a * c,\n            _ad = a * d,\n            _bc = b * c,\n            _bd = b * d;\n\n        te[0] = c * e;\n        te[4] = -f;\n        te[8] = d * e;\n        te[1] = _ac * f + _bd;\n        te[5] = a * e;\n        te[9] = _ad * f - _bc;\n        te[2] = _bc * f - _ad;\n        te[6] = b * e;\n        te[10] = _bd * f + _ac;\n      } // bottom row\n\n\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0; // last column\n\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n  }, {\n    key: "makeRotationFromQuaternion",\n    value: function makeRotationFromQuaternion(q) {\n      return this.compose(_zero, q, _one);\n    }\n  }, {\n    key: "lookAt",\n    value: function lookAt(eye, target, up) {\n      var te = this.elements;\n\n      _z.subVectors(eye, target);\n\n      if (_z.lengthSq() === 0) {\n        // eye and target are in the same position\n        _z.z = 1;\n      }\n\n      _z.normalize();\n\n      _x.crossVectors(up, _z);\n\n      if (_x.lengthSq() === 0) {\n        // up and z are parallel\n        if (Math.abs(up.z) === 1) {\n          _z.x += 0.0001;\n        } else {\n          _z.z += 0.0001;\n        }\n\n        _z.normalize();\n\n        _x.crossVectors(up, _z);\n      }\n\n      _x.normalize();\n\n      _y.crossVectors(_z, _x);\n\n      te[0] = _x.x;\n      te[4] = _y.x;\n      te[8] = _z.x;\n      te[1] = _x.y;\n      te[5] = _y.y;\n      te[9] = _z.y;\n      te[2] = _x.z;\n      te[6] = _y.z;\n      te[10] = _z.z;\n      return this;\n    }\n  }, {\n    key: "multiply",\n    value: function multiply(m, n) {\n      if (n !== undefined) {\n        console.warn(\'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\');\n        return this.multiplyMatrices(m, n);\n      }\n\n      return this.multiplyMatrices(this, m);\n    }\n  }, {\n    key: "premultiply",\n    value: function premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n  }, {\n    key: "multiplyMatrices",\n    value: function multiplyMatrices(a, b) {\n      var ae = a.elements;\n      var be = b.elements;\n      var te = this.elements;\n      var a11 = ae[0],\n          a12 = ae[4],\n          a13 = ae[8],\n          a14 = ae[12];\n      var a21 = ae[1],\n          a22 = ae[5],\n          a23 = ae[9],\n          a24 = ae[13];\n      var a31 = ae[2],\n          a32 = ae[6],\n          a33 = ae[10],\n          a34 = ae[14];\n      var a41 = ae[3],\n          a42 = ae[7],\n          a43 = ae[11],\n          a44 = ae[15];\n      var b11 = be[0],\n          b12 = be[4],\n          b13 = be[8],\n          b14 = be[12];\n      var b21 = be[1],\n          b22 = be[5],\n          b23 = be[9],\n          b24 = be[13];\n      var b31 = be[2],\n          b32 = be[6],\n          b33 = be[10],\n          b34 = be[14];\n      var b41 = be[3],\n          b42 = be[7],\n          b43 = be[11],\n          b44 = be[15];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n  }, {\n    key: "multiplyScalar",\n    value: function multiplyScalar(s) {\n      var te = this.elements;\n      te[0] *= s;\n      te[4] *= s;\n      te[8] *= s;\n      te[12] *= s;\n      te[1] *= s;\n      te[5] *= s;\n      te[9] *= s;\n      te[13] *= s;\n      te[2] *= s;\n      te[6] *= s;\n      te[10] *= s;\n      te[14] *= s;\n      te[3] *= s;\n      te[7] *= s;\n      te[11] *= s;\n      te[15] *= s;\n      return this;\n    }\n  }, {\n    key: "determinant",\n    value: function determinant() {\n      var te = this.elements;\n      var n11 = te[0],\n          n12 = te[4],\n          n13 = te[8],\n          n14 = te[12];\n      var n21 = te[1],\n          n22 = te[5],\n          n23 = te[9],\n          n24 = te[13];\n      var n31 = te[2],\n          n32 = te[6],\n          n33 = te[10],\n          n34 = te[14];\n      var n41 = te[3],\n          n42 = te[7],\n          n43 = te[11],\n          n44 = te[15]; //TODO: make this more efficient\n      //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    }\n  }, {\n    key: "transpose",\n    value: function transpose() {\n      var te = this.elements;\n      var tmp;\n      tmp = te[1];\n      te[1] = te[4];\n      te[4] = tmp;\n      tmp = te[2];\n      te[2] = te[8];\n      te[8] = tmp;\n      tmp = te[6];\n      te[6] = te[9];\n      te[9] = tmp;\n      tmp = te[3];\n      te[3] = te[12];\n      te[12] = tmp;\n      tmp = te[7];\n      te[7] = te[13];\n      te[13] = tmp;\n      tmp = te[11];\n      te[11] = te[14];\n      te[14] = tmp;\n      return this;\n    }\n  }, {\n    key: "setPosition",\n    value: function setPosition(x, y, z) {\n      var te = this.elements;\n\n      if (x.isVector3) {\n        te[12] = x.x;\n        te[13] = x.y;\n        te[14] = x.z;\n      } else {\n        te[12] = x;\n        te[13] = y;\n        te[14] = z;\n      }\n\n      return this;\n    }\n  }, {\n    key: "invert",\n    value: function invert() {\n      // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n      var te = this.elements,\n          n11 = te[0],\n          n21 = te[1],\n          n31 = te[2],\n          n41 = te[3],\n          n12 = te[4],\n          n22 = te[5],\n          n32 = te[6],\n          n42 = te[7],\n          n13 = te[8],\n          n23 = te[9],\n          n33 = te[10],\n          n43 = te[11],\n          n14 = te[12],\n          n24 = te[13],\n          n34 = te[14],\n          n44 = te[15],\n          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      var detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      te[4] = t12 * detInv;\n      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      te[8] = t13 * detInv;\n      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      te[12] = t14 * detInv;\n      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      return this;\n    }\n  }, {\n    key: "scale",\n    value: function scale(v) {\n      var te = this.elements;\n      var x = v.x,\n          y = v.y,\n          z = v.z;\n      te[0] *= x;\n      te[4] *= y;\n      te[8] *= z;\n      te[1] *= x;\n      te[5] *= y;\n      te[9] *= z;\n      te[2] *= x;\n      te[6] *= y;\n      te[10] *= z;\n      te[3] *= x;\n      te[7] *= y;\n      te[11] *= z;\n      return this;\n    }\n  }, {\n    key: "getMaxScaleOnAxis",\n    value: function getMaxScaleOnAxis() {\n      var te = this.elements;\n      var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n      var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n      var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n  }, {\n    key: "makeTranslation",\n    value: function makeTranslation(x, y, z) {\n      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "makeRotationX",\n    value: function makeRotationX(theta) {\n      var c = Math.cos(theta),\n          s = Math.sin(theta);\n      this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "makeRotationY",\n    value: function makeRotationY(theta) {\n      var c = Math.cos(theta),\n          s = Math.sin(theta);\n      this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "makeRotationZ",\n    value: function makeRotationZ(theta) {\n      var c = Math.cos(theta),\n          s = Math.sin(theta);\n      this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "makeRotationAxis",\n    value: function makeRotationAxis(axis, angle) {\n      // Based on http://www.gamedev.net/reference/articles/article1199.asp\n      var c = Math.cos(angle);\n      var s = Math.sin(angle);\n      var t = 1 - c;\n      var x = axis.x,\n          y = axis.y,\n          z = axis.z;\n      var tx = t * x,\n          ty = t * y;\n      this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "makeScale",\n    value: function makeScale(x, y, z) {\n      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "makeShear",\n    value: function makeShear(xy, xz, yx, yz, zx, zy) {\n      this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n      return this;\n    }\n  }, {\n    key: "compose",\n    value: function compose(position, quaternion, scale) {\n      var te = this.elements;\n      var x = quaternion._x,\n          y = quaternion._y,\n          z = quaternion._z,\n          w = quaternion._w;\n      var x2 = x + x,\n          y2 = y + y,\n          z2 = z + z;\n      var xx = x * x2,\n          xy = x * y2,\n          xz = x * z2;\n      var yy = y * y2,\n          yz = y * z2,\n          zz = z * z2;\n      var wx = w * x2,\n          wy = w * y2,\n          wz = w * z2;\n      var sx = scale.x,\n          sy = scale.y,\n          sz = scale.z;\n      te[0] = (1 - (yy + zz)) * sx;\n      te[1] = (xy + wz) * sx;\n      te[2] = (xz - wy) * sx;\n      te[3] = 0;\n      te[4] = (xy - wz) * sy;\n      te[5] = (1 - (xx + zz)) * sy;\n      te[6] = (yz + wx) * sy;\n      te[7] = 0;\n      te[8] = (xz + wy) * sz;\n      te[9] = (yz - wx) * sz;\n      te[10] = (1 - (xx + yy)) * sz;\n      te[11] = 0;\n      te[12] = position.x;\n      te[13] = position.y;\n      te[14] = position.z;\n      te[15] = 1;\n      return this;\n    }\n  }, {\n    key: "decompose",\n    value: function decompose(position, quaternion, scale) {\n      var te = this.elements;\n\n      var sx = _v1$5.set(te[0], te[1], te[2]).length();\n\n      var sy = _v1$5.set(te[4], te[5], te[6]).length();\n\n      var sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale\n\n\n      var det = this.determinant();\n      if (det < 0) sx = -sx;\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14]; // scale the rotation part\n\n      _m1$2.copy(this);\n\n      var invSX = 1 / sx;\n      var invSY = 1 / sy;\n      var invSZ = 1 / sz;\n      _m1$2.elements[0] *= invSX;\n      _m1$2.elements[1] *= invSX;\n      _m1$2.elements[2] *= invSX;\n      _m1$2.elements[4] *= invSY;\n      _m1$2.elements[5] *= invSY;\n      _m1$2.elements[6] *= invSY;\n      _m1$2.elements[8] *= invSZ;\n      _m1$2.elements[9] *= invSZ;\n      _m1$2.elements[10] *= invSZ;\n      quaternion.setFromRotationMatrix(_m1$2);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return this;\n    }\n  }, {\n    key: "makePerspective",\n    value: function makePerspective(left, right, top, bottom, near, far) {\n      if (far === undefined) {\n        console.warn(\'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\');\n      }\n\n      var te = this.elements;\n      var x = 2 * near / (right - left);\n      var y = 2 * near / (top - bottom);\n      var a = (right + left) / (right - left);\n      var b = (top + bottom) / (top - bottom);\n      var c = -(far + near) / (far - near);\n      var d = -2 * far * near / (far - near);\n      te[0] = x;\n      te[4] = 0;\n      te[8] = a;\n      te[12] = 0;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = b;\n      te[13] = 0;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = -1;\n      te[15] = 0;\n      return this;\n    }\n  }, {\n    key: "makeOrthographic",\n    value: function makeOrthographic(left, right, top, bottom, near, far) {\n      var te = this.elements;\n      var w = 1.0 / (right - left);\n      var h = 1.0 / (top - bottom);\n      var p = 1.0 / (far - near);\n      var x = (right + left) * w;\n      var y = (top + bottom) * h;\n      var z = (far + near) * p;\n      te[0] = 2 * w;\n      te[4] = 0;\n      te[8] = 0;\n      te[12] = -x;\n      te[1] = 0;\n      te[5] = 2 * h;\n      te[9] = 0;\n      te[13] = -y;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = -2 * p;\n      te[14] = -z;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[15] = 1;\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(matrix) {\n      var te = this.elements;\n      var me = matrix.elements;\n\n      for (var _i17 = 0; _i17 < 16; _i17++) {\n        if (te[_i17] !== me[_i17]) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      for (var _i18 = 0; _i18 < 16; _i18++) {\n        this.elements[_i18] = array[_i18 + offset];\n      }\n\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      array[offset + 9] = te[9];\n      array[offset + 10] = te[10];\n      array[offset + 11] = te[11];\n      array[offset + 12] = te[12];\n      array[offset + 13] = te[13];\n      array[offset + 14] = te[14];\n      array[offset + 15] = te[15];\n      return array;\n    }\n  }]);\n\n  return Matrix4;\n}();\n\nvar _v1$5 = /*@__PURE__*/new Vector3();\n\nvar _m1$2 = /*@__PURE__*/new Matrix4();\n\nvar _zero = /*@__PURE__*/new Vector3(0, 0, 0);\n\nvar _one = /*@__PURE__*/new Vector3(1, 1, 1);\n\nvar _x = /*@__PURE__*/new Vector3();\n\nvar _y = /*@__PURE__*/new Vector3();\n\nvar _z = /*@__PURE__*/new Vector3();\n\nvar _matrix$1 = /*@__PURE__*/new Matrix4();\n\nvar _quaternion$3 = /*@__PURE__*/new Quaternion();\n\nvar Euler = /*#__PURE__*/function (_Symbol$iterator6) {\n  function Euler() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DefaultOrder;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Euler);\n\n    this.isEuler = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Euler, [{\n    key: "x",\n    get: function get() {\n      return this._x;\n    },\n    set: function set(value) {\n      this._x = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: "y",\n    get: function get() {\n      return this._y;\n    },\n    set: function set(value) {\n      this._y = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: "z",\n    get: function get() {\n      return this._z;\n    },\n    set: function set(value) {\n      this._z = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: "order",\n    get: function get() {\n      return this._order;\n    },\n    set: function set(value) {\n      this._order = value;\n\n      this._onChangeCallback();\n    }\n  }, {\n    key: "set",\n    value: function set(x, y, z) {\n      var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._order;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor(this._x, this._y, this._z, this._order);\n    }\n  }, {\n    key: "copy",\n    value: function copy(euler) {\n      this._x = euler._x;\n      this._y = euler._y;\n      this._z = euler._z;\n      this._order = euler._order;\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "setFromRotationMatrix",\n    value: function setFromRotationMatrix(m) {\n      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;\n      var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n      var te = m.elements;\n      var m11 = te[0],\n          m12 = te[4],\n          m13 = te[8];\n      var m21 = te[1],\n          m22 = te[5],\n          m23 = te[9];\n      var m31 = te[2],\n          m32 = te[6],\n          m33 = te[10];\n\n      switch (order) {\n        case \'XYZ\':\n          this._y = Math.asin(clamp(m13, -1, 1));\n\n          if (Math.abs(m13) < 0.9999999) {\n            this._x = Math.atan2(-m23, m33);\n            this._z = Math.atan2(-m12, m11);\n          } else {\n            this._x = Math.atan2(m32, m22);\n            this._z = 0;\n          }\n\n          break;\n\n        case \'YXZ\':\n          this._x = Math.asin(-clamp(m23, -1, 1));\n\n          if (Math.abs(m23) < 0.9999999) {\n            this._y = Math.atan2(m13, m33);\n            this._z = Math.atan2(m21, m22);\n          } else {\n            this._y = Math.atan2(-m31, m11);\n            this._z = 0;\n          }\n\n          break;\n\n        case \'ZXY\':\n          this._x = Math.asin(clamp(m32, -1, 1));\n\n          if (Math.abs(m32) < 0.9999999) {\n            this._y = Math.atan2(-m31, m33);\n            this._z = Math.atan2(-m12, m22);\n          } else {\n            this._y = 0;\n            this._z = Math.atan2(m21, m11);\n          }\n\n          break;\n\n        case \'ZYX\':\n          this._y = Math.asin(-clamp(m31, -1, 1));\n\n          if (Math.abs(m31) < 0.9999999) {\n            this._x = Math.atan2(m32, m33);\n            this._z = Math.atan2(m21, m11);\n          } else {\n            this._x = 0;\n            this._z = Math.atan2(-m12, m22);\n          }\n\n          break;\n\n        case \'YZX\':\n          this._z = Math.asin(clamp(m21, -1, 1));\n\n          if (Math.abs(m21) < 0.9999999) {\n            this._x = Math.atan2(-m23, m22);\n            this._y = Math.atan2(-m31, m11);\n          } else {\n            this._x = 0;\n            this._y = Math.atan2(m13, m33);\n          }\n\n          break;\n\n        case \'XZY\':\n          this._z = Math.asin(-clamp(m12, -1, 1));\n\n          if (Math.abs(m12) < 0.9999999) {\n            this._x = Math.atan2(m32, m22);\n            this._y = Math.atan2(m13, m11);\n          } else {\n            this._x = Math.atan2(-m23, m33);\n            this._y = 0;\n          }\n\n          break;\n\n        default:\n          console.warn(\'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: \' + order);\n      }\n\n      this._order = order;\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n  }, {\n    key: "setFromQuaternion",\n    value: function setFromQuaternion(q, order, update) {\n      _matrix$1.makeRotationFromQuaternion(q);\n\n      return this.setFromRotationMatrix(_matrix$1, order, update);\n    }\n  }, {\n    key: "setFromVector3",\n    value: function setFromVector3(v) {\n      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;\n      return this.set(v.x, v.y, v.z, order);\n    }\n  }, {\n    key: "reorder",\n    value: function reorder(newOrder) {\n      // WARNING: this discards revolution information -bhouston\n      _quaternion$3.setFromEuler(this);\n\n      return this.setFromQuaternion(_quaternion$3, newOrder);\n    }\n  }, {\n    key: "equals",\n    value: function equals(euler) {\n      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      this._x = array[0];\n      this._y = array[1];\n      this._z = array[2];\n      if (array[3] !== undefined) this._order = array[3];\n\n      this._onChangeCallback();\n\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._order;\n      return array;\n    }\n  }, {\n    key: "_onChange",\n    value: function _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n  }, {\n    key: "_onChangeCallback",\n    value: function _onChangeCallback() {}\n  }, {\n    key: _Symbol$iterator6,\n    value: /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function value() {\n      return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function value$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this._x;\n\n            case 2:\n              _context7.next = 4;\n              return this._y;\n\n            case 4:\n              _context7.next = 6;\n              return this._z;\n\n            case 6:\n              _context7.next = 8;\n              return this._order;\n\n            case 8:\n            case "end":\n              return _context7.stop();\n          }\n        }\n      }, value, this);\n    }) // @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53\n\n  }, {\n    key: "toVector3",\n    value: function toVector3() {\n      console.error(\'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead\');\n    }\n  }]);\n\n  return Euler;\n}(Symbol.iterator);\n\nEuler.DefaultOrder = \'XYZ\';\nEuler.RotationOrders = [\'XYZ\', \'YZX\', \'ZXY\', \'XZY\', \'YXZ\', \'ZYX\'];\n\nvar Layers = /*#__PURE__*/function () {\n  function Layers() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Layers);\n\n    this.mask = 1 | 0;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Layers, [{\n    key: "set",\n    value: function set(channel) {\n      this.mask = (1 << channel | 0) >>> 0;\n    }\n  }, {\n    key: "enable",\n    value: function enable(channel) {\n      this.mask |= 1 << channel | 0;\n    }\n  }, {\n    key: "enableAll",\n    value: function enableAll() {\n      this.mask = 0xffffffff | 0;\n    }\n  }, {\n    key: "toggle",\n    value: function toggle(channel) {\n      this.mask ^= 1 << channel | 0;\n    }\n  }, {\n    key: "disable",\n    value: function disable(channel) {\n      this.mask &= ~(1 << channel | 0);\n    }\n  }, {\n    key: "disableAll",\n    value: function disableAll() {\n      this.mask = 0;\n    }\n  }, {\n    key: "test",\n    value: function test(layers) {\n      return (this.mask & layers.mask) !== 0;\n    }\n  }, {\n    key: "isEnabled",\n    value: function isEnabled(channel) {\n      return (this.mask & (1 << channel | 0)) !== 0;\n    }\n  }]);\n\n  return Layers;\n}();\n\nvar _object3DId = 0;\n\nvar _v1$4 = /*@__PURE__*/new Vector3();\n\nvar _q1 = /*@__PURE__*/new Quaternion();\n\nvar _m1$1 = /*@__PURE__*/new Matrix4();\n\nvar _target = /*@__PURE__*/new Vector3();\n\nvar _position$3 = /*@__PURE__*/new Vector3();\n\nvar _scale$2 = /*@__PURE__*/new Vector3();\n\nvar _quaternion$2 = /*@__PURE__*/new Quaternion();\n\nvar _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);\n\nvar _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);\n\nvar _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);\n\nvar _addedEvent = {\n  type: \'added\'\n};\nvar _removedEvent = {\n  type: \'removed\'\n};\n\nvar Object3D = /*#__PURE__*/function (_EventDispatcher3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Object3D, _EventDispatcher3);\n\n  var _super8 = _createSuper(Object3D);\n\n  function Object3D() {\n    var _this9;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Object3D);\n\n    _this9 = _super8.call(this);\n    _this9.isObject3D = true;\n    Object.defineProperty((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this9), \'id\', {\n      value: _object3DId++\n    });\n    _this9.uuid = generateUUID();\n    _this9.name = \'\';\n    _this9.type = \'Object3D\';\n    _this9.parent = null;\n    _this9.children = [];\n    _this9.up = Object3D.DefaultUp.clone();\n    var position = new Vector3();\n    var rotation = new Euler();\n    var quaternion = new Quaternion();\n    var scale = new Vector3(1, 1, 1);\n\n    function onRotationChange() {\n      quaternion.setFromEuler(rotation, false);\n    }\n\n    function onQuaternionChange() {\n      rotation.setFromQuaternion(quaternion, undefined, false);\n    }\n\n    rotation._onChange(onRotationChange);\n\n    quaternion._onChange(onQuaternionChange);\n\n    Object.defineProperties((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this9), {\n      position: {\n        configurable: true,\n        enumerable: true,\n        value: position\n      },\n      rotation: {\n        configurable: true,\n        enumerable: true,\n        value: rotation\n      },\n      quaternion: {\n        configurable: true,\n        enumerable: true,\n        value: quaternion\n      },\n      scale: {\n        configurable: true,\n        enumerable: true,\n        value: scale\n      },\n      modelViewMatrix: {\n        value: new Matrix4()\n      },\n      normalMatrix: {\n        value: new Matrix3()\n      }\n    });\n    _this9.matrix = new Matrix4();\n    _this9.matrixWorld = new Matrix4();\n    _this9.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n    _this9.matrixWorldNeedsUpdate = false;\n    _this9.layers = new Layers();\n    _this9.visible = true;\n    _this9.castShadow = false;\n    _this9.receiveShadow = false;\n    _this9.frustumCulled = true;\n    _this9.renderOrder = 0;\n    _this9.animations = [];\n    _this9.userData = {};\n    return _this9;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Object3D, [{\n    key: "onBeforeRender",\n    value: function\n      /* renderer, scene, camera, geometry, material, group */\n    onBeforeRender() {}\n  }, {\n    key: "onAfterRender",\n    value: function\n      /* renderer, scene, camera, geometry, material, group */\n    onAfterRender() {}\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(matrix) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      this.matrix.premultiply(matrix);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n  }, {\n    key: "applyQuaternion",\n    value: function applyQuaternion(q) {\n      this.quaternion.premultiply(q);\n      return this;\n    }\n  }, {\n    key: "setRotationFromAxisAngle",\n    value: function setRotationFromAxisAngle(axis, angle) {\n      // assumes axis is normalized\n      this.quaternion.setFromAxisAngle(axis, angle);\n    }\n  }, {\n    key: "setRotationFromEuler",\n    value: function setRotationFromEuler(euler) {\n      this.quaternion.setFromEuler(euler, true);\n    }\n  }, {\n    key: "setRotationFromMatrix",\n    value: function setRotationFromMatrix(m) {\n      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n      this.quaternion.setFromRotationMatrix(m);\n    }\n  }, {\n    key: "setRotationFromQuaternion",\n    value: function setRotationFromQuaternion(q) {\n      // assumes q is normalized\n      this.quaternion.copy(q);\n    }\n  }, {\n    key: "rotateOnAxis",\n    value: function rotateOnAxis(axis, angle) {\n      // rotate object on axis in object space\n      // axis is assumed to be normalized\n      _q1.setFromAxisAngle(axis, angle);\n\n      this.quaternion.multiply(_q1);\n      return this;\n    }\n  }, {\n    key: "rotateOnWorldAxis",\n    value: function rotateOnWorldAxis(axis, angle) {\n      // rotate object on axis in world space\n      // axis is assumed to be normalized\n      // method assumes no rotated parent\n      _q1.setFromAxisAngle(axis, angle);\n\n      this.quaternion.premultiply(_q1);\n      return this;\n    }\n  }, {\n    key: "rotateX",\n    value: function rotateX(angle) {\n      return this.rotateOnAxis(_xAxis, angle);\n    }\n  }, {\n    key: "rotateY",\n    value: function rotateY(angle) {\n      return this.rotateOnAxis(_yAxis, angle);\n    }\n  }, {\n    key: "rotateZ",\n    value: function rotateZ(angle) {\n      return this.rotateOnAxis(_zAxis, angle);\n    }\n  }, {\n    key: "translateOnAxis",\n    value: function translateOnAxis(axis, distance) {\n      // translate object by distance along axis in object space\n      // axis is assumed to be normalized\n      _v1$4.copy(axis).applyQuaternion(this.quaternion);\n\n      this.position.add(_v1$4.multiplyScalar(distance));\n      return this;\n    }\n  }, {\n    key: "translateX",\n    value: function translateX(distance) {\n      return this.translateOnAxis(_xAxis, distance);\n    }\n  }, {\n    key: "translateY",\n    value: function translateY(distance) {\n      return this.translateOnAxis(_yAxis, distance);\n    }\n  }, {\n    key: "translateZ",\n    value: function translateZ(distance) {\n      return this.translateOnAxis(_zAxis, distance);\n    }\n  }, {\n    key: "localToWorld",\n    value: function localToWorld(vector) {\n      return vector.applyMatrix4(this.matrixWorld);\n    }\n  }, {\n    key: "worldToLocal",\n    value: function worldToLocal(vector) {\n      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n    }\n  }, {\n    key: "lookAt",\n    value: function lookAt(x, y, z) {\n      // This method does not support objects having non-uniformly-scaled parent(s)\n      if (x.isVector3) {\n        _target.copy(x);\n      } else {\n        _target.set(x, y, z);\n      }\n\n      var parent = this.parent;\n      this.updateWorldMatrix(true, false);\n\n      _position$3.setFromMatrixPosition(this.matrixWorld);\n\n      if (this.isCamera || this.isLight) {\n        _m1$1.lookAt(_position$3, _target, this.up);\n      } else {\n        _m1$1.lookAt(_target, _position$3, this.up);\n      }\n\n      this.quaternion.setFromRotationMatrix(_m1$1);\n\n      if (parent) {\n        _m1$1.extractRotation(parent.matrixWorld);\n\n        _q1.setFromRotationMatrix(_m1$1);\n\n        this.quaternion.premultiply(_q1.invert());\n      }\n    }\n  }, {\n    key: "add",\n    value: function add(object) {\n      if (arguments.length > 1) {\n        for (var _i19 = 0; _i19 < arguments.length; _i19++) {\n          this.add(arguments[_i19]);\n        }\n\n        return this;\n      }\n\n      if (object === this) {\n        console.error(\'THREE.Object3D.add: object can\\\'t be added as a child of itself.\', object);\n        return this;\n      }\n\n      if (object && object.isObject3D) {\n        if (object.parent !== null) {\n          object.parent.remove(object);\n        }\n\n        object.parent = this;\n        this.children.push(object);\n        object.dispatchEvent(_addedEvent);\n      } else {\n        console.error(\'THREE.Object3D.add: object not an instance of THREE.Object3D.\', object);\n      }\n\n      return this;\n    }\n  }, {\n    key: "remove",\n    value: function remove(object) {\n      if (arguments.length > 1) {\n        for (var _i20 = 0; _i20 < arguments.length; _i20++) {\n          this.remove(arguments[_i20]);\n        }\n\n        return this;\n      }\n\n      var index = this.children.indexOf(object);\n\n      if (index !== -1) {\n        object.parent = null;\n        this.children.splice(index, 1);\n        object.dispatchEvent(_removedEvent);\n      }\n\n      return this;\n    }\n  }, {\n    key: "removeFromParent",\n    value: function removeFromParent() {\n      var parent = this.parent;\n\n      if (parent !== null) {\n        parent.remove(this);\n      }\n\n      return this;\n    }\n  }, {\n    key: "clear",\n    value: function clear() {\n      for (var _i21 = 0; _i21 < this.children.length; _i21++) {\n        var object = this.children[_i21];\n        object.parent = null;\n        object.dispatchEvent(_removedEvent);\n      }\n\n      this.children.length = 0;\n      return this;\n    }\n  }, {\n    key: "attach",\n    value: function attach(object) {\n      // adds object as a child of this, while maintaining the object\'s world transform\n      // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n      this.updateWorldMatrix(true, false);\n\n      _m1$1.copy(this.matrixWorld).invert();\n\n      if (object.parent !== null) {\n        object.parent.updateWorldMatrix(true, false);\n\n        _m1$1.multiply(object.parent.matrixWorld);\n      }\n\n      object.applyMatrix4(_m1$1);\n      this.add(object);\n      object.updateWorldMatrix(false, true);\n      return this;\n    }\n  }, {\n    key: "getObjectById",\n    value: function getObjectById(id) {\n      return this.getObjectByProperty(\'id\', id);\n    }\n  }, {\n    key: "getObjectByName",\n    value: function getObjectByName(name) {\n      return this.getObjectByProperty(\'name\', name);\n    }\n  }, {\n    key: "getObjectByProperty",\n    value: function getObjectByProperty(name, value) {\n      if (this[name] === value) return this;\n\n      for (var _i22 = 0, l = this.children.length; _i22 < l; _i22++) {\n        var child = this.children[_i22];\n        var object = child.getObjectByProperty(name, value);\n\n        if (object !== undefined) {\n          return object;\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: "getWorldPosition",\n    value: function getWorldPosition(target) {\n      this.updateWorldMatrix(true, false);\n      return target.setFromMatrixPosition(this.matrixWorld);\n    }\n  }, {\n    key: "getWorldQuaternion",\n    value: function getWorldQuaternion(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, target, _scale$2);\n      return target;\n    }\n  }, {\n    key: "getWorldScale",\n    value: function getWorldScale(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n      return target;\n    }\n  }, {\n    key: "getWorldDirection",\n    value: function getWorldDirection(target) {\n      this.updateWorldMatrix(true, false);\n      var e = this.matrixWorld.elements;\n      return target.set(e[8], e[9], e[10]).normalize();\n    }\n  }, {\n    key: "raycast",\n    value: function\n      /* raycaster, intersects */\n    raycast() {}\n  }, {\n    key: "traverse",\n    value: function traverse(callback) {\n      callback(this);\n      var children = this.children;\n\n      for (var _i23 = 0, l = children.length; _i23 < l; _i23++) {\n        children[_i23].traverse(callback);\n      }\n    }\n  }, {\n    key: "traverseVisible",\n    value: function traverseVisible(callback) {\n      if (this.visible === false) return;\n      callback(this);\n      var children = this.children;\n\n      for (var _i24 = 0, l = children.length; _i24 < l; _i24++) {\n        children[_i24].traverseVisible(callback);\n      }\n    }\n  }, {\n    key: "traverseAncestors",\n    value: function traverseAncestors(callback) {\n      var parent = this.parent;\n\n      if (parent !== null) {\n        callback(parent);\n        parent.traverseAncestors(callback);\n      }\n    }\n  }, {\n    key: "updateMatrix",\n    value: function updateMatrix() {\n      this.matrix.compose(this.position, this.quaternion, this.scale);\n      this.matrixWorldNeedsUpdate = true;\n    }\n  }, {\n    key: "updateMatrixWorld",\n    value: function updateMatrixWorld(force) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n\n      if (this.matrixWorldNeedsUpdate || force) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n      } // update children\n\n\n      var children = this.children;\n\n      for (var _i25 = 0, l = children.length; _i25 < l; _i25++) {\n        children[_i25].updateMatrixWorld(force);\n      }\n    }\n  }, {\n    key: "updateWorldMatrix",\n    value: function updateWorldMatrix(updateParents, updateChildren) {\n      var parent = this.parent;\n\n      if (updateParents === true && parent !== null) {\n        parent.updateWorldMatrix(true, false);\n      }\n\n      if (this.matrixAutoUpdate) this.updateMatrix();\n\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      } // update children\n\n\n      if (updateChildren === true) {\n        var children = this.children;\n\n        for (var _i26 = 0, l = children.length; _i26 < l; _i26++) {\n          children[_i26].updateWorldMatrix(false, true);\n        }\n      }\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      // meta is a string when called from JSON.stringify\n      var isRootObject = meta === undefined || typeof meta === \'string\';\n      var output = {}; // meta is a hash used to collect geometries, materials.\n      // not providing it implies that this is the root object\n      // being serialized.\n\n      if (isRootObject) {\n        // initialize meta obj\n        meta = {\n          geometries: {},\n          materials: {},\n          textures: {},\n          images: {},\n          shapes: {},\n          skeletons: {},\n          animations: {},\n          nodes: {}\n        };\n        output.metadata = {\n          version: 4.5,\n          type: \'Object\',\n          generator: \'Object3D.toJSON\'\n        };\n      } // standard Object3D serialization\n\n\n      var object = {};\n      object.uuid = this.uuid;\n      object.type = this.type;\n      if (this.name !== \'\') object.name = this.name;\n      if (this.castShadow === true) object.castShadow = true;\n      if (this.receiveShadow === true) object.receiveShadow = true;\n      if (this.visible === false) object.visible = false;\n      if (this.frustumCulled === false) object.frustumCulled = false;\n      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n      if (JSON.stringify(this.userData) !== \'{}\') object.userData = this.userData;\n      object.layers = this.layers.mask;\n      object.matrix = this.matrix.toArray();\n      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties\n\n      if (this.isInstancedMesh) {\n        object.type = \'InstancedMesh\';\n        object.count = this.count;\n        object.instanceMatrix = this.instanceMatrix.toJSON();\n        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n      } //\n\n\n      function serialize(library, element) {\n        if (library[element.uuid] === undefined) {\n          library[element.uuid] = element.toJSON(meta);\n        }\n\n        return element.uuid;\n      }\n\n      if (this.isScene) {\n        if (this.background) {\n          if (this.background.isColor) {\n            object.background = this.background.toJSON();\n          } else if (this.background.isTexture) {\n            object.background = this.background.toJSON(meta).uuid;\n          }\n        }\n\n        if (this.environment && this.environment.isTexture) {\n          object.environment = this.environment.toJSON(meta).uuid;\n        }\n      } else if (this.isMesh || this.isLine || this.isPoints) {\n        object.geometry = serialize(meta.geometries, this.geometry);\n        var parameters = this.geometry.parameters;\n\n        if (parameters !== undefined && parameters.shapes !== undefined) {\n          var shapes = parameters.shapes;\n\n          if (Array.isArray(shapes)) {\n            for (var _i27 = 0, l = shapes.length; _i27 < l; _i27++) {\n              var shape = shapes[_i27];\n              serialize(meta.shapes, shape);\n            }\n          } else {\n            serialize(meta.shapes, shapes);\n          }\n        }\n      }\n\n      if (this.isSkinnedMesh) {\n        object.bindMode = this.bindMode;\n        object.bindMatrix = this.bindMatrix.toArray();\n\n        if (this.skeleton !== undefined) {\n          serialize(meta.skeletons, this.skeleton);\n          object.skeleton = this.skeleton.uuid;\n        }\n      }\n\n      if (this.material !== undefined) {\n        if (Array.isArray(this.material)) {\n          var uuids = [];\n\n          for (var _i28 = 0, _l2 = this.material.length; _i28 < _l2; _i28++) {\n            uuids.push(serialize(meta.materials, this.material[_i28]));\n          }\n\n          object.material = uuids;\n        } else {\n          object.material = serialize(meta.materials, this.material);\n        }\n      } //\n\n\n      if (this.children.length > 0) {\n        object.children = [];\n\n        for (var _i29 = 0; _i29 < this.children.length; _i29++) {\n          object.children.push(this.children[_i29].toJSON(meta).object);\n        }\n      } //\n\n\n      if (this.animations.length > 0) {\n        object.animations = [];\n\n        for (var _i30 = 0; _i30 < this.animations.length; _i30++) {\n          var animation = this.animations[_i30];\n          object.animations.push(serialize(meta.animations, animation));\n        }\n      }\n\n      if (isRootObject) {\n        var geometries = extractFromCache(meta.geometries);\n        var materials = extractFromCache(meta.materials);\n        var textures = extractFromCache(meta.textures);\n        var images = extractFromCache(meta.images);\n\n        var _shapes = extractFromCache(meta.shapes);\n\n        var skeletons = extractFromCache(meta.skeletons);\n        var animations = extractFromCache(meta.animations);\n        var nodes = extractFromCache(meta.nodes);\n        if (geometries.length > 0) output.geometries = geometries;\n        if (materials.length > 0) output.materials = materials;\n        if (textures.length > 0) output.textures = textures;\n        if (images.length > 0) output.images = images;\n        if (_shapes.length > 0) output.shapes = _shapes;\n        if (skeletons.length > 0) output.skeletons = skeletons;\n        if (animations.length > 0) output.animations = animations;\n        if (nodes.length > 0) output.nodes = nodes;\n      }\n\n      output.object = object;\n      return output; // extract data from the cache hash\n      // remove metadata on each item\n      // and return as array\n\n      function extractFromCache(cache) {\n        var values = [];\n\n        for (var key in cache) {\n          var data = cache[key];\n          delete data.metadata;\n          values.push(data);\n        }\n\n        return values;\n      }\n    }\n  }, {\n    key: "clone",\n    value: function clone(recursive) {\n      return new this.constructor().copy(this, recursive);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.name = source.name;\n      this.up.copy(source.up);\n      this.position.copy(source.position);\n      this.rotation.order = source.rotation.order;\n      this.quaternion.copy(source.quaternion);\n      this.scale.copy(source.scale);\n      this.matrix.copy(source.matrix);\n      this.matrixWorld.copy(source.matrixWorld);\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n      this.layers.mask = source.layers.mask;\n      this.visible = source.visible;\n      this.castShadow = source.castShadow;\n      this.receiveShadow = source.receiveShadow;\n      this.frustumCulled = source.frustumCulled;\n      this.renderOrder = source.renderOrder;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n\n      if (recursive === true) {\n        for (var _i31 = 0; _i31 < source.children.length; _i31++) {\n          var child = source.children[_i31];\n          this.add(child.clone());\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return Object3D;\n}(EventDispatcher);\n\nObject3D.DefaultUp = new Vector3(0, 1, 0);\nObject3D.DefaultMatrixAutoUpdate = true;\n\nvar _v0$1 = /*@__PURE__*/new Vector3();\n\nvar _v1$3 = /*@__PURE__*/new Vector3();\n\nvar _v2$2 = /*@__PURE__*/new Vector3();\n\nvar _v3$1 = /*@__PURE__*/new Vector3();\n\nvar _vab = /*@__PURE__*/new Vector3();\n\nvar _vac = /*@__PURE__*/new Vector3();\n\nvar _vbc = /*@__PURE__*/new Vector3();\n\nvar _vap = /*@__PURE__*/new Vector3();\n\nvar _vbp = /*@__PURE__*/new Vector3();\n\nvar _vcp = /*@__PURE__*/new Vector3();\n\nvar Triangle = /*#__PURE__*/function () {\n  function Triangle() {\n    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Triangle);\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Triangle, [{\n    key: "set",\n    value: function set(a, b, c) {\n      this.a.copy(a);\n      this.b.copy(b);\n      this.c.copy(c);\n      return this;\n    }\n  }, {\n    key: "setFromPointsAndIndices",\n    value: function setFromPointsAndIndices(points, i0, i1, i2) {\n      this.a.copy(points[i0]);\n      this.b.copy(points[i1]);\n      this.c.copy(points[i2]);\n      return this;\n    }\n  }, {\n    key: "setFromAttributeAndIndices",\n    value: function setFromAttributeAndIndices(attribute, i0, i1, i2) {\n      this.a.fromBufferAttribute(attribute, i0);\n      this.b.fromBufferAttribute(attribute, i1);\n      this.c.fromBufferAttribute(attribute, i2);\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "copy",\n    value: function copy(triangle) {\n      this.a.copy(triangle.a);\n      this.b.copy(triangle.b);\n      this.c.copy(triangle.c);\n      return this;\n    }\n  }, {\n    key: "getArea",\n    value: function getArea() {\n      _v0$1.subVectors(this.c, this.b);\n\n      _v1$3.subVectors(this.a, this.b);\n\n      return _v0$1.cross(_v1$3).length() * 0.5;\n    }\n  }, {\n    key: "getMidpoint",\n    value: function getMidpoint(target) {\n      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    }\n  }, {\n    key: "getNormal",\n    value: function getNormal(target) {\n      return Triangle.getNormal(this.a, this.b, this.c, target);\n    }\n  }, {\n    key: "getPlane",\n    value: function getPlane(target) {\n      return target.setFromCoplanarPoints(this.a, this.b, this.c);\n    }\n  }, {\n    key: "getBarycoord",\n    value: function getBarycoord(point, target) {\n      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n    }\n  }, {\n    key: "getUV",\n    value: function getUV(point, uv1, uv2, uv3, target) {\n      return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n    }\n  }, {\n    key: "containsPoint",\n    value: function containsPoint(point) {\n      return Triangle.containsPoint(point, this.a, this.b, this.c);\n    }\n  }, {\n    key: "isFrontFacing",\n    value: function isFrontFacing(direction) {\n      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n    }\n  }, {\n    key: "intersectsBox",\n    value: function intersectsBox(box) {\n      return box.intersectsTriangle(this);\n    }\n  }, {\n    key: "closestPointToPoint",\n    value: function closestPointToPoint(p, target) {\n      var a = this.a,\n          b = this.b,\n          c = this.c;\n      var v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n      // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n      // under the accompanying license; see chapter 5.1.5 for detailed explanation.\n      // basically, we\'re distinguishing which of the voronoi regions of the triangle\n      // the point lies in with the minimum amount of redundant computation.\n\n      _vab.subVectors(b, a);\n\n      _vac.subVectors(c, a);\n\n      _vap.subVectors(p, a);\n\n      var d1 = _vab.dot(_vap);\n\n      var d2 = _vac.dot(_vap);\n\n      if (d1 <= 0 && d2 <= 0) {\n        // vertex region of A; barycentric coords (1, 0, 0)\n        return target.copy(a);\n      }\n\n      _vbp.subVectors(p, b);\n\n      var d3 = _vab.dot(_vbp);\n\n      var d4 = _vac.dot(_vbp);\n\n      if (d3 >= 0 && d4 <= d3) {\n        // vertex region of B; barycentric coords (0, 1, 0)\n        return target.copy(b);\n      }\n\n      var vc = d1 * d4 - d3 * d2;\n\n      if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n        v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)\n\n        return target.copy(a).addScaledVector(_vab, v);\n      }\n\n      _vcp.subVectors(p, c);\n\n      var d5 = _vab.dot(_vcp);\n\n      var d6 = _vac.dot(_vcp);\n\n      if (d6 >= 0 && d5 <= d6) {\n        // vertex region of C; barycentric coords (0, 0, 1)\n        return target.copy(c);\n      }\n\n      var vb = d5 * d2 - d1 * d6;\n\n      if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n        w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)\n\n        return target.copy(a).addScaledVector(_vac, w);\n      }\n\n      var va = d3 * d6 - d5 * d4;\n\n      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n        _vbc.subVectors(c, b);\n\n        w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)\n\n        return target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n      } // face region\n\n\n      var denom = 1 / (va + vb + vc); // u = va * denom\n\n      v = vb * denom;\n      w = vc * denom;\n      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n    }\n  }, {\n    key: "equals",\n    value: function equals(triangle) {\n      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n    }\n  }], [{\n    key: "getNormal",\n    value: function getNormal(a, b, c, target) {\n      target.subVectors(c, b);\n\n      _v0$1.subVectors(a, b);\n\n      target.cross(_v0$1);\n      var targetLengthSq = target.lengthSq();\n\n      if (targetLengthSq > 0) {\n        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n      }\n\n      return target.set(0, 0, 0);\n    } // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\n  }, {\n    key: "getBarycoord",\n    value: function getBarycoord(point, a, b, c, target) {\n      _v0$1.subVectors(c, a);\n\n      _v1$3.subVectors(b, a);\n\n      _v2$2.subVectors(point, a);\n\n      var dot00 = _v0$1.dot(_v0$1);\n\n      var dot01 = _v0$1.dot(_v1$3);\n\n      var dot02 = _v0$1.dot(_v2$2);\n\n      var dot11 = _v1$3.dot(_v1$3);\n\n      var dot12 = _v1$3.dot(_v2$2);\n\n      var denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle\n\n      if (denom === 0) {\n        // arbitrary location outside of triangle?\n        // not sure if this is the best idea, maybe should be returning undefined\n        return target.set(-2, -1, -1);\n      }\n\n      var invDenom = 1 / denom;\n      var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n      var v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1\n\n      return target.set(1 - u - v, v, u);\n    }\n  }, {\n    key: "containsPoint",\n    value: function containsPoint(point, a, b, c) {\n      this.getBarycoord(point, a, b, c, _v3$1);\n      return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;\n    }\n  }, {\n    key: "getUV",\n    value: function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\n      this.getBarycoord(point, p1, p2, p3, _v3$1);\n      target.set(0, 0);\n      target.addScaledVector(uv1, _v3$1.x);\n      target.addScaledVector(uv2, _v3$1.y);\n      target.addScaledVector(uv3, _v3$1.z);\n      return target;\n    }\n  }, {\n    key: "isFrontFacing",\n    value: function isFrontFacing(a, b, c, direction) {\n      _v0$1.subVectors(c, b);\n\n      _v1$3.subVectors(a, b); // strictly front facing\n\n\n      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n    }\n  }]);\n\n  return Triangle;\n}();\n\nvar materialId = 0;\n\nvar Material = /*#__PURE__*/function (_EventDispatcher4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Material, _EventDispatcher4);\n\n  var _super9 = _createSuper(Material);\n\n  function Material() {\n    var _this10;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Material);\n\n    _this10 = _super9.call(this);\n    _this10.isMaterial = true;\n    Object.defineProperty((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this10), \'id\', {\n      value: materialId++\n    });\n    _this10.uuid = generateUUID();\n    _this10.name = \'\';\n    _this10.type = \'Material\';\n    _this10.blending = NormalBlending;\n    _this10.side = FrontSide;\n    _this10.vertexColors = false;\n    _this10.opacity = 1;\n    _this10.transparent = false;\n    _this10.blendSrc = SrcAlphaFactor;\n    _this10.blendDst = OneMinusSrcAlphaFactor;\n    _this10.blendEquation = AddEquation;\n    _this10.blendSrcAlpha = null;\n    _this10.blendDstAlpha = null;\n    _this10.blendEquationAlpha = null;\n    _this10.depthFunc = LessEqualDepth;\n    _this10.depthTest = true;\n    _this10.depthWrite = true;\n    _this10.stencilWriteMask = 0xff;\n    _this10.stencilFunc = AlwaysStencilFunc;\n    _this10.stencilRef = 0;\n    _this10.stencilFuncMask = 0xff;\n    _this10.stencilFail = KeepStencilOp;\n    _this10.stencilZFail = KeepStencilOp;\n    _this10.stencilZPass = KeepStencilOp;\n    _this10.stencilWrite = false;\n    _this10.clippingPlanes = null;\n    _this10.clipIntersection = false;\n    _this10.clipShadows = false;\n    _this10.shadowSide = null;\n    _this10.colorWrite = true;\n    _this10.precision = null; // override the renderer\'s default precision for this material\n\n    _this10.polygonOffset = false;\n    _this10.polygonOffsetFactor = 0;\n    _this10.polygonOffsetUnits = 0;\n    _this10.dithering = false;\n    _this10.alphaToCoverage = false;\n    _this10.premultipliedAlpha = false;\n    _this10.visible = true;\n    _this10.toneMapped = true;\n    _this10.userData = {};\n    _this10.version = 0;\n    _this10._alphaTest = 0;\n    return _this10;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Material, [{\n    key: "alphaTest",\n    get: function get() {\n      return this._alphaTest;\n    },\n    set: function set(value) {\n      if (this._alphaTest > 0 !== value > 0) {\n        this.version++;\n      }\n\n      this._alphaTest = value;\n    }\n  }, {\n    key: "onBuild",\n    value: function\n      /* shaderobject, renderer */\n    onBuild() {}\n  }, {\n    key: "onBeforeRender",\n    value: function\n      /* renderer, scene, camera, geometry, object, group */\n    onBeforeRender() {}\n  }, {\n    key: "onBeforeCompile",\n    value: function\n      /* shaderobject, renderer */\n    onBeforeCompile() {}\n  }, {\n    key: "customProgramCacheKey",\n    value: function customProgramCacheKey() {\n      return this.onBeforeCompile.toString();\n    }\n  }, {\n    key: "setValues",\n    value: function setValues(values) {\n      if (values === undefined) return;\n\n      for (var key in values) {\n        var newValue = values[key];\n\n        if (newValue === undefined) {\n          console.warn(\'THREE.Material: \\\'\' + key + \'\\\' parameter is undefined.\');\n          continue;\n        } // for backward compatibility if shading is set in the constructor\n\n\n        if (key === \'shading\') {\n          console.warn(\'THREE.\' + this.type + \': .shading has been removed. Use the boolean .flatShading instead.\');\n          this.flatShading = newValue === FlatShading ? true : false;\n          continue;\n        }\n\n        var currentValue = this[key];\n\n        if (currentValue === undefined) {\n          console.warn(\'THREE.\' + this.type + \': \\\'\' + key + \'\\\' is not a property of this material.\');\n          continue;\n        }\n\n        if (currentValue && currentValue.isColor) {\n          currentValue.set(newValue);\n        } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {\n          currentValue.copy(newValue);\n        } else {\n          this[key] = newValue;\n        }\n      }\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var isRootObject = meta === undefined || typeof meta === \'string\';\n\n      if (isRootObject) {\n        meta = {\n          textures: {},\n          images: {}\n        };\n      }\n\n      var data = {\n        metadata: {\n          version: 4.5,\n          type: \'Material\',\n          generator: \'Material.toJSON\'\n        }\n      }; // standard Material serialization\n\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== \'\') data.name = this.name;\n      if (this.color && this.color.isColor) data.color = this.color.getHex();\n      if (this.roughness !== undefined) data.roughness = this.roughness;\n      if (this.metalness !== undefined) data.metalness = this.metalness;\n      if (this.sheen !== undefined) data.sheen = this.sheen;\n      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n      if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;\n      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n      if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n      if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;\n      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n      if (this.shininess !== undefined) data.shininess = this.shininess;\n      if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;\n      if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;\n\n      if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n      }\n\n      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n      }\n\n      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n      }\n\n      if (this.iridescence !== undefined) data.iridescence = this.iridescence;\n      if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;\n      if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n\n      if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n      }\n\n      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n      }\n\n      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n\n      if (this.lightMap && this.lightMap.isTexture) {\n        data.lightMap = this.lightMap.toJSON(meta).uuid;\n        data.lightMapIntensity = this.lightMapIntensity;\n      }\n\n      if (this.aoMap && this.aoMap.isTexture) {\n        data.aoMap = this.aoMap.toJSON(meta).uuid;\n        data.aoMapIntensity = this.aoMapIntensity;\n      }\n\n      if (this.bumpMap && this.bumpMap.isTexture) {\n        data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n        data.bumpScale = this.bumpScale;\n      }\n\n      if (this.normalMap && this.normalMap.isTexture) {\n        data.normalMap = this.normalMap.toJSON(meta).uuid;\n        data.normalMapType = this.normalMapType;\n        data.normalScale = this.normalScale.toArray();\n      }\n\n      if (this.displacementMap && this.displacementMap.isTexture) {\n        data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n        data.displacementScale = this.displacementScale;\n        data.displacementBias = this.displacementBias;\n      }\n\n      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n\n      if (this.envMap && this.envMap.isTexture) {\n        data.envMap = this.envMap.toJSON(meta).uuid;\n        if (this.combine !== undefined) data.combine = this.combine;\n      }\n\n      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;\n      if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;\n      if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;\n\n      if (this.gradientMap && this.gradientMap.isTexture) {\n        data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n      }\n\n      if (this.transmission !== undefined) data.transmission = this.transmission;\n      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n      if (this.thickness !== undefined) data.thickness = this.thickness;\n      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n      if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;\n      if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();\n      if (this.size !== undefined) data.size = this.size;\n      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n      if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n      if (this.blending !== NormalBlending) data.blending = this.blending;\n      if (this.side !== FrontSide) data.side = this.side;\n      if (this.vertexColors) data.vertexColors = true;\n      if (this.opacity < 1) data.opacity = this.opacity;\n      if (this.transparent === true) data.transparent = this.transparent;\n      data.depthFunc = this.depthFunc;\n      data.depthTest = this.depthTest;\n      data.depthWrite = this.depthWrite;\n      data.colorWrite = this.colorWrite;\n      data.stencilWrite = this.stencilWrite;\n      data.stencilWriteMask = this.stencilWriteMask;\n      data.stencilFunc = this.stencilFunc;\n      data.stencilRef = this.stencilRef;\n      data.stencilFuncMask = this.stencilFuncMask;\n      data.stencilFail = this.stencilFail;\n      data.stencilZFail = this.stencilZFail;\n      data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)\n\n      if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;\n      if (this.polygonOffset === true) data.polygonOffset = true;\n      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n      if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;\n      if (this.dashSize !== undefined) data.dashSize = this.dashSize;\n      if (this.gapSize !== undefined) data.gapSize = this.gapSize;\n      if (this.scale !== undefined) data.scale = this.scale;\n      if (this.dithering === true) data.dithering = true;\n      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n      if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;\n      if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;\n      if (this.wireframe === true) data.wireframe = this.wireframe;\n      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n      if (this.wireframeLinecap !== \'round\') data.wireframeLinecap = this.wireframeLinecap;\n      if (this.wireframeLinejoin !== \'round\') data.wireframeLinejoin = this.wireframeLinejoin;\n      if (this.flatShading === true) data.flatShading = this.flatShading;\n      if (this.visible === false) data.visible = false;\n      if (this.toneMapped === false) data.toneMapped = false;\n      if (this.fog === false) data.fog = false;\n      if (JSON.stringify(this.userData) !== \'{}\') data.userData = this.userData; // TODO: Copied from Object3D.toJSON\n\n      function extractFromCache(cache) {\n        var values = [];\n\n        for (var key in cache) {\n          var _data2 = cache[key];\n          delete _data2.metadata;\n          values.push(_data2);\n        }\n\n        return values;\n      }\n\n      if (isRootObject) {\n        var textures = extractFromCache(meta.textures);\n        var images = extractFromCache(meta.images);\n        if (textures.length > 0) data.textures = textures;\n        if (images.length > 0) data.images = images;\n      }\n\n      return data;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      this.name = source.name;\n      this.blending = source.blending;\n      this.side = source.side;\n      this.vertexColors = source.vertexColors;\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n      this.blendSrc = source.blendSrc;\n      this.blendDst = source.blendDst;\n      this.blendEquation = source.blendEquation;\n      this.blendSrcAlpha = source.blendSrcAlpha;\n      this.blendDstAlpha = source.blendDstAlpha;\n      this.blendEquationAlpha = source.blendEquationAlpha;\n      this.depthFunc = source.depthFunc;\n      this.depthTest = source.depthTest;\n      this.depthWrite = source.depthWrite;\n      this.stencilWriteMask = source.stencilWriteMask;\n      this.stencilFunc = source.stencilFunc;\n      this.stencilRef = source.stencilRef;\n      this.stencilFuncMask = source.stencilFuncMask;\n      this.stencilFail = source.stencilFail;\n      this.stencilZFail = source.stencilZFail;\n      this.stencilZPass = source.stencilZPass;\n      this.stencilWrite = source.stencilWrite;\n      var srcPlanes = source.clippingPlanes;\n      var dstPlanes = null;\n\n      if (srcPlanes !== null) {\n        var n = srcPlanes.length;\n        dstPlanes = new Array(n);\n\n        for (var _i32 = 0; _i32 !== n; ++_i32) {\n          dstPlanes[_i32] = srcPlanes[_i32].clone();\n        }\n      }\n\n      this.clippingPlanes = dstPlanes;\n      this.clipIntersection = source.clipIntersection;\n      this.clipShadows = source.clipShadows;\n      this.shadowSide = source.shadowSide;\n      this.colorWrite = source.colorWrite;\n      this.precision = source.precision;\n      this.polygonOffset = source.polygonOffset;\n      this.polygonOffsetFactor = source.polygonOffsetFactor;\n      this.polygonOffsetUnits = source.polygonOffsetUnits;\n      this.dithering = source.dithering;\n      this.alphaTest = source.alphaTest;\n      this.alphaToCoverage = source.alphaToCoverage;\n      this.premultipliedAlpha = source.premultipliedAlpha;\n      this.visible = source.visible;\n      this.toneMapped = source.toneMapped;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      return this;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: \'dispose\'\n      });\n    }\n  }, {\n    key: "needsUpdate",\n    set: function set(value) {\n      if (value === true) this.version++;\n    } // @deprecated since r131, f5803c62cc4a29d90744e9dc7811d086e354c1d8\n\n  }, {\n    key: "vertexTangents",\n    get: function get() {\n      console.warn(\'THREE.\' + this.type + \': .vertexTangents has been removed.\');\n      return false;\n    },\n    set: function set(value) {\n      console.warn(\'THREE.\' + this.type + \': .vertexTangents has been removed.\');\n    }\n  }]);\n\n  return Material;\n}(EventDispatcher);\n\nMaterial.fromType = function\n  /*type*/\n() {\n  // TODO: Behavior added in Materials.js\n  return null;\n};\n\nvar MeshBasicMaterial = /*#__PURE__*/function (_Material) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshBasicMaterial, _Material);\n\n  var _super10 = _createSuper(MeshBasicMaterial);\n\n  function MeshBasicMaterial(parameters) {\n    var _this11;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshBasicMaterial);\n\n    _this11 = _super10.call(this);\n    _this11.isMeshBasicMaterial = true;\n    _this11.type = \'MeshBasicMaterial\';\n    _this11.color = new Color(0xffffff); // emissive\n\n    _this11.map = null;\n    _this11.lightMap = null;\n    _this11.lightMapIntensity = 1.0;\n    _this11.aoMap = null;\n    _this11.aoMapIntensity = 1.0;\n    _this11.specularMap = null;\n    _this11.alphaMap = null;\n    _this11.envMap = null;\n    _this11.combine = MultiplyOperation;\n    _this11.reflectivity = 1;\n    _this11.refractionRatio = 0.98;\n    _this11.wireframe = false;\n    _this11.wireframeLinewidth = 1;\n    _this11.wireframeLinecap = \'round\';\n    _this11.wireframeLinejoin = \'round\';\n    _this11.fog = true;\n\n    _this11.setValues(parameters);\n\n    return _this11;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshBasicMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshBasicMaterial.prototype), "copy", this).call(this, source);\n\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return MeshBasicMaterial;\n}(Material);\n\nvar _vector$9 = /*@__PURE__*/new Vector3();\n\nvar _vector2$1 = /*@__PURE__*/new Vector2();\n\nvar BufferAttribute = /*#__PURE__*/function () {\n  function BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, BufferAttribute);\n\n    if (Array.isArray(array)) {\n      throw new TypeError(\'THREE.BufferAttribute: array should be a Typed Array.\');\n    }\n\n    this.isBufferAttribute = true;\n    this.name = \'\';\n    this.array = array;\n    this.itemSize = itemSize;\n    this.count = array !== undefined ? array.length / itemSize : 0;\n    this.normalized = normalized === true;\n    this.usage = StaticDrawUsage;\n    this.updateRange = {\n      offset: 0,\n      count: -1\n    };\n    this.version = 0;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(BufferAttribute, [{\n    key: "onUploadCallback",\n    value: function onUploadCallback() {}\n  }, {\n    key: "needsUpdate",\n    set: function set(value) {\n      if (value === true) this.version++;\n    }\n  }, {\n    key: "setUsage",\n    value: function setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      this.name = source.name;\n      this.array = new source.array.constructor(source.array);\n      this.itemSize = source.itemSize;\n      this.count = source.count;\n      this.normalized = source.normalized;\n      this.usage = source.usage;\n      return this;\n    }\n  }, {\n    key: "copyAt",\n    value: function copyAt(index1, attribute, index2) {\n      index1 *= this.itemSize;\n      index2 *= attribute.itemSize;\n\n      for (var _i33 = 0, l = this.itemSize; _i33 < l; _i33++) {\n        this.array[index1 + _i33] = attribute.array[index2 + _i33];\n      }\n\n      return this;\n    }\n  }, {\n    key: "copyArray",\n    value: function copyArray(array) {\n      this.array.set(array);\n      return this;\n    }\n  }, {\n    key: "copyColorsArray",\n    value: function copyColorsArray(colors) {\n      var array = this.array;\n      var offset = 0;\n\n      for (var _i34 = 0, l = colors.length; _i34 < l; _i34++) {\n        var color = colors[_i34];\n\n        if (color === undefined) {\n          console.warn(\'THREE.BufferAttribute.copyColorsArray(): color is undefined\', _i34);\n          color = new Color();\n        }\n\n        array[offset++] = color.r;\n        array[offset++] = color.g;\n        array[offset++] = color.b;\n      }\n\n      return this;\n    }\n  }, {\n    key: "copyVector2sArray",\n    value: function copyVector2sArray(vectors) {\n      var array = this.array;\n      var offset = 0;\n\n      for (var _i35 = 0, l = vectors.length; _i35 < l; _i35++) {\n        var vector = vectors[_i35];\n\n        if (vector === undefined) {\n          console.warn(\'THREE.BufferAttribute.copyVector2sArray(): vector is undefined\', _i35);\n          vector = new Vector2();\n        }\n\n        array[offset++] = vector.x;\n        array[offset++] = vector.y;\n      }\n\n      return this;\n    }\n  }, {\n    key: "copyVector3sArray",\n    value: function copyVector3sArray(vectors) {\n      var array = this.array;\n      var offset = 0;\n\n      for (var _i36 = 0, l = vectors.length; _i36 < l; _i36++) {\n        var vector = vectors[_i36];\n\n        if (vector === undefined) {\n          console.warn(\'THREE.BufferAttribute.copyVector3sArray(): vector is undefined\', _i36);\n          vector = new Vector3();\n        }\n\n        array[offset++] = vector.x;\n        array[offset++] = vector.y;\n        array[offset++] = vector.z;\n      }\n\n      return this;\n    }\n  }, {\n    key: "copyVector4sArray",\n    value: function copyVector4sArray(vectors) {\n      var array = this.array;\n      var offset = 0;\n\n      for (var _i37 = 0, l = vectors.length; _i37 < l; _i37++) {\n        var vector = vectors[_i37];\n\n        if (vector === undefined) {\n          console.warn(\'THREE.BufferAttribute.copyVector4sArray(): vector is undefined\', _i37);\n          vector = new Vector4();\n        }\n\n        array[offset++] = vector.x;\n        array[offset++] = vector.y;\n        array[offset++] = vector.z;\n        array[offset++] = vector.w;\n      }\n\n      return this;\n    }\n  }, {\n    key: "applyMatrix3",\n    value: function applyMatrix3(m) {\n      if (this.itemSize === 2) {\n        for (var _i38 = 0, l = this.count; _i38 < l; _i38++) {\n          _vector2$1.fromBufferAttribute(this, _i38);\n\n          _vector2$1.applyMatrix3(m);\n\n          this.setXY(_i38, _vector2$1.x, _vector2$1.y);\n        }\n      } else if (this.itemSize === 3) {\n        for (var _i39 = 0, _l3 = this.count; _i39 < _l3; _i39++) {\n          _vector$9.fromBufferAttribute(this, _i39);\n\n          _vector$9.applyMatrix3(m);\n\n          this.setXYZ(_i39, _vector$9.x, _vector$9.y, _vector$9.z);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(m) {\n      for (var _i40 = 0, l = this.count; _i40 < l; _i40++) {\n        _vector$9.fromBufferAttribute(this, _i40);\n\n        _vector$9.applyMatrix4(m);\n\n        this.setXYZ(_i40, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n\n      return this;\n    }\n  }, {\n    key: "applyNormalMatrix",\n    value: function applyNormalMatrix(m) {\n      for (var _i41 = 0, l = this.count; _i41 < l; _i41++) {\n        _vector$9.fromBufferAttribute(this, _i41);\n\n        _vector$9.applyNormalMatrix(m);\n\n        this.setXYZ(_i41, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n\n      return this;\n    }\n  }, {\n    key: "transformDirection",\n    value: function transformDirection(m) {\n      for (var _i42 = 0, l = this.count; _i42 < l; _i42++) {\n        _vector$9.fromBufferAttribute(this, _i42);\n\n        _vector$9.transformDirection(m);\n\n        this.setXYZ(_i42, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n\n      return this;\n    }\n  }, {\n    key: "set",\n    value: function set(value) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.array.set(value, offset);\n      return this;\n    }\n  }, {\n    key: "getX",\n    value: function getX(index) {\n      return this.array[index * this.itemSize];\n    }\n  }, {\n    key: "setX",\n    value: function setX(index, x) {\n      this.array[index * this.itemSize] = x;\n      return this;\n    }\n  }, {\n    key: "getY",\n    value: function getY(index) {\n      return this.array[index * this.itemSize + 1];\n    }\n  }, {\n    key: "setY",\n    value: function setY(index, y) {\n      this.array[index * this.itemSize + 1] = y;\n      return this;\n    }\n  }, {\n    key: "getZ",\n    value: function getZ(index) {\n      return this.array[index * this.itemSize + 2];\n    }\n  }, {\n    key: "setZ",\n    value: function setZ(index, z) {\n      this.array[index * this.itemSize + 2] = z;\n      return this;\n    }\n  }, {\n    key: "getW",\n    value: function getW(index) {\n      return this.array[index * this.itemSize + 3];\n    }\n  }, {\n    key: "setW",\n    value: function setW(index, w) {\n      this.array[index * this.itemSize + 3] = w;\n      return this;\n    }\n  }, {\n    key: "setXY",\n    value: function setXY(index, x, y) {\n      index *= this.itemSize;\n      this.array[index + 0] = x;\n      this.array[index + 1] = y;\n      return this;\n    }\n  }, {\n    key: "setXYZ",\n    value: function setXYZ(index, x, y, z) {\n      index *= this.itemSize;\n      this.array[index + 0] = x;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      return this;\n    }\n  }, {\n    key: "setXYZW",\n    value: function setXYZW(index, x, y, z, w) {\n      index *= this.itemSize;\n      this.array[index + 0] = x;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      this.array[index + 3] = w;\n      return this;\n    }\n  }, {\n    key: "onUpload",\n    value: function onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor(this.array, this.itemSize).copy(this);\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: Array.prototype.slice.call(this.array),\n        normalized: this.normalized\n      };\n      if (this.name !== \'\') data.name = this.name;\n      if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n      if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;\n      return data;\n    }\n  }]);\n\n  return BufferAttribute;\n}(); //\n\n\nvar Int8BufferAttribute = /*#__PURE__*/function (_BufferAttribute) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Int8BufferAttribute, _BufferAttribute);\n\n  var _super11 = _createSuper(Int8BufferAttribute);\n\n  function Int8BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Int8BufferAttribute);\n\n    return _super11.call(this, new Int8Array(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Int8BufferAttribute);\n}(BufferAttribute);\n\nvar Uint8BufferAttribute = /*#__PURE__*/function (_BufferAttribute2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Uint8BufferAttribute, _BufferAttribute2);\n\n  var _super12 = _createSuper(Uint8BufferAttribute);\n\n  function Uint8BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Uint8BufferAttribute);\n\n    return _super12.call(this, new Uint8Array(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Uint8BufferAttribute);\n}(BufferAttribute);\n\nvar Uint8ClampedBufferAttribute = /*#__PURE__*/function (_BufferAttribute3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Uint8ClampedBufferAttribute, _BufferAttribute3);\n\n  var _super13 = _createSuper(Uint8ClampedBufferAttribute);\n\n  function Uint8ClampedBufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Uint8ClampedBufferAttribute);\n\n    return _super13.call(this, new Uint8ClampedArray(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Uint8ClampedBufferAttribute);\n}(BufferAttribute);\n\nvar Int16BufferAttribute = /*#__PURE__*/function (_BufferAttribute4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Int16BufferAttribute, _BufferAttribute4);\n\n  var _super14 = _createSuper(Int16BufferAttribute);\n\n  function Int16BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Int16BufferAttribute);\n\n    return _super14.call(this, new Int16Array(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Int16BufferAttribute);\n}(BufferAttribute);\n\nvar Uint16BufferAttribute = /*#__PURE__*/function (_BufferAttribute5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Uint16BufferAttribute, _BufferAttribute5);\n\n  var _super15 = _createSuper(Uint16BufferAttribute);\n\n  function Uint16BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Uint16BufferAttribute);\n\n    return _super15.call(this, new Uint16Array(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Uint16BufferAttribute);\n}(BufferAttribute);\n\nvar Int32BufferAttribute = /*#__PURE__*/function (_BufferAttribute6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Int32BufferAttribute, _BufferAttribute6);\n\n  var _super16 = _createSuper(Int32BufferAttribute);\n\n  function Int32BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Int32BufferAttribute);\n\n    return _super16.call(this, new Int32Array(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Int32BufferAttribute);\n}(BufferAttribute);\n\nvar Uint32BufferAttribute = /*#__PURE__*/function (_BufferAttribute7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Uint32BufferAttribute, _BufferAttribute7);\n\n  var _super17 = _createSuper(Uint32BufferAttribute);\n\n  function Uint32BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Uint32BufferAttribute);\n\n    return _super17.call(this, new Uint32Array(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Uint32BufferAttribute);\n}(BufferAttribute);\n\nvar Float16BufferAttribute = /*#__PURE__*/function (_BufferAttribute8) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Float16BufferAttribute, _BufferAttribute8);\n\n  var _super18 = _createSuper(Float16BufferAttribute);\n\n  function Float16BufferAttribute(array, itemSize, normalized) {\n    var _this12;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Float16BufferAttribute);\n\n    _this12 = _super18.call(this, new Uint16Array(array), itemSize, normalized);\n    _this12.isFloat16BufferAttribute = true;\n    return _this12;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Float16BufferAttribute);\n}(BufferAttribute);\n\nvar Float32BufferAttribute = /*#__PURE__*/function (_BufferAttribute9) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Float32BufferAttribute, _BufferAttribute9);\n\n  var _super19 = _createSuper(Float32BufferAttribute);\n\n  function Float32BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Float32BufferAttribute);\n\n    return _super19.call(this, new Float32Array(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Float32BufferAttribute);\n}(BufferAttribute);\n\nvar Float64BufferAttribute = /*#__PURE__*/function (_BufferAttribute10) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Float64BufferAttribute, _BufferAttribute10);\n\n  var _super20 = _createSuper(Float64BufferAttribute);\n\n  function Float64BufferAttribute(array, itemSize, normalized) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Float64BufferAttribute);\n\n    return _super20.call(this, new Float64Array(array), itemSize, normalized);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Float64BufferAttribute);\n}(BufferAttribute);\n\nvar _id$1 = 0;\n\nvar _m1 = /*@__PURE__*/new Matrix4();\n\nvar _obj = /*@__PURE__*/new Object3D();\n\nvar _offset = /*@__PURE__*/new Vector3();\n\nvar _box$1 = /*@__PURE__*/new Box3();\n\nvar _boxMorphTargets = /*@__PURE__*/new Box3();\n\nvar _vector$8 = /*@__PURE__*/new Vector3();\n\nvar BufferGeometry = /*#__PURE__*/function (_EventDispatcher5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(BufferGeometry, _EventDispatcher5);\n\n  var _super21 = _createSuper(BufferGeometry);\n\n  function BufferGeometry() {\n    var _this13;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, BufferGeometry);\n\n    _this13 = _super21.call(this);\n    _this13.isBufferGeometry = true;\n    Object.defineProperty((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this13), \'id\', {\n      value: _id$1++\n    });\n    _this13.uuid = generateUUID();\n    _this13.name = \'\';\n    _this13.type = \'BufferGeometry\';\n    _this13.index = null;\n    _this13.attributes = {};\n    _this13.morphAttributes = {};\n    _this13.morphTargetsRelative = false;\n    _this13.groups = [];\n    _this13.boundingBox = null;\n    _this13.boundingSphere = null;\n    _this13.drawRange = {\n      start: 0,\n      count: Infinity\n    };\n    _this13.userData = {};\n    return _this13;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(BufferGeometry, [{\n    key: "getIndex",\n    value: function getIndex() {\n      return this.index;\n    }\n  }, {\n    key: "setIndex",\n    value: function setIndex(index) {\n      if (Array.isArray(index)) {\n        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n      } else {\n        this.index = index;\n      }\n\n      return this;\n    }\n  }, {\n    key: "getAttribute",\n    value: function getAttribute(name) {\n      return this.attributes[name];\n    }\n  }, {\n    key: "setAttribute",\n    value: function setAttribute(name, attribute) {\n      this.attributes[name] = attribute;\n      return this;\n    }\n  }, {\n    key: "deleteAttribute",\n    value: function deleteAttribute(name) {\n      delete this.attributes[name];\n      return this;\n    }\n  }, {\n    key: "hasAttribute",\n    value: function hasAttribute(name) {\n      return this.attributes[name] !== undefined;\n    }\n  }, {\n    key: "addGroup",\n    value: function addGroup(start, count) {\n      var materialIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.groups.push({\n        start: start,\n        count: count,\n        materialIndex: materialIndex\n      });\n    }\n  }, {\n    key: "clearGroups",\n    value: function clearGroups() {\n      this.groups = [];\n    }\n  }, {\n    key: "setDrawRange",\n    value: function setDrawRange(start, count) {\n      this.drawRange.start = start;\n      this.drawRange.count = count;\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(matrix) {\n      var position = this.attributes.position;\n\n      if (position !== undefined) {\n        position.applyMatrix4(matrix);\n        position.needsUpdate = true;\n      }\n\n      var normal = this.attributes.normal;\n\n      if (normal !== undefined) {\n        var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n        normal.applyNormalMatrix(normalMatrix);\n        normal.needsUpdate = true;\n      }\n\n      var tangent = this.attributes.tangent;\n\n      if (tangent !== undefined) {\n        tangent.transformDirection(matrix);\n        tangent.needsUpdate = true;\n      }\n\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n\n      return this;\n    }\n  }, {\n    key: "applyQuaternion",\n    value: function applyQuaternion(q) {\n      _m1.makeRotationFromQuaternion(q);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: "rotateX",\n    value: function rotateX(angle) {\n      // rotate geometry around world x-axis\n      _m1.makeRotationX(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: "rotateY",\n    value: function rotateY(angle) {\n      // rotate geometry around world y-axis\n      _m1.makeRotationY(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: "rotateZ",\n    value: function rotateZ(angle) {\n      // rotate geometry around world z-axis\n      _m1.makeRotationZ(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: "translate",\n    value: function translate(x, y, z) {\n      // translate geometry\n      _m1.makeTranslation(x, y, z);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: "scale",\n    value: function scale(x, y, z) {\n      // scale geometry\n      _m1.makeScale(x, y, z);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: "lookAt",\n    value: function lookAt(vector) {\n      _obj.lookAt(vector);\n\n      _obj.updateMatrix();\n\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n  }, {\n    key: "center",\n    value: function center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n  }, {\n    key: "setFromPoints",\n    value: function setFromPoints(points) {\n      var position = [];\n\n      for (var _i43 = 0, l = points.length; _i43 < l; _i43++) {\n        var point = points[_i43];\n        position.push(point.x, point.y, point.z || 0);\n      }\n\n      this.setAttribute(\'position\', new Float32BufferAttribute(position, 3));\n      return this;\n    }\n  }, {\n    key: "computeBoundingBox",\n    value: function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n\n      var position = this.attributes.position;\n      var morphAttributesPosition = this.morphAttributes.position;\n\n      if (position && position.isGLBufferAttribute) {\n        console.error(\'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".\', this);\n        this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n        return;\n      }\n\n      if (position !== undefined) {\n        this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n        if (morphAttributesPosition) {\n          for (var _i44 = 0, il = morphAttributesPosition.length; _i44 < il; _i44++) {\n            var morphAttribute = morphAttributesPosition[_i44];\n\n            _box$1.setFromBufferAttribute(morphAttribute);\n\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(this.boundingBox.min, _box$1.min);\n\n              this.boundingBox.expandByPoint(_vector$8);\n\n              _vector$8.addVectors(this.boundingBox.max, _box$1.max);\n\n              this.boundingBox.expandByPoint(_vector$8);\n            } else {\n              this.boundingBox.expandByPoint(_box$1.min);\n              this.boundingBox.expandByPoint(_box$1.max);\n            }\n          }\n        }\n      } else {\n        this.boundingBox.makeEmpty();\n      }\n\n      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n        console.error(\'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.\', this);\n      }\n    }\n  }, {\n    key: "computeBoundingSphere",\n    value: function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n\n      var position = this.attributes.position;\n      var morphAttributesPosition = this.morphAttributes.position;\n\n      if (position && position.isGLBufferAttribute) {\n        console.error(\'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".\', this);\n        this.boundingSphere.set(new Vector3(), Infinity);\n        return;\n      }\n\n      if (position) {\n        // first, find the center of the bounding sphere\n        var center = this.boundingSphere.center;\n\n        _box$1.setFromBufferAttribute(position); // process morph attributes if present\n\n\n        if (morphAttributesPosition) {\n          for (var _i45 = 0, il = morphAttributesPosition.length; _i45 < il; _i45++) {\n            var morphAttribute = morphAttributesPosition[_i45];\n\n            _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);\n\n              _box$1.expandByPoint(_vector$8);\n\n              _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);\n\n              _box$1.expandByPoint(_vector$8);\n            } else {\n              _box$1.expandByPoint(_boxMorphTargets.min);\n\n              _box$1.expandByPoint(_boxMorphTargets.max);\n            }\n          }\n        }\n\n        _box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n        var maxRadiusSq = 0;\n\n        for (var _i46 = 0, _il = position.count; _i46 < _il; _i46++) {\n          _vector$8.fromBufferAttribute(position, _i46);\n\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n        } // process morph attributes if present\n\n\n        if (morphAttributesPosition) {\n          for (var _i47 = 0, _il2 = morphAttributesPosition.length; _i47 < _il2; _i47++) {\n            var _morphAttribute = morphAttributesPosition[_i47];\n            var morphTargetsRelative = this.morphTargetsRelative;\n\n            for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {\n              _vector$8.fromBufferAttribute(_morphAttribute, j);\n\n              if (morphTargetsRelative) {\n                _offset.fromBufferAttribute(position, j);\n\n                _vector$8.add(_offset);\n              }\n\n              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n            }\n          }\n        }\n\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error(\'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.\', this);\n        }\n      }\n    }\n  }, {\n    key: "computeTangents",\n    value: function computeTangents() {\n      var index = this.index;\n      var attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html\n      // (per vertex tangents)\n\n      if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n        console.error(\'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)\');\n        return;\n      }\n\n      var indices = index.array;\n      var positions = attributes.position.array;\n      var normals = attributes.normal.array;\n      var uvs = attributes.uv.array;\n      var nVertices = positions.length / 3;\n\n      if (this.hasAttribute(\'tangent\') === false) {\n        this.setAttribute(\'tangent\', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n      }\n\n      var tangents = this.getAttribute(\'tangent\').array;\n      var tan1 = [],\n          tan2 = [];\n\n      for (var _i48 = 0; _i48 < nVertices; _i48++) {\n        tan1[_i48] = new Vector3();\n        tan2[_i48] = new Vector3();\n      }\n\n      var vA = new Vector3(),\n          vB = new Vector3(),\n          vC = new Vector3(),\n          uvA = new Vector2(),\n          uvB = new Vector2(),\n          uvC = new Vector2(),\n          sdir = new Vector3(),\n          tdir = new Vector3();\n\n      function handleTriangle(a, b, c) {\n        vA.fromArray(positions, a * 3);\n        vB.fromArray(positions, b * 3);\n        vC.fromArray(positions, c * 3);\n        uvA.fromArray(uvs, a * 2);\n        uvB.fromArray(uvs, b * 2);\n        uvC.fromArray(uvs, c * 2);\n        vB.sub(vA);\n        vC.sub(vA);\n        uvB.sub(uvA);\n        uvC.sub(uvA);\n        var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n        if (!isFinite(r)) return;\n        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n        tan1[a].add(sdir);\n        tan1[b].add(sdir);\n        tan1[c].add(sdir);\n        tan2[a].add(tdir);\n        tan2[b].add(tdir);\n        tan2[c].add(tdir);\n      }\n\n      var groups = this.groups;\n\n      if (groups.length === 0) {\n        groups = [{\n          start: 0,\n          count: indices.length\n        }];\n      }\n\n      for (var _i49 = 0, il = groups.length; _i49 < il; ++_i49) {\n        var group = groups[_i49];\n        var start = group.start;\n        var count = group.count;\n\n        for (var j = start, jl = start + count; j < jl; j += 3) {\n          handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n        }\n      }\n\n      var tmp = new Vector3(),\n          tmp2 = new Vector3();\n      var n = new Vector3(),\n          n2 = new Vector3();\n\n      function handleVertex(v) {\n        n.fromArray(normals, v * 3);\n        n2.copy(n);\n        var t = tan1[v]; // Gram-Schmidt orthogonalize\n\n        tmp.copy(t);\n        tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n        tmp2.crossVectors(n2, t);\n        var test = tmp2.dot(tan2[v]);\n        var w = test < 0.0 ? -1.0 : 1.0;\n        tangents[v * 4] = tmp.x;\n        tangents[v * 4 + 1] = tmp.y;\n        tangents[v * 4 + 2] = tmp.z;\n        tangents[v * 4 + 3] = w;\n      }\n\n      for (var _i50 = 0, _il3 = groups.length; _i50 < _il3; ++_i50) {\n        var _group = groups[_i50];\n        var _start2 = _group.start;\n        var _count = _group.count;\n\n        for (var _j = _start2, _jl = _start2 + _count; _j < _jl; _j += 3) {\n          handleVertex(indices[_j + 0]);\n          handleVertex(indices[_j + 1]);\n          handleVertex(indices[_j + 2]);\n        }\n      }\n    }\n  }, {\n    key: "computeVertexNormals",\n    value: function computeVertexNormals() {\n      var index = this.index;\n      var positionAttribute = this.getAttribute(\'position\');\n\n      if (positionAttribute !== undefined) {\n        var normalAttribute = this.getAttribute(\'normal\');\n\n        if (normalAttribute === undefined) {\n          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n          this.setAttribute(\'normal\', normalAttribute);\n        } else {\n          // reset existing normals to zero\n          for (var _i51 = 0, il = normalAttribute.count; _i51 < il; _i51++) {\n            normalAttribute.setXYZ(_i51, 0, 0, 0);\n          }\n        }\n\n        var pA = new Vector3(),\n            pB = new Vector3(),\n            pC = new Vector3();\n        var nA = new Vector3(),\n            nB = new Vector3(),\n            nC = new Vector3();\n        var cb = new Vector3(),\n            ab = new Vector3(); // indexed elements\n\n        if (index) {\n          for (var _i52 = 0, _il4 = index.count; _i52 < _il4; _i52 += 3) {\n            var vA = index.getX(_i52 + 0);\n            var vB = index.getX(_i52 + 1);\n            var vC = index.getX(_i52 + 2);\n            pA.fromBufferAttribute(positionAttribute, vA);\n            pB.fromBufferAttribute(positionAttribute, vB);\n            pC.fromBufferAttribute(positionAttribute, vC);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            nA.fromBufferAttribute(normalAttribute, vA);\n            nB.fromBufferAttribute(normalAttribute, vB);\n            nC.fromBufferAttribute(normalAttribute, vC);\n            nA.add(cb);\n            nB.add(cb);\n            nC.add(cb);\n            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n          }\n        } else {\n          // non-indexed elements (unconnected triangle soup)\n          for (var _i53 = 0, _il5 = positionAttribute.count; _i53 < _il5; _i53 += 3) {\n            pA.fromBufferAttribute(positionAttribute, _i53 + 0);\n            pB.fromBufferAttribute(positionAttribute, _i53 + 1);\n            pC.fromBufferAttribute(positionAttribute, _i53 + 2);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            normalAttribute.setXYZ(_i53 + 0, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(_i53 + 1, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(_i53 + 2, cb.x, cb.y, cb.z);\n          }\n        }\n\n        this.normalizeNormals();\n        normalAttribute.needsUpdate = true;\n      }\n    }\n  }, {\n    key: "merge",\n    value: function merge(geometry, offset) {\n      if (!(geometry && geometry.isBufferGeometry)) {\n        console.error(\'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.\', geometry);\n        return;\n      }\n\n      if (offset === undefined) {\n        offset = 0;\n        console.warn(\'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. \' + \'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.\');\n      }\n\n      var attributes = this.attributes;\n\n      for (var key in attributes) {\n        if (geometry.attributes[key] === undefined) continue;\n        var attribute1 = attributes[key];\n        var attributeArray1 = attribute1.array;\n        var attribute2 = geometry.attributes[key];\n        var attributeArray2 = attribute2.array;\n        var attributeOffset = attribute2.itemSize * offset;\n        var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n        for (var _i54 = 0, j = attributeOffset; _i54 < length; _i54++, j++) {\n          attributeArray1[j] = attributeArray2[_i54];\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: "normalizeNormals",\n    value: function normalizeNormals() {\n      var normals = this.attributes.normal;\n\n      for (var _i55 = 0, il = normals.count; _i55 < il; _i55++) {\n        _vector$8.fromBufferAttribute(normals, _i55);\n\n        _vector$8.normalize();\n\n        normals.setXYZ(_i55, _vector$8.x, _vector$8.y, _vector$8.z);\n      }\n    }\n  }, {\n    key: "toNonIndexed",\n    value: function toNonIndexed() {\n      function convertBufferAttribute(attribute, indices) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var normalized = attribute.normalized;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n            index2 = 0;\n\n        for (var _i56 = 0, l = indices.length; _i56 < l; _i56++) {\n          if (attribute.isInterleavedBufferAttribute) {\n            index = indices[_i56] * attribute.data.stride + attribute.offset;\n          } else {\n            index = indices[_i56] * itemSize;\n          }\n\n          for (var j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n\n        return new BufferAttribute(array2, itemSize, normalized);\n      } //\n\n\n      if (this.index === null) {\n        console.warn(\'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.\');\n        return this;\n      }\n\n      var geometry2 = new BufferGeometry();\n      var indices = this.index.array;\n      var attributes = this.attributes; // attributes\n\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        var newAttribute = convertBufferAttribute(attribute, indices);\n        geometry2.setAttribute(name, newAttribute);\n      } // morph attributes\n\n\n      var morphAttributes = this.morphAttributes;\n\n      for (var _name in morphAttributes) {\n        var morphArray = [];\n        var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes\n\n        for (var _i57 = 0, il = morphAttribute.length; _i57 < il; _i57++) {\n          var _attribute = morphAttribute[_i57];\n\n          var _newAttribute = convertBufferAttribute(_attribute, indices);\n\n          morphArray.push(_newAttribute);\n        }\n\n        geometry2.morphAttributes[_name] = morphArray;\n      }\n\n      geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n      var groups = this.groups;\n\n      for (var _i58 = 0, l = groups.length; _i58 < l; _i58++) {\n        var group = groups[_i58];\n        geometry2.addGroup(group.start, group.count, group.materialIndex);\n      }\n\n      return geometry2;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = {\n        metadata: {\n          version: 4.5,\n          type: \'BufferGeometry\',\n          generator: \'BufferGeometry.toJSON\'\n        }\n      }; // standard BufferGeometry serialization\n\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== \'\') data.name = this.name;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n      if (this.parameters !== undefined) {\n        var parameters = this.parameters;\n\n        for (var key in parameters) {\n          if (parameters[key] !== undefined) data[key] = parameters[key];\n        }\n\n        return data;\n      } // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\n      data.data = {\n        attributes: {}\n      };\n      var index = this.index;\n\n      if (index !== null) {\n        data.data.index = {\n          type: index.array.constructor.name,\n          array: Array.prototype.slice.call(index.array)\n        };\n      }\n\n      var attributes = this.attributes;\n\n      for (var _key in attributes) {\n        var attribute = attributes[_key];\n        data.data.attributes[_key] = attribute.toJSON(data.data);\n      }\n\n      var morphAttributes = {};\n      var hasMorphAttributes = false;\n\n      for (var _key2 in this.morphAttributes) {\n        var attributeArray = this.morphAttributes[_key2];\n        var array = [];\n\n        for (var _i59 = 0, il = attributeArray.length; _i59 < il; _i59++) {\n          var _attribute2 = attributeArray[_i59];\n          array.push(_attribute2.toJSON(data.data));\n        }\n\n        if (array.length > 0) {\n          morphAttributes[_key2] = array;\n          hasMorphAttributes = true;\n        }\n      }\n\n      if (hasMorphAttributes) {\n        data.data.morphAttributes = morphAttributes;\n        data.data.morphTargetsRelative = this.morphTargetsRelative;\n      }\n\n      var groups = this.groups;\n\n      if (groups.length > 0) {\n        data.data.groups = JSON.parse(JSON.stringify(groups));\n      }\n\n      var boundingSphere = this.boundingSphere;\n\n      if (boundingSphere !== null) {\n        data.data.boundingSphere = {\n          center: boundingSphere.center.toArray(),\n          radius: boundingSphere.radius\n        };\n      }\n\n      return data;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      // reset\n      this.index = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null; // used for storing cloned, shared data\n\n      var data = {}; // name\n\n      this.name = source.name; // index\n\n      var index = source.index;\n\n      if (index !== null) {\n        this.setIndex(index.clone(data));\n      } // attributes\n\n\n      var attributes = source.attributes;\n\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        this.setAttribute(name, attribute.clone(data));\n      } // morph attributes\n\n\n      var morphAttributes = source.morphAttributes;\n\n      for (var _name2 in morphAttributes) {\n        var array = [];\n        var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes\n\n        for (var _i60 = 0, l = morphAttribute.length; _i60 < l; _i60++) {\n          array.push(morphAttribute[_i60].clone(data));\n        }\n\n        this.morphAttributes[_name2] = array;\n      }\n\n      this.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n      var groups = source.groups;\n\n      for (var _i61 = 0, _l4 = groups.length; _i61 < _l4; _i61++) {\n        var group = groups[_i61];\n        this.addGroup(group.start, group.count, group.materialIndex);\n      } // bounding box\n\n\n      var boundingBox = source.boundingBox;\n\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      } // bounding sphere\n\n\n      var boundingSphere = source.boundingSphere;\n\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      } // draw range\n\n\n      this.drawRange.start = source.drawRange.start;\n      this.drawRange.count = source.drawRange.count; // user data\n\n      this.userData = source.userData; // geometry generator parameters\n\n      if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);\n      return this;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: \'dispose\'\n      });\n    }\n  }]);\n\n  return BufferGeometry;\n}(EventDispatcher);\n\nvar _inverseMatrix$2 = /*@__PURE__*/new Matrix4();\n\nvar _ray$2 = /*@__PURE__*/new Ray();\n\nvar _sphere$3 = /*@__PURE__*/new Sphere();\n\nvar _vA$1 = /*@__PURE__*/new Vector3();\n\nvar _vB$1 = /*@__PURE__*/new Vector3();\n\nvar _vC$1 = /*@__PURE__*/new Vector3();\n\nvar _tempA = /*@__PURE__*/new Vector3();\n\nvar _tempB = /*@__PURE__*/new Vector3();\n\nvar _tempC = /*@__PURE__*/new Vector3();\n\nvar _morphA = /*@__PURE__*/new Vector3();\n\nvar _morphB = /*@__PURE__*/new Vector3();\n\nvar _morphC = /*@__PURE__*/new Vector3();\n\nvar _uvA$1 = /*@__PURE__*/new Vector2();\n\nvar _uvB$1 = /*@__PURE__*/new Vector2();\n\nvar _uvC$1 = /*@__PURE__*/new Vector2();\n\nvar _intersectionPoint = /*@__PURE__*/new Vector3();\n\nvar _intersectionPointWorld = /*@__PURE__*/new Vector3();\n\nvar Mesh = /*#__PURE__*/function (_Object3D) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Mesh, _Object3D);\n\n  var _super22 = _createSuper(Mesh);\n\n  function Mesh() {\n    var _this14;\n\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Mesh);\n\n    _this14 = _super22.call(this);\n    _this14.isMesh = true;\n    _this14.type = \'Mesh\';\n    _this14.geometry = geometry;\n    _this14.material = material;\n\n    _this14.updateMorphTargets();\n\n    return _this14;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Mesh, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Mesh.prototype), "copy", this).call(this, source, recursive);\n\n      if (source.morphTargetInfluences !== undefined) {\n        this.morphTargetInfluences = source.morphTargetInfluences.slice();\n      }\n\n      if (source.morphTargetDictionary !== undefined) {\n        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n      }\n\n      this.material = source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n  }, {\n    key: "updateMorphTargets",\n    value: function updateMorphTargets() {\n      var geometry = this.geometry;\n      var morphAttributes = geometry.morphAttributes;\n      var keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        var morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {\n            var name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n  }, {\n    key: "raycast",\n    value: function raycast(raycaster, intersects) {\n      var geometry = this.geometry;\n      var material = this.material;\n      var matrixWorld = this.matrixWorld;\n      if (material === undefined) return; // Checking boundingSphere distance to ray\n\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n      _sphere$3.copy(geometry.boundingSphere);\n\n      _sphere$3.applyMatrix4(matrixWorld);\n\n      if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //\n\n      _inverseMatrix$2.copy(matrixWorld).invert();\n\n      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing\n\n\n      if (geometry.boundingBox !== null) {\n        if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;\n      }\n\n      var intersection;\n      var index = geometry.index;\n      var position = geometry.attributes.position;\n      var morphPosition = geometry.morphAttributes.position;\n      var morphTargetsRelative = geometry.morphTargetsRelative;\n      var uv = geometry.attributes.uv;\n      var uv2 = geometry.attributes.uv2;\n      var groups = geometry.groups;\n      var drawRange = geometry.drawRange;\n\n      if (index !== null) {\n        // indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (var _i62 = 0, il = groups.length; _i62 < il; _i62++) {\n            var group = groups[_i62];\n            var groupMaterial = material[group.materialIndex];\n            var start = Math.max(group.start, drawRange.start);\n            var end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n\n            for (var j = start, jl = end; j < jl; j += 3) {\n              var a = index.getX(j);\n              var b = index.getX(j + 1);\n              var c = index.getX(j + 2);\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          var _start3 = Math.max(0, drawRange.start);\n\n          var _end2 = Math.min(index.count, drawRange.start + drawRange.count);\n\n          for (var _i63 = _start3, _il6 = _end2; _i63 < _il6; _i63 += 3) {\n            var _a = index.getX(_i63);\n\n            var _b = index.getX(_i63 + 1);\n\n            var _c = index.getX(_i63 + 2);\n\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a, _b, _c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(_i63 / 3); // triangle number in indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== undefined) {\n        // non-indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (var _i64 = 0, _il7 = groups.length; _i64 < _il7; _i64++) {\n            var _group2 = groups[_i64];\n            var _groupMaterial = material[_group2.materialIndex];\n\n            var _start4 = Math.max(_group2.start, drawRange.start);\n\n            var _end3 = Math.min(position.count, Math.min(_group2.start + _group2.count, drawRange.start + drawRange.count));\n\n            for (var _j2 = _start4, _jl2 = _end3; _j2 < _jl2; _j2 += 3) {\n              var _a2 = _j2;\n\n              var _b2 = _j2 + 1;\n\n              var _c2 = _j2 + 2;\n\n              intersection = checkBufferGeometryIntersection(this, _groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a2, _b2, _c2);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(_j2 / 3); // triangle number in non-indexed buffer semantics\n\n                intersection.face.materialIndex = _group2.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          var _start5 = Math.max(0, drawRange.start);\n\n          var _end4 = Math.min(position.count, drawRange.start + drawRange.count);\n\n          for (var _i65 = _start5, _il8 = _end4; _i65 < _il8; _i65 += 3) {\n            var _a3 = _i65;\n\n            var _b3 = _i65 + 1;\n\n            var _c3 = _i65 + 2;\n\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, _a3, _b3, _c3);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(_i65 / 3); // triangle number in non-indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return Mesh;\n}(Object3D);\n\nfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n  var intersect;\n\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n  }\n\n  if (intersect === null) return null;\n\n  _intersectionPointWorld.copy(point);\n\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n  var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object\n  };\n}\n\nfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n  _vA$1.fromBufferAttribute(position, a);\n\n  _vB$1.fromBufferAttribute(position, b);\n\n  _vC$1.fromBufferAttribute(position, c);\n\n  var morphInfluences = object.morphTargetInfluences;\n\n  if (morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n\n    _morphB.set(0, 0, 0);\n\n    _morphC.set(0, 0, 0);\n\n    for (var _i66 = 0, il = morphPosition.length; _i66 < il; _i66++) {\n      var influence = morphInfluences[_i66];\n      var morphAttribute = morphPosition[_i66];\n      if (influence === 0) continue;\n\n      _tempA.fromBufferAttribute(morphAttribute, a);\n\n      _tempB.fromBufferAttribute(morphAttribute, b);\n\n      _tempC.fromBufferAttribute(morphAttribute, c);\n\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n\n        _morphB.addScaledVector(_tempB, influence);\n\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);\n\n        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);\n\n        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);\n      }\n    }\n\n    _vA$1.add(_morphA);\n\n    _vB$1.add(_morphB);\n\n    _vC$1.add(_morphC);\n  }\n\n  if (object.isSkinnedMesh) {\n    object.boneTransform(a, _vA$1);\n    object.boneTransform(b, _vB$1);\n    object.boneTransform(c, _vC$1);\n  }\n\n  var intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n\n  if (intersection) {\n    if (uv) {\n      _uvA$1.fromBufferAttribute(uv, a);\n\n      _uvB$1.fromBufferAttribute(uv, b);\n\n      _uvC$1.fromBufferAttribute(uv, c);\n\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n    }\n\n    if (uv2) {\n      _uvA$1.fromBufferAttribute(uv2, a);\n\n      _uvB$1.fromBufferAttribute(uv2, b);\n\n      _uvC$1.fromBufferAttribute(uv2, c);\n\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n    }\n\n    var face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n    intersection.face = face;\n  }\n\n  return intersection;\n}\n\nvar BoxGeometry = /*#__PURE__*/function (_BufferGeometry) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(BoxGeometry, _BufferGeometry);\n\n  var _super23 = _createSuper(BoxGeometry);\n\n  function BoxGeometry() {\n    var _this15;\n\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var widthSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var depthSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, BoxGeometry);\n\n    _this15 = _super23.call(this);\n    _this15.type = \'BoxGeometry\';\n    _this15.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n\n    var scope = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this15); // segments\n\n\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var numberOfVertices = 0;\n    var groupStart = 0; // build each side of the box geometry\n\n    buildPlane(\'z\', \'y\', \'x\', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n\n    buildPlane(\'z\', \'y\', \'x\', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n\n    buildPlane(\'x\', \'z\', \'y\', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n\n    buildPlane(\'x\', \'z\', \'y\', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n\n    buildPlane(\'x\', \'y\', \'z\', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n\n    buildPlane(\'x\', \'y\', \'z\', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n    // build geometry\n\n    _this15.setIndex(indices);\n\n    _this15.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this15.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this15.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2));\n\n    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n      var segmentWidth = width / gridX;\n      var segmentHeight = height / gridY;\n      var widthHalf = width / 2;\n      var heightHalf = height / 2;\n      var depthHalf = depth / 2;\n      var gridX1 = gridX + 1;\n      var gridY1 = gridY + 1;\n      var vertexCounter = 0;\n      var groupCount = 0;\n      var vector = new Vector3(); // generate vertices, normals and uvs\n\n      for (var iy = 0; iy < gridY1; iy++) {\n        var y = iy * segmentHeight - heightHalf;\n\n        for (var ix = 0; ix < gridX1; ix++) {\n          var x = ix * segmentWidth - widthHalf; // set values to correct vector component\n\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf; // now apply vector to vertex buffer\n\n          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component\n\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer\n\n          normals.push(vector.x, vector.y, vector.z); // uvs\n\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY); // counters\n\n          vertexCounter += 1;\n        }\n      } // indices\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n\n      for (var _iy = 0; _iy < gridY; _iy++) {\n        for (var _ix = 0; _ix < gridX; _ix++) {\n          var a = numberOfVertices + _ix + gridX1 * _iy;\n          var b = numberOfVertices + _ix + gridX1 * (_iy + 1);\n          var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);\n          var d = numberOfVertices + (_ix + 1) + gridX1 * _iy; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d); // increase counter\n\n          groupCount += 6;\n        }\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups\n\n      groupStart += groupCount; // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n    }\n\n    return _this15;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(BoxGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n    }\n  }]);\n\n  return BoxGeometry;\n}(BufferGeometry);\n/**\n * Uniform Utilities\n */\n\n\nfunction cloneUniforms(src) {\n  var dst = {};\n\n  for (var u in src) {\n    dst[u] = {};\n\n    for (var p in src[u]) {\n      var property = src[u][p];\n\n      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n        dst[u][p] = property.clone();\n      } else if (Array.isArray(property)) {\n        dst[u][p] = property.slice();\n      } else {\n        dst[u][p] = property;\n      }\n    }\n  }\n\n  return dst;\n}\n\nfunction mergeUniforms(uniforms) {\n  var merged = {};\n\n  for (var u = 0; u < uniforms.length; u++) {\n    var _tmp = cloneUniforms(uniforms[u]);\n\n    for (var p in _tmp) {\n      merged[p] = _tmp[p];\n    }\n  }\n\n  return merged;\n} // Legacy\n\n\nvar UniformsUtils = {\n  clone: cloneUniforms,\n  merge: mergeUniforms\n};\nvar default_vertex = "void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}";\nvar default_fragment = "void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}";\n\nvar ShaderMaterial = /*#__PURE__*/function (_Material2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ShaderMaterial, _Material2);\n\n  var _super24 = _createSuper(ShaderMaterial);\n\n  function ShaderMaterial(parameters) {\n    var _this16;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ShaderMaterial);\n\n    _this16 = _super24.call(this);\n    _this16.isShaderMaterial = true;\n    _this16.type = \'ShaderMaterial\';\n    _this16.defines = {};\n    _this16.uniforms = {};\n    _this16.vertexShader = default_vertex;\n    _this16.fragmentShader = default_fragment;\n    _this16.linewidth = 1;\n    _this16.wireframe = false;\n    _this16.wireframeLinewidth = 1;\n    _this16.fog = false; // set to use scene fog\n\n    _this16.lights = false; // set to use scene lights\n\n    _this16.clipping = false; // set to use user-defined clipping planes\n\n    _this16.extensions = {\n      derivatives: false,\n      // set to use derivatives\n      fragDepth: false,\n      // set to use fragment depth values\n      drawBuffers: false,\n      // set to use draw buffers\n      shaderTextureLOD: false // set to use shader texture LOD\n\n    }; // When rendered geometry doesn\'t include these attributes but the material does,\n    // use these default values in WebGL. This avoids errors when buffer data is missing.\n\n    _this16.defaultAttributeValues = {\n      \'color\': [1, 1, 1],\n      \'uv\': [0, 0],\n      \'uv2\': [0, 0]\n    };\n    _this16.index0AttributeName = undefined;\n    _this16.uniformsNeedUpdate = false;\n    _this16.glslVersion = null;\n\n    if (parameters !== undefined) {\n      if (parameters.attributes !== undefined) {\n        console.error(\'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.\');\n      }\n\n      _this16.setValues(parameters);\n    }\n\n    return _this16;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ShaderMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(ShaderMaterial.prototype), "copy", this).call(this, source);\n\n      this.fragmentShader = source.fragmentShader;\n      this.vertexShader = source.vertexShader;\n      this.uniforms = cloneUniforms(source.uniforms);\n      this.defines = Object.assign({}, source.defines);\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.fog = source.fog;\n      this.lights = source.lights;\n      this.clipping = source.clipping;\n      this.extensions = Object.assign({}, source.extensions);\n      this.glslVersion = source.glslVersion;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(ShaderMaterial.prototype), "toJSON", this).call(this, meta);\n\n      data.glslVersion = this.glslVersion;\n      data.uniforms = {};\n\n      for (var name in this.uniforms) {\n        var uniform = this.uniforms[name];\n        var _value = uniform.value;\n\n        if (_value && _value.isTexture) {\n          data.uniforms[name] = {\n            type: \'t\',\n            value: _value.toJSON(meta).uuid\n          };\n        } else if (_value && _value.isColor) {\n          data.uniforms[name] = {\n            type: \'c\',\n            value: _value.getHex()\n          };\n        } else if (_value && _value.isVector2) {\n          data.uniforms[name] = {\n            type: \'v2\',\n            value: _value.toArray()\n          };\n        } else if (_value && _value.isVector3) {\n          data.uniforms[name] = {\n            type: \'v3\',\n            value: _value.toArray()\n          };\n        } else if (_value && _value.isVector4) {\n          data.uniforms[name] = {\n            type: \'v4\',\n            value: _value.toArray()\n          };\n        } else if (_value && _value.isMatrix3) {\n          data.uniforms[name] = {\n            type: \'m3\',\n            value: _value.toArray()\n          };\n        } else if (_value && _value.isMatrix4) {\n          data.uniforms[name] = {\n            type: \'m4\',\n            value: _value.toArray()\n          };\n        } else {\n          data.uniforms[name] = {\n            value: _value\n          }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n        }\n      }\n\n      if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n      data.vertexShader = this.vertexShader;\n      data.fragmentShader = this.fragmentShader;\n      var extensions = {};\n\n      for (var key in this.extensions) {\n        if (this.extensions[key] === true) extensions[key] = true;\n      }\n\n      if (Object.keys(extensions).length > 0) data.extensions = extensions;\n      return data;\n    }\n  }]);\n\n  return ShaderMaterial;\n}(Material);\n\nvar Camera = /*#__PURE__*/function (_Object3D2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Camera, _Object3D2);\n\n  var _super25 = _createSuper(Camera);\n\n  function Camera() {\n    var _this17;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Camera);\n\n    _this17 = _super25.call(this);\n    _this17.isCamera = true;\n    _this17.type = \'Camera\';\n    _this17.matrixWorldInverse = new Matrix4();\n    _this17.projectionMatrix = new Matrix4();\n    _this17.projectionMatrixInverse = new Matrix4();\n    return _this17;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Camera, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Camera.prototype), "copy", this).call(this, source, recursive);\n\n      this.matrixWorldInverse.copy(source.matrixWorldInverse);\n      this.projectionMatrix.copy(source.projectionMatrix);\n      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n      return this;\n    }\n  }, {\n    key: "getWorldDirection",\n    value: function getWorldDirection(target) {\n      this.updateWorldMatrix(true, false);\n      var e = this.matrixWorld.elements;\n      return target.set(-e[8], -e[9], -e[10]).normalize();\n    }\n  }, {\n    key: "updateMatrixWorld",\n    value: function updateMatrixWorld(force) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Camera.prototype), "updateMatrixWorld", this).call(this, force);\n\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n  }, {\n    key: "updateWorldMatrix",\n    value: function updateWorldMatrix(updateParents, updateChildren) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Camera.prototype), "updateWorldMatrix", this).call(this, updateParents, updateChildren);\n\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }]);\n\n  return Camera;\n}(Object3D);\n\nvar PerspectiveCamera = /*#__PURE__*/function (_Camera) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PerspectiveCamera, _Camera);\n\n  var _super26 = _createSuper(PerspectiveCamera);\n\n  function PerspectiveCamera() {\n    var _this18;\n\n    var fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    var aspect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2000;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PerspectiveCamera);\n\n    _this18 = _super26.call(this);\n    _this18.isPerspectiveCamera = true;\n    _this18.type = \'PerspectiveCamera\';\n    _this18.fov = fov;\n    _this18.zoom = 1;\n    _this18.near = near;\n    _this18.far = far;\n    _this18.focus = 10;\n    _this18.aspect = aspect;\n    _this18.view = null;\n    _this18.filmGauge = 35; // width of the film (default in millimeters)\n\n    _this18.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n    _this18.updateProjectionMatrix();\n\n    return _this18;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PerspectiveCamera, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(PerspectiveCamera.prototype), "copy", this).call(this, source, recursive);\n\n      this.fov = source.fov;\n      this.zoom = source.zoom;\n      this.near = source.near;\n      this.far = source.far;\n      this.focus = source.focus;\n      this.aspect = source.aspect;\n      this.view = source.view === null ? null : Object.assign({}, source.view);\n      this.filmGauge = source.filmGauge;\n      this.filmOffset = source.filmOffset;\n      return this;\n    }\n    /**\n     * Sets the FOV by focal length in respect to the current .filmGauge.\n     *\n     * The default film gauge is 35, so that the focal length can be specified for\n     * a 35mm (full frame) camera.\n     *\n     * Values for focal length and film gauge must have the same unit.\n     */\n\n  }, {\n    key: "setFocalLength",\n    value: function setFocalLength(focalLength) {\n      /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n      var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n      this.updateProjectionMatrix();\n    }\n    /**\n     * Calculates the focal length from the current .fov and .filmGauge.\n     */\n\n  }, {\n    key: "getFocalLength",\n    value: function getFocalLength() {\n      var vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n      return 0.5 * this.getFilmHeight() / vExtentSlope;\n    }\n  }, {\n    key: "getEffectiveFOV",\n    value: function getEffectiveFOV() {\n      return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);\n    }\n  }, {\n    key: "getFilmWidth",\n    value: function getFilmWidth() {\n      // film not completely covered in portrait format (aspect < 1)\n      return this.filmGauge * Math.min(this.aspect, 1);\n    }\n  }, {\n    key: "getFilmHeight",\n    value: function getFilmHeight() {\n      // film not completely covered in landscape format (aspect > 1)\n      return this.filmGauge / Math.max(this.aspect, 1);\n    }\n    /**\n     * Sets an offset in a larger frustum. This is useful for multi-window or\n     * multi-monitor/multi-machine setups.\n     *\n     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n     * the monitors are in grid like this\n     *\n     *   +---+---+---+\n     *   | A | B | C |\n     *   +---+---+---+\n     *   | D | E | F |\n     *   +---+---+---+\n     *\n     * then for each monitor you would call it like this\n     *\n     *   const w = 1920;\n     *   const h = 1080;\n     *   const fullWidth = w * 3;\n     *   const fullHeight = h * 2;\n     *\n     *   --A--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n     *   --B--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n     *   --C--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n     *   --D--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n     *   --E--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n     *   --F--\n     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n     *\n     *   Note there is no reason monitors have to be the same size or in a grid.\n     */\n\n  }, {\n    key: "setViewOffset",\n    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n      this.aspect = fullWidth / fullHeight;\n\n      if (this.view === null) {\n        this.view = {\n          enabled: true,\n          fullWidth: 1,\n          fullHeight: 1,\n          offsetX: 0,\n          offsetY: 0,\n          width: 1,\n          height: 1\n        };\n      }\n\n      this.view.enabled = true;\n      this.view.fullWidth = fullWidth;\n      this.view.fullHeight = fullHeight;\n      this.view.offsetX = x;\n      this.view.offsetY = y;\n      this.view.width = width;\n      this.view.height = height;\n      this.updateProjectionMatrix();\n    }\n  }, {\n    key: "clearViewOffset",\n    value: function clearViewOffset() {\n      if (this.view !== null) {\n        this.view.enabled = false;\n      }\n\n      this.updateProjectionMatrix();\n    }\n  }, {\n    key: "updateProjectionMatrix",\n    value: function updateProjectionMatrix() {\n      var near = this.near;\n      var top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n      var height = 2 * top;\n      var width = this.aspect * height;\n      var left = -0.5 * width;\n      var view = this.view;\n\n      if (this.view !== null && this.view.enabled) {\n        var fullWidth = view.fullWidth,\n            fullHeight = view.fullHeight;\n        left += view.offsetX * width / fullWidth;\n        top -= view.offsetY * height / fullHeight;\n        width *= view.width / fullWidth;\n        height *= view.height / fullHeight;\n      }\n\n      var skew = this.filmOffset;\n      if (skew !== 0) left += near * skew / this.getFilmWidth();\n      this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(PerspectiveCamera.prototype), "toJSON", this).call(this, meta);\n\n      data.object.fov = this.fov;\n      data.object.zoom = this.zoom;\n      data.object.near = this.near;\n      data.object.far = this.far;\n      data.object.focus = this.focus;\n      data.object.aspect = this.aspect;\n      if (this.view !== null) data.object.view = Object.assign({}, this.view);\n      data.object.filmGauge = this.filmGauge;\n      data.object.filmOffset = this.filmOffset;\n      return data;\n    }\n  }]);\n\n  return PerspectiveCamera;\n}(Camera);\n\nvar fov = 90,\n    aspect = 1;\n\nvar CubeCamera = /*#__PURE__*/function (_Object3D3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CubeCamera, _Object3D3);\n\n  var _super27 = _createSuper(CubeCamera);\n\n  function CubeCamera(near, far, renderTarget) {\n    var _this19;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CubeCamera);\n\n    _this19 = _super27.call(this);\n    _this19.type = \'CubeCamera\';\n\n    if (renderTarget.isWebGLCubeRenderTarget !== true) {\n      console.error(\'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.\');\n      return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(_this19);\n    }\n\n    _this19.renderTarget = renderTarget;\n    var cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPX.layers = _this19.layers;\n    cameraPX.up.set(0, -1, 0);\n    cameraPX.lookAt(new Vector3(1, 0, 0));\n\n    _this19.add(cameraPX);\n\n    var cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNX.layers = _this19.layers;\n    cameraNX.up.set(0, -1, 0);\n    cameraNX.lookAt(new Vector3(-1, 0, 0));\n\n    _this19.add(cameraNX);\n\n    var cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPY.layers = _this19.layers;\n    cameraPY.up.set(0, 0, 1);\n    cameraPY.lookAt(new Vector3(0, 1, 0));\n\n    _this19.add(cameraPY);\n\n    var cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNY.layers = _this19.layers;\n    cameraNY.up.set(0, 0, -1);\n    cameraNY.lookAt(new Vector3(0, -1, 0));\n\n    _this19.add(cameraNY);\n\n    var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPZ.layers = _this19.layers;\n    cameraPZ.up.set(0, -1, 0);\n    cameraPZ.lookAt(new Vector3(0, 0, 1));\n\n    _this19.add(cameraPZ);\n\n    var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNZ.layers = _this19.layers;\n    cameraNZ.up.set(0, -1, 0);\n    cameraNZ.lookAt(new Vector3(0, 0, -1));\n\n    _this19.add(cameraNZ);\n\n    return _this19;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CubeCamera, [{\n    key: "update",\n    value: function update(renderer, scene) {\n      if (this.parent === null) this.updateMatrixWorld();\n      var renderTarget = this.renderTarget;\n\n      var _this$children = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_10__/* ["default"] */ .Z)(this.children, 6),\n          cameraPX = _this$children[0],\n          cameraNX = _this$children[1],\n          cameraPY = _this$children[2],\n          cameraNY = _this$children[3],\n          cameraPZ = _this$children[4],\n          cameraNZ = _this$children[5];\n\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentToneMapping = renderer.toneMapping;\n      var currentXrEnabled = renderer.xr.enabled;\n      renderer.toneMapping = NoToneMapping;\n      renderer.xr.enabled = false;\n      var generateMipmaps = renderTarget.texture.generateMipmaps;\n      renderTarget.texture.generateMipmaps = false;\n      renderer.setRenderTarget(renderTarget, 0);\n      renderer.render(scene, cameraPX);\n      renderer.setRenderTarget(renderTarget, 1);\n      renderer.render(scene, cameraNX);\n      renderer.setRenderTarget(renderTarget, 2);\n      renderer.render(scene, cameraPY);\n      renderer.setRenderTarget(renderTarget, 3);\n      renderer.render(scene, cameraNY);\n      renderer.setRenderTarget(renderTarget, 4);\n      renderer.render(scene, cameraPZ);\n      renderTarget.texture.generateMipmaps = generateMipmaps;\n      renderer.setRenderTarget(renderTarget, 5);\n      renderer.render(scene, cameraNZ);\n      renderer.setRenderTarget(currentRenderTarget);\n      renderer.toneMapping = currentToneMapping;\n      renderer.xr.enabled = currentXrEnabled;\n      renderTarget.texture.needsPMREMUpdate = true;\n    }\n  }]);\n\n  return CubeCamera;\n}(Object3D);\n\nvar CubeTexture = /*#__PURE__*/function (_Texture3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CubeTexture, _Texture3);\n\n  var _super28 = _createSuper(CubeTexture);\n\n  function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\n    var _this20;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CubeTexture);\n\n    images = images !== undefined ? images : [];\n    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n    _this20 = _super28.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    _this20.isCubeTexture = true;\n    _this20.flipY = false;\n    return _this20;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CubeTexture, [{\n    key: "images",\n    get: function get() {\n      return this.image;\n    },\n    set: function set(value) {\n      this.image = value;\n    }\n  }]);\n\n  return CubeTexture;\n}(Texture);\n\nvar WebGLCubeRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WebGLCubeRenderTarget, _WebGLRenderTarget4);\n\n  var _super29 = _createSuper(WebGLCubeRenderTarget);\n\n  function WebGLCubeRenderTarget(size) {\n    var _this21;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGLCubeRenderTarget);\n\n    _this21 = _super29.call(this, size, size, options);\n    _this21.isWebGLCubeRenderTarget = true;\n    var image = {\n      width: size,\n      height: size,\n      depth: 1\n    };\n    var images = [image, image, image, image, image, image];\n    _this21.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding); // By convention -- likely based on the RenderMan spec from the 1990\'s -- cube maps are specified by WebGL (and three.js)\n    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n    _this21.texture.isRenderTargetTexture = true;\n    _this21.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    _this21.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n    return _this21;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGLCubeRenderTarget, [{\n    key: "fromEquirectangularTexture",\n    value: function fromEquirectangularTexture(renderer, texture) {\n      this.texture.type = texture.type;\n      this.texture.encoding = texture.encoding;\n      this.texture.generateMipmaps = texture.generateMipmaps;\n      this.texture.minFilter = texture.minFilter;\n      this.texture.magFilter = texture.magFilter;\n      var shader = {\n        uniforms: {\n          tEquirect: {\n            value: null\n          }\n        },\n        vertexShader:\n        /* glsl */\n        "\\n\\n\\t\\t\\t\\tvarying vec3 vWorldDirection;\\n\\n\\t\\t\\t\\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\n\\t\\t\\t\\t\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\n\\t\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t\\t#include <project_vertex>\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t",\n        fragmentShader:\n        /* glsl */\n        "\\n\\n\\t\\t\\t\\tuniform sampler2D tEquirect;\\n\\n\\t\\t\\t\\tvarying vec3 vWorldDirection;\\n\\n\\t\\t\\t\\t#include <common>\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvec3 direction = normalize( vWorldDirection );\\n\\n\\t\\t\\t\\t\\tvec2 sampleUV = equirectUv( direction );\\n\\n\\t\\t\\t\\t\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t"\n      };\n      var geometry = new BoxGeometry(5, 5, 5);\n      var material = new ShaderMaterial({\n        name: \'CubemapFromEquirect\',\n        uniforms: cloneUniforms(shader.uniforms),\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader,\n        side: BackSide,\n        blending: NoBlending\n      });\n      material.uniforms.tEquirect.value = texture;\n      var mesh = new Mesh(geometry, material);\n      var currentMinFilter = texture.minFilter; // Avoid blurred poles\n\n      if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n      var camera = new CubeCamera(1, 10, this);\n      camera.update(renderer, mesh);\n      texture.minFilter = currentMinFilter;\n      mesh.geometry.dispose();\n      mesh.material.dispose();\n      return this;\n    }\n  }, {\n    key: "clear",\n    value: function clear(renderer, color, depth, stencil) {\n      var currentRenderTarget = renderer.getRenderTarget();\n\n      for (var _i67 = 0; _i67 < 6; _i67++) {\n        renderer.setRenderTarget(this, _i67);\n        renderer.clear(color, depth, stencil);\n      }\n\n      renderer.setRenderTarget(currentRenderTarget);\n    }\n  }]);\n\n  return WebGLCubeRenderTarget;\n}(WebGLRenderTarget);\n\nvar _vector1 = /*@__PURE__*/new Vector3();\n\nvar _vector2 = /*@__PURE__*/new Vector3();\n\nvar _normalMatrix = /*@__PURE__*/new Matrix3();\n\nvar Plane = /*#__PURE__*/function () {\n  function Plane() {\n    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);\n    var constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Plane);\n\n    this.isPlane = true; // normal is assumed to be normalized\n\n    this.normal = normal;\n    this.constant = constant;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Plane, [{\n    key: "set",\n    value: function set(normal, constant) {\n      this.normal.copy(normal);\n      this.constant = constant;\n      return this;\n    }\n  }, {\n    key: "setComponents",\n    value: function setComponents(x, y, z, w) {\n      this.normal.set(x, y, z);\n      this.constant = w;\n      return this;\n    }\n  }, {\n    key: "setFromNormalAndCoplanarPoint",\n    value: function setFromNormalAndCoplanarPoint(normal, point) {\n      this.normal.copy(normal);\n      this.constant = -point.dot(this.normal);\n      return this;\n    }\n  }, {\n    key: "setFromCoplanarPoints",\n    value: function setFromCoplanarPoints(a, b, c) {\n      var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n      this.setFromNormalAndCoplanarPoint(normal, a);\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(plane) {\n      this.normal.copy(plane.normal);\n      this.constant = plane.constant;\n      return this;\n    }\n  }, {\n    key: "normalize",\n    value: function normalize() {\n      // Note: will lead to a divide by zero if the plane is invalid.\n      var inverseNormalLength = 1.0 / this.normal.length();\n      this.normal.multiplyScalar(inverseNormalLength);\n      this.constant *= inverseNormalLength;\n      return this;\n    }\n  }, {\n    key: "negate",\n    value: function negate() {\n      this.constant *= -1;\n      this.normal.negate();\n      return this;\n    }\n  }, {\n    key: "distanceToPoint",\n    value: function distanceToPoint(point) {\n      return this.normal.dot(point) + this.constant;\n    }\n  }, {\n    key: "distanceToSphere",\n    value: function distanceToSphere(sphere) {\n      return this.distanceToPoint(sphere.center) - sphere.radius;\n    }\n  }, {\n    key: "projectPoint",\n    value: function projectPoint(point, target) {\n      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n    }\n  }, {\n    key: "intersectLine",\n    value: function intersectLine(line, target) {\n      var direction = line.delta(_vector1);\n      var denominator = this.normal.dot(direction);\n\n      if (denominator === 0) {\n        // line is coplanar, return origin\n        if (this.distanceToPoint(line.start) === 0) {\n          return target.copy(line.start);\n        } // Unsure if this is the correct method to handle this case.\n\n\n        return null;\n      }\n\n      var t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n      if (t < 0 || t > 1) {\n        return null;\n      }\n\n      return target.copy(direction).multiplyScalar(t).add(line.start);\n    }\n  }, {\n    key: "intersectsLine",\n    value: function intersectsLine(line) {\n      // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n      var startSign = this.distanceToPoint(line.start);\n      var endSign = this.distanceToPoint(line.end);\n      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n    }\n  }, {\n    key: "intersectsBox",\n    value: function intersectsBox(box) {\n      return box.intersectsPlane(this);\n    }\n  }, {\n    key: "intersectsSphere",\n    value: function intersectsSphere(sphere) {\n      return sphere.intersectsPlane(this);\n    }\n  }, {\n    key: "coplanarPoint",\n    value: function coplanarPoint(target) {\n      return target.copy(this.normal).multiplyScalar(-this.constant);\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(matrix, optionalNormalMatrix) {\n      var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n      var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n      var normal = this.normal.applyMatrix3(normalMatrix).normalize();\n      this.constant = -referencePoint.dot(normal);\n      return this;\n    }\n  }, {\n    key: "translate",\n    value: function translate(offset) {\n      this.constant -= offset.dot(this.normal);\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(plane) {\n      return plane.normal.equals(this.normal) && plane.constant === this.constant;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }]);\n\n  return Plane;\n}();\n\nvar _sphere$2 = /*@__PURE__*/new Sphere();\n\nvar _vector$7 = /*@__PURE__*/new Vector3();\n\nvar Frustum = /*#__PURE__*/function () {\n  function Frustum() {\n    var p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Plane();\n    var p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Plane();\n    var p2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Plane();\n    var p3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Plane();\n    var p4 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Plane();\n    var p5 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Plane();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Frustum);\n\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Frustum, [{\n    key: "set",\n    value: function set(p0, p1, p2, p3, p4, p5) {\n      var planes = this.planes;\n      planes[0].copy(p0);\n      planes[1].copy(p1);\n      planes[2].copy(p2);\n      planes[3].copy(p3);\n      planes[4].copy(p4);\n      planes[5].copy(p5);\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(frustum) {\n      var planes = this.planes;\n\n      for (var _i68 = 0; _i68 < 6; _i68++) {\n        planes[_i68].copy(frustum.planes[_i68]);\n      }\n\n      return this;\n    }\n  }, {\n    key: "setFromProjectionMatrix",\n    value: function setFromProjectionMatrix(m) {\n      var planes = this.planes;\n      var me = m.elements;\n      var me0 = me[0],\n          me1 = me[1],\n          me2 = me[2],\n          me3 = me[3];\n      var me4 = me[4],\n          me5 = me[5],\n          me6 = me[6],\n          me7 = me[7];\n      var me8 = me[8],\n          me9 = me[9],\n          me10 = me[10],\n          me11 = me[11];\n      var me12 = me[12],\n          me13 = me[13],\n          me14 = me[14],\n          me15 = me[15];\n      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n      return this;\n    }\n  }, {\n    key: "intersectsObject",\n    value: function intersectsObject(object) {\n      var geometry = object.geometry;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n      _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n\n      return this.intersectsSphere(_sphere$2);\n    }\n  }, {\n    key: "intersectsSprite",\n    value: function intersectsSprite(sprite) {\n      _sphere$2.center.set(0, 0, 0);\n\n      _sphere$2.radius = 0.7071067811865476;\n\n      _sphere$2.applyMatrix4(sprite.matrixWorld);\n\n      return this.intersectsSphere(_sphere$2);\n    }\n  }, {\n    key: "intersectsSphere",\n    value: function intersectsSphere(sphere) {\n      var planes = this.planes;\n      var center = sphere.center;\n      var negRadius = -sphere.radius;\n\n      for (var _i69 = 0; _i69 < 6; _i69++) {\n        var distance = planes[_i69].distanceToPoint(center);\n\n        if (distance < negRadius) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: "intersectsBox",\n    value: function intersectsBox(box) {\n      var planes = this.planes;\n\n      for (var _i70 = 0; _i70 < 6; _i70++) {\n        var plane = planes[_i70]; // corner at max distance\n\n        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n        if (plane.distanceToPoint(_vector$7) < 0) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: "containsPoint",\n    value: function containsPoint(point) {\n      var planes = this.planes;\n\n      for (var _i71 = 0; _i71 < 6; _i71++) {\n        if (planes[_i71].distanceToPoint(point) < 0) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }]);\n\n  return Frustum;\n}();\n\nfunction WebGLAnimation() {\n  var context = null;\n  var isAnimating = false;\n  var animationLoop = null;\n  var requestId = null;\n\n  function onAnimationFrame(time, frame) {\n    animationLoop(time, frame);\n    requestId = context.requestAnimationFrame(onAnimationFrame);\n  }\n\n  return {\n    start: function start() {\n      if (isAnimating === true) return;\n      if (animationLoop === null) return;\n      requestId = context.requestAnimationFrame(onAnimationFrame);\n      isAnimating = true;\n    },\n    stop: function stop() {\n      context.cancelAnimationFrame(requestId);\n      isAnimating = false;\n    },\n    setAnimationLoop: function setAnimationLoop(callback) {\n      animationLoop = callback;\n    },\n    setContext: function setContext(value) {\n      context = value;\n    }\n  };\n}\n\nfunction WebGLAttributes(gl, capabilities) {\n  var isWebGL2 = capabilities.isWebGL2;\n  var buffers = new WeakMap();\n\n  function createBuffer(attribute, bufferType) {\n    var array = attribute.array;\n    var usage = attribute.usage;\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(bufferType, buffer);\n    gl.bufferData(bufferType, array, usage);\n    attribute.onUploadCallback();\n    var type;\n\n    if (array instanceof Float32Array) {\n      type = 5126;\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        if (isWebGL2) {\n          type = 5131;\n        } else {\n          throw new Error(\'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.\');\n        }\n      } else {\n        type = 5123;\n      }\n    } else if (array instanceof Int16Array) {\n      type = 5122;\n    } else if (array instanceof Uint32Array) {\n      type = 5125;\n    } else if (array instanceof Int32Array) {\n      type = 5124;\n    } else if (array instanceof Int8Array) {\n      type = 5120;\n    } else if (array instanceof Uint8Array) {\n      type = 5121;\n    } else if (array instanceof Uint8ClampedArray) {\n      type = 5121;\n    } else {\n      throw new Error(\'THREE.WebGLAttributes: Unsupported buffer data format: \' + array);\n    }\n\n    return {\n      buffer: buffer,\n      type: type,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version\n    };\n  }\n\n  function updateBuffer(buffer, attribute, bufferType) {\n    var array = attribute.array;\n    var updateRange = attribute.updateRange;\n    gl.bindBuffer(bufferType, buffer);\n\n    if (updateRange.count === -1) {\n      // Not using update ranges\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      if (isWebGL2) {\n        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);\n      } else {\n        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));\n      }\n\n      updateRange.count = -1; // reset range\n    }\n  } //\n\n\n  function get(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return buffers.get(attribute);\n  }\n\n  function remove(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    var data = buffers.get(attribute);\n\n    if (data) {\n      gl.deleteBuffer(data.buffer);\n      buffers.delete(attribute);\n    }\n  }\n\n  function update(attribute, bufferType) {\n    if (attribute.isGLBufferAttribute) {\n      var cached = buffers.get(attribute);\n\n      if (!cached || cached.version < attribute.version) {\n        buffers.set(attribute, {\n          buffer: attribute.buffer,\n          type: attribute.type,\n          bytesPerElement: attribute.elementSize,\n          version: attribute.version\n        });\n      }\n\n      return;\n    }\n\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    var data = buffers.get(attribute);\n\n    if (data === undefined) {\n      buffers.set(attribute, createBuffer(attribute, bufferType));\n    } else if (data.version < attribute.version) {\n      updateBuffer(data.buffer, attribute, bufferType);\n      data.version = attribute.version;\n    }\n  }\n\n  return {\n    get: get,\n    remove: remove,\n    update: update\n  };\n}\n\nvar PlaneGeometry = /*#__PURE__*/function (_BufferGeometry2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PlaneGeometry, _BufferGeometry2);\n\n  var _super30 = _createSuper(PlaneGeometry);\n\n  function PlaneGeometry() {\n    var _this22;\n\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PlaneGeometry);\n\n    _this22 = _super30.call(this);\n    _this22.type = \'PlaneGeometry\';\n    _this22.parameters = {\n      width: width,\n      height: height,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments\n    };\n    var width_half = width / 2;\n    var height_half = height / 2;\n    var gridX = Math.floor(widthSegments);\n    var gridY = Math.floor(heightSegments);\n    var gridX1 = gridX + 1;\n    var gridY1 = gridY + 1;\n    var segment_width = width / gridX;\n    var segment_height = height / gridY; //\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n\n    for (var iy = 0; iy < gridY1; iy++) {\n      var y = iy * segment_height - height_half;\n\n      for (var ix = 0; ix < gridX1; ix++) {\n        var x = ix * segment_width - width_half;\n        vertices.push(x, -y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      }\n    }\n\n    for (var _iy2 = 0; _iy2 < gridY; _iy2++) {\n      for (var _ix2 = 0; _ix2 < gridX; _ix2++) {\n        var a = _ix2 + gridX1 * _iy2;\n        var b = _ix2 + gridX1 * (_iy2 + 1);\n        var c = _ix2 + 1 + gridX1 * (_iy2 + 1);\n        var d = _ix2 + 1 + gridX1 * _iy2;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n\n    _this22.setIndex(indices);\n\n    _this22.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this22.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this22.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2));\n\n    return _this22;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PlaneGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n    }\n  }]);\n\n  return PlaneGeometry;\n}(BufferGeometry);\n\nvar alphamap_fragment = "#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif";\nvar alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif";\nvar alphatest_fragment = "#ifdef USE_ALPHATEST\\n\\tif ( diffuseColor.a < alphaTest ) discard;\\n#endif";\nvar alphatest_pars_fragment = "#ifdef USE_ALPHATEST\\n\\tuniform float alphaTest;\\n#endif";\nvar aomap_fragment = "#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\\n\\t#endif\\n#endif";\nvar aomap_pars_fragment = "#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif";\nvar begin_vertex = "vec3 transformed = vec3( position );";\nvar beginnormal_vertex = "vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif";\nvar bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\\n    float x2 = x * x;\\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\\n}\\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( V * D );\\n}\\n#ifdef USE_IRIDESCENCE\\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\\n\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( V * D );\\n}\\n#endif\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float dotNH ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tfloat invAlpha = 1.0 / alpha;\\n\\tfloat cos2h = dotNH * dotNH;\\n\\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\\n\\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat D = D_Charlie( sheenRoughness, dotNH );\\n\\tfloat V = V_Neubelt( dotNV, dotNL );\\n\\treturn sheenColor * ( D * V );\\n}\\n#endif";\nvar iridescence_fragment = "#ifdef USE_IRIDESCENCE\\nconst mat3 XYZ_TO_REC709 = mat3(\\n    3.2404542, -0.9692660,  0.0556434,\\n   -1.5371385,  1.8760108, -0.2040259,\\n   -0.4985314,  0.0415560,  1.0572252\\n);\\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\\n   vec3 sqrtF0 = sqrt( fresnel0 );\\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\\n}\\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\\n}\\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\\n}\\nvec3 evalSensitivity( float OPD, vec3 shift ) {\\n   float phase = 2.0 * PI * OPD * 1.0e-9;\\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\\n   xyz /= 1.0685e-7;\\n   vec3 srgb = XYZ_TO_REC709 * xyz;\\n   return srgb;\\n}\\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\\n   vec3 I;\\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\\n   if ( cosTheta2Sq < 0.0 ) {\\n       return vec3( 1.0 );\\n   }\\n   float cosTheta2 = sqrt( cosTheta2Sq );\\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\\n   float R21 = R12;\\n   float T121 = 1.0 - R12;\\n   float phi12 = 0.0;\\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\\n   float phi21 = PI - phi12;\\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\\n   vec3 phi23 = vec3( 0.0 );\\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\\n   vec3 phi = vec3( phi21 ) + phi23;\\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\\n   vec3 r123 = sqrt( R123 );\\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\\n   vec3 C0 = R12 + Rs;\\n   I = C0;\\n   vec3 Cm = Rs - T121;\\n   for ( int m = 1; m <= 2; ++m ) {\\n       Cm *= r123;\\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\\n       I += Cm * Sm;\\n   }\\n   return max( I, vec3( 0.0 ) );\\n}\\n#endif";\nvar bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif";\nvar clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif";\nvar clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif";\nvar clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif";\nvar clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif";\nvar color_fragment = "#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif";\nvar color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif";\nvar color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif";\nvar color_vertex = "#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif";\nvar common = "#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nvec3 pow2( const in vec3 x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract( sin( sn ) * c );\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}";\nvar cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\\n\\t\\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\\n\\t\\tuv.x *= CUBEUV_TEXEL_WIDTH;\\n\\t\\tuv.y *= CUBEUV_TEXEL_HEIGHT;\\n\\t\\t#ifdef texture2DGradEXT\\n\\t\\t\\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn texture2D( envMap, uv ).rgb;\\n\\t\\t#endif\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif";\nvar defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif";\nvar displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif";\nvar displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif";\nvar emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif";\nvar emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif";\nvar encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";\nvar encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}";\nvar envmap_fragment = "#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif";\nvar envmap_common_pars_fragment = "#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif";\nvar envmap_pars_fragment = "#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif";\nvar envmap_pars_vertex = "#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif";\nvar envmap_vertex = "#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif";\nvar fog_vertex = "#ifdef USE_FOG\\n\\tvFogDepth = - mvPosition.z;\\n#endif";\nvar fog_pars_vertex = "#ifdef USE_FOG\\n\\tvarying float vFogDepth;\\n#endif";\nvar fog_fragment = "#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif";\nvar fog_pars_fragment = "#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float vFogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif";\nvar gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn vec3( texture2D( gradientMap, coord ).r );\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}";\nvar lightmap_fragment = "#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\\n\\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\\n\\treflectedLight.indirectDiffuse += lightMapIrradiance;\\n#endif";\nvar lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif";\nvar lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif";\nvar lights_pars_begin = "uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\\n\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tif ( cutoffDistance > 0.0 ) {\\n\\t\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t}\\n\\t\\treturn distanceFalloff;\\n\\t#else\\n\\t\\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\t\\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t#endif\\n}\\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\\n\\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tlight.color = directionalLight.color;\\n\\t\\tlight.direction = directionalLight.direction;\\n\\t\\tlight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tlight.color = pointLight.color;\\n\\t\\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat angleCos = dot( light.direction, spotLight.direction );\\n\\t\\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\tif ( spotAttenuation > 0.0 ) {\\n\\t\\t\\tfloat lightDistance = length( lVector );\\n\\t\\t\\tlight.color = spotLight.color * spotAttenuation;\\n\\t\\t\\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t\\t} else {\\n\\t\\t\\tlight.color = vec3( 0.0 );\\n\\t\\t\\tlight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\\n\\t\\tfloat dotNL = dot( normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\treturn irradiance;\\n\\t}\\n#endif";\nvar envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\\n\\tvec3 getIBLIrradiance( const in vec3 normal ) {\\n\\t\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\\n\\t\\t#if defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 reflectVec = reflect( - viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n#endif";\nvar lights_toon_fragment = "ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;";\nvar lights_toon_pars_fragment = "varying vec3 vViewPosition;\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)";\nvar lights_phong_fragment = "BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;";\nvar lights_phong_pars_fragment = "varying vec3 vViewPosition;\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)";\nvar lights_physical_fragment = "PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\\nmaterial.roughness = min( material.roughness, 1.0 );\\n#ifdef IOR\\n\\t#ifdef SPECULAR\\n\\t\\tfloat specularIntensityFactor = specularIntensity;\\n\\t\\tvec3 specularColorFactor = specularColor;\\n\\t\\t#ifdef USE_SPECULARINTENSITYMAP\\n\\t\\t\\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\\n\\t\\t#endif\\n\\t\\t#ifdef USE_SPECULARCOLORMAP\\n\\t\\t\\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\\n\\t\\t#endif\\n\\t\\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\\n\\t#else\\n\\t\\tfloat specularIntensityFactor = 1.0;\\n\\t\\tvec3 specularColorFactor = vec3( 1.0 );\\n\\t\\tmaterial.specularF90 = 1.0;\\n\\t#endif\\n\\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\tmaterial.clearcoatF0 = vec3( 0.04 );\\n\\tmaterial.clearcoatF90 = 1.0;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tmaterial.iridescence = iridescence;\\n\\tmaterial.iridescenceIOR = iridescenceIOR;\\n\\t#ifdef USE_IRIDESCENCEMAP\\n\\t\\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\t\\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\\n\\t#else\\n\\t\\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\\n\\t#endif\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheenColor;\\n\\t#ifdef USE_SHEENCOLORMAP\\n\\t\\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\\n\\t#endif\\n\\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\\n\\t#ifdef USE_SHEENROUGHNESSMAP\\n\\t\\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\\n\\t#endif\\n#endif";\nvar lights_physical_pars_fragment = "struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat roughness;\\n\\tvec3 specularColor;\\n\\tfloat specularF90;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat clearcoat;\\n\\t\\tfloat clearcoatRoughness;\\n\\t\\tvec3 clearcoatF0;\\n\\t\\tfloat clearcoatF90;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tfloat iridescence;\\n\\t\\tfloat iridescenceIOR;\\n\\t\\tfloat iridescenceThickness;\\n\\t\\tvec3 iridescenceFresnel;\\n\\t\\tvec3 iridescenceF0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tvec3 sheenColor;\\n\\t\\tfloat sheenRoughness;\\n\\t#endif\\n};\\nvec3 clearcoatSpecular = vec3( 0.0 );\\nvec3 sheenSpecular = vec3( 0.0 );\\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat r2 = roughness * roughness;\\n\\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\\n\\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\\n\\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\\n\\treturn saturate( DG * RECIPROCAL_PI );\\n}\\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\\n\\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\treturn specularColor * fab.x + specularF90 * fab.y;\\n}\\n#ifdef USE_IRIDESCENCE\\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#else\\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#endif\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\\n\\t#else\\n\\t\\tvec3 Fr = specularColor;\\n\\t#endif\\n\\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\\n\\tfloat Ess = fab.x + fab.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.roughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = dotNLcc * directLight.color;\\n\\t\\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\\n\\t#else\\n\\t\\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\\n\\t#endif\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\\n\\t#else\\n\\t\\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\\n\\t#endif\\n\\tvec3 totalScattering = singleScattering + multiScattering;\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\\n\\treflectedLight.indirectSpecular += radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}";\nvar lights_fragment_begin = "\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef USE_CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\n#ifdef USE_IRIDESCENCE\\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\\nif ( material.iridescenceThickness == 0.0 ) {\\n\\tmaterial.iridescence = 0.0;\\n} else {\\n\\tmaterial.iridescence = saturate( material.iridescence );\\n}\\nif ( material.iridescence > 0.0 ) {\\n\\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\\n\\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\\n}\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointLightInfo( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotLightInfo( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif";\nvar lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getIBLIrradiance( geometry.normal );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\\n\\t#endif\\n#endif";\nvar lights_fragment_end = "#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif";\nvar logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif";\nvar logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif";\nvar logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif";\nvar logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif";\nvar map_fragment = "#ifdef USE_MAP\\n\\tvec4 sampledDiffuseColor = texture2D( map, vUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE\\n\\t\\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\\n\\t#endif\\n\\tdiffuseColor *= sampledDiffuseColor;\\n#endif";\nvar map_pars_fragment = "#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif";\nvar map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tdiffuseColor *= texture2D( map, uv );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif";\nvar map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif";\nvar metalnessmap_fragment = "float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif";\nvar metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif";\nvar morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\\n\\tvColor *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t#if defined( USE_COLOR_ALPHA )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t#elif defined( USE_COLOR )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\\n\\t\\t#endif\\n\\t}\\n#endif";\nvar morphnormal_vertex = "#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\\n\\t\\t}\\n\\t#else\\n\\t\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\t\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\t\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\t\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n\\t#endif\\n#endif";\nvar morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\t\\tuniform sampler2DArray morphTargetsTexture;\\n\\t\\tuniform ivec2 morphTargetsTextureSize;\\n\\t\\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\\n\\t\\t\\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\\n\\t\\t\\tint y = texelIndex / morphTargetsTextureSize.x;\\n\\t\\t\\tint x = texelIndex - y * morphTargetsTextureSize.x;\\n\\t\\t\\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\\n\\t\\t\\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\\n\\t\\t}\\n\\t#else\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t\\t#else\\n\\t\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif";\nvar morphtarget_vertex = "#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\\n\\t\\t}\\n\\t#else\\n\\t\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\t\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\t\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\t\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif";\nvar normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;";\nvar normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif";\nvar normal_pars_fragment = "#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif";\nvar normal_pars_vertex = "#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif";\nvar normal_vertex = "#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif";\nvar normalmap_pars_fragment = "#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif";\nvar clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif";\nvar clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif";\nvar clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif";\nvar iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\\n\\tuniform sampler2D iridescenceMap;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform sampler2D iridescenceThicknessMap;\\n#endif";\nvar output_fragment = "#ifdef OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef USE_TRANSMISSION\\ndiffuseColor.a *= transmissionAlpha + 0.1;\\n#endif\\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";\nvar packing = "vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}";\nvar premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif";\nvar project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;";\nvar dithering_fragment = "#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif";\nvar dithering_pars_fragment = "#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif";\nvar roughnessmap_fragment = "float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif";\nvar roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif";\nvar shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif";\nvar shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif";\nvar shadowmap_vertex = "#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif";\nvar shadowmask_pars_fragment = "float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}";\nvar skinbase_vertex = "#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif";\nvar skinning_pars_vertex = "#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\tuniform highp sampler2D boneTexture;\\n\\tuniform int boneTextureSize;\\n\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\tfloat j = i * 4.0;\\n\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\ty = dy * ( y + 0.5 );\\n\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\treturn bone;\\n\\t}\\n#endif";\nvar skinning_vertex = "#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif";\nvar skinnormal_vertex = "#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif";\nvar specularmap_fragment = "float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif";\nvar specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif";\nvar tonemapping_fragment = "#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif";\nvar tonemapping_pars_fragment = "#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }";\nvar transmission_fragment = "#ifdef USE_TRANSMISSION\\n\\tfloat transmissionAlpha = 1.0;\\n\\tfloat transmissionFactor = transmission;\\n\\tfloat thicknessFactor = thickness;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\\tvec4 transmission = getIBLVolumeRefraction(\\n\\t\\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\\n\\t\\tattenuationColor, attenuationDistance );\\n\\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\\n\\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\\n#endif";\nvar transmission_pars_fragment = "#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform float attenuationDistance;\\n\\tuniform vec3 attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec3 vWorldPosition;\\n\\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\\n\\t\\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n\\t\\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n\\t\\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n\\t\\treturn normalize( refractionVector ) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\\n\\t\\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n\\t}\\n\\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\\n\\t\\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\\n\\t\\t#ifdef texture2DLodEXT\\n\\t\\t\\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\\n\\t\\t#else\\n\\t\\t\\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tif ( attenuationDistance == 0.0 ) {\\n\\t\\t\\treturn radiance;\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\\t\\t\\treturn transmittance * radiance;\\n\\t\\t}\\n\\t}\\n\\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\\n\\t\\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\\n\\t\\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\\n\\t\\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n\\t\\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\\n\\t\\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n\\t\\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\\n\\t}\\n#endif";\nvar uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif";\nvar uv_pars_vertex = "#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif";\nvar uv_vertex = "#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif";\nvar uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif";\nvar uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif";\nvar uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif";\nvar worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif";\nvar vertex$g = "varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}";\nvar fragment$g = "uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tgl_FragColor = texture2D( t2D, vUv );\\n\\t#ifdef DECODE_VIDEO_TEXTURE\\n\\t\\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\\n\\t#endif\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}";\nvar vertex$f = "varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}";\nvar fragment$f = "#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}";\nvar vertex$e = "#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}";\nvar fragment$e = "#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}";\nvar vertex$d = "#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}";\nvar fragment$d = "#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}";\nvar vertex$c = "varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}";\nvar fragment$c = "uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}";\nvar vertex$b = "uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}";\nvar fragment$b = "uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}";\nvar vertex$a = "#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinbase_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}";\nvar fragment$a = "uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}";\nvar vertex$9 = "#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}";\nvar fragment$9 = "uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}";\nvar vertex$8 = "#define MATCAP\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}";\nvar fragment$8 = "#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}";\nvar vertex$7 = "#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}";\nvar fragment$7 = "#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n\\t#ifdef OPAQUE\\n\\t\\tgl_FragColor.a = 1.0;\\n\\t#endif\\n}";\nvar vertex$6 = "#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}";\nvar fragment$6 = "#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}";\nvar vertex$5 = "#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec3 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}";\nvar fragment$5 = "#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define IOR\\n\\t#define SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef IOR\\n\\tuniform float ior;\\n#endif\\n#ifdef SPECULAR\\n\\tuniform float specularIntensity;\\n\\tuniform vec3 specularColor;\\n\\t#ifdef USE_SPECULARINTENSITYMAP\\n\\t\\tuniform sampler2D specularIntensityMap;\\n\\t#endif\\n\\t#ifdef USE_SPECULARCOLORMAP\\n\\t\\tuniform sampler2D specularColorMap;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tuniform float iridescence;\\n\\tuniform float iridescenceIOR;\\n\\tuniform float iridescenceThicknessMinimum;\\n\\tuniform float iridescenceThicknessMaximum;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheenColor;\\n\\tuniform float sheenRoughness;\\n\\t#ifdef USE_SHEENCOLORMAP\\n\\t\\tuniform sampler2D sheenColorMap;\\n\\t#endif\\n\\t#ifdef USE_SHEENROUGHNESSMAP\\n\\t\\tuniform sampler2D sheenRoughnessMap;\\n\\t#endif\\n#endif\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <iridescence_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <iridescence_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\t#ifdef USE_SHEEN\\n\\t\\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\\n\\t\\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\\n\\t\\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\\n\\t#endif\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}";\nvar vertex$4 = "#define TOON\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}";\nvar fragment$4 = "#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}";\nvar vertex$3 = "uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}";\nvar fragment$3 = "uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}";\nvar vertex$2 = "#include <common>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}";\nvar fragment$2 = "uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}";\nvar vertex$1 = "uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}";\nvar fragment$1 = "uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <output_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}";\nvar ShaderChunk = {\n  alphamap_fragment: alphamap_fragment,\n  alphamap_pars_fragment: alphamap_pars_fragment,\n  alphatest_fragment: alphatest_fragment,\n  alphatest_pars_fragment: alphatest_pars_fragment,\n  aomap_fragment: aomap_fragment,\n  aomap_pars_fragment: aomap_pars_fragment,\n  begin_vertex: begin_vertex,\n  beginnormal_vertex: beginnormal_vertex,\n  bsdfs: bsdfs,\n  iridescence_fragment: iridescence_fragment,\n  bumpmap_pars_fragment: bumpmap_pars_fragment,\n  clipping_planes_fragment: clipping_planes_fragment,\n  clipping_planes_pars_fragment: clipping_planes_pars_fragment,\n  clipping_planes_pars_vertex: clipping_planes_pars_vertex,\n  clipping_planes_vertex: clipping_planes_vertex,\n  color_fragment: color_fragment,\n  color_pars_fragment: color_pars_fragment,\n  color_pars_vertex: color_pars_vertex,\n  color_vertex: color_vertex,\n  common: common,\n  cube_uv_reflection_fragment: cube_uv_reflection_fragment,\n  defaultnormal_vertex: defaultnormal_vertex,\n  displacementmap_pars_vertex: displacementmap_pars_vertex,\n  displacementmap_vertex: displacementmap_vertex,\n  emissivemap_fragment: emissivemap_fragment,\n  emissivemap_pars_fragment: emissivemap_pars_fragment,\n  encodings_fragment: encodings_fragment,\n  encodings_pars_fragment: encodings_pars_fragment,\n  envmap_fragment: envmap_fragment,\n  envmap_common_pars_fragment: envmap_common_pars_fragment,\n  envmap_pars_fragment: envmap_pars_fragment,\n  envmap_pars_vertex: envmap_pars_vertex,\n  envmap_physical_pars_fragment: envmap_physical_pars_fragment,\n  envmap_vertex: envmap_vertex,\n  fog_vertex: fog_vertex,\n  fog_pars_vertex: fog_pars_vertex,\n  fog_fragment: fog_fragment,\n  fog_pars_fragment: fog_pars_fragment,\n  gradientmap_pars_fragment: gradientmap_pars_fragment,\n  lightmap_fragment: lightmap_fragment,\n  lightmap_pars_fragment: lightmap_pars_fragment,\n  lights_lambert_vertex: lights_lambert_vertex,\n  lights_pars_begin: lights_pars_begin,\n  lights_toon_fragment: lights_toon_fragment,\n  lights_toon_pars_fragment: lights_toon_pars_fragment,\n  lights_phong_fragment: lights_phong_fragment,\n  lights_phong_pars_fragment: lights_phong_pars_fragment,\n  lights_physical_fragment: lights_physical_fragment,\n  lights_physical_pars_fragment: lights_physical_pars_fragment,\n  lights_fragment_begin: lights_fragment_begin,\n  lights_fragment_maps: lights_fragment_maps,\n  lights_fragment_end: lights_fragment_end,\n  logdepthbuf_fragment: logdepthbuf_fragment,\n  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n  logdepthbuf_vertex: logdepthbuf_vertex,\n  map_fragment: map_fragment,\n  map_pars_fragment: map_pars_fragment,\n  map_particle_fragment: map_particle_fragment,\n  map_particle_pars_fragment: map_particle_pars_fragment,\n  metalnessmap_fragment: metalnessmap_fragment,\n  metalnessmap_pars_fragment: metalnessmap_pars_fragment,\n  morphcolor_vertex: morphcolor_vertex,\n  morphnormal_vertex: morphnormal_vertex,\n  morphtarget_pars_vertex: morphtarget_pars_vertex,\n  morphtarget_vertex: morphtarget_vertex,\n  normal_fragment_begin: normal_fragment_begin,\n  normal_fragment_maps: normal_fragment_maps,\n  normal_pars_fragment: normal_pars_fragment,\n  normal_pars_vertex: normal_pars_vertex,\n  normal_vertex: normal_vertex,\n  normalmap_pars_fragment: normalmap_pars_fragment,\n  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n  clearcoat_pars_fragment: clearcoat_pars_fragment,\n  iridescence_pars_fragment: iridescence_pars_fragment,\n  output_fragment: output_fragment,\n  packing: packing,\n  premultiplied_alpha_fragment: premultiplied_alpha_fragment,\n  project_vertex: project_vertex,\n  dithering_fragment: dithering_fragment,\n  dithering_pars_fragment: dithering_pars_fragment,\n  roughnessmap_fragment: roughnessmap_fragment,\n  roughnessmap_pars_fragment: roughnessmap_pars_fragment,\n  shadowmap_pars_fragment: shadowmap_pars_fragment,\n  shadowmap_pars_vertex: shadowmap_pars_vertex,\n  shadowmap_vertex: shadowmap_vertex,\n  shadowmask_pars_fragment: shadowmask_pars_fragment,\n  skinbase_vertex: skinbase_vertex,\n  skinning_pars_vertex: skinning_pars_vertex,\n  skinning_vertex: skinning_vertex,\n  skinnormal_vertex: skinnormal_vertex,\n  specularmap_fragment: specularmap_fragment,\n  specularmap_pars_fragment: specularmap_pars_fragment,\n  tonemapping_fragment: tonemapping_fragment,\n  tonemapping_pars_fragment: tonemapping_pars_fragment,\n  transmission_fragment: transmission_fragment,\n  transmission_pars_fragment: transmission_pars_fragment,\n  uv_pars_fragment: uv_pars_fragment,\n  uv_pars_vertex: uv_pars_vertex,\n  uv_vertex: uv_vertex,\n  uv2_pars_fragment: uv2_pars_fragment,\n  uv2_pars_vertex: uv2_pars_vertex,\n  uv2_vertex: uv2_vertex,\n  worldpos_vertex: worldpos_vertex,\n  background_vert: vertex$g,\n  background_frag: fragment$g,\n  cube_vert: vertex$f,\n  cube_frag: fragment$f,\n  depth_vert: vertex$e,\n  depth_frag: fragment$e,\n  distanceRGBA_vert: vertex$d,\n  distanceRGBA_frag: fragment$d,\n  equirect_vert: vertex$c,\n  equirect_frag: fragment$c,\n  linedashed_vert: vertex$b,\n  linedashed_frag: fragment$b,\n  meshbasic_vert: vertex$a,\n  meshbasic_frag: fragment$a,\n  meshlambert_vert: vertex$9,\n  meshlambert_frag: fragment$9,\n  meshmatcap_vert: vertex$8,\n  meshmatcap_frag: fragment$8,\n  meshnormal_vert: vertex$7,\n  meshnormal_frag: fragment$7,\n  meshphong_vert: vertex$6,\n  meshphong_frag: fragment$6,\n  meshphysical_vert: vertex$5,\n  meshphysical_frag: fragment$5,\n  meshtoon_vert: vertex$4,\n  meshtoon_frag: fragment$4,\n  points_vert: vertex$3,\n  points_frag: fragment$3,\n  shadow_vert: vertex$2,\n  shadow_frag: fragment$2,\n  sprite_vert: vertex$1,\n  sprite_frag: fragment$1\n};\n/**\n * Uniforms library for shared webgl shaders\n */\n\nvar UniformsLib = {\n  common: {\n    diffuse: {\n      value: new Color(0xffffff)\n    },\n    opacity: {\n      value: 1.0\n    },\n    map: {\n      value: null\n    },\n    uvTransform: {\n      value: new Matrix3()\n    },\n    uv2Transform: {\n      value: new Matrix3()\n    },\n    alphaMap: {\n      value: null\n    },\n    alphaTest: {\n      value: 0\n    }\n  },\n  specularmap: {\n    specularMap: {\n      value: null\n    }\n  },\n  envmap: {\n    envMap: {\n      value: null\n    },\n    flipEnvMap: {\n      value: -1\n    },\n    reflectivity: {\n      value: 1.0\n    },\n    // basic, lambert, phong\n    ior: {\n      value: 1.5\n    },\n    // physical\n    refractionRatio: {\n      value: 0.98\n    } // basic, lambert, phong\n\n  },\n  aomap: {\n    aoMap: {\n      value: null\n    },\n    aoMapIntensity: {\n      value: 1\n    }\n  },\n  lightmap: {\n    lightMap: {\n      value: null\n    },\n    lightMapIntensity: {\n      value: 1\n    }\n  },\n  emissivemap: {\n    emissiveMap: {\n      value: null\n    }\n  },\n  bumpmap: {\n    bumpMap: {\n      value: null\n    },\n    bumpScale: {\n      value: 1\n    }\n  },\n  normalmap: {\n    normalMap: {\n      value: null\n    },\n    normalScale: {\n      value: new Vector2(1, 1)\n    }\n  },\n  displacementmap: {\n    displacementMap: {\n      value: null\n    },\n    displacementScale: {\n      value: 1\n    },\n    displacementBias: {\n      value: 0\n    }\n  },\n  roughnessmap: {\n    roughnessMap: {\n      value: null\n    }\n  },\n  metalnessmap: {\n    metalnessMap: {\n      value: null\n    }\n  },\n  gradientmap: {\n    gradientMap: {\n      value: null\n    }\n  },\n  fog: {\n    fogDensity: {\n      value: 0.00025\n    },\n    fogNear: {\n      value: 1\n    },\n    fogFar: {\n      value: 2000\n    },\n    fogColor: {\n      value: new Color(0xffffff)\n    }\n  },\n  lights: {\n    ambientLightColor: {\n      value: []\n    },\n    lightProbe: {\n      value: []\n    },\n    directionalLights: {\n      value: [],\n      properties: {\n        direction: {},\n        color: {}\n      }\n    },\n    directionalLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {}\n      }\n    },\n    directionalShadowMap: {\n      value: []\n    },\n    directionalShadowMatrix: {\n      value: []\n    },\n    spotLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        direction: {},\n        distance: {},\n        coneCos: {},\n        penumbraCos: {},\n        decay: {}\n      }\n    },\n    spotLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {}\n      }\n    },\n    spotShadowMap: {\n      value: []\n    },\n    spotShadowMatrix: {\n      value: []\n    },\n    pointLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        decay: {},\n        distance: {}\n      }\n    },\n    pointLightShadows: {\n      value: [],\n      properties: {\n        shadowBias: {},\n        shadowNormalBias: {},\n        shadowRadius: {},\n        shadowMapSize: {},\n        shadowCameraNear: {},\n        shadowCameraFar: {}\n      }\n    },\n    pointShadowMap: {\n      value: []\n    },\n    pointShadowMatrix: {\n      value: []\n    },\n    hemisphereLights: {\n      value: [],\n      properties: {\n        direction: {},\n        skyColor: {},\n        groundColor: {}\n      }\n    },\n    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n    rectAreaLights: {\n      value: [],\n      properties: {\n        color: {},\n        position: {},\n        width: {},\n        height: {}\n      }\n    },\n    ltc_1: {\n      value: null\n    },\n    ltc_2: {\n      value: null\n    }\n  },\n  points: {\n    diffuse: {\n      value: new Color(0xffffff)\n    },\n    opacity: {\n      value: 1.0\n    },\n    size: {\n      value: 1.0\n    },\n    scale: {\n      value: 1.0\n    },\n    map: {\n      value: null\n    },\n    alphaMap: {\n      value: null\n    },\n    alphaTest: {\n      value: 0\n    },\n    uvTransform: {\n      value: new Matrix3()\n    }\n  },\n  sprite: {\n    diffuse: {\n      value: new Color(0xffffff)\n    },\n    opacity: {\n      value: 1.0\n    },\n    center: {\n      value: new Vector2(0.5, 0.5)\n    },\n    rotation: {\n      value: 0.0\n    },\n    map: {\n      value: null\n    },\n    alphaMap: {\n      value: null\n    },\n    alphaTest: {\n      value: 0\n    },\n    uvTransform: {\n      value: new Matrix3()\n    }\n  }\n};\nvar ShaderLib = {\n  basic: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),\n    vertexShader: ShaderChunk.meshbasic_vert,\n    fragmentShader: ShaderChunk.meshbasic_frag\n  },\n  lambert: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {\n      emissive: {\n        value: new Color(0x000000)\n      }\n    }]),\n    vertexShader: ShaderChunk.meshlambert_vert,\n    fragmentShader: ShaderChunk.meshlambert_frag\n  },\n  phong: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {\n      emissive: {\n        value: new Color(0x000000)\n      },\n      specular: {\n        value: new Color(0x111111)\n      },\n      shininess: {\n        value: 30\n      }\n    }]),\n    vertexShader: ShaderChunk.meshphong_vert,\n    fragmentShader: ShaderChunk.meshphong_frag\n  },\n  standard: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {\n      emissive: {\n        value: new Color(0x000000)\n      },\n      roughness: {\n        value: 1.0\n      },\n      metalness: {\n        value: 0.0\n      },\n      envMapIntensity: {\n        value: 1\n      } // temporary\n\n    }]),\n    vertexShader: ShaderChunk.meshphysical_vert,\n    fragmentShader: ShaderChunk.meshphysical_frag\n  },\n  toon: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {\n      emissive: {\n        value: new Color(0x000000)\n      }\n    }]),\n    vertexShader: ShaderChunk.meshtoon_vert,\n    fragmentShader: ShaderChunk.meshtoon_frag\n  },\n  matcap: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {\n      matcap: {\n        value: null\n      }\n    }]),\n    vertexShader: ShaderChunk.meshmatcap_vert,\n    fragmentShader: ShaderChunk.meshmatcap_frag\n  },\n  points: {\n    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),\n    vertexShader: ShaderChunk.points_vert,\n    fragmentShader: ShaderChunk.points_frag\n  },\n  dashed: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {\n      scale: {\n        value: 1\n      },\n      dashSize: {\n        value: 1\n      },\n      totalSize: {\n        value: 2\n      }\n    }]),\n    vertexShader: ShaderChunk.linedashed_vert,\n    fragmentShader: ShaderChunk.linedashed_frag\n  },\n  depth: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),\n    vertexShader: ShaderChunk.depth_vert,\n    fragmentShader: ShaderChunk.depth_frag\n  },\n  normal: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {\n      opacity: {\n        value: 1.0\n      }\n    }]),\n    vertexShader: ShaderChunk.meshnormal_vert,\n    fragmentShader: ShaderChunk.meshnormal_frag\n  },\n  sprite: {\n    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),\n    vertexShader: ShaderChunk.sprite_vert,\n    fragmentShader: ShaderChunk.sprite_frag\n  },\n  background: {\n    uniforms: {\n      uvTransform: {\n        value: new Matrix3()\n      },\n      t2D: {\n        value: null\n      }\n    },\n    vertexShader: ShaderChunk.background_vert,\n    fragmentShader: ShaderChunk.background_frag\n  },\n\n  /* -------------------------------------------------------------------------\n  //\tCube map shader\n   ------------------------------------------------------------------------- */\n  cube: {\n    uniforms: mergeUniforms([UniformsLib.envmap, {\n      opacity: {\n        value: 1.0\n      }\n    }]),\n    vertexShader: ShaderChunk.cube_vert,\n    fragmentShader: ShaderChunk.cube_frag\n  },\n  equirect: {\n    uniforms: {\n      tEquirect: {\n        value: null\n      }\n    },\n    vertexShader: ShaderChunk.equirect_vert,\n    fragmentShader: ShaderChunk.equirect_frag\n  },\n  distanceRGBA: {\n    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {\n      referencePosition: {\n        value: new Vector3()\n      },\n      nearDistance: {\n        value: 1\n      },\n      farDistance: {\n        value: 1000\n      }\n    }]),\n    vertexShader: ShaderChunk.distanceRGBA_vert,\n    fragmentShader: ShaderChunk.distanceRGBA_frag\n  },\n  shadow: {\n    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {\n      color: {\n        value: new Color(0x00000)\n      },\n      opacity: {\n        value: 1.0\n      }\n    }]),\n    vertexShader: ShaderChunk.shadow_vert,\n    fragmentShader: ShaderChunk.shadow_frag\n  }\n};\nShaderLib.physical = {\n  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {\n    clearcoat: {\n      value: 0\n    },\n    clearcoatMap: {\n      value: null\n    },\n    clearcoatRoughness: {\n      value: 0\n    },\n    clearcoatRoughnessMap: {\n      value: null\n    },\n    clearcoatNormalScale: {\n      value: new Vector2(1, 1)\n    },\n    clearcoatNormalMap: {\n      value: null\n    },\n    iridescence: {\n      value: 0\n    },\n    iridescenceMap: {\n      value: null\n    },\n    iridescenceIOR: {\n      value: 1.3\n    },\n    iridescenceThicknessMinimum: {\n      value: 100\n    },\n    iridescenceThicknessMaximum: {\n      value: 400\n    },\n    iridescenceThicknessMap: {\n      value: null\n    },\n    sheen: {\n      value: 0\n    },\n    sheenColor: {\n      value: new Color(0x000000)\n    },\n    sheenColorMap: {\n      value: null\n    },\n    sheenRoughness: {\n      value: 1\n    },\n    sheenRoughnessMap: {\n      value: null\n    },\n    transmission: {\n      value: 0\n    },\n    transmissionMap: {\n      value: null\n    },\n    transmissionSamplerSize: {\n      value: new Vector2()\n    },\n    transmissionSamplerMap: {\n      value: null\n    },\n    thickness: {\n      value: 0\n    },\n    thicknessMap: {\n      value: null\n    },\n    attenuationDistance: {\n      value: 0\n    },\n    attenuationColor: {\n      value: new Color(0x000000)\n    },\n    specularIntensity: {\n      value: 1\n    },\n    specularIntensityMap: {\n      value: null\n    },\n    specularColor: {\n      value: new Color(1, 1, 1)\n    },\n    specularColorMap: {\n      value: null\n    }\n  }]),\n  vertexShader: ShaderChunk.meshphysical_vert,\n  fragmentShader: ShaderChunk.meshphysical_frag\n};\n\nfunction WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {\n  var clearColor = new Color(0x000000);\n  var clearAlpha = alpha === true ? 0 : 1;\n  var planeMesh;\n  var boxMesh;\n  var currentBackground = null;\n  var currentBackgroundVersion = 0;\n  var currentTonemapping = null;\n\n  function render(renderList, scene) {\n    var forceClear = false;\n    var background = scene.isScene === true ? scene.background : null;\n\n    if (background && background.isTexture) {\n      background = cubemaps.get(background);\n    } // Ignore background in AR\n    // TODO: Reconsider this.\n\n\n    var xr = renderer.xr;\n    var session = xr.getSession && xr.getSession();\n\n    if (session && session.environmentBlendMode === \'additive\') {\n      background = null;\n    }\n\n    if (background === null) {\n      setClear(clearColor, clearAlpha);\n    } else if (background && background.isColor) {\n      setClear(background, 1);\n      forceClear = true;\n    }\n\n    if (renderer.autoClear || forceClear) {\n      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n    }\n\n    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n      if (boxMesh === undefined) {\n        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({\n          name: \'BackgroundCubeMaterial\',\n          uniforms: cloneUniforms(ShaderLib.cube.uniforms),\n          vertexShader: ShaderLib.cube.vertexShader,\n          fragmentShader: ShaderLib.cube.fragmentShader,\n          side: BackSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        boxMesh.geometry.deleteAttribute(\'normal\');\n        boxMesh.geometry.deleteAttribute(\'uv\');\n\n        boxMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        }; // enable code injection for non-built-in material\n\n\n        Object.defineProperty(boxMesh.material, \'envMap\', {\n          get: function get() {\n            return this.uniforms.envMap.value;\n          }\n        });\n        objects.update(boxMesh);\n      }\n\n      boxMesh.material.uniforms.envMap.value = background;\n      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;\n\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        boxMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n\n      boxMesh.layers.enableAll(); // push to the pre-sorted opaque render list\n\n      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n    } else if (background && background.isTexture) {\n      if (planeMesh === undefined) {\n        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({\n          name: \'BackgroundMaterial\',\n          uniforms: cloneUniforms(ShaderLib.background.uniforms),\n          vertexShader: ShaderLib.background.vertexShader,\n          fragmentShader: ShaderLib.background.fragmentShader,\n          side: FrontSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        planeMesh.geometry.deleteAttribute(\'normal\'); // enable code injection for non-built-in material\n\n        Object.defineProperty(planeMesh.material, \'map\', {\n          get: function get() {\n            return this.uniforms.t2D.value;\n          }\n        });\n        objects.update(planeMesh);\n      }\n\n      planeMesh.material.uniforms.t2D.value = background;\n\n      if (background.matrixAutoUpdate === true) {\n        background.updateMatrix();\n      }\n\n      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        planeMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n\n      planeMesh.layers.enableAll(); // push to the pre-sorted opaque render list\n\n      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n    }\n  }\n\n  function setClear(color, alpha) {\n    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);\n  }\n\n  return {\n    getClearColor: function getClearColor() {\n      return clearColor;\n    },\n    setClearColor: function setClearColor(color) {\n      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      clearColor.set(color);\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    getClearAlpha: function getClearAlpha() {\n      return clearAlpha;\n    },\n    setClearAlpha: function setClearAlpha(alpha) {\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    render: render\n  };\n}\n\nfunction WebGLBindingStates(gl, extensions, attributes, capabilities) {\n  var maxVertexAttributes = gl.getParameter(34921);\n  var extension = capabilities.isWebGL2 ? null : extensions.get(\'OES_vertex_array_object\');\n  var vaoAvailable = capabilities.isWebGL2 || extension !== null;\n  var bindingStates = {};\n  var defaultState = createBindingState(null);\n  var currentState = defaultState;\n  var forceUpdate = false;\n\n  function setup(object, material, program, geometry, index) {\n    var updateBuffers = false;\n\n    if (vaoAvailable) {\n      var state = getBindingState(geometry, program, material);\n\n      if (currentState !== state) {\n        currentState = state;\n        bindVertexArrayObject(currentState.object);\n      }\n\n      updateBuffers = needsUpdate(object, geometry, program, index);\n      if (updateBuffers) saveCache(object, geometry, program, index);\n    } else {\n      var wireframe = material.wireframe === true;\n\n      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n        currentState.geometry = geometry.id;\n        currentState.program = program.id;\n        currentState.wireframe = wireframe;\n        updateBuffers = true;\n      }\n    }\n\n    if (index !== null) {\n      attributes.update(index, 34963);\n    }\n\n    if (updateBuffers || forceUpdate) {\n      forceUpdate = false;\n      setupVertexAttributes(object, material, program, geometry);\n\n      if (index !== null) {\n        gl.bindBuffer(34963, attributes.get(index).buffer);\n      }\n    }\n  }\n\n  function createVertexArrayObject() {\n    if (capabilities.isWebGL2) return gl.createVertexArray();\n    return extension.createVertexArrayOES();\n  }\n\n  function bindVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n    return extension.bindVertexArrayOES(vao);\n  }\n\n  function deleteVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n    return extension.deleteVertexArrayOES(vao);\n  }\n\n  function getBindingState(geometry, program, material) {\n    var wireframe = material.wireframe === true;\n    var programMap = bindingStates[geometry.id];\n\n    if (programMap === undefined) {\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n    }\n\n    var stateMap = programMap[program.id];\n\n    if (stateMap === undefined) {\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n\n    var state = stateMap[wireframe];\n\n    if (state === undefined) {\n      state = createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = state;\n    }\n\n    return state;\n  }\n\n  function createBindingState(vao) {\n    var newAttributes = [];\n    var enabledAttributes = [];\n    var attributeDivisors = [];\n\n    for (var _i72 = 0; _i72 < maxVertexAttributes; _i72++) {\n      newAttributes[_i72] = 0;\n      enabledAttributes[_i72] = 0;\n      attributeDivisors[_i72] = 0;\n    }\n\n    return {\n      // for backward compatibility on non-VAO support browser\n      geometry: null,\n      program: null,\n      wireframe: false,\n      newAttributes: newAttributes,\n      enabledAttributes: enabledAttributes,\n      attributeDivisors: attributeDivisors,\n      object: vao,\n      attributes: {},\n      index: null\n    };\n  }\n\n  function needsUpdate(object, geometry, program, index) {\n    var cachedAttributes = currentState.attributes;\n    var geometryAttributes = geometry.attributes;\n    var attributesNum = 0;\n    var programAttributes = program.getAttributes();\n\n    for (var name in programAttributes) {\n      var programAttribute = programAttributes[name];\n\n      if (programAttribute.location >= 0) {\n        var cachedAttribute = cachedAttributes[name];\n        var geometryAttribute = geometryAttributes[name];\n\n        if (geometryAttribute === undefined) {\n          if (name === \'instanceMatrix\' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;\n          if (name === \'instanceColor\' && object.instanceColor) geometryAttribute = object.instanceColor;\n        }\n\n        if (cachedAttribute === undefined) return true;\n        if (cachedAttribute.attribute !== geometryAttribute) return true;\n        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;\n        attributesNum++;\n      }\n    }\n\n    if (currentState.attributesNum !== attributesNum) return true;\n    if (currentState.index !== index) return true;\n    return false;\n  }\n\n  function saveCache(object, geometry, program, index) {\n    var cache = {};\n    var attributes = geometry.attributes;\n    var attributesNum = 0;\n    var programAttributes = program.getAttributes();\n\n    for (var name in programAttributes) {\n      var programAttribute = programAttributes[name];\n\n      if (programAttribute.location >= 0) {\n        var attribute = attributes[name];\n\n        if (attribute === undefined) {\n          if (name === \'instanceMatrix\' && object.instanceMatrix) attribute = object.instanceMatrix;\n          if (name === \'instanceColor\' && object.instanceColor) attribute = object.instanceColor;\n        }\n\n        var data = {};\n        data.attribute = attribute;\n\n        if (attribute && attribute.data) {\n          data.data = attribute.data;\n        }\n\n        cache[name] = data;\n        attributesNum++;\n      }\n    }\n\n    currentState.attributes = cache;\n    currentState.attributesNum = attributesNum;\n    currentState.index = index;\n  }\n\n  function initAttributes() {\n    var newAttributes = currentState.newAttributes;\n\n    for (var _i73 = 0, il = newAttributes.length; _i73 < il; _i73++) {\n      newAttributes[_i73] = 0;\n    }\n  }\n\n  function enableAttribute(attribute) {\n    enableAttributeAndDivisor(attribute, 0);\n  }\n\n  function enableAttributeAndDivisor(attribute, meshPerAttribute) {\n    var newAttributes = currentState.newAttributes;\n    var enabledAttributes = currentState.enabledAttributes;\n    var attributeDivisors = currentState.attributeDivisors;\n    newAttributes[attribute] = 1;\n\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n\n    if (attributeDivisors[attribute] !== meshPerAttribute) {\n      var _extension = capabilities.isWebGL2 ? gl : extensions.get(\'ANGLE_instanced_arrays\');\n\n      _extension[capabilities.isWebGL2 ? \'vertexAttribDivisor\' : \'vertexAttribDivisorANGLE\'](attribute, meshPerAttribute);\n\n      attributeDivisors[attribute] = meshPerAttribute;\n    }\n  }\n\n  function disableUnusedAttributes() {\n    var newAttributes = currentState.newAttributes;\n    var enabledAttributes = currentState.enabledAttributes;\n\n    for (var _i74 = 0, il = enabledAttributes.length; _i74 < il; _i74++) {\n      if (enabledAttributes[_i74] !== newAttributes[_i74]) {\n        gl.disableVertexAttribArray(_i74);\n        enabledAttributes[_i74] = 0;\n      }\n    }\n  }\n\n  function vertexAttribPointer(index, size, type, normalized, stride, offset) {\n    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {\n      gl.vertexAttribIPointer(index, size, type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n    }\n  }\n\n  function setupVertexAttributes(object, material, program, geometry) {\n    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n      if (extensions.get(\'ANGLE_instanced_arrays\') === null) return;\n    }\n\n    initAttributes();\n    var geometryAttributes = geometry.attributes;\n    var programAttributes = program.getAttributes();\n    var materialDefaultAttributeValues = material.defaultAttributeValues;\n\n    for (var name in programAttributes) {\n      var programAttribute = programAttributes[name];\n\n      if (programAttribute.location >= 0) {\n        var geometryAttribute = geometryAttributes[name];\n\n        if (geometryAttribute === undefined) {\n          if (name === \'instanceMatrix\' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;\n          if (name === \'instanceColor\' && object.instanceColor) geometryAttribute = object.instanceColor;\n        }\n\n        if (geometryAttribute !== undefined) {\n          var normalized = geometryAttribute.normalized;\n          var size = geometryAttribute.itemSize;\n          var attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore\n\n          if (attribute === undefined) continue;\n          var buffer = attribute.buffer;\n          var type = attribute.type;\n          var bytesPerElement = attribute.bytesPerElement;\n\n          if (geometryAttribute.isInterleavedBufferAttribute) {\n            var data = geometryAttribute.data;\n            var stride = data.stride;\n            var offset = geometryAttribute.offset;\n\n            if (data.isInstancedInterleavedBuffer) {\n              for (var _i75 = 0; _i75 < programAttribute.locationSize; _i75++) {\n                enableAttributeAndDivisor(programAttribute.location + _i75, data.meshPerAttribute);\n              }\n\n              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = data.meshPerAttribute * data.count;\n              }\n            } else {\n              for (var _i76 = 0; _i76 < programAttribute.locationSize; _i76++) {\n                enableAttribute(programAttribute.location + _i76);\n              }\n            }\n\n            gl.bindBuffer(34962, buffer);\n\n            for (var _i77 = 0; _i77 < programAttribute.locationSize; _i77++) {\n              vertexAttribPointer(programAttribute.location + _i77, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * _i77) * bytesPerElement);\n            }\n          } else {\n            if (geometryAttribute.isInstancedBufferAttribute) {\n              for (var _i78 = 0; _i78 < programAttribute.locationSize; _i78++) {\n                enableAttributeAndDivisor(programAttribute.location + _i78, geometryAttribute.meshPerAttribute);\n              }\n\n              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            } else {\n              for (var _i79 = 0; _i79 < programAttribute.locationSize; _i79++) {\n                enableAttribute(programAttribute.location + _i79);\n              }\n            }\n\n            gl.bindBuffer(34962, buffer);\n\n            for (var _i80 = 0; _i80 < programAttribute.locationSize; _i80++) {\n              vertexAttribPointer(programAttribute.location + _i80, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * _i80 * bytesPerElement);\n            }\n          }\n        } else if (materialDefaultAttributeValues !== undefined) {\n          var _value2 = materialDefaultAttributeValues[name];\n\n          if (_value2 !== undefined) {\n            switch (_value2.length) {\n              case 2:\n                gl.vertexAttrib2fv(programAttribute.location, _value2);\n                break;\n\n              case 3:\n                gl.vertexAttrib3fv(programAttribute.location, _value2);\n                break;\n\n              case 4:\n                gl.vertexAttrib4fv(programAttribute.location, _value2);\n                break;\n\n              default:\n                gl.vertexAttrib1fv(programAttribute.location, _value2);\n            }\n          }\n        }\n      }\n    }\n\n    disableUnusedAttributes();\n  }\n\n  function dispose() {\n    reset();\n\n    for (var geometryId in bindingStates) {\n      var programMap = bindingStates[geometryId];\n\n      for (var programId in programMap) {\n        var stateMap = programMap[programId];\n\n        for (var wireframe in stateMap) {\n          deleteVertexArrayObject(stateMap[wireframe].object);\n          delete stateMap[wireframe];\n        }\n\n        delete programMap[programId];\n      }\n\n      delete bindingStates[geometryId];\n    }\n  }\n\n  function releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === undefined) return;\n    var programMap = bindingStates[geometry.id];\n\n    for (var programId in programMap) {\n      var stateMap = programMap[programId];\n\n      for (var wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[programId];\n    }\n\n    delete bindingStates[geometry.id];\n  }\n\n  function releaseStatesOfProgram(program) {\n    for (var geometryId in bindingStates) {\n      var programMap = bindingStates[geometryId];\n      if (programMap[program.id] === undefined) continue;\n      var stateMap = programMap[program.id];\n\n      for (var wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[program.id];\n    }\n  }\n\n  function reset() {\n    resetDefaultState();\n    forceUpdate = true;\n    if (currentState === defaultState) return;\n    currentState = defaultState;\n    bindVertexArrayObject(currentState.object);\n  } // for backward-compatibility\n\n\n  function resetDefaultState() {\n    defaultState.geometry = null;\n    defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n\n  return {\n    setup: setup,\n    reset: reset,\n    resetDefaultState: resetDefaultState,\n    dispose: dispose,\n    releaseStatesOfGeometry: releaseStatesOfGeometry,\n    releaseStatesOfProgram: releaseStatesOfProgram,\n    initAttributes: initAttributes,\n    enableAttribute: enableAttribute,\n    disableUnusedAttributes: disableUnusedAttributes\n  };\n}\n\nfunction WebGLBufferRenderer(gl, extensions, info, capabilities) {\n  var isWebGL2 = capabilities.isWebGL2;\n  var mode;\n\n  function setMode(value) {\n    mode = value;\n  }\n\n  function render(start, count) {\n    gl.drawArrays(mode, start, count);\n    info.update(count, mode, 1);\n  }\n\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0) return;\n    var extension, methodName;\n\n    if (isWebGL2) {\n      extension = gl;\n      methodName = \'drawArraysInstanced\';\n    } else {\n      extension = extensions.get(\'ANGLE_instanced_arrays\');\n      methodName = \'drawArraysInstancedANGLE\';\n\n      if (extension === null) {\n        console.error(\'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\');\n        return;\n      }\n    }\n\n    extension[methodName](mode, start, count, primcount);\n    info.update(count, mode, primcount);\n  } //\n\n\n  this.setMode = setMode;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}\n\nfunction WebGLCapabilities(gl, extensions, parameters) {\n  var maxAnisotropy;\n\n  function getMaxAnisotropy() {\n    if (maxAnisotropy !== undefined) return maxAnisotropy;\n\n    if (extensions.has(\'EXT_texture_filter_anisotropic\') === true) {\n      var extension = extensions.get(\'EXT_texture_filter_anisotropic\');\n      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      maxAnisotropy = 0;\n    }\n\n    return maxAnisotropy;\n  }\n\n  function getMaxPrecision(precision) {\n    if (precision === \'highp\') {\n      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {\n        return \'highp\';\n      }\n\n      precision = \'mediump\';\n    }\n\n    if (precision === \'mediump\') {\n      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {\n        return \'mediump\';\n      }\n    }\n\n    return \'lowp\';\n  }\n\n  var isWebGL2 = typeof WebGL2RenderingContext !== \'undefined\' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== \'undefined\' && gl instanceof WebGL2ComputeRenderingContext;\n  var precision = parameters.precision !== undefined ? parameters.precision : \'highp\';\n  var maxPrecision = getMaxPrecision(precision);\n\n  if (maxPrecision !== precision) {\n    console.warn(\'THREE.WebGLRenderer:\', precision, \'not supported, using\', maxPrecision, \'instead.\');\n    precision = maxPrecision;\n  }\n\n  var drawBuffers = isWebGL2 || extensions.has(\'WEBGL_draw_buffers\');\n  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n  var maxTextures = gl.getParameter(34930);\n  var maxVertexTextures = gl.getParameter(35660);\n  var maxTextureSize = gl.getParameter(3379);\n  var maxCubemapSize = gl.getParameter(34076);\n  var maxAttributes = gl.getParameter(34921);\n  var maxVertexUniforms = gl.getParameter(36347);\n  var maxVaryings = gl.getParameter(36348);\n  var maxFragmentUniforms = gl.getParameter(36349);\n  var vertexTextures = maxVertexTextures > 0;\n  var floatFragmentTextures = isWebGL2 || extensions.has(\'OES_texture_float\');\n  var floatVertexTextures = vertexTextures && floatFragmentTextures;\n  var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;\n  return {\n    isWebGL2: isWebGL2,\n    drawBuffers: drawBuffers,\n    getMaxAnisotropy: getMaxAnisotropy,\n    getMaxPrecision: getMaxPrecision,\n    precision: precision,\n    logarithmicDepthBuffer: logarithmicDepthBuffer,\n    maxTextures: maxTextures,\n    maxVertexTextures: maxVertexTextures,\n    maxTextureSize: maxTextureSize,\n    maxCubemapSize: maxCubemapSize,\n    maxAttributes: maxAttributes,\n    maxVertexUniforms: maxVertexUniforms,\n    maxVaryings: maxVaryings,\n    maxFragmentUniforms: maxFragmentUniforms,\n    vertexTextures: vertexTextures,\n    floatFragmentTextures: floatFragmentTextures,\n    floatVertexTextures: floatVertexTextures,\n    maxSamples: maxSamples\n  };\n}\n\nfunction WebGLClipping(properties) {\n  var scope = this;\n  var globalState = null,\n      numGlobalPlanes = 0,\n      localClippingEnabled = false,\n      renderingShadows = false;\n  var plane = new Plane(),\n      viewNormalMatrix = new Matrix3(),\n      uniform = {\n    value: null,\n    needsUpdate: false\n  };\n  this.uniform = uniform;\n  this.numPlanes = 0;\n  this.numIntersection = 0;\n\n  this.init = function (planes, enableLocalClipping, camera) {\n    var enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to\n    // run another frame in order to reset the state:\n    numGlobalPlanes !== 0 || localClippingEnabled;\n    localClippingEnabled = enableLocalClipping;\n    globalState = projectPlanes(planes, camera, 0);\n    numGlobalPlanes = planes.length;\n    return enabled;\n  };\n\n  this.beginShadows = function () {\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n\n  this.endShadows = function () {\n    renderingShadows = false;\n    resetGlobalState();\n  };\n\n  this.setState = function (material, camera, useCache) {\n    var planes = material.clippingPlanes,\n        clipIntersection = material.clipIntersection,\n        clipShadows = material.clipShadows;\n    var materialProperties = properties.get(material);\n\n    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n      // there\'s no local clipping\n      if (renderingShadows) {\n        // there\'s no global clipping\n        projectPlanes(null);\n      } else {\n        resetGlobalState();\n      }\n    } else {\n      var nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n          lGlobal = nGlobal * 4;\n      var dstArray = materialProperties.clippingState || null;\n      uniform.value = dstArray; // ensure unique state\n\n      dstArray = projectPlanes(planes, camera, lGlobal, useCache);\n\n      for (var _i81 = 0; _i81 !== lGlobal; ++_i81) {\n        dstArray[_i81] = globalState[_i81];\n      }\n\n      materialProperties.clippingState = dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : 0;\n      this.numPlanes += nGlobal;\n    }\n  };\n\n  function resetGlobalState() {\n    if (uniform.value !== globalState) {\n      uniform.value = globalState;\n      uniform.needsUpdate = numGlobalPlanes > 0;\n    }\n\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection = 0;\n  }\n\n  function projectPlanes(planes, camera, dstOffset, skipTransform) {\n    var nPlanes = planes !== null ? planes.length : 0;\n    var dstArray = null;\n\n    if (nPlanes !== 0) {\n      dstArray = uniform.value;\n\n      if (skipTransform !== true || dstArray === null) {\n        var flatSize = dstOffset + nPlanes * 4,\n            viewMatrix = camera.matrixWorldInverse;\n        viewNormalMatrix.getNormalMatrix(viewMatrix);\n\n        if (dstArray === null || dstArray.length < flatSize) {\n          dstArray = new Float32Array(flatSize);\n        }\n\n        for (var _i82 = 0, i4 = dstOffset; _i82 !== nPlanes; ++_i82, i4 += 4) {\n          plane.copy(planes[_i82]).applyMatrix4(viewMatrix, viewNormalMatrix);\n          plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = plane.constant;\n        }\n      }\n\n      uniform.value = dstArray;\n      uniform.needsUpdate = true;\n    }\n\n    scope.numPlanes = nPlanes;\n    scope.numIntersection = 0;\n    return dstArray;\n  }\n}\n\nfunction WebGLCubeMaps(renderer) {\n  var cubemaps = new WeakMap();\n\n  function mapTextureMapping(texture, mapping) {\n    if (mapping === EquirectangularReflectionMapping) {\n      texture.mapping = CubeReflectionMapping;\n    } else if (mapping === EquirectangularRefractionMapping) {\n      texture.mapping = CubeRefractionMapping;\n    }\n\n    return texture;\n  }\n\n  function get(texture) {\n    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {\n      var mapping = texture.mapping;\n\n      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n        if (cubemaps.has(texture)) {\n          var cubemap = cubemaps.get(texture).texture;\n          return mapTextureMapping(cubemap, texture.mapping);\n        } else {\n          var image = texture.image;\n\n          if (image && image.height > 0) {\n            var renderTarget = new WebGLCubeRenderTarget(image.height / 2);\n            renderTarget.fromEquirectangularTexture(renderer, texture);\n            cubemaps.set(texture, renderTarget);\n            texture.addEventListener(\'dispose\', onTextureDispose);\n            return mapTextureMapping(renderTarget.texture, texture.mapping);\n          } else {\n            // image not yet ready. try the conversion next frame\n            return null;\n          }\n        }\n      }\n    }\n\n    return texture;\n  }\n\n  function onTextureDispose(event) {\n    var texture = event.target;\n    texture.removeEventListener(\'dispose\', onTextureDispose);\n    var cubemap = cubemaps.get(texture);\n\n    if (cubemap !== undefined) {\n      cubemaps.delete(texture);\n      cubemap.dispose();\n    }\n  }\n\n  function dispose() {\n    cubemaps = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nvar OrthographicCamera = /*#__PURE__*/function (_Camera2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(OrthographicCamera, _Camera2);\n\n  var _super31 = _createSuper(OrthographicCamera);\n\n  function OrthographicCamera() {\n    var _this23;\n\n    var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    var right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var bottom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n    var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;\n    var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2000;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, OrthographicCamera);\n\n    _this23 = _super31.call(this);\n    _this23.isOrthographicCamera = true;\n    _this23.type = \'OrthographicCamera\';\n    _this23.zoom = 1;\n    _this23.view = null;\n    _this23.left = left;\n    _this23.right = right;\n    _this23.top = top;\n    _this23.bottom = bottom;\n    _this23.near = near;\n    _this23.far = far;\n\n    _this23.updateProjectionMatrix();\n\n    return _this23;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(OrthographicCamera, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(OrthographicCamera.prototype), "copy", this).call(this, source, recursive);\n\n      this.left = source.left;\n      this.right = source.right;\n      this.top = source.top;\n      this.bottom = source.bottom;\n      this.near = source.near;\n      this.far = source.far;\n      this.zoom = source.zoom;\n      this.view = source.view === null ? null : Object.assign({}, source.view);\n      return this;\n    }\n  }, {\n    key: "setViewOffset",\n    value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n      if (this.view === null) {\n        this.view = {\n          enabled: true,\n          fullWidth: 1,\n          fullHeight: 1,\n          offsetX: 0,\n          offsetY: 0,\n          width: 1,\n          height: 1\n        };\n      }\n\n      this.view.enabled = true;\n      this.view.fullWidth = fullWidth;\n      this.view.fullHeight = fullHeight;\n      this.view.offsetX = x;\n      this.view.offsetY = y;\n      this.view.width = width;\n      this.view.height = height;\n      this.updateProjectionMatrix();\n    }\n  }, {\n    key: "clearViewOffset",\n    value: function clearViewOffset() {\n      if (this.view !== null) {\n        this.view.enabled = false;\n      }\n\n      this.updateProjectionMatrix();\n    }\n  }, {\n    key: "updateProjectionMatrix",\n    value: function updateProjectionMatrix() {\n      var dx = (this.right - this.left) / (2 * this.zoom);\n      var dy = (this.top - this.bottom) / (2 * this.zoom);\n      var cx = (this.right + this.left) / 2;\n      var cy = (this.top + this.bottom) / 2;\n      var left = cx - dx;\n      var right = cx + dx;\n      var top = cy + dy;\n      var bottom = cy - dy;\n\n      if (this.view !== null && this.view.enabled) {\n        var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n        var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n        left += scaleW * this.view.offsetX;\n        right = left + scaleW * this.view.width;\n        top -= scaleH * this.view.offsetY;\n        bottom = top - scaleH * this.view.height;\n      }\n\n      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(OrthographicCamera.prototype), "toJSON", this).call(this, meta);\n\n      data.object.zoom = this.zoom;\n      data.object.left = this.left;\n      data.object.right = this.right;\n      data.object.top = this.top;\n      data.object.bottom = this.bottom;\n      data.object.near = this.near;\n      data.object.far = this.far;\n      if (this.view !== null) data.object.view = Object.assign({}, this.view);\n      return data;\n    }\n  }]);\n\n  return OrthographicCamera;\n}(Camera);\n\nvar LOD_MIN = 4; // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nvar EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582]; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nvar MAX_SAMPLES = 20;\n\nvar _flatCamera = /*@__PURE__*/new OrthographicCamera();\n\nvar _clearColor = /*@__PURE__*/new Color();\n\nvar _oldTarget = null; // Golden Ratio\n\nvar PHI = (1 + Math.sqrt(5)) / 2;\nvar INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nvar _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered \'mips\' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nvar PMREMGenerator = /*#__PURE__*/function () {\n  function PMREMGenerator(renderer) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PMREMGenerator);\n\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PMREMGenerator, [{\n    key: "fromScene",\n    value: function fromScene(scene) {\n      var sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n      var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;\n      _oldTarget = this._renderer.getRenderTarget();\n\n      this._setSize(256);\n\n      var cubeUVRenderTarget = this._allocateTargets();\n\n      cubeUVRenderTarget.depthBuffer = true;\n\n      this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n      if (sigma > 0) {\n        this._blur(cubeUVRenderTarget, 0, 0, sigma);\n      }\n\n      this._applyPMREM(cubeUVRenderTarget);\n\n      this._cleanup(cubeUVRenderTarget);\n\n      return cubeUVRenderTarget;\n    }\n    /**\n     * Generates a PMREM from an equirectangular texture, which can be either LDR\n     * or HDR. The ideal input image size is 1k (1024 x 512),\n     * as this matches best with the 256 x 256 cubemap output.\n     */\n\n  }, {\n    key: "fromEquirectangular",\n    value: function fromEquirectangular(equirectangular) {\n      var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return this._fromTexture(equirectangular, renderTarget);\n    }\n    /**\n     * Generates a PMREM from an cubemap texture, which can be either LDR\n     * or HDR. The ideal input cube size is 256 x 256,\n     * as this matches best with the 256 x 256 cubemap output.\n     */\n\n  }, {\n    key: "fromCubemap",\n    value: function fromCubemap(cubemap) {\n      var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return this._fromTexture(cubemap, renderTarget);\n    }\n    /**\n     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n     * your texture\'s network fetch for increased concurrency.\n     */\n\n  }, {\n    key: "compileCubemapShader",\n    value: function compileCubemapShader() {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial();\n\n        this._compileMaterial(this._cubemapMaterial);\n      }\n    }\n    /**\n     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n     * your texture\'s network fetch for increased concurrency.\n     */\n\n  }, {\n    key: "compileEquirectangularShader",\n    value: function compileEquirectangularShader() {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial();\n\n        this._compileMaterial(this._equirectMaterial);\n      }\n    }\n    /**\n     * Disposes of the PMREMGenerator\'s internal memory. Note that PMREMGenerator is a static class,\n     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n     * one of them will cause any others to also become unusable.\n     */\n\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this._dispose();\n\n      if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n      if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n    } // private interface\n\n  }, {\n    key: "_setSize",\n    value: function _setSize(cubeSize) {\n      this._lodMax = Math.floor(Math.log2(cubeSize));\n      this._cubeSize = Math.pow(2, this._lodMax);\n    }\n  }, {\n    key: "_dispose",\n    value: function _dispose() {\n      if (this._blurMaterial !== null) this._blurMaterial.dispose();\n      if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n\n      for (var _i83 = 0; _i83 < this._lodPlanes.length; _i83++) {\n        this._lodPlanes[_i83].dispose();\n      }\n    }\n  }, {\n    key: "_cleanup",\n    value: function _cleanup(outputTarget) {\n      this._renderer.setRenderTarget(_oldTarget);\n\n      outputTarget.scissorTest = false;\n\n      _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n    }\n  }, {\n    key: "_fromTexture",\n    value: function _fromTexture(texture, renderTarget) {\n      if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {\n        this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n      } else {\n        // Equirectangular\n        this._setSize(texture.image.width / 4);\n      }\n\n      _oldTarget = this._renderer.getRenderTarget();\n\n      var cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n      this._textureToCubeUV(texture, cubeUVRenderTarget);\n\n      this._applyPMREM(cubeUVRenderTarget);\n\n      this._cleanup(cubeUVRenderTarget);\n\n      return cubeUVRenderTarget;\n    }\n  }, {\n    key: "_allocateTargets",\n    value: function _allocateTargets() {\n      var width = 3 * Math.max(this._cubeSize, 16 * 7);\n      var height = 4 * this._cubeSize;\n      var params = {\n        magFilter: LinearFilter,\n        minFilter: LinearFilter,\n        generateMipmaps: false,\n        type: HalfFloatType,\n        format: RGBAFormat,\n        encoding: LinearEncoding,\n        depthBuffer: false\n      };\n\n      var cubeUVRenderTarget = _createRenderTarget(width, height, params);\n\n      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {\n        if (this._pingPongRenderTarget !== null) {\n          this._dispose();\n        }\n\n        this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n        var _lodMax = this._lodMax;\n\n        var _createPlanes2 = _createPlanes(_lodMax);\n\n        this._sizeLods = _createPlanes2.sizeLods;\n        this._lodPlanes = _createPlanes2.lodPlanes;\n        this._sigmas = _createPlanes2.sigmas;\n        this._blurMaterial = _getBlurShader(_lodMax, width, height);\n      }\n\n      return cubeUVRenderTarget;\n    }\n  }, {\n    key: "_compileMaterial",\n    value: function _compileMaterial(material) {\n      var tmpMesh = new Mesh(this._lodPlanes[0], material);\n\n      this._renderer.compile(tmpMesh, _flatCamera);\n    }\n  }, {\n    key: "_sceneToCubeUV",\n    value: function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n      var fov = 90;\n      var aspect = 1;\n      var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n      var upSign = [1, -1, 1, 1, 1, 1];\n      var forwardSign = [1, 1, 1, -1, -1, -1];\n      var renderer = this._renderer;\n      var originalAutoClear = renderer.autoClear;\n      var toneMapping = renderer.toneMapping;\n      renderer.getClearColor(_clearColor);\n      renderer.toneMapping = NoToneMapping;\n      renderer.autoClear = false;\n      var backgroundMaterial = new MeshBasicMaterial({\n        name: \'PMREM.Background\',\n        side: BackSide,\n        depthWrite: false,\n        depthTest: false\n      });\n      var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n      var useSolidColor = false;\n      var background = scene.background;\n\n      if (background) {\n        if (background.isColor) {\n          backgroundMaterial.color.copy(background);\n          scene.background = null;\n          useSolidColor = true;\n        }\n      } else {\n        backgroundMaterial.color.copy(_clearColor);\n        useSolidColor = true;\n      }\n\n      for (var _i84 = 0; _i84 < 6; _i84++) {\n        var col = _i84 % 3;\n\n        if (col === 0) {\n          cubeCamera.up.set(0, upSign[_i84], 0);\n          cubeCamera.lookAt(forwardSign[_i84], 0, 0);\n        } else if (col === 1) {\n          cubeCamera.up.set(0, 0, upSign[_i84]);\n          cubeCamera.lookAt(0, forwardSign[_i84], 0);\n        } else {\n          cubeCamera.up.set(0, upSign[_i84], 0);\n          cubeCamera.lookAt(0, 0, forwardSign[_i84]);\n        }\n\n        var size = this._cubeSize;\n\n        _setViewport(cubeUVRenderTarget, col * size, _i84 > 2 ? size : 0, size, size);\n\n        renderer.setRenderTarget(cubeUVRenderTarget);\n\n        if (useSolidColor) {\n          renderer.render(backgroundBox, cubeCamera);\n        }\n\n        renderer.render(scene, cubeCamera);\n      }\n\n      backgroundBox.geometry.dispose();\n      backgroundBox.material.dispose();\n      renderer.toneMapping = toneMapping;\n      renderer.autoClear = originalAutoClear;\n      scene.background = background;\n    }\n  }, {\n    key: "_textureToCubeUV",\n    value: function _textureToCubeUV(texture, cubeUVRenderTarget) {\n      var renderer = this._renderer;\n      var isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;\n\n      if (isCubeTexture) {\n        if (this._cubemapMaterial === null) {\n          this._cubemapMaterial = _getCubemapMaterial();\n        }\n\n        this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;\n      } else {\n        if (this._equirectMaterial === null) {\n          this._equirectMaterial = _getEquirectMaterial();\n        }\n      }\n\n      var material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n      var mesh = new Mesh(this._lodPlanes[0], material);\n      var uniforms = material.uniforms;\n      uniforms[\'envMap\'].value = texture;\n      var size = this._cubeSize;\n\n      _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n      renderer.render(mesh, _flatCamera);\n    }\n  }, {\n    key: "_applyPMREM",\n    value: function _applyPMREM(cubeUVRenderTarget) {\n      var renderer = this._renderer;\n      var autoClear = renderer.autoClear;\n      renderer.autoClear = false;\n\n      for (var _i85 = 1; _i85 < this._lodPlanes.length; _i85++) {\n        var sigma = Math.sqrt(this._sigmas[_i85] * this._sigmas[_i85] - this._sigmas[_i85 - 1] * this._sigmas[_i85 - 1]);\n        var poleAxis = _axisDirections[(_i85 - 1) % _axisDirections.length];\n\n        this._blur(cubeUVRenderTarget, _i85 - 1, _i85, sigma, poleAxis);\n      }\n\n      renderer.autoClear = autoClear;\n    }\n    /**\n     * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n     * vertically and horizontally, but this breaks down on a cube. Here we apply\n     * the blur latitudinally (around the poles), and then longitudinally (towards\n     * the poles) to approximate the orthogonally-separable blur. It is least\n     * accurate at the poles, but still does a decent job.\n     */\n\n  }, {\n    key: "_blur",\n    value: function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n      var pingPongRenderTarget = this._pingPongRenderTarget;\n\n      this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, \'latitudinal\', poleAxis);\n\n      this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, \'longitudinal\', poleAxis);\n    }\n  }, {\n    key: "_halfBlur",\n    value: function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n      var renderer = this._renderer;\n      var blurMaterial = this._blurMaterial;\n\n      if (direction !== \'latitudinal\' && direction !== \'longitudinal\') {\n        console.error(\'blur direction must be either latitudinal or longitudinal!\');\n      } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n      var STANDARD_DEVIATIONS = 3;\n      var blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);\n      var blurUniforms = blurMaterial.uniforms;\n      var pixels = this._sizeLods[lodIn] - 1;\n      var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n      var sigmaPixels = sigmaRadians / radiansPerPixel;\n      var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n      if (samples > MAX_SAMPLES) {\n        console.warn("sigmaRadians, ".concat(sigmaRadians, ", is too large and will clip, as it requested ").concat(samples, " samples when the maximum is set to ").concat(MAX_SAMPLES));\n      }\n\n      var weights = [];\n      var sum = 0;\n\n      for (var _i86 = 0; _i86 < MAX_SAMPLES; ++_i86) {\n        var _x2 = _i86 / sigmaPixels;\n\n        var weight = Math.exp(-_x2 * _x2 / 2);\n        weights.push(weight);\n\n        if (_i86 === 0) {\n          sum += weight;\n        } else if (_i86 < samples) {\n          sum += 2 * weight;\n        }\n      }\n\n      for (var _i87 = 0; _i87 < weights.length; _i87++) {\n        weights[_i87] = weights[_i87] / sum;\n      }\n\n      blurUniforms[\'envMap\'].value = targetIn.texture;\n      blurUniforms[\'samples\'].value = samples;\n      blurUniforms[\'weights\'].value = weights;\n      blurUniforms[\'latitudinal\'].value = direction === \'latitudinal\';\n\n      if (poleAxis) {\n        blurUniforms[\'poleAxis\'].value = poleAxis;\n      }\n\n      var _lodMax = this._lodMax;\n      blurUniforms[\'dTheta\'].value = radiansPerPixel;\n      blurUniforms[\'mipInt\'].value = _lodMax - lodIn;\n      var outputSize = this._sizeLods[lodOut];\n      var x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n      var y = 4 * (this._cubeSize - outputSize);\n\n      _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n      renderer.setRenderTarget(targetOut);\n      renderer.render(blurMesh, _flatCamera);\n    }\n  }]);\n\n  return PMREMGenerator;\n}();\n\nfunction _createPlanes(lodMax) {\n  var lodPlanes = [];\n  var sizeLods = [];\n  var sigmas = [];\n  var lod = lodMax;\n  var totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n  for (var _i88 = 0; _i88 < totalLods; _i88++) {\n    var sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    var sigma = 1.0 / sizeLod;\n\n    if (_i88 > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[_i88 - lodMax + LOD_MIN - 1];\n    } else if (_i88 === 0) {\n      sigma = 0;\n    }\n\n    sigmas.push(sigma);\n    var texelSize = 1.0 / (sizeLod - 2);\n    var min = -texelSize;\n    var max = 1 + texelSize;\n    var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    var cubeFaces = 6;\n    var vertices = 6;\n    var positionSize = 3;\n    var uvSize = 2;\n    var faceIndexSize = 1;\n    var position = new Float32Array(positionSize * vertices * cubeFaces);\n    var uv = new Float32Array(uvSize * vertices * cubeFaces);\n    var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (var face = 0; face < cubeFaces; face++) {\n      var x = face % 3 * 2 / 3 - 1;\n      var y = face > 2 ? 0 : -1;\n      var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      var fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    var planes = new BufferGeometry();\n    planes.setAttribute(\'position\', new BufferAttribute(position, positionSize));\n    planes.setAttribute(\'uv\', new BufferAttribute(uv, uvSize));\n    planes.setAttribute(\'faceIndex\', new BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    lodPlanes: lodPlanes,\n    sizeLods: sizeLods,\n    sigmas: sigmas\n  };\n}\n\nfunction _createRenderTarget(width, height, params) {\n  var cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = \'PMREM.cubeUv\';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _getBlurShader(lodMax, width, height) {\n  var weights = new Float32Array(MAX_SAMPLES);\n  var poleAxis = new Vector3(0, 1, 0);\n  var shaderMaterial = new ShaderMaterial({\n    name: \'SphericalGaussianBlur\',\n    defines: {\n      \'n\': MAX_SAMPLES,\n      \'CUBEUV_TEXEL_WIDTH\': 1.0 / width,\n      \'CUBEUV_TEXEL_HEIGHT\': 1.0 / height,\n      \'CUBEUV_MAX_MIP\': "".concat(lodMax, ".0")\n    },\n    uniforms: {\n      \'envMap\': {\n        value: null\n      },\n      \'samples\': {\n        value: 1\n      },\n      \'weights\': {\n        value: weights\n      },\n      \'latitudinal\': {\n        value: false\n      },\n      \'dTheta\': {\n        value: 0\n      },\n      \'mipInt\': {\n        value: 0\n      },\n      \'poleAxis\': {\n        value: poleAxis\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    "\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform sampler2D envMap;\\n\\t\\t\\tuniform int samples;\\n\\t\\t\\tuniform float weights[ n ];\\n\\t\\t\\tuniform bool latitudinal;\\n\\t\\t\\tuniform float dTheta;\\n\\t\\t\\tuniform float mipInt;\\n\\t\\t\\tuniform vec3 poleAxis;\\n\\n\\t\\t\\t#define ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\t#include <cube_uv_reflection_fragment>\\n\\n\\t\\t\\tvec3 getSample( float theta, vec3 axis ) {\\n\\n\\t\\t\\t\\tfloat cosTheta = cos( theta );\\n\\t\\t\\t\\t// Rodrigues\' axis-angle rotation\\n\\t\\t\\t\\tvec3 sampleDirection = vOutputDirection * cosTheta\\n\\t\\t\\t\\t\\t+ cross( axis, vOutputDirection ) * sin( theta )\\n\\t\\t\\t\\t\\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\\n\\n\\t\\t\\t\\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\\n\\n\\t\\t\\t\\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\\n\\n\\t\\t\\t\\t\\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\taxis = normalize( axis );\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t\\t\\t\\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\\n\\n\\t\\t\\t\\tfor ( int i = 1; i < n; i++ ) {\\n\\n\\t\\t\\t\\t\\tif ( i >= samples ) {\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfloat theta = dTheta * float( i );\\n\\t\\t\\t\\t\\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\\n\\t\\t\\t\\t\\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t",\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getEquirectMaterial() {\n  return new ShaderMaterial({\n    name: \'EquirectangularToCubeUV\',\n    uniforms: {\n      \'envMap\': {\n        value: null\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    "\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform sampler2D envMap;\\n\\n\\t\\t\\t#include <common>\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvec3 outputDirection = normalize( vOutputDirection );\\n\\t\\t\\t\\tvec2 uv = equirectUv( outputDirection );\\n\\n\\t\\t\\t\\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\\n\\n\\t\\t\\t}\\n\\t\\t",\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n\nfunction _getCubemapMaterial() {\n  return new ShaderMaterial({\n    name: \'CubemapToCubeUV\',\n    uniforms: {\n      \'envMap\': {\n        value: null\n      },\n      \'flipEnvMap\': {\n        value: -1\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    "\\n\\n\\t\\t\\tprecision mediump float;\\n\\t\\t\\tprecision mediump int;\\n\\n\\t\\t\\tuniform float flipEnvMap;\\n\\n\\t\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t\\tuniform samplerCube envMap;\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\\n\\n\\t\\t\\t}\\n\\t\\t",\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    "\\n\\n\\t\\tprecision mediump float;\\n\\t\\tprecision mediump int;\\n\\n\\t\\tattribute float faceIndex;\\n\\n\\t\\tvarying vec3 vOutputDirection;\\n\\n\\t\\t// RH coordinate system; PMREM face-indexing convention\\n\\t\\tvec3 getDirection( vec2 uv, float face ) {\\n\\n\\t\\t\\tuv = 2.0 * uv - 1.0;\\n\\n\\t\\t\\tvec3 direction = vec3( uv, 1.0 );\\n\\n\\t\\t\\tif ( face == 0.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.zyx; // ( 1, v, u ) pos x\\n\\n\\t\\t\\t} else if ( face == 1.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.xzy;\\n\\t\\t\\t\\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\\n\\n\\t\\t\\t} else if ( face == 2.0 ) {\\n\\n\\t\\t\\t\\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\\n\\n\\t\\t\\t} else if ( face == 3.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.zyx;\\n\\t\\t\\t\\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\\n\\n\\t\\t\\t} else if ( face == 4.0 ) {\\n\\n\\t\\t\\t\\tdirection = direction.xzy;\\n\\t\\t\\t\\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\\n\\n\\t\\t\\t} else if ( face == 5.0 ) {\\n\\n\\t\\t\\t\\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn direction;\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvOutputDirection = getDirection( uv, faceIndex );\\n\\t\\t\\tgl_Position = vec4( position, 1.0 );\\n\\n\\t\\t}\\n\\t"\n  );\n}\n\nfunction WebGLCubeUVMaps(renderer) {\n  var cubeUVmaps = new WeakMap();\n  var pmremGenerator = null;\n\n  function get(texture) {\n    if (texture && texture.isTexture) {\n      var mapping = texture.mapping;\n      var isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;\n      var isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping; // equirect/cube map to cubeUV conversion\n\n      if (isEquirectMap || isCubeMap) {\n        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {\n          texture.needsPMREMUpdate = false;\n          var renderTarget = cubeUVmaps.get(texture);\n          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);\n          cubeUVmaps.set(texture, renderTarget);\n          return renderTarget.texture;\n        } else {\n          if (cubeUVmaps.has(texture)) {\n            return cubeUVmaps.get(texture).texture;\n          } else {\n            var image = texture.image;\n\n            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {\n              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n\n              var _renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);\n\n              cubeUVmaps.set(texture, _renderTarget);\n              texture.addEventListener(\'dispose\', onTextureDispose);\n              return _renderTarget.texture;\n            } else {\n              // image not yet ready. try the conversion next frame\n              return null;\n            }\n          }\n        }\n      }\n    }\n\n    return texture;\n  }\n\n  function isCubeTextureComplete(image) {\n    var count = 0;\n    var length = 6;\n\n    for (var _i89 = 0; _i89 < length; _i89++) {\n      if (image[_i89] !== undefined) count++;\n    }\n\n    return count === length;\n  }\n\n  function onTextureDispose(event) {\n    var texture = event.target;\n    texture.removeEventListener(\'dispose\', onTextureDispose);\n    var cubemapUV = cubeUVmaps.get(texture);\n\n    if (cubemapUV !== undefined) {\n      cubeUVmaps.delete(texture);\n      cubemapUV.dispose();\n    }\n  }\n\n  function dispose() {\n    cubeUVmaps = new WeakMap();\n\n    if (pmremGenerator !== null) {\n      pmremGenerator.dispose();\n      pmremGenerator = null;\n    }\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nfunction WebGLExtensions(gl) {\n  var extensions = {};\n\n  function getExtension(name) {\n    if (extensions[name] !== undefined) {\n      return extensions[name];\n    }\n\n    var extension;\n\n    switch (name) {\n      case \'WEBGL_depth_texture\':\n        extension = gl.getExtension(\'WEBGL_depth_texture\') || gl.getExtension(\'MOZ_WEBGL_depth_texture\') || gl.getExtension(\'WEBKIT_WEBGL_depth_texture\');\n        break;\n\n      case \'EXT_texture_filter_anisotropic\':\n        extension = gl.getExtension(\'EXT_texture_filter_anisotropic\') || gl.getExtension(\'MOZ_EXT_texture_filter_anisotropic\') || gl.getExtension(\'WEBKIT_EXT_texture_filter_anisotropic\');\n        break;\n\n      case \'WEBGL_compressed_texture_s3tc\':\n        extension = gl.getExtension(\'WEBGL_compressed_texture_s3tc\') || gl.getExtension(\'MOZ_WEBGL_compressed_texture_s3tc\') || gl.getExtension(\'WEBKIT_WEBGL_compressed_texture_s3tc\');\n        break;\n\n      case \'WEBGL_compressed_texture_pvrtc\':\n        extension = gl.getExtension(\'WEBGL_compressed_texture_pvrtc\') || gl.getExtension(\'WEBKIT_WEBGL_compressed_texture_pvrtc\');\n        break;\n\n      default:\n        extension = gl.getExtension(name);\n    }\n\n    extensions[name] = extension;\n    return extension;\n  }\n\n  return {\n    has: function has(name) {\n      return getExtension(name) !== null;\n    },\n    init: function init(capabilities) {\n      if (capabilities.isWebGL2) {\n        getExtension(\'EXT_color_buffer_float\');\n      } else {\n        getExtension(\'WEBGL_depth_texture\');\n        getExtension(\'OES_texture_float\');\n        getExtension(\'OES_texture_half_float\');\n        getExtension(\'OES_texture_half_float_linear\');\n        getExtension(\'OES_standard_derivatives\');\n        getExtension(\'OES_element_index_uint\');\n        getExtension(\'OES_vertex_array_object\');\n        getExtension(\'ANGLE_instanced_arrays\');\n      }\n\n      getExtension(\'OES_texture_float_linear\');\n      getExtension(\'EXT_color_buffer_half_float\');\n      getExtension(\'WEBGL_multisampled_render_to_texture\');\n    },\n    get: function get(name) {\n      var extension = getExtension(name);\n\n      if (extension === null) {\n        console.warn(\'THREE.WebGLRenderer: \' + name + \' extension not supported.\');\n      }\n\n      return extension;\n    }\n  };\n}\n\nfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n  var geometries = {};\n  var wireframeAttributes = new WeakMap();\n\n  function onGeometryDispose(event) {\n    var geometry = event.target;\n\n    if (geometry.index !== null) {\n      attributes.remove(geometry.index);\n    }\n\n    for (var name in geometry.attributes) {\n      attributes.remove(geometry.attributes[name]);\n    }\n\n    geometry.removeEventListener(\'dispose\', onGeometryDispose);\n    delete geometries[geometry.id];\n    var attribute = wireframeAttributes.get(geometry);\n\n    if (attribute) {\n      attributes.remove(attribute);\n      wireframeAttributes.delete(geometry);\n    }\n\n    bindingStates.releaseStatesOfGeometry(geometry);\n\n    if (geometry.isInstancedBufferGeometry === true) {\n      delete geometry._maxInstanceCount;\n    } //\n\n\n    info.memory.geometries--;\n  }\n\n  function get(object, geometry) {\n    if (geometries[geometry.id] === true) return geometry;\n    geometry.addEventListener(\'dispose\', onGeometryDispose);\n    geometries[geometry.id] = true;\n    info.memory.geometries++;\n    return geometry;\n  }\n\n  function update(geometry) {\n    var geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.\n\n    for (var name in geometryAttributes) {\n      attributes.update(geometryAttributes[name], 34962);\n    } // morph targets\n\n\n    var morphAttributes = geometry.morphAttributes;\n\n    for (var _name3 in morphAttributes) {\n      var array = morphAttributes[_name3];\n\n      for (var _i90 = 0, l = array.length; _i90 < l; _i90++) {\n        attributes.update(array[_i90], 34962);\n      }\n    }\n  }\n\n  function updateWireframeAttribute(geometry) {\n    var indices = [];\n    var geometryIndex = geometry.index;\n    var geometryPosition = geometry.attributes.position;\n    var version = 0;\n\n    if (geometryIndex !== null) {\n      var array = geometryIndex.array;\n      version = geometryIndex.version;\n\n      for (var _i91 = 0, l = array.length; _i91 < l; _i91 += 3) {\n        var a = array[_i91 + 0];\n        var b = array[_i91 + 1];\n        var c = array[_i91 + 2];\n        indices.push(a, b, b, c, c, a);\n      }\n    } else {\n      var _array = geometryPosition.array;\n      version = geometryPosition.version;\n\n      for (var _i92 = 0, _l5 = _array.length / 3 - 1; _i92 < _l5; _i92 += 3) {\n        var _a4 = _i92 + 0;\n\n        var _b4 = _i92 + 1;\n\n        var _c4 = _i92 + 2;\n\n        indices.push(_a4, _b4, _b4, _c4, _c4, _a4);\n      }\n    }\n\n    var attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n    attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates\n    //\n\n    var previousAttribute = wireframeAttributes.get(geometry);\n    if (previousAttribute) attributes.remove(previousAttribute); //\n\n    wireframeAttributes.set(geometry, attribute);\n  }\n\n  function getWireframeAttribute(geometry) {\n    var currentAttribute = wireframeAttributes.get(geometry);\n\n    if (currentAttribute) {\n      var geometryIndex = geometry.index;\n\n      if (geometryIndex !== null) {\n        // if the attribute is obsolete, create a new one\n        if (currentAttribute.version < geometryIndex.version) {\n          updateWireframeAttribute(geometry);\n        }\n      }\n    } else {\n      updateWireframeAttribute(geometry);\n    }\n\n    return wireframeAttributes.get(geometry);\n  }\n\n  return {\n    get: get,\n    update: update,\n    getWireframeAttribute: getWireframeAttribute\n  };\n}\n\nfunction WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {\n  var isWebGL2 = capabilities.isWebGL2;\n  var mode;\n\n  function setMode(value) {\n    mode = value;\n  }\n\n  var type, bytesPerElement;\n\n  function setIndex(value) {\n    type = value.type;\n    bytesPerElement = value.bytesPerElement;\n  }\n\n  function render(start, count) {\n    gl.drawElements(mode, count, type, start * bytesPerElement);\n    info.update(count, mode, 1);\n  }\n\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0) return;\n    var extension, methodName;\n\n    if (isWebGL2) {\n      extension = gl;\n      methodName = \'drawElementsInstanced\';\n    } else {\n      extension = extensions.get(\'ANGLE_instanced_arrays\');\n      methodName = \'drawElementsInstancedANGLE\';\n\n      if (extension === null) {\n        console.error(\'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\');\n        return;\n      }\n    }\n\n    extension[methodName](mode, count, type, start * bytesPerElement, primcount);\n    info.update(count, mode, primcount);\n  } //\n\n\n  this.setMode = setMode;\n  this.setIndex = setIndex;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}\n\nfunction WebGLInfo(gl) {\n  var memory = {\n    geometries: 0,\n    textures: 0\n  };\n  var render = {\n    frame: 0,\n    calls: 0,\n    triangles: 0,\n    points: 0,\n    lines: 0\n  };\n\n  function update(count, mode, instanceCount) {\n    render.calls++;\n\n    switch (mode) {\n      case 4:\n        render.triangles += instanceCount * (count / 3);\n        break;\n\n      case 1:\n        render.lines += instanceCount * (count / 2);\n        break;\n\n      case 3:\n        render.lines += instanceCount * (count - 1);\n        break;\n\n      case 2:\n        render.lines += instanceCount * count;\n        break;\n\n      case 0:\n        render.points += instanceCount * count;\n        break;\n\n      default:\n        console.error(\'THREE.WebGLInfo: Unknown draw mode:\', mode);\n        break;\n    }\n  }\n\n  function reset() {\n    render.frame++;\n    render.calls = 0;\n    render.triangles = 0;\n    render.points = 0;\n    render.lines = 0;\n  }\n\n  return {\n    memory: memory,\n    render: render,\n    programs: null,\n    autoReset: true,\n    reset: reset,\n    update: update\n  };\n}\n\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction denormalize(morph, attribute) {\n  var denominator = 1;\n  var array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n  if (array instanceof Int8Array) denominator = 127;else if (array instanceof Int16Array) denominator = 32767;else if (array instanceof Int32Array) denominator = 2147483647;else console.error(\'THREE.WebGLMorphtargets: Unsupported morph attribute data type: \', array);\n  morph.divideScalar(denominator);\n}\n\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  var influencesList = {};\n  var morphInfluences = new Float32Array(8);\n  var morphTextures = new WeakMap();\n  var morph = new Vector4();\n  var workInfluences = [];\n\n  for (var _i93 = 0; _i93 < 8; _i93++) {\n    workInfluences[_i93] = [_i93, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    var objectInfluences = object.morphTargetInfluences;\n\n    if (capabilities.isWebGL2 === true) {\n      // instead of using attributes, the WebGL 2 code path encodes morph targets\n      // into an array of data textures. Each layer represents a single morph target.\n      var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n      var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n      var entry = morphTextures.get(geometry);\n\n      if (entry === undefined || entry.count !== morphTargetsCount) {\n        var disposeTexture = function disposeTexture() {\n          texture.dispose();\n          morphTextures.delete(geometry);\n          geometry.removeEventListener(\'dispose\', disposeTexture);\n        };\n\n        if (entry !== undefined) entry.texture.dispose();\n        var hasMorphPosition = geometry.morphAttributes.position !== undefined;\n        var hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n        var hasMorphColors = geometry.morphAttributes.color !== undefined;\n        var morphTargets = geometry.morphAttributes.position || [];\n        var morphNormals = geometry.morphAttributes.normal || [];\n        var morphColors = geometry.morphAttributes.color || [];\n        var vertexDataCount = 0;\n        if (hasMorphPosition === true) vertexDataCount = 1;\n        if (hasMorphNormals === true) vertexDataCount = 2;\n        if (hasMorphColors === true) vertexDataCount = 3;\n        var width = geometry.attributes.position.count * vertexDataCount;\n        var height = 1;\n\n        if (width > capabilities.maxTextureSize) {\n          height = Math.ceil(width / capabilities.maxTextureSize);\n          width = capabilities.maxTextureSize;\n        }\n\n        var buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n        var texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n        texture.type = FloatType;\n        texture.needsUpdate = true; // fill buffer\n\n        var vertexDataStride = vertexDataCount * 4;\n\n        for (var _i94 = 0; _i94 < morphTargetsCount; _i94++) {\n          var morphTarget = morphTargets[_i94];\n          var morphNormal = morphNormals[_i94];\n          var morphColor = morphColors[_i94];\n          var offset = width * height * 4 * _i94;\n\n          for (var j = 0; j < morphTarget.count; j++) {\n            var stride = j * vertexDataStride;\n\n            if (hasMorphPosition === true) {\n              morph.fromBufferAttribute(morphTarget, j);\n              if (morphTarget.normalized === true) denormalize(morph, morphTarget);\n              buffer[offset + stride + 0] = morph.x;\n              buffer[offset + stride + 1] = morph.y;\n              buffer[offset + stride + 2] = morph.z;\n              buffer[offset + stride + 3] = 0;\n            }\n\n            if (hasMorphNormals === true) {\n              morph.fromBufferAttribute(morphNormal, j);\n              if (morphNormal.normalized === true) denormalize(morph, morphNormal);\n              buffer[offset + stride + 4] = morph.x;\n              buffer[offset + stride + 5] = morph.y;\n              buffer[offset + stride + 6] = morph.z;\n              buffer[offset + stride + 7] = 0;\n            }\n\n            if (hasMorphColors === true) {\n              morph.fromBufferAttribute(morphColor, j);\n              if (morphColor.normalized === true) denormalize(morph, morphColor);\n              buffer[offset + stride + 8] = morph.x;\n              buffer[offset + stride + 9] = morph.y;\n              buffer[offset + stride + 10] = morph.z;\n              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;\n            }\n          }\n        }\n\n        entry = {\n          count: morphTargetsCount,\n          texture: texture,\n          size: new Vector2(width, height)\n        };\n        morphTextures.set(geometry, entry);\n        geometry.addEventListener(\'dispose\', disposeTexture);\n      } //\n\n\n      var morphInfluencesSum = 0;\n\n      for (var _i95 = 0; _i95 < objectInfluences.length; _i95++) {\n        morphInfluencesSum += objectInfluences[_i95];\n      }\n\n      var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, \'morphTargetBaseInfluence\', morphBaseInfluence);\n      program.getUniforms().setValue(gl, \'morphTargetInfluences\', objectInfluences);\n      program.getUniforms().setValue(gl, \'morphTargetsTexture\', entry.texture, textures);\n      program.getUniforms().setValue(gl, \'morphTargetsTextureSize\', entry.size);\n    } else {\n      // When object doesn\'t have morph target influences defined, we treat it as a 0-length array\n      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n      var length = objectInfluences === undefined ? 0 : objectInfluences.length;\n      var influences = influencesList[geometry.id];\n\n      if (influences === undefined || influences.length !== length) {\n        // initialise list\n        influences = [];\n\n        for (var _i96 = 0; _i96 < length; _i96++) {\n          influences[_i96] = [_i96, 0];\n        }\n\n        influencesList[geometry.id] = influences;\n      } // Collect influences\n\n\n      for (var _i97 = 0; _i97 < length; _i97++) {\n        var influence = influences[_i97];\n        influence[0] = _i97;\n        influence[1] = objectInfluences[_i97];\n      }\n\n      influences.sort(absNumericalSort);\n\n      for (var _i98 = 0; _i98 < 8; _i98++) {\n        if (_i98 < length && influences[_i98][1]) {\n          workInfluences[_i98][0] = influences[_i98][0];\n          workInfluences[_i98][1] = influences[_i98][1];\n        } else {\n          workInfluences[_i98][0] = Number.MAX_SAFE_INTEGER;\n          workInfluences[_i98][1] = 0;\n        }\n      }\n\n      workInfluences.sort(numericalSort);\n      var _morphTargets = geometry.morphAttributes.position;\n      var _morphNormals = geometry.morphAttributes.normal;\n      var _morphInfluencesSum = 0;\n\n      for (var _i99 = 0; _i99 < 8; _i99++) {\n        var _influence = workInfluences[_i99];\n        var index = _influence[0];\n        var _value3 = _influence[1];\n\n        if (index !== Number.MAX_SAFE_INTEGER && _value3) {\n          if (_morphTargets && geometry.getAttribute(\'morphTarget\' + _i99) !== _morphTargets[index]) {\n            geometry.setAttribute(\'morphTarget\' + _i99, _morphTargets[index]);\n          }\n\n          if (_morphNormals && geometry.getAttribute(\'morphNormal\' + _i99) !== _morphNormals[index]) {\n            geometry.setAttribute(\'morphNormal\' + _i99, _morphNormals[index]);\n          }\n\n          morphInfluences[_i99] = _value3;\n          _morphInfluencesSum += _value3;\n        } else {\n          if (_morphTargets && geometry.hasAttribute(\'morphTarget\' + _i99) === true) {\n            geometry.deleteAttribute(\'morphTarget\' + _i99);\n          }\n\n          if (_morphNormals && geometry.hasAttribute(\'morphNormal\' + _i99) === true) {\n            geometry.deleteAttribute(\'morphNormal\' + _i99);\n          }\n\n          morphInfluences[_i99] = 0;\n        }\n      } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n      // This allows us to switch between absolute morphs and relative morphs without changing shader code\n      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n      var _morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - _morphInfluencesSum;\n\n      program.getUniforms().setValue(gl, \'morphTargetBaseInfluence\', _morphBaseInfluence);\n      program.getUniforms().setValue(gl, \'morphTargetInfluences\', morphInfluences);\n    }\n  }\n\n  return {\n    update: update\n  };\n}\n\nfunction WebGLObjects(gl, geometries, attributes, info) {\n  var updateMap = new WeakMap();\n\n  function update(object) {\n    var frame = info.render.frame;\n    var geometry = object.geometry;\n    var buffergeometry = geometries.get(object, geometry); // Update once per frame\n\n    if (updateMap.get(buffergeometry) !== frame) {\n      geometries.update(buffergeometry);\n      updateMap.set(buffergeometry, frame);\n    }\n\n    if (object.isInstancedMesh) {\n      if (object.hasEventListener(\'dispose\', onInstancedMeshDispose) === false) {\n        object.addEventListener(\'dispose\', onInstancedMeshDispose);\n      }\n\n      attributes.update(object.instanceMatrix, 34962);\n\n      if (object.instanceColor !== null) {\n        attributes.update(object.instanceColor, 34962);\n      }\n    }\n\n    return buffergeometry;\n  }\n\n  function dispose() {\n    updateMap = new WeakMap();\n  }\n\n  function onInstancedMeshDispose(event) {\n    var instancedMesh = event.target;\n    instancedMesh.removeEventListener(\'dispose\', onInstancedMeshDispose);\n    attributes.remove(instancedMesh.instanceMatrix);\n    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);\n  }\n\n  return {\n    update: update,\n    dispose: dispose\n  };\n}\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling \'new WebGLUniforms( gl, program )\'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe \'textures\' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in \'seq\' to \'values[id].value\'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters \'seq\' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name \'name\' to \'value\'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\n\nvar emptyTexture = new Texture();\nvar emptyArrayTexture = new DataArrayTexture();\nvar empty3dTexture = new Data3DTexture();\nvar emptyCubeTexture = new CubeTexture(); // --- Utilities ---\n// Array Caches (provide typed arrays for temporary by size)\n\nvar arrayCacheF32 = [];\nvar arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms\n\nvar mat4array = new Float32Array(16);\nvar mat3array = new Float32Array(9);\nvar mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices\n\nfunction flatten(array, nBlocks, blockSize) {\n  var firstElem = array[0];\n  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )\n  // see http://jacksondunstan.com/articles/983\n\n  var n = nBlocks * blockSize;\n  var r = arrayCacheF32[n];\n\n  if (r === undefined) {\n    r = new Float32Array(n);\n    arrayCacheF32[n] = r;\n  }\n\n  if (nBlocks !== 0) {\n    firstElem.toArray(r, 0);\n\n    for (var _i100 = 1, offset = 0; _i100 !== nBlocks; ++_i100) {\n      offset += blockSize;\n\n      array[_i100].toArray(r, offset);\n    }\n  }\n\n  return r;\n}\n\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n\n  for (var _i101 = 0, l = a.length; _i101 < l; _i101++) {\n    if (a[_i101] !== b[_i101]) return false;\n  }\n\n  return true;\n}\n\nfunction copyArray(a, b) {\n  for (var _i102 = 0, l = b.length; _i102 < l; _i102++) {\n    a[_i102] = b[_i102];\n  }\n} // Texture unit allocation\n\n\nfunction allocTexUnits(textures, n) {\n  var r = arrayCacheI32[n];\n\n  if (r === undefined) {\n    r = new Int32Array(n);\n    arrayCacheI32[n] = r;\n  }\n\n  for (var _i103 = 0; _i103 !== n; ++_i103) {\n    r[_i103] = textures.allocateTextureUnit();\n  }\n\n  return r;\n} // --- Setters ---\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n// Single scalar\n\n\nfunction setValueV1f(gl, v) {\n  var cache = this.cache;\n  if (cache[0] === v) return;\n  gl.uniform1f(this.addr, v);\n  cache[0] = v;\n} // Single float vector (from flat array or THREE.VectorN)\n\n\nfunction setValueV2f(gl, v) {\n  var cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (cache[0] !== v.x || cache[1] !== v.y) {\n      gl.uniform2f(this.addr, v.x, v.y);\n      cache[0] = v.x;\n      cache[1] = v.y;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n    gl.uniform2fv(this.addr, v);\n    copyArray(cache, v);\n  }\n}\n\nfunction setValueV3f(gl, v) {\n  var cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {\n      gl.uniform3f(this.addr, v.x, v.y, v.z);\n      cache[0] = v.x;\n      cache[1] = v.y;\n      cache[2] = v.z;\n    }\n  } else if (v.r !== undefined) {\n    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {\n      gl.uniform3f(this.addr, v.r, v.g, v.b);\n      cache[0] = v.r;\n      cache[1] = v.g;\n      cache[2] = v.b;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n    gl.uniform3fv(this.addr, v);\n    copyArray(cache, v);\n  }\n}\n\nfunction setValueV4f(gl, v) {\n  var cache = this.cache;\n\n  if (v.x !== undefined) {\n    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {\n      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n      cache[0] = v.x;\n      cache[1] = v.y;\n      cache[2] = v.z;\n      cache[3] = v.w;\n    }\n  } else {\n    if (arraysEqual(cache, v)) return;\n    gl.uniform4fv(this.addr, v);\n    copyArray(cache, v);\n  }\n} // Single matrix (from flat array or THREE.MatrixN)\n\n\nfunction setValueM2(gl, v) {\n  var cache = this.cache;\n  var elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n    gl.uniformMatrix2fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n    mat2array.set(elements);\n    gl.uniformMatrix2fv(this.addr, false, mat2array);\n    copyArray(cache, elements);\n  }\n}\n\nfunction setValueM3(gl, v) {\n  var cache = this.cache;\n  var elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n    gl.uniformMatrix3fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n    mat3array.set(elements);\n    gl.uniformMatrix3fv(this.addr, false, mat3array);\n    copyArray(cache, elements);\n  }\n}\n\nfunction setValueM4(gl, v) {\n  var cache = this.cache;\n  var elements = v.elements;\n\n  if (elements === undefined) {\n    if (arraysEqual(cache, v)) return;\n    gl.uniformMatrix4fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements)) return;\n    mat4array.set(elements);\n    gl.uniformMatrix4fv(this.addr, false, mat4array);\n    copyArray(cache, elements);\n  }\n} // Single integer / boolean\n\n\nfunction setValueV1i(gl, v) {\n  var cache = this.cache;\n  if (cache[0] === v) return;\n  gl.uniform1i(this.addr, v);\n  cache[0] = v;\n} // Single integer / boolean vector (from flat array)\n\n\nfunction setValueV2i(gl, v) {\n  var cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform2iv(this.addr, v);\n  copyArray(cache, v);\n}\n\nfunction setValueV3i(gl, v) {\n  var cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform3iv(this.addr, v);\n  copyArray(cache, v);\n}\n\nfunction setValueV4i(gl, v) {\n  var cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform4iv(this.addr, v);\n  copyArray(cache, v);\n} // Single unsigned integer\n\n\nfunction setValueV1ui(gl, v) {\n  var cache = this.cache;\n  if (cache[0] === v) return;\n  gl.uniform1ui(this.addr, v);\n  cache[0] = v;\n} // Single unsigned integer vector (from flat array)\n\n\nfunction setValueV2ui(gl, v) {\n  var cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform2uiv(this.addr, v);\n  copyArray(cache, v);\n}\n\nfunction setValueV3ui(gl, v) {\n  var cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform3uiv(this.addr, v);\n  copyArray(cache, v);\n}\n\nfunction setValueV4ui(gl, v) {\n  var cache = this.cache;\n  if (arraysEqual(cache, v)) return;\n  gl.uniform4uiv(this.addr, v);\n  copyArray(cache, v);\n} // Single texture (2D / Cube)\n\n\nfunction setValueT1(gl, v, textures) {\n  var cache = this.cache;\n  var unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.setTexture2D(v || emptyTexture, unit);\n}\n\nfunction setValueT3D1(gl, v, textures) {\n  var cache = this.cache;\n  var unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.setTexture3D(v || empty3dTexture, unit);\n}\n\nfunction setValueT6(gl, v, textures) {\n  var cache = this.cache;\n  var unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.setTextureCube(v || emptyCubeTexture, unit);\n}\n\nfunction setValueT2DArray1(gl, v, textures) {\n  var cache = this.cache;\n  var unit = textures.allocateTextureUnit();\n\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n\n  textures.setTexture2DArray(v || emptyArrayTexture, unit);\n} // Helper to pick the right setter for the singular case\n\n\nfunction getSingularSetter(type) {\n  switch (type) {\n    case 0x1406:\n      return setValueV1f;\n    // FLOAT\n\n    case 0x8b50:\n      return setValueV2f;\n    // _VEC2\n\n    case 0x8b51:\n      return setValueV3f;\n    // _VEC3\n\n    case 0x8b52:\n      return setValueV4f;\n    // _VEC4\n\n    case 0x8b5a:\n      return setValueM2;\n    // _MAT2\n\n    case 0x8b5b:\n      return setValueM3;\n    // _MAT3\n\n    case 0x8b5c:\n      return setValueM4;\n    // _MAT4\n\n    case 0x1404:\n    case 0x8b56:\n      return setValueV1i;\n    // INT, BOOL\n\n    case 0x8b53:\n    case 0x8b57:\n      return setValueV2i;\n    // _VEC2\n\n    case 0x8b54:\n    case 0x8b58:\n      return setValueV3i;\n    // _VEC3\n\n    case 0x8b55:\n    case 0x8b59:\n      return setValueV4i;\n    // _VEC4\n\n    case 0x1405:\n      return setValueV1ui;\n    // UINT\n\n    case 0x8dc6:\n      return setValueV2ui;\n    // _VEC2\n\n    case 0x8dc7:\n      return setValueV3ui;\n    // _VEC3\n\n    case 0x8dc8:\n      return setValueV4ui;\n    // _VEC4\n\n    case 0x8b5e: // SAMPLER_2D\n\n    case 0x8d66: // SAMPLER_EXTERNAL_OES\n\n    case 0x8dca: // INT_SAMPLER_2D\n\n    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n    case 0x8b62:\n      // SAMPLER_2D_SHADOW\n      return setValueT1;\n\n    case 0x8b5f: // SAMPLER_3D\n\n    case 0x8dcb: // INT_SAMPLER_3D\n\n    case 0x8dd3:\n      // UNSIGNED_INT_SAMPLER_3D\n      return setValueT3D1;\n\n    case 0x8b60: // SAMPLER_CUBE\n\n    case 0x8dcc: // INT_SAMPLER_CUBE\n\n    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n    case 0x8dc5:\n      // SAMPLER_CUBE_SHADOW\n      return setValueT6;\n\n    case 0x8dc1: // SAMPLER_2D_ARRAY\n\n    case 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\n    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\n    case 0x8dc4:\n      // SAMPLER_2D_ARRAY_SHADOW\n      return setValueT2DArray1;\n  }\n} // Array of scalars\n\n\nfunction setValueV1fArray(gl, v) {\n  gl.uniform1fv(this.addr, v);\n} // Array of vectors (from flat array or array of THREE.VectorN)\n\n\nfunction setValueV2fArray(gl, v) {\n  var data = flatten(v, this.size, 2);\n  gl.uniform2fv(this.addr, data);\n}\n\nfunction setValueV3fArray(gl, v) {\n  var data = flatten(v, this.size, 3);\n  gl.uniform3fv(this.addr, data);\n}\n\nfunction setValueV4fArray(gl, v) {\n  var data = flatten(v, this.size, 4);\n  gl.uniform4fv(this.addr, data);\n} // Array of matrices (from flat array or array of THREE.MatrixN)\n\n\nfunction setValueM2Array(gl, v) {\n  var data = flatten(v, this.size, 4);\n  gl.uniformMatrix2fv(this.addr, false, data);\n}\n\nfunction setValueM3Array(gl, v) {\n  var data = flatten(v, this.size, 9);\n  gl.uniformMatrix3fv(this.addr, false, data);\n}\n\nfunction setValueM4Array(gl, v) {\n  var data = flatten(v, this.size, 16);\n  gl.uniformMatrix4fv(this.addr, false, data);\n} // Array of integer / boolean\n\n\nfunction setValueV1iArray(gl, v) {\n  gl.uniform1iv(this.addr, v);\n} // Array of integer / boolean vectors (from flat array)\n\n\nfunction setValueV2iArray(gl, v) {\n  gl.uniform2iv(this.addr, v);\n}\n\nfunction setValueV3iArray(gl, v) {\n  gl.uniform3iv(this.addr, v);\n}\n\nfunction setValueV4iArray(gl, v) {\n  gl.uniform4iv(this.addr, v);\n} // Array of unsigned integer\n\n\nfunction setValueV1uiArray(gl, v) {\n  gl.uniform1uiv(this.addr, v);\n} // Array of unsigned integer vectors (from flat array)\n\n\nfunction setValueV2uiArray(gl, v) {\n  gl.uniform2uiv(this.addr, v);\n}\n\nfunction setValueV3uiArray(gl, v) {\n  gl.uniform3uiv(this.addr, v);\n}\n\nfunction setValueV4uiArray(gl, v) {\n  gl.uniform4uiv(this.addr, v);\n} // Array of textures (2D / 3D / Cube / 2DArray)\n\n\nfunction setValueT1Array(gl, v, textures) {\n  var n = v.length;\n  var units = allocTexUnits(textures, n);\n  gl.uniform1iv(this.addr, units);\n\n  for (var _i104 = 0; _i104 !== n; ++_i104) {\n    textures.setTexture2D(v[_i104] || emptyTexture, units[_i104]);\n  }\n}\n\nfunction setValueT3DArray(gl, v, textures) {\n  var n = v.length;\n  var units = allocTexUnits(textures, n);\n  gl.uniform1iv(this.addr, units);\n\n  for (var _i105 = 0; _i105 !== n; ++_i105) {\n    textures.setTexture3D(v[_i105] || empty3dTexture, units[_i105]);\n  }\n}\n\nfunction setValueT6Array(gl, v, textures) {\n  var n = v.length;\n  var units = allocTexUnits(textures, n);\n  gl.uniform1iv(this.addr, units);\n\n  for (var _i106 = 0; _i106 !== n; ++_i106) {\n    textures.setTextureCube(v[_i106] || emptyCubeTexture, units[_i106]);\n  }\n}\n\nfunction setValueT2DArrayArray(gl, v, textures) {\n  var n = v.length;\n  var units = allocTexUnits(textures, n);\n  gl.uniform1iv(this.addr, units);\n\n  for (var _i107 = 0; _i107 !== n; ++_i107) {\n    textures.setTexture2DArray(v[_i107] || emptyArrayTexture, units[_i107]);\n  }\n} // Helper to pick the right setter for a pure (bottom-level) array\n\n\nfunction getPureArraySetter(type) {\n  switch (type) {\n    case 0x1406:\n      return setValueV1fArray;\n    // FLOAT\n\n    case 0x8b50:\n      return setValueV2fArray;\n    // _VEC2\n\n    case 0x8b51:\n      return setValueV3fArray;\n    // _VEC3\n\n    case 0x8b52:\n      return setValueV4fArray;\n    // _VEC4\n\n    case 0x8b5a:\n      return setValueM2Array;\n    // _MAT2\n\n    case 0x8b5b:\n      return setValueM3Array;\n    // _MAT3\n\n    case 0x8b5c:\n      return setValueM4Array;\n    // _MAT4\n\n    case 0x1404:\n    case 0x8b56:\n      return setValueV1iArray;\n    // INT, BOOL\n\n    case 0x8b53:\n    case 0x8b57:\n      return setValueV2iArray;\n    // _VEC2\n\n    case 0x8b54:\n    case 0x8b58:\n      return setValueV3iArray;\n    // _VEC3\n\n    case 0x8b55:\n    case 0x8b59:\n      return setValueV4iArray;\n    // _VEC4\n\n    case 0x1405:\n      return setValueV1uiArray;\n    // UINT\n\n    case 0x8dc6:\n      return setValueV2uiArray;\n    // _VEC2\n\n    case 0x8dc7:\n      return setValueV3uiArray;\n    // _VEC3\n\n    case 0x8dc8:\n      return setValueV4uiArray;\n    // _VEC4\n\n    case 0x8b5e: // SAMPLER_2D\n\n    case 0x8d66: // SAMPLER_EXTERNAL_OES\n\n    case 0x8dca: // INT_SAMPLER_2D\n\n    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n    case 0x8b62:\n      // SAMPLER_2D_SHADOW\n      return setValueT1Array;\n\n    case 0x8b5f: // SAMPLER_3D\n\n    case 0x8dcb: // INT_SAMPLER_3D\n\n    case 0x8dd3:\n      // UNSIGNED_INT_SAMPLER_3D\n      return setValueT3DArray;\n\n    case 0x8b60: // SAMPLER_CUBE\n\n    case 0x8dcc: // INT_SAMPLER_CUBE\n\n    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n    case 0x8dc5:\n      // SAMPLER_CUBE_SHADOW\n      return setValueT6Array;\n\n    case 0x8dc1: // SAMPLER_2D_ARRAY\n\n    case 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\n    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\n    case 0x8dc4:\n      // SAMPLER_2D_ARRAY_SHADOW\n      return setValueT2DArrayArray;\n  }\n} // --- Uniform Classes ---\n\n\nvar SingleUniform = /*#__PURE__*/(0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(function SingleUniform(id, activeInfo, addr) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SingleUniform);\n\n  this.id = id;\n  this.addr = addr;\n  this.cache = [];\n  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n});\n\nvar PureArrayUniform = /*#__PURE__*/(0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(function PureArrayUniform(id, activeInfo, addr) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PureArrayUniform);\n\n  this.id = id;\n  this.addr = addr;\n  this.cache = [];\n  this.size = activeInfo.size;\n  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n});\n\nvar StructuredUniform = /*#__PURE__*/function () {\n  function StructuredUniform(id) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, StructuredUniform);\n\n    this.id = id;\n    this.seq = [];\n    this.map = {};\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(StructuredUniform, [{\n    key: "setValue",\n    value: function setValue(gl, value, textures) {\n      var seq = this.seq;\n\n      for (var _i108 = 0, n = seq.length; _i108 !== n; ++_i108) {\n        var u = seq[_i108];\n        u.setValue(gl, value[u.id], textures);\n      }\n    }\n  }]);\n\n  return StructuredUniform;\n}(); // --- Top-level ---\n// Parser - builds up the property tree from the path strings\n\n\nvar RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g; // extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform(container, uniformObject) {\n  container.seq.push(uniformObject);\n  container.map[uniformObject.id] = uniformObject;\n}\n\nfunction parseUniform(activeInfo, addr, container) {\n  var path = activeInfo.name,\n      pathLength = path.length; // reset RegExp object, because of the early exit of a previous run\n\n  RePathPart.lastIndex = 0;\n\n  while (true) {\n    var match = RePathPart.exec(path),\n        matchEnd = RePathPart.lastIndex;\n    var id = match[1];\n    var idIsIndex = match[2] === \']\',\n        subscript = match[3];\n    if (idIsIndex) id = id | 0; // convert to integer\n\n    if (subscript === undefined || subscript === \'[\' && matchEnd + 2 === pathLength) {\n      // bare name or "pure" bottom-level array "[0]" suffix\n      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));\n      break;\n    } else {\n      // step into inner node / create it in case it doesn\'t exist\n      var map = container.map;\n      var next = map[id];\n\n      if (next === undefined) {\n        next = new StructuredUniform(id);\n        addUniform(container, next);\n      }\n\n      container = next;\n    }\n  }\n} // Root Container\n\n\nvar WebGLUniforms = /*#__PURE__*/function () {\n  function WebGLUniforms(gl, program) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGLUniforms);\n\n    this.seq = [];\n    this.map = {};\n    var n = gl.getProgramParameter(program, 35718);\n\n    for (var _i109 = 0; _i109 < n; ++_i109) {\n      var info = gl.getActiveUniform(program, _i109),\n          addr = gl.getUniformLocation(program, info.name);\n      parseUniform(info, addr, this);\n    }\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGLUniforms, [{\n    key: "setValue",\n    value: function setValue(gl, name, value, textures) {\n      var u = this.map[name];\n      if (u !== undefined) u.setValue(gl, value, textures);\n    }\n  }, {\n    key: "setOptional",\n    value: function setOptional(gl, object, name) {\n      var v = object[name];\n      if (v !== undefined) this.setValue(gl, name, v);\n    }\n  }], [{\n    key: "upload",\n    value: function upload(gl, seq, values, textures) {\n      for (var _i110 = 0, n = seq.length; _i110 !== n; ++_i110) {\n        var u = seq[_i110],\n            v = values[u.id];\n\n        if (v.needsUpdate !== false) {\n          // note: always updating when .needsUpdate is undefined\n          u.setValue(gl, v.value, textures);\n        }\n      }\n    }\n  }, {\n    key: "seqWithValue",\n    value: function seqWithValue(seq, values) {\n      var r = [];\n\n      for (var _i111 = 0, n = seq.length; _i111 !== n; ++_i111) {\n        var u = seq[_i111];\n        if (u.id in values) r.push(u);\n      }\n\n      return r;\n    }\n  }]);\n\n  return WebGLUniforms;\n}();\n\nfunction WebGLShader(gl, type, string) {\n  var shader = gl.createShader(type);\n  gl.shaderSource(shader, string);\n  gl.compileShader(shader);\n  return shader;\n}\n\nvar programIdCount = 0;\n\nfunction handleSource(string, errorLine) {\n  var lines = string.split(\'\\n\');\n  var lines2 = [];\n  var from = Math.max(errorLine - 6, 0);\n  var to = Math.min(errorLine + 6, lines.length);\n\n  for (var _i112 = from; _i112 < to; _i112++) {\n    var line = _i112 + 1;\n    lines2.push("".concat(line === errorLine ? \'>\' : \' \', " ").concat(line, ": ").concat(lines[_i112]));\n  }\n\n  return lines2.join(\'\\n\');\n}\n\nfunction getEncodingComponents(encoding) {\n  switch (encoding) {\n    case LinearEncoding:\n      return [\'Linear\', \'( value )\'];\n\n    case sRGBEncoding:\n      return [\'sRGB\', \'( value )\'];\n\n    default:\n      console.warn(\'THREE.WebGLProgram: Unsupported encoding:\', encoding);\n      return [\'Linear\', \'( value )\'];\n  }\n}\n\nfunction getShaderErrors(gl, shader, type) {\n  var status = gl.getShaderParameter(shader, 35713);\n  var errors = gl.getShaderInfoLog(shader).trim();\n  if (status && errors === \'\') return \'\';\n  var errorMatches = /ERROR: 0:(\\d+)/.exec(errors);\n\n  if (errorMatches) {\n    // --enable-privileged-webgl-extension\n    // console.log( \'**\' + type + \'**\', gl.getExtension( \'WEBGL_debug_shaders\' ).getTranslatedShaderSource( shader ) );\n    var errorLine = parseInt(errorMatches[1]);\n    return type.toUpperCase() + \'\\n\\n\' + errors + \'\\n\\n\' + handleSource(gl.getShaderSource(shader), errorLine);\n  } else {\n    return errors;\n  }\n}\n\nfunction getTexelEncodingFunction(functionName, encoding) {\n  var components = getEncodingComponents(encoding);\n  return \'vec4 \' + functionName + \'( vec4 value ) { return LinearTo\' + components[0] + components[1] + \'; }\';\n}\n\nfunction getToneMappingFunction(functionName, toneMapping) {\n  var toneMappingName;\n\n  switch (toneMapping) {\n    case LinearToneMapping:\n      toneMappingName = \'Linear\';\n      break;\n\n    case ReinhardToneMapping:\n      toneMappingName = \'Reinhard\';\n      break;\n\n    case CineonToneMapping:\n      toneMappingName = \'OptimizedCineon\';\n      break;\n\n    case ACESFilmicToneMapping:\n      toneMappingName = \'ACESFilmic\';\n      break;\n\n    case CustomToneMapping:\n      toneMappingName = \'Custom\';\n      break;\n\n    default:\n      console.warn(\'THREE.WebGLProgram: Unsupported toneMapping:\', toneMapping);\n      toneMappingName = \'Linear\';\n  }\n\n  return \'vec3 \' + functionName + \'( vec3 color ) { return \' + toneMappingName + \'ToneMapping( color ); }\';\n}\n\nfunction generateExtensions(parameters) {\n  var chunks = [parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === \'physical\' ? \'#extension GL_OES_standard_derivatives : enable\' : \'\', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? \'#extension GL_EXT_frag_depth : enable\' : \'\', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? \'#extension GL_EXT_draw_buffers : require\' : \'\', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? \'#extension GL_EXT_shader_texture_lod : enable\' : \'\'];\n  return chunks.filter(filterEmptyLine).join(\'\\n\');\n}\n\nfunction generateDefines(defines) {\n  var chunks = [];\n\n  for (var name in defines) {\n    var _value4 = defines[name];\n    if (_value4 === false) continue;\n    chunks.push(\'#define \' + name + \' \' + _value4);\n  }\n\n  return chunks.join(\'\\n\');\n}\n\nfunction fetchAttributeLocations(gl, program) {\n  var attributes = {};\n  var n = gl.getProgramParameter(program, 35721);\n\n  for (var _i113 = 0; _i113 < n; _i113++) {\n    var info = gl.getActiveAttrib(program, _i113);\n    var name = info.name;\n    var locationSize = 1;\n    if (info.type === 35674) locationSize = 2;\n    if (info.type === 35675) locationSize = 3;\n    if (info.type === 35676) locationSize = 4; // console.log( \'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\', name, i );\n\n    attributes[name] = {\n      type: info.type,\n      location: gl.getAttribLocation(program, name),\n      locationSize: locationSize\n    };\n  }\n\n  return attributes;\n}\n\nfunction filterEmptyLine(string) {\n  return string !== \'\';\n}\n\nfunction replaceLightNums(string, parameters) {\n  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);\n}\n\nfunction replaceClippingPlaneNums(string, parameters) {\n  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);\n} // Resolve Includes\n\n\nvar includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes(string) {\n  return string.replace(includePattern, includeReplacer);\n}\n\nfunction includeReplacer(match, include) {\n  var string = ShaderChunk[include];\n\n  if (string === undefined) {\n    throw new Error(\'Can not resolve #include <\' + include + \'>\');\n  }\n\n  return resolveIncludes(string);\n} // Unroll Loops\n\n\nvar deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\nvar unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops(string) {\n  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);\n}\n\nfunction deprecatedLoopReplacer(match, start, end, snippet) {\n  console.warn(\'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.\');\n  return loopReplacer(match, start, end, snippet);\n}\n\nfunction loopReplacer(match, start, end, snippet) {\n  var string = \'\';\n\n  for (var _i114 = parseInt(start); _i114 < parseInt(end); _i114++) {\n    string += snippet.replace(/\\[\\s*i\\s*\\]/g, \'[ \' + _i114 + \' ]\').replace(/UNROLLED_LOOP_INDEX/g, _i114);\n  }\n\n  return string;\n} //\n\n\nfunction generatePrecision(parameters) {\n  var precisionstring = \'precision \' + parameters.precision + \' float;\\nprecision \' + parameters.precision + \' int;\';\n\n  if (parameters.precision === \'highp\') {\n    precisionstring += \'\\n#define HIGH_PRECISION\';\n  } else if (parameters.precision === \'mediump\') {\n    precisionstring += \'\\n#define MEDIUM_PRECISION\';\n  } else if (parameters.precision === \'lowp\') {\n    precisionstring += \'\\n#define LOW_PRECISION\';\n  }\n\n  return precisionstring;\n}\n\nfunction generateShadowMapTypeDefine(parameters) {\n  var shadowMapTypeDefine = \'SHADOWMAP_TYPE_BASIC\';\n\n  if (parameters.shadowMapType === PCFShadowMap) {\n    shadowMapTypeDefine = \'SHADOWMAP_TYPE_PCF\';\n  } else if (parameters.shadowMapType === PCFSoftShadowMap) {\n    shadowMapTypeDefine = \'SHADOWMAP_TYPE_PCF_SOFT\';\n  } else if (parameters.shadowMapType === VSMShadowMap) {\n    shadowMapTypeDefine = \'SHADOWMAP_TYPE_VSM\';\n  }\n\n  return shadowMapTypeDefine;\n}\n\nfunction generateEnvMapTypeDefine(parameters) {\n  var envMapTypeDefine = \'ENVMAP_TYPE_CUBE\';\n\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeReflectionMapping:\n      case CubeRefractionMapping:\n        envMapTypeDefine = \'ENVMAP_TYPE_CUBE\';\n        break;\n\n      case CubeUVReflectionMapping:\n        envMapTypeDefine = \'ENVMAP_TYPE_CUBE_UV\';\n        break;\n    }\n  }\n\n  return envMapTypeDefine;\n}\n\nfunction generateEnvMapModeDefine(parameters) {\n  var envMapModeDefine = \'ENVMAP_MODE_REFLECTION\';\n\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeRefractionMapping:\n        envMapModeDefine = \'ENVMAP_MODE_REFRACTION\';\n        break;\n    }\n  }\n\n  return envMapModeDefine;\n}\n\nfunction generateEnvMapBlendingDefine(parameters) {\n  var envMapBlendingDefine = \'ENVMAP_BLENDING_NONE\';\n\n  if (parameters.envMap) {\n    switch (parameters.combine) {\n      case MultiplyOperation:\n        envMapBlendingDefine = \'ENVMAP_BLENDING_MULTIPLY\';\n        break;\n\n      case MixOperation:\n        envMapBlendingDefine = \'ENVMAP_BLENDING_MIX\';\n        break;\n\n      case AddOperation:\n        envMapBlendingDefine = \'ENVMAP_BLENDING_ADD\';\n        break;\n    }\n  }\n\n  return envMapBlendingDefine;\n}\n\nfunction generateCubeUVSize(parameters) {\n  var imageHeight = parameters.envMapCubeUVHeight;\n  if (imageHeight === null) return null;\n  var maxMip = Math.log2(imageHeight) - 2;\n  var texelHeight = 1.0 / imageHeight;\n  var texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return {\n    texelWidth: texelWidth,\n    texelHeight: texelHeight,\n    maxMip: maxMip\n  };\n}\n\nfunction WebGLProgram(renderer, cacheKey, parameters, bindingStates) {\n  // TODO Send this event to Three.js DevTools\n  // console.log( \'WebGLProgram\', cacheKey );\n  var gl = renderer.getContext();\n  var defines = parameters.defines;\n  var vertexShader = parameters.vertexShader;\n  var fragmentShader = parameters.fragmentShader;\n  var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);\n  var envMapTypeDefine = generateEnvMapTypeDefine(parameters);\n  var envMapModeDefine = generateEnvMapModeDefine(parameters);\n  var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);\n  var envMapCubeUVSize = generateCubeUVSize(parameters);\n  var customExtensions = parameters.isWebGL2 ? \'\' : generateExtensions(parameters);\n  var customDefines = generateDefines(defines);\n  var program = gl.createProgram();\n  var prefixVertex, prefixFragment;\n  var versionString = parameters.glslVersion ? \'#version \' + parameters.glslVersion + \'\\n\' : \'\';\n\n  if (parameters.isRawShaderMaterial) {\n    prefixVertex = [customDefines].filter(filterEmptyLine).join(\'\\n\');\n\n    if (prefixVertex.length > 0) {\n      prefixVertex += \'\\n\';\n    }\n\n    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join(\'\\n\');\n\n    if (prefixFragment.length > 0) {\n      prefixFragment += \'\\n\';\n    }\n  } else {\n    prefixVertex = [generatePrecision(parameters), \'#define SHADER_NAME \' + parameters.shaderName, customDefines, parameters.instancing ? \'#define USE_INSTANCING\' : \'\', parameters.instancingColor ? \'#define USE_INSTANCING_COLOR\' : \'\', parameters.supportsVertexTextures ? \'#define VERTEX_TEXTURES\' : \'\', parameters.useFog && parameters.fog ? \'#define USE_FOG\' : \'\', parameters.useFog && parameters.fogExp2 ? \'#define FOG_EXP2\' : \'\', parameters.map ? \'#define USE_MAP\' : \'\', parameters.envMap ? \'#define USE_ENVMAP\' : \'\', parameters.envMap ? \'#define \' + envMapModeDefine : \'\', parameters.lightMap ? \'#define USE_LIGHTMAP\' : \'\', parameters.aoMap ? \'#define USE_AOMAP\' : \'\', parameters.emissiveMap ? \'#define USE_EMISSIVEMAP\' : \'\', parameters.bumpMap ? \'#define USE_BUMPMAP\' : \'\', parameters.normalMap ? \'#define USE_NORMALMAP\' : \'\', parameters.normalMap && parameters.objectSpaceNormalMap ? \'#define OBJECTSPACE_NORMALMAP\' : \'\', parameters.normalMap && parameters.tangentSpaceNormalMap ? \'#define TANGENTSPACE_NORMALMAP\' : \'\', parameters.clearcoatMap ? \'#define USE_CLEARCOATMAP\' : \'\', parameters.clearcoatRoughnessMap ? \'#define USE_CLEARCOAT_ROUGHNESSMAP\' : \'\', parameters.clearcoatNormalMap ? \'#define USE_CLEARCOAT_NORMALMAP\' : \'\', parameters.iridescenceMap ? \'#define USE_IRIDESCENCEMAP\' : \'\', parameters.iridescenceThicknessMap ? \'#define USE_IRIDESCENCE_THICKNESSMAP\' : \'\', parameters.displacementMap && parameters.supportsVertexTextures ? \'#define USE_DISPLACEMENTMAP\' : \'\', parameters.specularMap ? \'#define USE_SPECULARMAP\' : \'\', parameters.specularIntensityMap ? \'#define USE_SPECULARINTENSITYMAP\' : \'\', parameters.specularColorMap ? \'#define USE_SPECULARCOLORMAP\' : \'\', parameters.roughnessMap ? \'#define USE_ROUGHNESSMAP\' : \'\', parameters.metalnessMap ? \'#define USE_METALNESSMAP\' : \'\', parameters.alphaMap ? \'#define USE_ALPHAMAP\' : \'\', parameters.transmission ? \'#define USE_TRANSMISSION\' : \'\', parameters.transmissionMap ? \'#define USE_TRANSMISSIONMAP\' : \'\', parameters.thicknessMap ? \'#define USE_THICKNESSMAP\' : \'\', parameters.sheenColorMap ? \'#define USE_SHEENCOLORMAP\' : \'\', parameters.sheenRoughnessMap ? \'#define USE_SHEENROUGHNESSMAP\' : \'\', parameters.vertexTangents ? \'#define USE_TANGENT\' : \'\', parameters.vertexColors ? \'#define USE_COLOR\' : \'\', parameters.vertexAlphas ? \'#define USE_COLOR_ALPHA\' : \'\', parameters.vertexUvs ? \'#define USE_UV\' : \'\', parameters.uvsVertexOnly ? \'#define UVS_VERTEX_ONLY\' : \'\', parameters.flatShading ? \'#define FLAT_SHADED\' : \'\', parameters.skinning ? \'#define USE_SKINNING\' : \'\', parameters.morphTargets ? \'#define USE_MORPHTARGETS\' : \'\', parameters.morphNormals && parameters.flatShading === false ? \'#define USE_MORPHNORMALS\' : \'\', parameters.morphColors && parameters.isWebGL2 ? \'#define USE_MORPHCOLORS\' : \'\', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? \'#define MORPHTARGETS_TEXTURE\' : \'\', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? \'#define MORPHTARGETS_TEXTURE_STRIDE \' + parameters.morphTextureStride : \'\', parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? \'#define MORPHTARGETS_COUNT \' + parameters.morphTargetsCount : \'\', parameters.doubleSided ? \'#define DOUBLE_SIDED\' : \'\', parameters.flipSided ? \'#define FLIP_SIDED\' : \'\', parameters.shadowMapEnabled ? \'#define USE_SHADOWMAP\' : \'\', parameters.shadowMapEnabled ? \'#define \' + shadowMapTypeDefine : \'\', parameters.sizeAttenuation ? \'#define USE_SIZEATTENUATION\' : \'\', parameters.logarithmicDepthBuffer ? \'#define USE_LOGDEPTHBUF\' : \'\', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? \'#define USE_LOGDEPTHBUF_EXT\' : \'\', \'uniform mat4 modelMatrix;\', \'uniform mat4 modelViewMatrix;\', \'uniform mat4 projectionMatrix;\', \'uniform mat4 viewMatrix;\', \'uniform mat3 normalMatrix;\', \'uniform vec3 cameraPosition;\', \'uniform bool isOrthographic;\', \'#ifdef USE_INSTANCING\', \'\tattribute mat4 instanceMatrix;\', \'#endif\', \'#ifdef USE_INSTANCING_COLOR\', \'\tattribute vec3 instanceColor;\', \'#endif\', \'attribute vec3 position;\', \'attribute vec3 normal;\', \'attribute vec2 uv;\', \'#ifdef USE_TANGENT\', \'\tattribute vec4 tangent;\', \'#endif\', \'#if defined( USE_COLOR_ALPHA )\', \'\tattribute vec4 color;\', \'#elif defined( USE_COLOR )\', \'\tattribute vec3 color;\', \'#endif\', \'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )\', \'\tattribute vec3 morphTarget0;\', \'\tattribute vec3 morphTarget1;\', \'\tattribute vec3 morphTarget2;\', \'\tattribute vec3 morphTarget3;\', \'\t#ifdef USE_MORPHNORMALS\', \'\t\tattribute vec3 morphNormal0;\', \'\t\tattribute vec3 morphNormal1;\', \'\t\tattribute vec3 morphNormal2;\', \'\t\tattribute vec3 morphNormal3;\', \'\t#else\', \'\t\tattribute vec3 morphTarget4;\', \'\t\tattribute vec3 morphTarget5;\', \'\t\tattribute vec3 morphTarget6;\', \'\t\tattribute vec3 morphTarget7;\', \'\t#endif\', \'#endif\', \'#ifdef USE_SKINNING\', \'\tattribute vec4 skinIndex;\', \'\tattribute vec4 skinWeight;\', \'#endif\', \'\\n\'].filter(filterEmptyLine).join(\'\\n\');\n    prefixFragment = [customExtensions, generatePrecision(parameters), \'#define SHADER_NAME \' + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? \'#define USE_FOG\' : \'\', parameters.useFog && parameters.fogExp2 ? \'#define FOG_EXP2\' : \'\', parameters.map ? \'#define USE_MAP\' : \'\', parameters.matcap ? \'#define USE_MATCAP\' : \'\', parameters.envMap ? \'#define USE_ENVMAP\' : \'\', parameters.envMap ? \'#define \' + envMapTypeDefine : \'\', parameters.envMap ? \'#define \' + envMapModeDefine : \'\', parameters.envMap ? \'#define \' + envMapBlendingDefine : \'\', envMapCubeUVSize ? \'#define CUBEUV_TEXEL_WIDTH \' + envMapCubeUVSize.texelWidth : \'\', envMapCubeUVSize ? \'#define CUBEUV_TEXEL_HEIGHT \' + envMapCubeUVSize.texelHeight : \'\', envMapCubeUVSize ? \'#define CUBEUV_MAX_MIP \' + envMapCubeUVSize.maxMip + \'.0\' : \'\', parameters.lightMap ? \'#define USE_LIGHTMAP\' : \'\', parameters.aoMap ? \'#define USE_AOMAP\' : \'\', parameters.emissiveMap ? \'#define USE_EMISSIVEMAP\' : \'\', parameters.bumpMap ? \'#define USE_BUMPMAP\' : \'\', parameters.normalMap ? \'#define USE_NORMALMAP\' : \'\', parameters.normalMap && parameters.objectSpaceNormalMap ? \'#define OBJECTSPACE_NORMALMAP\' : \'\', parameters.normalMap && parameters.tangentSpaceNormalMap ? \'#define TANGENTSPACE_NORMALMAP\' : \'\', parameters.clearcoat ? \'#define USE_CLEARCOAT\' : \'\', parameters.clearcoatMap ? \'#define USE_CLEARCOATMAP\' : \'\', parameters.clearcoatRoughnessMap ? \'#define USE_CLEARCOAT_ROUGHNESSMAP\' : \'\', parameters.clearcoatNormalMap ? \'#define USE_CLEARCOAT_NORMALMAP\' : \'\', parameters.iridescence ? \'#define USE_IRIDESCENCE\' : \'\', parameters.iridescenceMap ? \'#define USE_IRIDESCENCEMAP\' : \'\', parameters.iridescenceThicknessMap ? \'#define USE_IRIDESCENCE_THICKNESSMAP\' : \'\', parameters.specularMap ? \'#define USE_SPECULARMAP\' : \'\', parameters.specularIntensityMap ? \'#define USE_SPECULARINTENSITYMAP\' : \'\', parameters.specularColorMap ? \'#define USE_SPECULARCOLORMAP\' : \'\', parameters.roughnessMap ? \'#define USE_ROUGHNESSMAP\' : \'\', parameters.metalnessMap ? \'#define USE_METALNESSMAP\' : \'\', parameters.alphaMap ? \'#define USE_ALPHAMAP\' : \'\', parameters.alphaTest ? \'#define USE_ALPHATEST\' : \'\', parameters.sheen ? \'#define USE_SHEEN\' : \'\', parameters.sheenColorMap ? \'#define USE_SHEENCOLORMAP\' : \'\', parameters.sheenRoughnessMap ? \'#define USE_SHEENROUGHNESSMAP\' : \'\', parameters.transmission ? \'#define USE_TRANSMISSION\' : \'\', parameters.transmissionMap ? \'#define USE_TRANSMISSIONMAP\' : \'\', parameters.thicknessMap ? \'#define USE_THICKNESSMAP\' : \'\', parameters.decodeVideoTexture ? \'#define DECODE_VIDEO_TEXTURE\' : \'\', parameters.vertexTangents ? \'#define USE_TANGENT\' : \'\', parameters.vertexColors || parameters.instancingColor ? \'#define USE_COLOR\' : \'\', parameters.vertexAlphas ? \'#define USE_COLOR_ALPHA\' : \'\', parameters.vertexUvs ? \'#define USE_UV\' : \'\', parameters.uvsVertexOnly ? \'#define UVS_VERTEX_ONLY\' : \'\', parameters.gradientMap ? \'#define USE_GRADIENTMAP\' : \'\', parameters.flatShading ? \'#define FLAT_SHADED\' : \'\', parameters.doubleSided ? \'#define DOUBLE_SIDED\' : \'\', parameters.flipSided ? \'#define FLIP_SIDED\' : \'\', parameters.shadowMapEnabled ? \'#define USE_SHADOWMAP\' : \'\', parameters.shadowMapEnabled ? \'#define \' + shadowMapTypeDefine : \'\', parameters.premultipliedAlpha ? \'#define PREMULTIPLIED_ALPHA\' : \'\', parameters.physicallyCorrectLights ? \'#define PHYSICALLY_CORRECT_LIGHTS\' : \'\', parameters.logarithmicDepthBuffer ? \'#define USE_LOGDEPTHBUF\' : \'\', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? \'#define USE_LOGDEPTHBUF_EXT\' : \'\', \'uniform mat4 viewMatrix;\', \'uniform vec3 cameraPosition;\', \'uniform bool isOrthographic;\', parameters.toneMapping !== NoToneMapping ? \'#define TONE_MAPPING\' : \'\', parameters.toneMapping !== NoToneMapping ? ShaderChunk[\'tonemapping_pars_fragment\'] : \'\', // this code is required here because it is used by the toneMapping() function defined below\n    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction(\'toneMapping\', parameters.toneMapping) : \'\', parameters.dithering ? \'#define DITHERING\' : \'\', parameters.opaque ? \'#define OPAQUE\' : \'\', ShaderChunk[\'encodings_pars_fragment\'], // this code is required here because it is used by the various encoding/decoding function defined below\n    getTexelEncodingFunction(\'linearToOutputTexel\', parameters.outputEncoding), parameters.useDepthPacking ? \'#define DEPTH_PACKING \' + parameters.depthPacking : \'\', \'\\n\'].filter(filterEmptyLine).join(\'\\n\');\n  }\n\n  vertexShader = resolveIncludes(vertexShader);\n  vertexShader = replaceLightNums(vertexShader, parameters);\n  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);\n  fragmentShader = resolveIncludes(fragmentShader);\n  fragmentShader = replaceLightNums(fragmentShader, parameters);\n  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\n  vertexShader = unrollLoops(vertexShader);\n  fragmentShader = unrollLoops(fragmentShader);\n\n  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {\n    // GLSL 3.0 conversion for built-in materials and ShaderMaterial\n    versionString = \'#version 300 es\\n\';\n    prefixVertex = [\'precision mediump sampler2DArray;\', \'#define attribute in\', \'#define varying out\', \'#define texture2D texture\'].join(\'\\n\') + \'\\n\' + prefixVertex;\n    prefixFragment = [\'#define varying in\', parameters.glslVersion === GLSL3 ? \'\' : \'layout(location = 0) out highp vec4 pc_fragColor;\', parameters.glslVersion === GLSL3 ? \'\' : \'#define gl_FragColor pc_fragColor\', \'#define gl_FragDepthEXT gl_FragDepth\', \'#define texture2D texture\', \'#define textureCube texture\', \'#define texture2DProj textureProj\', \'#define texture2DLodEXT textureLod\', \'#define texture2DProjLodEXT textureProjLod\', \'#define textureCubeLodEXT textureLod\', \'#define texture2DGradEXT textureGrad\', \'#define texture2DProjGradEXT textureProjGrad\', \'#define textureCubeGradEXT textureGrad\'].join(\'\\n\') + \'\\n\' + prefixFragment;\n  }\n\n  var vertexGlsl = versionString + prefixVertex + vertexShader;\n  var fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( \'*VERTEX*\', vertexGlsl );\n  // console.log( \'*FRAGMENT*\', fragmentGlsl );\n\n  var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);\n  var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);\n  gl.attachShader(program, glVertexShader);\n  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.\n\n  if (parameters.index0AttributeName !== undefined) {\n    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n  } else if (parameters.morphTargets === true) {\n    // programs with morphTargets displace position out of attribute 0\n    gl.bindAttribLocation(program, 0, \'position\');\n  }\n\n  gl.linkProgram(program); // check for link errors\n\n  if (renderer.debug.checkShaderErrors) {\n    var programLog = gl.getProgramInfoLog(program).trim();\n    var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n    var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n    var runnable = true;\n    var haveDiagnostics = true;\n\n    if (gl.getProgramParameter(program, 35714) === false) {\n      runnable = false;\n      var vertexErrors = getShaderErrors(gl, glVertexShader, \'vertex\');\n      var fragmentErrors = getShaderErrors(gl, glFragmentShader, \'fragment\');\n      console.error(\'THREE.WebGLProgram: Shader Error \' + gl.getError() + \' - \' + \'VALIDATE_STATUS \' + gl.getProgramParameter(program, 35715) + \'\\n\\n\' + \'Program Info Log: \' + programLog + \'\\n\' + vertexErrors + \'\\n\' + fragmentErrors);\n    } else if (programLog !== \'\') {\n      console.warn(\'THREE.WebGLProgram: Program Info Log:\', programLog);\n    } else if (vertexLog === \'\' || fragmentLog === \'\') {\n      haveDiagnostics = false;\n    }\n\n    if (haveDiagnostics) {\n      this.diagnostics = {\n        runnable: runnable,\n        programLog: programLog,\n        vertexShader: {\n          log: vertexLog,\n          prefix: prefixVertex\n        },\n        fragmentShader: {\n          log: fragmentLog,\n          prefix: prefixFragment\n        }\n      };\n    }\n  } // Clean up\n  // Crashes in iOS9 and iOS10. #18402\n  // gl.detachShader( program, glVertexShader );\n  // gl.detachShader( program, glFragmentShader );\n\n\n  gl.deleteShader(glVertexShader);\n  gl.deleteShader(glFragmentShader); // set up caching for uniform locations\n\n  var cachedUniforms;\n\n  this.getUniforms = function () {\n    if (cachedUniforms === undefined) {\n      cachedUniforms = new WebGLUniforms(gl, program);\n    }\n\n    return cachedUniforms;\n  }; // set up caching for attribute locations\n\n\n  var cachedAttributes;\n\n  this.getAttributes = function () {\n    if (cachedAttributes === undefined) {\n      cachedAttributes = fetchAttributeLocations(gl, program);\n    }\n\n    return cachedAttributes;\n  }; // free resource\n\n\n  this.destroy = function () {\n    bindingStates.releaseStatesOfProgram(this);\n    gl.deleteProgram(program);\n    this.program = undefined;\n  }; //\n\n\n  this.name = parameters.shaderName;\n  this.id = programIdCount++;\n  this.cacheKey = cacheKey;\n  this.usedTimes = 1;\n  this.program = program;\n  this.vertexShader = glVertexShader;\n  this.fragmentShader = glFragmentShader;\n  return this;\n}\n\nvar _id = 0;\n\nvar WebGLShaderCache = /*#__PURE__*/function () {\n  function WebGLShaderCache() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGLShaderCache);\n\n    this.shaderCache = new Map();\n    this.materialCache = new Map();\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGLShaderCache, [{\n    key: "update",\n    value: function update(material) {\n      var vertexShader = material.vertexShader;\n      var fragmentShader = material.fragmentShader;\n\n      var vertexShaderStage = this._getShaderStage(vertexShader);\n\n      var fragmentShaderStage = this._getShaderStage(fragmentShader);\n\n      var materialShaders = this._getShaderCacheForMaterial(material);\n\n      if (materialShaders.has(vertexShaderStage) === false) {\n        materialShaders.add(vertexShaderStage);\n        vertexShaderStage.usedTimes++;\n      }\n\n      if (materialShaders.has(fragmentShaderStage) === false) {\n        materialShaders.add(fragmentShaderStage);\n        fragmentShaderStage.usedTimes++;\n      }\n\n      return this;\n    }\n  }, {\n    key: "remove",\n    value: function remove(material) {\n      var materialShaders = this.materialCache.get(material);\n\n      var _iterator = _createForOfIteratorHelper(materialShaders),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var shaderStage = _step.value;\n          shaderStage.usedTimes--;\n          if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.materialCache.delete(material);\n      return this;\n    }\n  }, {\n    key: "getVertexShaderID",\n    value: function getVertexShaderID(material) {\n      return this._getShaderStage(material.vertexShader).id;\n    }\n  }, {\n    key: "getFragmentShaderID",\n    value: function getFragmentShaderID(material) {\n      return this._getShaderStage(material.fragmentShader).id;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.shaderCache.clear();\n      this.materialCache.clear();\n    }\n  }, {\n    key: "_getShaderCacheForMaterial",\n    value: function _getShaderCacheForMaterial(material) {\n      var cache = this.materialCache;\n\n      if (cache.has(material) === false) {\n        cache.set(material, new Set());\n      }\n\n      return cache.get(material);\n    }\n  }, {\n    key: "_getShaderStage",\n    value: function _getShaderStage(code) {\n      var cache = this.shaderCache;\n\n      if (cache.has(code) === false) {\n        var stage = new WebGLShaderStage(code);\n        cache.set(code, stage);\n      }\n\n      return cache.get(code);\n    }\n  }]);\n\n  return WebGLShaderCache;\n}();\n\nvar WebGLShaderStage = /*#__PURE__*/(0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(function WebGLShaderStage(code) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGLShaderStage);\n\n  this.id = _id++;\n  this.code = code;\n  this.usedTimes = 0;\n});\n\nfunction WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {\n  var _programLayers = new Layers();\n\n  var _customShaders = new WebGLShaderCache();\n\n  var programs = [];\n  var isWebGL2 = capabilities.isWebGL2;\n  var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n  var vertexTextures = capabilities.vertexTextures;\n  var precision = capabilities.precision;\n  var shaderIDs = {\n    MeshDepthMaterial: \'depth\',\n    MeshDistanceMaterial: \'distanceRGBA\',\n    MeshNormalMaterial: \'normal\',\n    MeshBasicMaterial: \'basic\',\n    MeshLambertMaterial: \'lambert\',\n    MeshPhongMaterial: \'phong\',\n    MeshToonMaterial: \'toon\',\n    MeshStandardMaterial: \'physical\',\n    MeshPhysicalMaterial: \'physical\',\n    MeshMatcapMaterial: \'matcap\',\n    LineBasicMaterial: \'basic\',\n    LineDashedMaterial: \'dashed\',\n    PointsMaterial: \'points\',\n    ShadowMaterial: \'shadow\',\n    SpriteMaterial: \'sprite\'\n  };\n\n  function getParameters(material, lights, shadows, scene, object) {\n    var fog = scene.fog;\n    var geometry = object.geometry;\n    var environment = material.isMeshStandardMaterial ? scene.environment : null;\n    var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n    var envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;\n    var shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene\n    // (not to blow over maxLights budget)\n\n    if (material.precision !== null) {\n      precision = capabilities.getMaxPrecision(material.precision);\n\n      if (precision !== material.precision) {\n        console.warn(\'THREE.WebGLProgram.getParameters:\', material.precision, \'not supported, using\', precision, \'instead.\');\n      }\n    } //\n\n\n    var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n    var morphTextureStride = 0;\n    if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;\n    if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;\n    if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3; //\n\n    var vertexShader, fragmentShader;\n    var customVertexShaderID, customFragmentShaderID;\n\n    if (shaderID) {\n      var shader = ShaderLib[shaderID];\n      vertexShader = shader.vertexShader;\n      fragmentShader = shader.fragmentShader;\n    } else {\n      vertexShader = material.vertexShader;\n      fragmentShader = material.fragmentShader;\n\n      _customShaders.update(material);\n\n      customVertexShaderID = _customShaders.getVertexShaderID(material);\n      customFragmentShaderID = _customShaders.getFragmentShaderID(material);\n    }\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var useAlphaTest = material.alphaTest > 0;\n    var useClearcoat = material.clearcoat > 0;\n    var useIridescence = material.iridescence > 0;\n    var parameters = {\n      isWebGL2: isWebGL2,\n      shaderID: shaderID,\n      shaderName: material.type,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      defines: material.defines,\n      customVertexShaderID: customVertexShaderID,\n      customFragmentShaderID: customFragmentShaderID,\n      isRawShaderMaterial: material.isRawShaderMaterial === true,\n      glslVersion: material.glslVersion,\n      precision: precision,\n      instancing: object.isInstancedMesh === true,\n      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n      supportsVertexTextures: vertexTextures,\n      outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,\n      map: !!material.map,\n      matcap: !!material.matcap,\n      envMap: !!envMap,\n      envMapMode: envMap && envMap.mapping,\n      envMapCubeUVHeight: envMapCubeUVHeight,\n      lightMap: !!material.lightMap,\n      aoMap: !!material.aoMap,\n      emissiveMap: !!material.emissiveMap,\n      bumpMap: !!material.bumpMap,\n      normalMap: !!material.normalMap,\n      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n      decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,\n      clearcoat: useClearcoat,\n      clearcoatMap: useClearcoat && !!material.clearcoatMap,\n      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,\n      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,\n      iridescence: useIridescence,\n      iridescenceMap: useIridescence && !!material.iridescenceMap,\n      iridescenceThicknessMap: useIridescence && !!material.iridescenceThicknessMap,\n      displacementMap: !!material.displacementMap,\n      roughnessMap: !!material.roughnessMap,\n      metalnessMap: !!material.metalnessMap,\n      specularMap: !!material.specularMap,\n      specularIntensityMap: !!material.specularIntensityMap,\n      specularColorMap: !!material.specularColorMap,\n      opaque: material.transparent === false && material.blending === NormalBlending,\n      alphaMap: !!material.alphaMap,\n      alphaTest: useAlphaTest,\n      gradientMap: !!material.gradientMap,\n      sheen: material.sheen > 0,\n      sheenColorMap: !!material.sheenColorMap,\n      sheenRoughnessMap: !!material.sheenRoughnessMap,\n      transmission: material.transmission > 0,\n      transmissionMap: !!material.transmissionMap,\n      thicknessMap: !!material.thicknessMap,\n      combine: material.combine,\n      vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,\n      vertexColors: material.vertexColors,\n      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,\n      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,\n      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.iridescenceMap || !!material.iridescenceThicknessMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,\n      fog: !!fog,\n      useFog: material.fog === true,\n      fogExp2: fog && fog.isFogExp2,\n      flatShading: !!material.flatShading,\n      sizeAttenuation: material.sizeAttenuation,\n      logarithmicDepthBuffer: logarithmicDepthBuffer,\n      skinning: object.isSkinnedMesh === true,\n      morphTargets: geometry.morphAttributes.position !== undefined,\n      morphNormals: geometry.morphAttributes.normal !== undefined,\n      morphColors: geometry.morphAttributes.color !== undefined,\n      morphTargetsCount: morphTargetsCount,\n      morphTextureStride: morphTextureStride,\n      numDirLights: lights.directional.length,\n      numPointLights: lights.point.length,\n      numSpotLights: lights.spot.length,\n      numRectAreaLights: lights.rectArea.length,\n      numHemiLights: lights.hemi.length,\n      numDirLightShadows: lights.directionalShadowMap.length,\n      numPointLightShadows: lights.pointShadowMap.length,\n      numSpotLightShadows: lights.spotShadowMap.length,\n      numClippingPlanes: clipping.numPlanes,\n      numClipIntersection: clipping.numIntersection,\n      dithering: material.dithering,\n      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n      shadowMapType: renderer.shadowMap.type,\n      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n      physicallyCorrectLights: renderer.physicallyCorrectLights,\n      premultipliedAlpha: material.premultipliedAlpha,\n      doubleSided: material.side === DoubleSide,\n      flipSided: material.side === BackSide,\n      useDepthPacking: !!material.depthPacking,\n      depthPacking: material.depthPacking || 0,\n      index0AttributeName: material.index0AttributeName,\n      extensionDerivatives: material.extensions && material.extensions.derivatives,\n      extensionFragDepth: material.extensions && material.extensions.fragDepth,\n      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n      rendererExtensionFragDepth: isWebGL2 || extensions.has(\'EXT_frag_depth\'),\n      rendererExtensionDrawBuffers: isWebGL2 || extensions.has(\'WEBGL_draw_buffers\'),\n      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has(\'EXT_shader_texture_lod\'),\n      customProgramCacheKey: material.customProgramCacheKey()\n    };\n    return parameters;\n  }\n\n  function getProgramCacheKey(parameters) {\n    var array = [];\n\n    if (parameters.shaderID) {\n      array.push(parameters.shaderID);\n    } else {\n      array.push(parameters.customVertexShaderID);\n      array.push(parameters.customFragmentShaderID);\n    }\n\n    if (parameters.defines !== undefined) {\n      for (var name in parameters.defines) {\n        array.push(name);\n        array.push(parameters.defines[name]);\n      }\n    }\n\n    if (parameters.isRawShaderMaterial === false) {\n      getProgramCacheKeyParameters(array, parameters);\n      getProgramCacheKeyBooleans(array, parameters);\n      array.push(renderer.outputEncoding);\n    }\n\n    array.push(parameters.customProgramCacheKey);\n    return array.join();\n  }\n\n  function getProgramCacheKeyParameters(array, parameters) {\n    array.push(parameters.precision);\n    array.push(parameters.outputEncoding);\n    array.push(parameters.envMapMode);\n    array.push(parameters.envMapCubeUVHeight);\n    array.push(parameters.combine);\n    array.push(parameters.vertexUvs);\n    array.push(parameters.fogExp2);\n    array.push(parameters.sizeAttenuation);\n    array.push(parameters.morphTargetsCount);\n    array.push(parameters.morphAttributeCount);\n    array.push(parameters.numDirLights);\n    array.push(parameters.numPointLights);\n    array.push(parameters.numSpotLights);\n    array.push(parameters.numHemiLights);\n    array.push(parameters.numRectAreaLights);\n    array.push(parameters.numDirLightShadows);\n    array.push(parameters.numPointLightShadows);\n    array.push(parameters.numSpotLightShadows);\n    array.push(parameters.shadowMapType);\n    array.push(parameters.toneMapping);\n    array.push(parameters.numClippingPlanes);\n    array.push(parameters.numClipIntersection);\n    array.push(parameters.depthPacking);\n  }\n\n  function getProgramCacheKeyBooleans(array, parameters) {\n    _programLayers.disableAll();\n\n    if (parameters.isWebGL2) _programLayers.enable(0);\n    if (parameters.supportsVertexTextures) _programLayers.enable(1);\n    if (parameters.instancing) _programLayers.enable(2);\n    if (parameters.instancingColor) _programLayers.enable(3);\n    if (parameters.map) _programLayers.enable(4);\n    if (parameters.matcap) _programLayers.enable(5);\n    if (parameters.envMap) _programLayers.enable(6);\n    if (parameters.lightMap) _programLayers.enable(7);\n    if (parameters.aoMap) _programLayers.enable(8);\n    if (parameters.emissiveMap) _programLayers.enable(9);\n    if (parameters.bumpMap) _programLayers.enable(10);\n    if (parameters.normalMap) _programLayers.enable(11);\n    if (parameters.objectSpaceNormalMap) _programLayers.enable(12);\n    if (parameters.tangentSpaceNormalMap) _programLayers.enable(13);\n    if (parameters.clearcoat) _programLayers.enable(14);\n    if (parameters.clearcoatMap) _programLayers.enable(15);\n    if (parameters.clearcoatRoughnessMap) _programLayers.enable(16);\n    if (parameters.clearcoatNormalMap) _programLayers.enable(17);\n    if (parameters.iridescence) _programLayers.enable(18);\n    if (parameters.iridescenceMap) _programLayers.enable(19);\n    if (parameters.iridescenceThicknessMap) _programLayers.enable(20);\n    if (parameters.displacementMap) _programLayers.enable(21);\n    if (parameters.specularMap) _programLayers.enable(22);\n    if (parameters.roughnessMap) _programLayers.enable(23);\n    if (parameters.metalnessMap) _programLayers.enable(24);\n    if (parameters.gradientMap) _programLayers.enable(25);\n    if (parameters.alphaMap) _programLayers.enable(26);\n    if (parameters.alphaTest) _programLayers.enable(27);\n    if (parameters.vertexColors) _programLayers.enable(28);\n    if (parameters.vertexAlphas) _programLayers.enable(29);\n    if (parameters.vertexUvs) _programLayers.enable(30);\n    if (parameters.vertexTangents) _programLayers.enable(31);\n    if (parameters.uvsVertexOnly) _programLayers.enable(32);\n    if (parameters.fog) _programLayers.enable(33);\n    array.push(_programLayers.mask);\n\n    _programLayers.disableAll();\n\n    if (parameters.useFog) _programLayers.enable(0);\n    if (parameters.flatShading) _programLayers.enable(1);\n    if (parameters.logarithmicDepthBuffer) _programLayers.enable(2);\n    if (parameters.skinning) _programLayers.enable(3);\n    if (parameters.morphTargets) _programLayers.enable(4);\n    if (parameters.morphNormals) _programLayers.enable(5);\n    if (parameters.morphColors) _programLayers.enable(6);\n    if (parameters.premultipliedAlpha) _programLayers.enable(7);\n    if (parameters.shadowMapEnabled) _programLayers.enable(8);\n    if (parameters.physicallyCorrectLights) _programLayers.enable(9);\n    if (parameters.doubleSided) _programLayers.enable(10);\n    if (parameters.flipSided) _programLayers.enable(11);\n    if (parameters.useDepthPacking) _programLayers.enable(12);\n    if (parameters.dithering) _programLayers.enable(13);\n    if (parameters.specularIntensityMap) _programLayers.enable(14);\n    if (parameters.specularColorMap) _programLayers.enable(15);\n    if (parameters.transmission) _programLayers.enable(16);\n    if (parameters.transmissionMap) _programLayers.enable(17);\n    if (parameters.thicknessMap) _programLayers.enable(18);\n    if (parameters.sheen) _programLayers.enable(19);\n    if (parameters.sheenColorMap) _programLayers.enable(20);\n    if (parameters.sheenRoughnessMap) _programLayers.enable(21);\n    if (parameters.decodeVideoTexture) _programLayers.enable(22);\n    if (parameters.opaque) _programLayers.enable(23);\n    array.push(_programLayers.mask);\n  }\n\n  function getUniforms(material) {\n    var shaderID = shaderIDs[material.type];\n    var uniforms;\n\n    if (shaderID) {\n      var shader = ShaderLib[shaderID];\n      uniforms = UniformsUtils.clone(shader.uniforms);\n    } else {\n      uniforms = material.uniforms;\n    }\n\n    return uniforms;\n  }\n\n  function acquireProgram(parameters, cacheKey) {\n    var program; // Check if code has been already compiled\n\n    for (var p = 0, pl = programs.length; p < pl; p++) {\n      var preexistingProgram = programs[p];\n\n      if (preexistingProgram.cacheKey === cacheKey) {\n        program = preexistingProgram;\n        ++program.usedTimes;\n        break;\n      }\n    }\n\n    if (program === undefined) {\n      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n      programs.push(program);\n    }\n\n    return program;\n  }\n\n  function releaseProgram(program) {\n    if (--program.usedTimes === 0) {\n      // Remove from unordered set\n      var _i115 = programs.indexOf(program);\n\n      programs[_i115] = programs[programs.length - 1];\n      programs.pop(); // Free WebGL resources\n\n      program.destroy();\n    }\n  }\n\n  function releaseShaderCache(material) {\n    _customShaders.remove(material);\n  }\n\n  function dispose() {\n    _customShaders.dispose();\n  }\n\n  return {\n    getParameters: getParameters,\n    getProgramCacheKey: getProgramCacheKey,\n    getUniforms: getUniforms,\n    acquireProgram: acquireProgram,\n    releaseProgram: releaseProgram,\n    releaseShaderCache: releaseShaderCache,\n    // Exposed for resource monitoring & error feedback via renderer.info:\n    programs: programs,\n    dispose: dispose\n  };\n}\n\nfunction WebGLProperties() {\n  var properties = new WeakMap();\n\n  function get(object) {\n    var map = properties.get(object);\n\n    if (map === undefined) {\n      map = {};\n      properties.set(object, map);\n    }\n\n    return map;\n  }\n\n  function remove(object) {\n    properties.delete(object);\n  }\n\n  function update(object, key, value) {\n    properties.get(object)[key] = value;\n  }\n\n  function dispose() {\n    properties = new WeakMap();\n  }\n\n  return {\n    get: get,\n    remove: remove,\n    update: update,\n    dispose: dispose\n  };\n}\n\nfunction painterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.material.id !== b.material.id) {\n    return a.material.id - b.material.id;\n  } else if (a.z !== b.z) {\n    return a.z - b.z;\n  } else {\n    return a.id - b.id;\n  }\n}\n\nfunction reversePainterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return a.id - b.id;\n  }\n}\n\nfunction WebGLRenderList() {\n  var renderItems = [];\n  var renderItemsIndex = 0;\n  var opaque = [];\n  var transmissive = [];\n  var transparent = [];\n\n  function init() {\n    renderItemsIndex = 0;\n    opaque.length = 0;\n    transmissive.length = 0;\n    transparent.length = 0;\n  }\n\n  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {\n    var renderItem = renderItems[renderItemsIndex];\n\n    if (renderItem === undefined) {\n      renderItem = {\n        id: object.id,\n        object: object,\n        geometry: geometry,\n        material: material,\n        groupOrder: groupOrder,\n        renderOrder: object.renderOrder,\n        z: z,\n        group: group\n      };\n      renderItems[renderItemsIndex] = renderItem;\n    } else {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = object.renderOrder;\n      renderItem.z = z;\n      renderItem.group = group;\n    }\n\n    renderItemsIndex++;\n    return renderItem;\n  }\n\n  function push(object, geometry, material, groupOrder, z, group) {\n    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n    if (material.transmission > 0.0) {\n      transmissive.push(renderItem);\n    } else if (material.transparent === true) {\n      transparent.push(renderItem);\n    } else {\n      opaque.push(renderItem);\n    }\n  }\n\n  function unshift(object, geometry, material, groupOrder, z, group) {\n    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n    if (material.transmission > 0.0) {\n      transmissive.unshift(renderItem);\n    } else if (material.transparent === true) {\n      transparent.unshift(renderItem);\n    } else {\n      opaque.unshift(renderItem);\n    }\n  }\n\n  function sort(customOpaqueSort, customTransparentSort) {\n    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);\n    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);\n    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n\n  function finish() {\n    // Clear references from inactive renderItems in the list\n    for (var _i116 = renderItemsIndex, il = renderItems.length; _i116 < il; _i116++) {\n      var renderItem = renderItems[_i116];\n      if (renderItem.id === null) break;\n      renderItem.id = null;\n      renderItem.object = null;\n      renderItem.geometry = null;\n      renderItem.material = null;\n      renderItem.group = null;\n    }\n  }\n\n  return {\n    opaque: opaque,\n    transmissive: transmissive,\n    transparent: transparent,\n    init: init,\n    push: push,\n    unshift: unshift,\n    finish: finish,\n    sort: sort\n  };\n}\n\nfunction WebGLRenderLists() {\n  var lists = new WeakMap();\n\n  function get(scene, renderCallDepth) {\n    var list;\n\n    if (lists.has(scene) === false) {\n      list = new WebGLRenderList();\n      lists.set(scene, [list]);\n    } else {\n      if (renderCallDepth >= lists.get(scene).length) {\n        list = new WebGLRenderList();\n        lists.get(scene).push(list);\n      } else {\n        list = lists.get(scene)[renderCallDepth];\n      }\n    }\n\n    return list;\n  }\n\n  function dispose() {\n    lists = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nfunction UniformsCache() {\n  var lights = {};\n  return {\n    get: function get(light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      var uniforms;\n\n      switch (light.type) {\n        case \'DirectionalLight\':\n          uniforms = {\n            direction: new Vector3(),\n            color: new Color()\n          };\n          break;\n\n        case \'SpotLight\':\n          uniforms = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0\n          };\n          break;\n\n        case \'PointLight\':\n          uniforms = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0\n          };\n          break;\n\n        case \'HemisphereLight\':\n          uniforms = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color()\n          };\n          break;\n\n        case \'RectAreaLight\':\n          uniforms = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3()\n          };\n          break;\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nfunction ShadowUniformsCache() {\n  var lights = {};\n  return {\n    get: function get(light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      var uniforms;\n\n      switch (light.type) {\n        case \'DirectionalLight\':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case \'SpotLight\':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case \'PointLight\':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1000\n          };\n          break;\n        // TODO (abelnation): set RectAreaLight shadow uniforms\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nvar nextVersion = 0;\n\nfunction shadowCastingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n}\n\nfunction WebGLLights(extensions, capabilities) {\n  var cache = new UniformsCache();\n  var shadowCache = ShadowUniformsCache();\n  var state = {\n    version: 0,\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1\n    },\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotShadow: [],\n    spotShadowMap: [],\n    spotShadowMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n    rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: []\n  };\n\n  for (var _i117 = 0; _i117 < 9; _i117++) {\n    state.probe.push(new Vector3());\n  }\n\n  var vector3 = new Vector3();\n  var matrix4 = new Matrix4();\n  var matrix42 = new Matrix4();\n\n  function setup(lights, physicallyCorrectLights) {\n    var r = 0,\n        g = 0,\n        b = 0;\n\n    for (var _i118 = 0; _i118 < 9; _i118++) {\n      state.probe[_i118].set(0, 0, 0);\n    }\n\n    var directionalLength = 0;\n    var pointLength = 0;\n    var spotLength = 0;\n    var rectAreaLength = 0;\n    var hemiLength = 0;\n    var numDirectionalShadows = 0;\n    var numPointShadows = 0;\n    var numSpotShadows = 0;\n    lights.sort(shadowCastingLightsFirst); // artist-friendly light intensity scaling factor\n\n    var scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;\n\n    for (var _i119 = 0, l = lights.length; _i119 < l; _i119++) {\n      var light = lights[_i119];\n      var color = light.color;\n      var intensity = light.intensity;\n      var distance = light.distance;\n      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n      if (light.isAmbientLight) {\n        r += color.r * intensity * scaleFactor;\n        g += color.g * intensity * scaleFactor;\n        b += color.b * intensity * scaleFactor;\n      } else if (light.isLightProbe) {\n        for (var j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n      } else if (light.isDirectionalLight) {\n        var uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);\n\n        if (light.castShadow) {\n          var shadow = light.shadow;\n          var shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.directionalShadow[directionalLength] = shadowUniforms;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n          numDirectionalShadows++;\n        }\n\n        state.directional[directionalLength] = uniforms;\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        var _uniforms = cache.get(light);\n\n        _uniforms.position.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);\n\n        _uniforms.distance = distance;\n        _uniforms.coneCos = Math.cos(light.angle);\n        _uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        _uniforms.decay = light.decay;\n\n        if (light.castShadow) {\n          var _shadow = light.shadow;\n\n          var _shadowUniforms = shadowCache.get(light);\n\n          _shadowUniforms.shadowBias = _shadow.bias;\n          _shadowUniforms.shadowNormalBias = _shadow.normalBias;\n          _shadowUniforms.shadowRadius = _shadow.radius;\n          _shadowUniforms.shadowMapSize = _shadow.mapSize;\n          state.spotShadow[spotLength] = _shadowUniforms;\n          state.spotShadowMap[spotLength] = shadowMap;\n          state.spotShadowMatrix[spotLength] = light.shadow.matrix;\n          numSpotShadows++;\n        }\n\n        state.spot[spotLength] = _uniforms;\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        var _uniforms2 = cache.get(light); // (a) intensity is the total visible light emitted\n        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n        // (b) intensity is the brightness of the light\n\n\n        _uniforms2.color.copy(color).multiplyScalar(intensity);\n\n        _uniforms2.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\n        _uniforms2.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\n        state.rectArea[rectAreaLength] = _uniforms2;\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        var _uniforms3 = cache.get(light);\n\n        _uniforms3.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);\n\n        _uniforms3.distance = light.distance;\n        _uniforms3.decay = light.decay;\n\n        if (light.castShadow) {\n          var _shadow2 = light.shadow;\n\n          var _shadowUniforms2 = shadowCache.get(light);\n\n          _shadowUniforms2.shadowBias = _shadow2.bias;\n          _shadowUniforms2.shadowNormalBias = _shadow2.normalBias;\n          _shadowUniforms2.shadowRadius = _shadow2.radius;\n          _shadowUniforms2.shadowMapSize = _shadow2.mapSize;\n          _shadowUniforms2.shadowCameraNear = _shadow2.camera.near;\n          _shadowUniforms2.shadowCameraFar = _shadow2.camera.far;\n          state.pointShadow[pointLength] = _shadowUniforms2;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          numPointShadows++;\n        }\n\n        state.point[pointLength] = _uniforms3;\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        var _uniforms4 = cache.get(light);\n\n        _uniforms4.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);\n\n        _uniforms4.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);\n\n        state.hemi[hemiLength] = _uniforms4;\n        hemiLength++;\n      }\n    }\n\n    if (rectAreaLength > 0) {\n      if (capabilities.isWebGL2) {\n        // WebGL 2\n        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n      } else {\n        // WebGL 1\n        if (extensions.has(\'OES_texture_float_linear\') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n        } else if (extensions.has(\'OES_texture_half_float_linear\') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n        } else {\n          console.error(\'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.\');\n        }\n      }\n    }\n\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n    var hash = state.hash;\n\n    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n      state.directionalShadow.length = numDirectionalShadows;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotShadowMatrix.length = numSpotShadows;\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n      state.version = nextVersion++;\n    }\n  }\n\n  function setupView(lights, camera) {\n    var directionalLength = 0;\n    var pointLength = 0;\n    var spotLength = 0;\n    var rectAreaLength = 0;\n    var hemiLength = 0;\n    var viewMatrix = camera.matrixWorldInverse;\n\n    for (var _i120 = 0, l = lights.length; _i120 < l; _i120++) {\n      var light = lights[_i120];\n\n      if (light.isDirectionalLight) {\n        var uniforms = state.directional[directionalLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        var _uniforms5 = state.spot[spotLength];\n\n        _uniforms5.position.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms5.position.applyMatrix4(viewMatrix);\n\n        _uniforms5.direction.setFromMatrixPosition(light.matrixWorld);\n\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n\n        _uniforms5.direction.sub(vector3);\n\n        _uniforms5.direction.transformDirection(viewMatrix);\n\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        var _uniforms6 = state.rectArea[rectAreaLength];\n\n        _uniforms6.position.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms6.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors\n\n\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n\n        _uniforms6.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\n        _uniforms6.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\n        _uniforms6.halfWidth.applyMatrix4(matrix42);\n\n        _uniforms6.halfHeight.applyMatrix4(matrix42);\n\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        var _uniforms7 = state.point[pointLength];\n\n        _uniforms7.position.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms7.position.applyMatrix4(viewMatrix);\n\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        var _uniforms8 = state.hemi[hemiLength];\n\n        _uniforms8.direction.setFromMatrixPosition(light.matrixWorld);\n\n        _uniforms8.direction.transformDirection(viewMatrix);\n\n        hemiLength++;\n      }\n    }\n  }\n\n  return {\n    setup: setup,\n    setupView: setupView,\n    state: state\n  };\n}\n\nfunction WebGLRenderState(extensions, capabilities) {\n  var lights = new WebGLLights(extensions, capabilities);\n  var lightsArray = [];\n  var shadowsArray = [];\n\n  function init() {\n    lightsArray.length = 0;\n    shadowsArray.length = 0;\n  }\n\n  function pushLight(light) {\n    lightsArray.push(light);\n  }\n\n  function pushShadow(shadowLight) {\n    shadowsArray.push(shadowLight);\n  }\n\n  function setupLights(physicallyCorrectLights) {\n    lights.setup(lightsArray, physicallyCorrectLights);\n  }\n\n  function setupLightsView(camera) {\n    lights.setupView(lightsArray, camera);\n  }\n\n  var state = {\n    lightsArray: lightsArray,\n    shadowsArray: shadowsArray,\n    lights: lights\n  };\n  return {\n    init: init,\n    state: state,\n    setupLights: setupLights,\n    setupLightsView: setupLightsView,\n    pushLight: pushLight,\n    pushShadow: pushShadow\n  };\n}\n\nfunction WebGLRenderStates(extensions, capabilities) {\n  var renderStates = new WeakMap();\n\n  function get(scene) {\n    var renderCallDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var renderState;\n\n    if (renderStates.has(scene) === false) {\n      renderState = new WebGLRenderState(extensions, capabilities);\n      renderStates.set(scene, [renderState]);\n    } else {\n      if (renderCallDepth >= renderStates.get(scene).length) {\n        renderState = new WebGLRenderState(extensions, capabilities);\n        renderStates.get(scene).push(renderState);\n      } else {\n        renderState = renderStates.get(scene)[renderCallDepth];\n      }\n    }\n\n    return renderState;\n  }\n\n  function dispose() {\n    renderStates = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nvar MeshDepthMaterial = /*#__PURE__*/function (_Material3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshDepthMaterial, _Material3);\n\n  var _super32 = _createSuper(MeshDepthMaterial);\n\n  function MeshDepthMaterial(parameters) {\n    var _this24;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshDepthMaterial);\n\n    _this24 = _super32.call(this);\n    _this24.isMeshDepthMaterial = true;\n    _this24.type = \'MeshDepthMaterial\';\n    _this24.depthPacking = BasicDepthPacking;\n    _this24.map = null;\n    _this24.alphaMap = null;\n    _this24.displacementMap = null;\n    _this24.displacementScale = 1;\n    _this24.displacementBias = 0;\n    _this24.wireframe = false;\n    _this24.wireframeLinewidth = 1;\n\n    _this24.setValues(parameters);\n\n    return _this24;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshDepthMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshDepthMaterial.prototype), "copy", this).call(this, source);\n\n      this.depthPacking = source.depthPacking;\n      this.map = source.map;\n      this.alphaMap = source.alphaMap;\n      this.displacementMap = source.displacementMap;\n      this.displacementScale = source.displacementScale;\n      this.displacementBias = source.displacementBias;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      return this;\n    }\n  }]);\n\n  return MeshDepthMaterial;\n}(Material);\n\nvar MeshDistanceMaterial = /*#__PURE__*/function (_Material4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshDistanceMaterial, _Material4);\n\n  var _super33 = _createSuper(MeshDistanceMaterial);\n\n  function MeshDistanceMaterial(parameters) {\n    var _this25;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshDistanceMaterial);\n\n    _this25 = _super33.call(this);\n    _this25.isMeshDistanceMaterial = true;\n    _this25.type = \'MeshDistanceMaterial\';\n    _this25.referencePosition = new Vector3();\n    _this25.nearDistance = 1;\n    _this25.farDistance = 1000;\n    _this25.map = null;\n    _this25.alphaMap = null;\n    _this25.displacementMap = null;\n    _this25.displacementScale = 1;\n    _this25.displacementBias = 0;\n\n    _this25.setValues(parameters);\n\n    return _this25;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshDistanceMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshDistanceMaterial.prototype), "copy", this).call(this, source);\n\n      this.referencePosition.copy(source.referencePosition);\n      this.nearDistance = source.nearDistance;\n      this.farDistance = source.farDistance;\n      this.map = source.map;\n      this.alphaMap = source.alphaMap;\n      this.displacementMap = source.displacementMap;\n      this.displacementScale = source.displacementScale;\n      this.displacementBias = source.displacementBias;\n      return this;\n    }\n  }]);\n\n  return MeshDistanceMaterial;\n}(Material);\n\nvar vertex = "void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}";\nvar fragment = "uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tconst float samples = float( VSM_SAMPLES );\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\\n\\tfor ( float i = 0.0; i < samples; i ++ ) {\\n\\t\\tfloat uvOffset = uvStart + i * uvStride;\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean / samples;\\n\\tsquared_mean = squared_mean / samples;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}";\n\nfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n  var _frustum = new Frustum();\n\n  var _shadowMapSize = new Vector2(),\n      _viewportSize = new Vector2(),\n      _viewport = new Vector4(),\n      _depthMaterial = new MeshDepthMaterial({\n    depthPacking: RGBADepthPacking\n  }),\n      _distanceMaterial = new MeshDistanceMaterial(),\n      _materialCache = {},\n      _maxTextureSize = _capabilities.maxTextureSize;\n\n  var shadowSide = {\n    0: BackSide,\n    1: FrontSide,\n    2: DoubleSide\n  };\n  var shadowMaterialVertical = new ShaderMaterial({\n    defines: {\n      VSM_SAMPLES: 8\n    },\n    uniforms: {\n      shadow_pass: {\n        value: null\n      },\n      resolution: {\n        value: new Vector2()\n      },\n      radius: {\n        value: 4.0\n      }\n    },\n    vertexShader: vertex,\n    fragmentShader: fragment\n  });\n  var shadowMaterialHorizontal = shadowMaterialVertical.clone();\n  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n  var fullScreenTri = new BufferGeometry();\n  fullScreenTri.setAttribute(\'position\', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n  var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n  var scope = this;\n  this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n  this.type = PCFShadowMap;\n\n  this.render = function (lights, scene, camera) {\n    if (scope.enabled === false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false) return;\n    if (lights.length === 0) return;\n\n    var currentRenderTarget = _renderer.getRenderTarget();\n\n    var activeCubeFace = _renderer.getActiveCubeFace();\n\n    var activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n    var _state = _renderer.state; // Set GL state for depth map.\n\n    _state.setBlending(NoBlending);\n\n    _state.buffers.color.setClear(1, 1, 1, 1);\n\n    _state.buffers.depth.setTest(true);\n\n    _state.setScissorTest(false); // render depth map\n\n\n    for (var _i121 = 0, il = lights.length; _i121 < il; _i121++) {\n      var light = lights[_i121];\n      var shadow = light.shadow;\n\n      if (shadow === undefined) {\n        console.warn(\'THREE.WebGLShadowMap:\', light, \'has no shadow.\');\n        continue;\n      }\n\n      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n\n      _shadowMapSize.copy(shadow.mapSize);\n\n      var shadowFrameExtents = shadow.getFrameExtents();\n\n      _shadowMapSize.multiply(shadowFrameExtents);\n\n      _viewportSize.copy(shadow.mapSize);\n\n      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n        if (_shadowMapSize.x > _maxTextureSize) {\n          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          shadow.mapSize.x = _viewportSize.x;\n        }\n\n        if (_shadowMapSize.y > _maxTextureSize) {\n          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n          shadow.mapSize.y = _viewportSize.y;\n        }\n      }\n\n      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);\n        shadow.map.texture.name = light.name + \'.shadowMap\';\n        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      if (shadow.map === null) {\n        var pars = {\n          minFilter: NearestFilter,\n          magFilter: NearestFilter,\n          format: RGBAFormat\n        };\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + \'.shadowMap\';\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      _renderer.setRenderTarget(shadow.map);\n\n      _renderer.clear();\n\n      var viewportCount = shadow.getViewportCount();\n\n      for (var vp = 0; vp < viewportCount; vp++) {\n        var viewport = shadow.getViewport(vp);\n\n        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n\n        _state.viewport(_viewport);\n\n        shadow.updateMatrices(light, vp);\n        _frustum = shadow.getFrustum();\n        renderObject(scene, camera, shadow.camera, light, this.type);\n      } // do blur pass for VSM\n\n\n      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        VSMPass(shadow, camera);\n      }\n\n      shadow.needsUpdate = false;\n    }\n\n    scope.needsUpdate = false;\n\n    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n  };\n\n  function VSMPass(shadow, camera) {\n    var geometry = _objects.update(fullScreenMesh);\n\n    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {\n      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n      shadowMaterialVertical.needsUpdate = true;\n      shadowMaterialHorizontal.needsUpdate = true;\n    } // vertical pass\n\n\n    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\n    _renderer.setRenderTarget(shadow.mapPass);\n\n    _renderer.clear();\n\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass\n\n\n    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\n    _renderer.setRenderTarget(shadow.map);\n\n    _renderer.clear();\n\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n  }\n\n  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {\n    var result = null;\n    var customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;\n\n    if (customMaterial !== undefined) {\n      result = customMaterial;\n    } else {\n      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;\n    }\n\n    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {\n      // in this case we need a unique material instance reflecting the\n      // appropriate state\n      var keyA = result.uuid,\n          keyB = material.uuid;\n      var materialsForVariant = _materialCache[keyA];\n\n      if (materialsForVariant === undefined) {\n        materialsForVariant = {};\n        _materialCache[keyA] = materialsForVariant;\n      }\n\n      var cachedMaterial = materialsForVariant[keyB];\n\n      if (cachedMaterial === undefined) {\n        cachedMaterial = result.clone();\n        materialsForVariant[keyB] = cachedMaterial;\n      }\n\n      result = cachedMaterial;\n    }\n\n    result.visible = material.visible;\n    result.wireframe = material.wireframe;\n\n    if (type === VSMShadowMap) {\n      result.side = material.shadowSide !== null ? material.shadowSide : material.side;\n    } else {\n      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n    }\n\n    result.alphaMap = material.alphaMap;\n    result.alphaTest = material.alphaTest;\n    result.clipShadows = material.clipShadows;\n    result.clippingPlanes = material.clippingPlanes;\n    result.clipIntersection = material.clipIntersection;\n    result.displacementMap = material.displacementMap;\n    result.displacementScale = material.displacementScale;\n    result.displacementBias = material.displacementBias;\n    result.wireframeLinewidth = material.wireframeLinewidth;\n    result.linewidth = material.linewidth;\n\n    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n      result.referencePosition.setFromMatrixPosition(light.matrixWorld);\n      result.nearDistance = shadowCameraNear;\n      result.farDistance = shadowCameraFar;\n    }\n\n    return result;\n  }\n\n  function renderObject(object, camera, shadowCamera, light, type) {\n    if (object.visible === false) return;\n    var visible = object.layers.test(camera.layers);\n\n    if (visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n\n        var geometry = _objects.update(object);\n\n        var material = object.material;\n\n        if (Array.isArray(material)) {\n          var groups = geometry.groups;\n\n          for (var k = 0, kl = groups.length; k < kl; k++) {\n            var group = groups[k];\n            var groupMaterial = material[group.materialIndex];\n\n            if (groupMaterial && groupMaterial.visible) {\n              var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n\n              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n            }\n          }\n        } else if (material.visible) {\n          var _depthMaterial2 = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);\n\n          _renderer.renderBufferDirect(shadowCamera, null, geometry, _depthMaterial2, object, null);\n        }\n      }\n    }\n\n    var children = object.children;\n\n    for (var _i122 = 0, l = children.length; _i122 < l; _i122++) {\n      renderObject(children[_i122], camera, shadowCamera, light, type);\n    }\n  }\n}\n\nfunction WebGLState(gl, extensions, capabilities) {\n  var _equationToGL, _factorToGL;\n\n  var isWebGL2 = capabilities.isWebGL2;\n\n  function ColorBuffer() {\n    var locked = false;\n    var color = new Vector4();\n    var currentColorMask = null;\n    var currentColorClear = new Vector4(0, 0, 0, 0);\n    return {\n      setMask: function setMask(colorMask) {\n        if (currentColorMask !== colorMask && !locked) {\n          gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n          currentColorMask = colorMask;\n        }\n      },\n      setLocked: function setLocked(lock) {\n        locked = lock;\n      },\n      setClear: function setClear(r, g, b, a, premultipliedAlpha) {\n        if (premultipliedAlpha === true) {\n          r *= a;\n          g *= a;\n          b *= a;\n        }\n\n        color.set(r, g, b, a);\n\n        if (currentColorClear.equals(color) === false) {\n          gl.clearColor(r, g, b, a);\n          currentColorClear.copy(color);\n        }\n      },\n      reset: function reset() {\n        locked = false;\n        currentColorMask = null;\n        currentColorClear.set(-1, 0, 0, 0); // set to invalid state\n      }\n    };\n  }\n\n  function DepthBuffer() {\n    var locked = false;\n    var currentDepthMask = null;\n    var currentDepthFunc = null;\n    var currentDepthClear = null;\n    return {\n      setTest: function setTest(depthTest) {\n        if (depthTest) {\n          enable(2929);\n        } else {\n          disable(2929);\n        }\n      },\n      setMask: function setMask(depthMask) {\n        if (currentDepthMask !== depthMask && !locked) {\n          gl.depthMask(depthMask);\n          currentDepthMask = depthMask;\n        }\n      },\n      setFunc: function setFunc(depthFunc) {\n        if (currentDepthFunc !== depthFunc) {\n          if (depthFunc) {\n            switch (depthFunc) {\n              case NeverDepth:\n                gl.depthFunc(512);\n                break;\n\n              case AlwaysDepth:\n                gl.depthFunc(519);\n                break;\n\n              case LessDepth:\n                gl.depthFunc(513);\n                break;\n\n              case LessEqualDepth:\n                gl.depthFunc(515);\n                break;\n\n              case EqualDepth:\n                gl.depthFunc(514);\n                break;\n\n              case GreaterEqualDepth:\n                gl.depthFunc(518);\n                break;\n\n              case GreaterDepth:\n                gl.depthFunc(516);\n                break;\n\n              case NotEqualDepth:\n                gl.depthFunc(517);\n                break;\n\n              default:\n                gl.depthFunc(515);\n            }\n          } else {\n            gl.depthFunc(515);\n          }\n\n          currentDepthFunc = depthFunc;\n        }\n      },\n      setLocked: function setLocked(lock) {\n        locked = lock;\n      },\n      setClear: function setClear(depth) {\n        if (currentDepthClear !== depth) {\n          gl.clearDepth(depth);\n          currentDepthClear = depth;\n        }\n      },\n      reset: function reset() {\n        locked = false;\n        currentDepthMask = null;\n        currentDepthFunc = null;\n        currentDepthClear = null;\n      }\n    };\n  }\n\n  function StencilBuffer() {\n    var locked = false;\n    var currentStencilMask = null;\n    var currentStencilFunc = null;\n    var currentStencilRef = null;\n    var currentStencilFuncMask = null;\n    var currentStencilFail = null;\n    var currentStencilZFail = null;\n    var currentStencilZPass = null;\n    var currentStencilClear = null;\n    return {\n      setTest: function setTest(stencilTest) {\n        if (!locked) {\n          if (stencilTest) {\n            enable(2960);\n          } else {\n            disable(2960);\n          }\n        }\n      },\n      setMask: function setMask(stencilMask) {\n        if (currentStencilMask !== stencilMask && !locked) {\n          gl.stencilMask(stencilMask);\n          currentStencilMask = stencilMask;\n        }\n      },\n      setFunc: function setFunc(stencilFunc, stencilRef, stencilMask) {\n        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {\n          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n          currentStencilFunc = stencilFunc;\n          currentStencilRef = stencilRef;\n          currentStencilFuncMask = stencilMask;\n        }\n      },\n      setOp: function setOp(stencilFail, stencilZFail, stencilZPass) {\n        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {\n          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n          currentStencilFail = stencilFail;\n          currentStencilZFail = stencilZFail;\n          currentStencilZPass = stencilZPass;\n        }\n      },\n      setLocked: function setLocked(lock) {\n        locked = lock;\n      },\n      setClear: function setClear(stencil) {\n        if (currentStencilClear !== stencil) {\n          gl.clearStencil(stencil);\n          currentStencilClear = stencil;\n        }\n      },\n      reset: function reset() {\n        locked = false;\n        currentStencilMask = null;\n        currentStencilFunc = null;\n        currentStencilRef = null;\n        currentStencilFuncMask = null;\n        currentStencilFail = null;\n        currentStencilZFail = null;\n        currentStencilZPass = null;\n        currentStencilClear = null;\n      }\n    };\n  } //\n\n\n  var colorBuffer = new ColorBuffer();\n  var depthBuffer = new DepthBuffer();\n  var stencilBuffer = new StencilBuffer();\n  var enabledCapabilities = {};\n  var currentBoundFramebuffers = {};\n  var currentDrawbuffers = new WeakMap();\n  var defaultDrawbuffers = [];\n  var currentProgram = null;\n  var currentBlendingEnabled = false;\n  var currentBlending = null;\n  var currentBlendEquation = null;\n  var currentBlendSrc = null;\n  var currentBlendDst = null;\n  var currentBlendEquationAlpha = null;\n  var currentBlendSrcAlpha = null;\n  var currentBlendDstAlpha = null;\n  var currentPremultipledAlpha = false;\n  var currentFlipSided = null;\n  var currentCullFace = null;\n  var currentLineWidth = null;\n  var currentPolygonOffsetFactor = null;\n  var currentPolygonOffsetUnits = null;\n  var maxTextures = gl.getParameter(35661);\n  var lineWidthAvailable = false;\n  var version = 0;\n  var glVersion = gl.getParameter(7938);\n\n  if (glVersion.indexOf(\'WebGL\') !== -1) {\n    version = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 1.0;\n  } else if (glVersion.indexOf(\'OpenGL ES\') !== -1) {\n    version = parseFloat(/^OpenGL ES (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 2.0;\n  }\n\n  var currentTextureSlot = null;\n  var currentBoundTextures = {};\n  var scissorParam = gl.getParameter(3088);\n  var viewportParam = gl.getParameter(2978);\n  var currentScissor = new Vector4().fromArray(scissorParam);\n  var currentViewport = new Vector4().fromArray(viewportParam);\n\n  function createTexture(type, target, count) {\n    var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.\n\n    var texture = gl.createTexture();\n    gl.bindTexture(type, texture);\n    gl.texParameteri(type, 10241, 9728);\n    gl.texParameteri(type, 10240, 9728);\n\n    for (var _i123 = 0; _i123 < count; _i123++) {\n      gl.texImage2D(target + _i123, 0, 6408, 1, 1, 0, 6408, 5121, data);\n    }\n\n    return texture;\n  }\n\n  var emptyTextures = {};\n  emptyTextures[3553] = createTexture(3553, 3553, 1);\n  emptyTextures[34067] = createTexture(34067, 34069, 6); // init\n\n  colorBuffer.setClear(0, 0, 0, 1);\n  depthBuffer.setClear(1);\n  stencilBuffer.setClear(0);\n  enable(2929);\n  depthBuffer.setFunc(LessEqualDepth);\n  setFlipSided(false);\n  setCullFace(CullFaceBack);\n  enable(2884);\n  setBlending(NoBlending); //\n\n  function enable(id) {\n    if (enabledCapabilities[id] !== true) {\n      gl.enable(id);\n      enabledCapabilities[id] = true;\n    }\n  }\n\n  function disable(id) {\n    if (enabledCapabilities[id] !== false) {\n      gl.disable(id);\n      enabledCapabilities[id] = false;\n    }\n  }\n\n  function bindFramebuffer(target, framebuffer) {\n    if (currentBoundFramebuffers[target] !== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n      currentBoundFramebuffers[target] = framebuffer;\n\n      if (isWebGL2) {\n        // 36009 is equivalent to 36160\n        if (target === 36009) {\n          currentBoundFramebuffers[36160] = framebuffer;\n        }\n\n        if (target === 36160) {\n          currentBoundFramebuffers[36009] = framebuffer;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function drawBuffers(renderTarget, framebuffer) {\n    var drawBuffers = defaultDrawbuffers;\n    var needsUpdate = false;\n\n    if (renderTarget) {\n      drawBuffers = currentDrawbuffers.get(framebuffer);\n\n      if (drawBuffers === undefined) {\n        drawBuffers = [];\n        currentDrawbuffers.set(framebuffer, drawBuffers);\n      }\n\n      if (renderTarget.isWebGLMultipleRenderTargets) {\n        var textures = renderTarget.texture;\n\n        if (drawBuffers.length !== textures.length || drawBuffers[0] !== 36064) {\n          for (var _i124 = 0, il = textures.length; _i124 < il; _i124++) {\n            drawBuffers[_i124] = 36064 + _i124;\n          }\n\n          drawBuffers.length = textures.length;\n          needsUpdate = true;\n        }\n      } else {\n        if (drawBuffers[0] !== 36064) {\n          drawBuffers[0] = 36064;\n          needsUpdate = true;\n        }\n      }\n    } else {\n      if (drawBuffers[0] !== 1029) {\n        drawBuffers[0] = 1029;\n        needsUpdate = true;\n      }\n    }\n\n    if (needsUpdate) {\n      if (capabilities.isWebGL2) {\n        gl.drawBuffers(drawBuffers);\n      } else {\n        extensions.get(\'WEBGL_draw_buffers\').drawBuffersWEBGL(drawBuffers);\n      }\n    }\n  }\n\n  function useProgram(program) {\n    if (currentProgram !== program) {\n      gl.useProgram(program);\n      currentProgram = program;\n      return true;\n    }\n\n    return false;\n  }\n\n  var equationToGL = (_equationToGL = {}, (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_equationToGL, AddEquation, 32774), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_equationToGL, SubtractEquation, 32778), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_equationToGL, ReverseSubtractEquation, 32779), _equationToGL);\n\n  if (isWebGL2) {\n    equationToGL[MinEquation] = 32775;\n    equationToGL[MaxEquation] = 32776;\n  } else {\n    var extension = extensions.get(\'EXT_blend_minmax\');\n\n    if (extension !== null) {\n      equationToGL[MinEquation] = extension.MIN_EXT;\n      equationToGL[MaxEquation] = extension.MAX_EXT;\n    }\n  }\n\n  var factorToGL = (_factorToGL = {}, (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, ZeroFactor, 0), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, OneFactor, 1), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, SrcColorFactor, 768), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, SrcAlphaFactor, 770), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, SrcAlphaSaturateFactor, 776), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, DstColorFactor, 774), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, DstAlphaFactor, 772), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, OneMinusSrcColorFactor, 769), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, OneMinusSrcAlphaFactor, 771), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, OneMinusDstColorFactor, 775), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_factorToGL, OneMinusDstAlphaFactor, 773), _factorToGL);\n\n  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n    if (blending === NoBlending) {\n      if (currentBlendingEnabled === true) {\n        disable(3042);\n        currentBlendingEnabled = false;\n      }\n\n      return;\n    }\n\n    if (currentBlendingEnabled === false) {\n      enable(3042);\n      currentBlendingEnabled = true;\n    }\n\n    if (blending !== CustomBlending) {\n      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {\n        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {\n          gl.blendEquation(32774);\n          currentBlendEquation = AddEquation;\n          currentBlendEquationAlpha = AddEquation;\n        }\n\n        if (premultipliedAlpha) {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(1, 771, 1, 771);\n              break;\n\n            case AdditiveBlending:\n              gl.blendFunc(1, 1);\n              break;\n\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(0, 769, 0, 1);\n              break;\n\n            case MultiplyBlending:\n              gl.blendFuncSeparate(0, 768, 0, 770);\n              break;\n\n            default:\n              console.error(\'THREE.WebGLState: Invalid blending: \', blending);\n              break;\n          }\n        } else {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(770, 771, 1, 771);\n              break;\n\n            case AdditiveBlending:\n              gl.blendFunc(770, 1);\n              break;\n\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(0, 769, 0, 1);\n              break;\n\n            case MultiplyBlending:\n              gl.blendFunc(0, 768);\n              break;\n\n            default:\n              console.error(\'THREE.WebGLState: Invalid blending: \', blending);\n              break;\n          }\n        }\n\n        currentBlendSrc = null;\n        currentBlendDst = null;\n        currentBlendSrcAlpha = null;\n        currentBlendDstAlpha = null;\n        currentBlending = blending;\n        currentPremultipledAlpha = premultipliedAlpha;\n      }\n\n      return;\n    } // custom blending\n\n\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n\n    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\n      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n      currentBlendEquation = blendEquation;\n      currentBlendEquationAlpha = blendEquationAlpha;\n    }\n\n    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\n      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n      currentBlendSrc = blendSrc;\n      currentBlendDst = blendDst;\n      currentBlendSrcAlpha = blendSrcAlpha;\n      currentBlendDstAlpha = blendDstAlpha;\n    }\n\n    currentBlending = blending;\n    currentPremultipledAlpha = null;\n  }\n\n  function setMaterial(material, frontFaceCW) {\n    material.side === DoubleSide ? disable(2884) : enable(2884);\n    var flipSided = material.side === BackSide;\n    if (frontFaceCW) flipSided = !flipSided;\n    setFlipSided(flipSided);\n    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n    depthBuffer.setFunc(material.depthFunc);\n    depthBuffer.setTest(material.depthTest);\n    depthBuffer.setMask(material.depthWrite);\n    colorBuffer.setMask(material.colorWrite);\n    var stencilWrite = material.stencilWrite;\n    stencilBuffer.setTest(stencilWrite);\n\n    if (stencilWrite) {\n      stencilBuffer.setMask(material.stencilWriteMask);\n      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n    }\n\n    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n    material.alphaToCoverage === true ? enable(32926) : disable(32926);\n  } //\n\n\n  function setFlipSided(flipSided) {\n    if (currentFlipSided !== flipSided) {\n      if (flipSided) {\n        gl.frontFace(2304);\n      } else {\n        gl.frontFace(2305);\n      }\n\n      currentFlipSided = flipSided;\n    }\n  }\n\n  function setCullFace(cullFace) {\n    if (cullFace !== CullFaceNone) {\n      enable(2884);\n\n      if (cullFace !== currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          gl.cullFace(1029);\n        } else if (cullFace === CullFaceFront) {\n          gl.cullFace(1028);\n        } else {\n          gl.cullFace(1032);\n        }\n      }\n    } else {\n      disable(2884);\n    }\n\n    currentCullFace = cullFace;\n  }\n\n  function setLineWidth(width) {\n    if (width !== currentLineWidth) {\n      if (lineWidthAvailable) gl.lineWidth(width);\n      currentLineWidth = width;\n    }\n  }\n\n  function setPolygonOffset(polygonOffset, factor, units) {\n    if (polygonOffset) {\n      enable(32823);\n\n      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {\n        gl.polygonOffset(factor, units);\n        currentPolygonOffsetFactor = factor;\n        currentPolygonOffsetUnits = units;\n      }\n    } else {\n      disable(32823);\n    }\n  }\n\n  function setScissorTest(scissorTest) {\n    if (scissorTest) {\n      enable(3089);\n    } else {\n      disable(3089);\n    }\n  } // texture\n\n\n  function activeTexture(webglSlot) {\n    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;\n\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      currentTextureSlot = webglSlot;\n    }\n  }\n\n  function bindTexture(webglType, webglTexture) {\n    if (currentTextureSlot === null) {\n      activeTexture();\n    }\n\n    var boundTexture = currentBoundTextures[currentTextureSlot];\n\n    if (boundTexture === undefined) {\n      boundTexture = {\n        type: undefined,\n        texture: undefined\n      };\n      currentBoundTextures[currentTextureSlot] = boundTexture;\n    }\n\n    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  }\n\n  function unbindTexture() {\n    var boundTexture = currentBoundTextures[currentTextureSlot];\n\n    if (boundTexture !== undefined && boundTexture.type !== undefined) {\n      gl.bindTexture(boundTexture.type, null);\n      boundTexture.type = undefined;\n      boundTexture.texture = undefined;\n    }\n  }\n\n  function compressedTexImage2D() {\n    try {\n      gl.compressedTexImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\'THREE.WebGLState:\', error);\n    }\n  }\n\n  function texSubImage2D() {\n    try {\n      gl.texSubImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\'THREE.WebGLState:\', error);\n    }\n  }\n\n  function texSubImage3D() {\n    try {\n      gl.texSubImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\'THREE.WebGLState:\', error);\n    }\n  }\n\n  function compressedTexSubImage2D() {\n    try {\n      gl.compressedTexSubImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\'THREE.WebGLState:\', error);\n    }\n  }\n\n  function texStorage2D() {\n    try {\n      gl.texStorage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\'THREE.WebGLState:\', error);\n    }\n  }\n\n  function texStorage3D() {\n    try {\n      gl.texStorage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\'THREE.WebGLState:\', error);\n    }\n  }\n\n  function texImage2D() {\n    try {\n      gl.texImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\'THREE.WebGLState:\', error);\n    }\n  }\n\n  function texImage3D() {\n    try {\n      gl.texImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\'THREE.WebGLState:\', error);\n    }\n  } //\n\n\n  function scissor(scissor) {\n    if (currentScissor.equals(scissor) === false) {\n      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);\n      currentScissor.copy(scissor);\n    }\n  }\n\n  function viewport(viewport) {\n    if (currentViewport.equals(viewport) === false) {\n      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);\n      currentViewport.copy(viewport);\n    }\n  } //\n\n\n  function reset() {\n    // reset state\n    gl.disable(3042);\n    gl.disable(2884);\n    gl.disable(2929);\n    gl.disable(32823);\n    gl.disable(3089);\n    gl.disable(2960);\n    gl.disable(32926);\n    gl.blendEquation(32774);\n    gl.blendFunc(1, 0);\n    gl.blendFuncSeparate(1, 0, 1, 0);\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0, 0, 0, 0);\n    gl.depthMask(true);\n    gl.depthFunc(513);\n    gl.clearDepth(1);\n    gl.stencilMask(0xffffffff);\n    gl.stencilFunc(519, 0, 0xffffffff);\n    gl.stencilOp(7680, 7680, 7680);\n    gl.clearStencil(0);\n    gl.cullFace(1029);\n    gl.frontFace(2305);\n    gl.polygonOffset(0, 0);\n    gl.activeTexture(33984);\n    gl.bindFramebuffer(36160, null);\n\n    if (isWebGL2 === true) {\n      gl.bindFramebuffer(36009, null);\n      gl.bindFramebuffer(36008, null);\n    }\n\n    gl.useProgram(null);\n    gl.lineWidth(1);\n    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals\n\n    enabledCapabilities = {};\n    currentTextureSlot = null;\n    currentBoundTextures = {};\n    currentBoundFramebuffers = {};\n    currentDrawbuffers = new WeakMap();\n    defaultDrawbuffers = [];\n    currentProgram = null;\n    currentBlendingEnabled = false;\n    currentBlending = null;\n    currentBlendEquation = null;\n    currentBlendSrc = null;\n    currentBlendDst = null;\n    currentBlendEquationAlpha = null;\n    currentBlendSrcAlpha = null;\n    currentBlendDstAlpha = null;\n    currentPremultipledAlpha = false;\n    currentFlipSided = null;\n    currentCullFace = null;\n    currentLineWidth = null;\n    currentPolygonOffsetFactor = null;\n    currentPolygonOffsetUnits = null;\n    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n    colorBuffer.reset();\n    depthBuffer.reset();\n    stencilBuffer.reset();\n  }\n\n  return {\n    buffers: {\n      color: colorBuffer,\n      depth: depthBuffer,\n      stencil: stencilBuffer\n    },\n    enable: enable,\n    disable: disable,\n    bindFramebuffer: bindFramebuffer,\n    drawBuffers: drawBuffers,\n    useProgram: useProgram,\n    setBlending: setBlending,\n    setMaterial: setMaterial,\n    setFlipSided: setFlipSided,\n    setCullFace: setCullFace,\n    setLineWidth: setLineWidth,\n    setPolygonOffset: setPolygonOffset,\n    setScissorTest: setScissorTest,\n    activeTexture: activeTexture,\n    bindTexture: bindTexture,\n    unbindTexture: unbindTexture,\n    compressedTexImage2D: compressedTexImage2D,\n    texImage2D: texImage2D,\n    texImage3D: texImage3D,\n    texStorage2D: texStorage2D,\n    texStorage3D: texStorage3D,\n    texSubImage2D: texSubImage2D,\n    texSubImage3D: texSubImage3D,\n    compressedTexSubImage2D: compressedTexSubImage2D,\n    scissor: scissor,\n    viewport: viewport,\n    reset: reset\n  };\n}\n\nfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\n  var _wrappingToGL, _filterToGL;\n\n  var isWebGL2 = capabilities.isWebGL2;\n  var maxTextures = capabilities.maxTextures;\n  var maxCubemapSize = capabilities.maxCubemapSize;\n  var maxTextureSize = capabilities.maxTextureSize;\n  var maxSamples = capabilities.maxSamples;\n  var multisampledRTTExt = extensions.has(\'WEBGL_multisampled_render_to_texture\') ? extensions.get(\'WEBGL_multisampled_render_to_texture\') : null;\n  var supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);\n\n  var _videoTextures = new WeakMap();\n\n  var _canvas;\n\n  var _sources = new WeakMap(); // maps WebglTexture objects to instances of Source\n  // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!\n  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\n  var useOffscreenCanvas = false;\n\n  try {\n    useOffscreenCanvas = typeof OffscreenCanvas !== \'undefined\' // eslint-disable-next-line compat/compat\n    && new OffscreenCanvas(1, 1).getContext(\'2d\') !== null;\n  } catch (err) {// Ignore any errors\n  }\n\n  function createCanvas(width, height) {\n    // Use OffscreenCanvas when available. Specially needed in web workers\n    return useOffscreenCanvas ? // eslint-disable-next-line compat/compat\n    new OffscreenCanvas(width, height) : createElementNS(\'canvas\');\n  }\n\n  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\n    var scale = 1; // handle case if texture exceeds max size\n\n    if (image.width > maxSize || image.height > maxSize) {\n      scale = maxSize / Math.max(image.width, image.height);\n    } // only perform resize if necessary\n\n\n    if (scale < 1 || needsPowerOfTwo === true) {\n      // only perform resize for certain image types\n      if (typeof HTMLImageElement !== \'undefined\' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \'undefined\' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \'undefined\' && image instanceof ImageBitmap) {\n        var floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n        var width = floor(scale * image.width);\n        var height = floor(scale * image.height);\n        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can\'t reuse the same canvas\n\n        var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;\n        canvas.width = width;\n        canvas.height = height;\n        var context = canvas.getContext(\'2d\');\n        context.drawImage(image, 0, 0, width, height);\n        console.warn(\'THREE.WebGLRenderer: Texture has been resized from (\' + image.width + \'x\' + image.height + \') to (\' + width + \'x\' + height + \').\');\n        return canvas;\n      } else {\n        if (\'data\' in image) {\n          console.warn(\'THREE.WebGLRenderer: Image in DataTexture is too big (\' + image.width + \'x\' + image.height + \').\');\n        }\n\n        return image;\n      }\n    }\n\n    return image;\n  }\n\n  function isPowerOfTwo$1(image) {\n    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);\n  }\n\n  function textureNeedsPowerOfTwo(texture) {\n    if (isWebGL2) return false;\n    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n  }\n\n  function textureNeedsGenerateMipmaps(texture, supportsMips) {\n    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n  }\n\n  function generateMipmap(target) {\n    _gl.generateMipmap(target);\n  }\n\n  function getInternalFormat(internalFormatName, glFormat, glType, encoding) {\n    var isVideoTexture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (isWebGL2 === false) return glFormat;\n\n    if (internalFormatName !== null) {\n      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];\n      console.warn(\'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\\'\' + internalFormatName + \'\\\'\');\n    }\n\n    var internalFormat = glFormat;\n\n    if (glFormat === 6403) {\n      if (glType === 5126) internalFormat = 33326;\n      if (glType === 5131) internalFormat = 33325;\n      if (glType === 5121) internalFormat = 33321;\n    }\n\n    if (glFormat === 33319) {\n      if (glType === 5126) internalFormat = 33328;\n      if (glType === 5131) internalFormat = 33327;\n      if (glType === 5121) internalFormat = 33323;\n    }\n\n    if (glFormat === 6408) {\n      if (glType === 5126) internalFormat = 34836;\n      if (glType === 5131) internalFormat = 34842;\n      if (glType === 5121) internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;\n      if (glType === 32819) internalFormat = 32854;\n      if (glType === 32820) internalFormat = 32855;\n    }\n\n    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {\n      extensions.get(\'EXT_color_buffer_float\');\n    }\n\n    return internalFormat;\n  }\n\n  function getMipLevels(texture, image, supportsMips) {\n    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n      return Math.log2(Math.max(image.width, image.height)) + 1;\n    } else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {\n      // user-defined mipmaps\n      return texture.mipmaps.length;\n    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {\n      return image.mipmaps.length;\n    } else {\n      // texture without mipmaps (only base level)\n      return 1;\n    }\n  } // Fallback filters for non-power-of-2 textures\n\n\n  function filterFallback(f) {\n    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n      return 9728;\n    }\n\n    return 9729;\n  } //\n\n\n  function onTextureDispose(event) {\n    var texture = event.target;\n    texture.removeEventListener(\'dispose\', onTextureDispose);\n    deallocateTexture(texture);\n\n    if (texture.isVideoTexture) {\n      _videoTextures.delete(texture);\n    }\n  }\n\n  function onRenderTargetDispose(event) {\n    var renderTarget = event.target;\n    renderTarget.removeEventListener(\'dispose\', onRenderTargetDispose);\n    deallocateRenderTarget(renderTarget);\n  } //\n\n\n  function deallocateTexture(texture) {\n    var textureProperties = properties.get(texture);\n    if (textureProperties.__webglInit === undefined) return; // check if it\'s necessary to remove the WebGLTexture object\n\n    var source = texture.source;\n\n    var webglTextures = _sources.get(source);\n\n    if (webglTextures) {\n      var webglTexture = webglTextures[textureProperties.__cacheKey];\n      webglTexture.usedTimes--; // the WebGLTexture object is not used anymore, remove it\n\n      if (webglTexture.usedTimes === 0) {\n        deleteTexture(texture);\n      } // remove the weak map entry if no WebGLTexture uses the source anymore\n\n\n      if (Object.keys(webglTextures).length === 0) {\n        _sources.delete(source);\n      }\n    }\n\n    properties.remove(texture);\n  }\n\n  function deleteTexture(texture) {\n    var textureProperties = properties.get(texture);\n\n    _gl.deleteTexture(textureProperties.__webglTexture);\n\n    var source = texture.source;\n\n    var webglTextures = _sources.get(source);\n\n    delete webglTextures[textureProperties.__cacheKey];\n    info.memory.textures--;\n  }\n\n  function deallocateRenderTarget(renderTarget) {\n    var texture = renderTarget.texture;\n    var renderTargetProperties = properties.get(renderTarget);\n    var textureProperties = properties.get(texture);\n\n    if (textureProperties.__webglTexture !== undefined) {\n      _gl.deleteTexture(textureProperties.__webglTexture);\n\n      info.memory.textures--;\n    }\n\n    if (renderTarget.depthTexture) {\n      renderTarget.depthTexture.dispose();\n    }\n\n    if (renderTarget.isWebGLCubeRenderTarget) {\n      for (var _i125 = 0; _i125 < 6; _i125++) {\n        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[_i125]);\n\n        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[_i125]);\n      }\n    } else {\n      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n\n      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\n\n      if (renderTargetProperties.__webglColorRenderbuffer) {\n        for (var _i126 = 0; _i126 < renderTargetProperties.__webglColorRenderbuffer.length; _i126++) {\n          if (renderTargetProperties.__webglColorRenderbuffer[_i126]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[_i126]);\n        }\n      }\n\n      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n    }\n\n    if (renderTarget.isWebGLMultipleRenderTargets) {\n      for (var _i127 = 0, il = texture.length; _i127 < il; _i127++) {\n        var attachmentProperties = properties.get(texture[_i127]);\n\n        if (attachmentProperties.__webglTexture) {\n          _gl.deleteTexture(attachmentProperties.__webglTexture);\n\n          info.memory.textures--;\n        }\n\n        properties.remove(texture[_i127]);\n      }\n    }\n\n    properties.remove(texture);\n    properties.remove(renderTarget);\n  } //\n\n\n  var textureUnits = 0;\n\n  function resetTextureUnits() {\n    textureUnits = 0;\n  }\n\n  function allocateTextureUnit() {\n    var textureUnit = textureUnits;\n\n    if (textureUnit >= maxTextures) {\n      console.warn(\'THREE.WebGLTextures: Trying to use \' + textureUnit + \' texture units while this GPU supports only \' + maxTextures);\n    }\n\n    textureUnits += 1;\n    return textureUnit;\n  }\n\n  function getTextureCacheKey(texture) {\n    var array = [];\n    array.push(texture.wrapS);\n    array.push(texture.wrapT);\n    array.push(texture.magFilter);\n    array.push(texture.minFilter);\n    array.push(texture.anisotropy);\n    array.push(texture.internalFormat);\n    array.push(texture.format);\n    array.push(texture.type);\n    array.push(texture.generateMipmaps);\n    array.push(texture.premultiplyAlpha);\n    array.push(texture.flipY);\n    array.push(texture.unpackAlignment);\n    array.push(texture.encoding);\n    return array.join();\n  } //\n\n\n  function setTexture2D(texture, slot) {\n    var textureProperties = properties.get(texture);\n    if (texture.isVideoTexture) updateVideoTexture(texture);\n\n    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {\n      var image = texture.image;\n\n      if (image === null) {\n        console.warn(\'THREE.WebGLRenderer: Texture marked for update but no image data found.\');\n      } else if (image.complete === false) {\n        console.warn(\'THREE.WebGLRenderer: Texture marked for update but image is incomplete\');\n      } else {\n        uploadTexture(textureProperties, texture, slot);\n        return;\n      }\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(3553, textureProperties.__webglTexture);\n  }\n\n  function setTexture2DArray(texture, slot) {\n    var textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(35866, textureProperties.__webglTexture);\n  }\n\n  function setTexture3D(texture, slot) {\n    var textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(32879, textureProperties.__webglTexture);\n  }\n\n  function setTextureCube(texture, slot) {\n    var textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadCubeTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(33984 + slot);\n    state.bindTexture(34067, textureProperties.__webglTexture);\n  }\n\n  var wrappingToGL = (_wrappingToGL = {}, (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_wrappingToGL, RepeatWrapping, 10497), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_wrappingToGL, ClampToEdgeWrapping, 33071), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_wrappingToGL, MirroredRepeatWrapping, 33648), _wrappingToGL);\n  var filterToGL = (_filterToGL = {}, (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_filterToGL, NearestFilter, 9728), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_filterToGL, NearestMipmapNearestFilter, 9984), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_filterToGL, NearestMipmapLinearFilter, 9986), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_filterToGL, LinearFilter, 9729), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_filterToGL, LinearMipmapNearestFilter, 9985), (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .Z)(_filterToGL, LinearMipmapLinearFilter, 9987), _filterToGL);\n\n  function setTextureParameters(textureType, texture, supportsMips) {\n    if (supportsMips) {\n      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);\n\n      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);\n\n      if (textureType === 32879 || textureType === 35866) {\n        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);\n      }\n\n      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);\n\n      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);\n    } else {\n      _gl.texParameteri(textureType, 10242, 33071);\n\n      _gl.texParameteri(textureType, 10243, 33071);\n\n      if (textureType === 32879 || textureType === 35866) {\n        _gl.texParameteri(textureType, 32882, 33071);\n      }\n\n      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {\n        console.warn(\'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.\');\n      }\n\n      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));\n\n      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));\n\n      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n        console.warn(\'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.\');\n      }\n    }\n\n    if (extensions.has(\'EXT_texture_filter_anisotropic\') === true) {\n      var extension = extensions.get(\'EXT_texture_filter_anisotropic\');\n      if (texture.type === FloatType && extensions.has(\'OES_texture_float_linear\') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n      if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has(\'OES_texture_half_float_linear\') === false) return; // verify extension for WebGL 1 only\n\n      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\n\n        properties.get(texture).__currentAnisotropy = texture.anisotropy;\n      }\n    }\n  }\n\n  function initTexture(textureProperties, texture) {\n    var forceUpload = false;\n\n    if (textureProperties.__webglInit === undefined) {\n      textureProperties.__webglInit = true;\n      texture.addEventListener(\'dispose\', onTextureDispose);\n    } // create Source <-> WebGLTextures mapping if necessary\n\n\n    var source = texture.source;\n\n    var webglTextures = _sources.get(source);\n\n    if (webglTextures === undefined) {\n      webglTextures = {};\n\n      _sources.set(source, webglTextures);\n    } // check if there is already a WebGLTexture object for the given texture parameters\n\n\n    var textureCacheKey = getTextureCacheKey(texture);\n\n    if (textureCacheKey !== textureProperties.__cacheKey) {\n      // if not, create a new instance of WebGLTexture\n      if (webglTextures[textureCacheKey] === undefined) {\n        // create new entry\n        webglTextures[textureCacheKey] = {\n          texture: _gl.createTexture(),\n          usedTimes: 0\n        };\n        info.memory.textures++; // when a new instance of WebGLTexture was created, a texture upload is required\n        // even if the image contents are identical\n\n        forceUpload = true;\n      }\n\n      webglTextures[textureCacheKey].usedTimes++; // every time the texture cache key changes, it\'s necessary to check if an instance of\n      // WebGLTexture can be deleted in order to avoid a memory leak.\n\n      var webglTexture = webglTextures[textureProperties.__cacheKey];\n\n      if (webglTexture !== undefined) {\n        webglTextures[textureProperties.__cacheKey].usedTimes--;\n\n        if (webglTexture.usedTimes === 0) {\n          deleteTexture(texture);\n        }\n      } // store references to cache key and WebGLTexture object\n\n\n      textureProperties.__cacheKey = textureCacheKey;\n      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;\n    }\n\n    return forceUpload;\n  }\n\n  function uploadTexture(textureProperties, texture, slot) {\n    var textureType = 3553;\n    if (texture.isDataArrayTexture) textureType = 35866;\n    if (texture.isData3DTexture) textureType = 32879;\n    var forceUpload = initTexture(textureProperties, texture);\n    var source = texture.source;\n    state.activeTexture(33984 + slot);\n    state.bindTexture(textureType, textureProperties.__webglTexture);\n\n    if (source.version !== source.__currentVersion || forceUpload === true) {\n      _gl.pixelStorei(37440, texture.flipY);\n\n      _gl.pixelStorei(37441, texture.premultiplyAlpha);\n\n      _gl.pixelStorei(3317, texture.unpackAlignment);\n\n      _gl.pixelStorei(37443, 0);\n\n      var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;\n      var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);\n      image = verifyColorSpace(texture, image);\n      var supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n          glFormat = utils.convert(texture.format, texture.encoding);\n      var glType = utils.convert(texture.type),\n          glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);\n      setTextureParameters(textureType, texture, supportsMips);\n      var mipmap;\n      var mipmaps = texture.mipmaps;\n      var useTexStorage = isWebGL2 && texture.isVideoTexture !== true;\n      var allocateMemory = source.__currentVersion === undefined || forceUpload === true;\n      var levels = getMipLevels(texture, image, supportsMips);\n\n      if (texture.isDepthTexture) {\n        // populate depth texture with dummy data\n        glInternalFormat = 6402;\n\n        if (isWebGL2) {\n          if (texture.type === FloatType) {\n            glInternalFormat = 36012;\n          } else if (texture.type === UnsignedIntType) {\n            glInternalFormat = 33190;\n          } else if (texture.type === UnsignedInt248Type) {\n            glInternalFormat = 35056;\n          } else {\n            glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D\n          }\n        } else {\n          if (texture.type === FloatType) {\n            console.error(\'WebGLRenderer: Floating point depth texture requires WebGL2.\');\n          }\n        } // validation checks for WebGL 1\n\n\n        if (texture.format === DepthFormat && glInternalFormat === 6402) {\n          // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n          // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {\n            console.warn(\'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.\');\n            texture.type = UnsignedIntType;\n            glType = utils.convert(texture.type);\n          }\n        }\n\n        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {\n          // Depth stencil textures need the DEPTH_STENCIL internal format\n          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n          glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n          // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n          // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\n          if (texture.type !== UnsignedInt248Type) {\n            console.warn(\'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.\');\n            texture.type = UnsignedInt248Type;\n            glType = utils.convert(texture.type);\n          }\n        } //\n\n\n        if (allocateMemory) {\n          if (useTexStorage) {\n            state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);\n          } else {\n            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n          }\n        }\n      } else if (texture.isDataTexture) {\n        // use manually created mipmaps if available\n        // if there are no manual mipmaps\n        // set 0 level mipmap and then use GL to generate other mipmap levels\n        if (mipmaps.length > 0 && supportsMips) {\n          if (useTexStorage && allocateMemory) {\n            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n          }\n\n          for (var _i128 = 0, il = mipmaps.length; _i128 < il; _i128++) {\n            mipmap = mipmaps[_i128];\n\n            if (useTexStorage) {\n              state.texSubImage2D(3553, _i128, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n            } else {\n              state.texImage2D(3553, _i128, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n            }\n          }\n\n          texture.generateMipmaps = false;\n        } else {\n          if (useTexStorage) {\n            if (allocateMemory) {\n              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);\n            }\n\n            state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);\n          } else {\n            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\n          }\n        }\n      } else if (texture.isCompressedTexture) {\n        if (useTexStorage && allocateMemory) {\n          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n        }\n\n        for (var _i129 = 0, _il9 = mipmaps.length; _i129 < _il9; _i129++) {\n          mipmap = mipmaps[_i129];\n\n          if (texture.format !== RGBAFormat) {\n            if (glFormat !== null) {\n              if (useTexStorage) {\n                state.compressedTexSubImage2D(3553, _i129, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n              } else {\n                state.compressedTexImage2D(3553, _i129, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n              }\n            } else {\n              console.warn(\'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\');\n            }\n          } else {\n            if (useTexStorage) {\n              state.texSubImage2D(3553, _i129, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n            } else {\n              state.texImage2D(3553, _i129, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n            }\n          }\n        }\n      } else if (texture.isDataArrayTexture) {\n        if (useTexStorage) {\n          if (allocateMemory) {\n            state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);\n          }\n\n          state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n        } else {\n          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n        }\n      } else if (texture.isData3DTexture) {\n        if (useTexStorage) {\n          if (allocateMemory) {\n            state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);\n          }\n\n          state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n        } else {\n          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n        }\n      } else if (texture.isFramebufferTexture) {\n        if (allocateMemory) {\n          if (useTexStorage) {\n            state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);\n          } else {\n            var width = image.width,\n                height = image.height;\n\n            for (var _i130 = 0; _i130 < levels; _i130++) {\n              state.texImage2D(3553, _i130, glInternalFormat, width, height, 0, glFormat, glType, null);\n              width >>= 1;\n              height >>= 1;\n            }\n          }\n        }\n      } else {\n        // regular Texture (image, video, canvas)\n        // use manually created mipmaps if available\n        // if there are no manual mipmaps\n        // set 0 level mipmap and then use GL to generate other mipmap levels\n        if (mipmaps.length > 0 && supportsMips) {\n          if (useTexStorage && allocateMemory) {\n            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n          }\n\n          for (var _i131 = 0, _il10 = mipmaps.length; _i131 < _il10; _i131++) {\n            mipmap = mipmaps[_i131];\n\n            if (useTexStorage) {\n              state.texSubImage2D(3553, _i131, 0, 0, glFormat, glType, mipmap);\n            } else {\n              state.texImage2D(3553, _i131, glInternalFormat, glFormat, glType, mipmap);\n            }\n          }\n\n          texture.generateMipmaps = false;\n        } else {\n          if (useTexStorage) {\n            if (allocateMemory) {\n              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);\n            }\n\n            state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);\n          } else {\n            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);\n          }\n        }\n      }\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(textureType);\n      }\n\n      source.__currentVersion = source.version;\n      if (texture.onUpdate) texture.onUpdate(texture);\n    }\n\n    textureProperties.__version = texture.version;\n  }\n\n  function uploadCubeTexture(textureProperties, texture, slot) {\n    if (texture.image.length !== 6) return;\n    var forceUpload = initTexture(textureProperties, texture);\n    var source = texture.source;\n    state.activeTexture(33984 + slot);\n    state.bindTexture(34067, textureProperties.__webglTexture);\n\n    if (source.version !== source.__currentVersion || forceUpload === true) {\n      _gl.pixelStorei(37440, texture.flipY);\n\n      _gl.pixelStorei(37441, texture.premultiplyAlpha);\n\n      _gl.pixelStorei(3317, texture.unpackAlignment);\n\n      _gl.pixelStorei(37443, 0);\n\n      var isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;\n      var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n      var cubeImage = [];\n\n      for (var _i132 = 0; _i132 < 6; _i132++) {\n        if (!isCompressed && !isDataTexture) {\n          cubeImage[_i132] = resizeImage(texture.image[_i132], false, true, maxCubemapSize);\n        } else {\n          cubeImage[_i132] = isDataTexture ? texture.image[_i132].image : texture.image[_i132];\n        }\n\n        cubeImage[_i132] = verifyColorSpace(texture, cubeImage[_i132]);\n      }\n\n      var image = cubeImage[0],\n          supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n          glFormat = utils.convert(texture.format, texture.encoding),\n          glType = utils.convert(texture.type),\n          glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);\n      var useTexStorage = isWebGL2 && texture.isVideoTexture !== true;\n      var allocateMemory = source.__currentVersion === undefined || forceUpload === true;\n      var levels = getMipLevels(texture, image, supportsMips);\n      setTextureParameters(34067, texture, supportsMips);\n      var mipmaps;\n\n      if (isCompressed) {\n        if (useTexStorage && allocateMemory) {\n          state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);\n        }\n\n        for (var _i133 = 0; _i133 < 6; _i133++) {\n          mipmaps = cubeImage[_i133].mipmaps;\n\n          for (var j = 0; j < mipmaps.length; j++) {\n            var mipmap = mipmaps[j];\n\n            if (texture.format !== RGBAFormat) {\n              if (glFormat !== null) {\n                if (useTexStorage) {\n                  state.compressedTexSubImage2D(34069 + _i133, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n                } else {\n                  state.compressedTexImage2D(34069 + _i133, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n                }\n              } else {\n                console.warn(\'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\');\n              }\n            } else {\n              if (useTexStorage) {\n                state.texSubImage2D(34069 + _i133, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n              } else {\n                state.texImage2D(34069 + _i133, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n              }\n            }\n          }\n        }\n      } else {\n        mipmaps = texture.mipmaps;\n\n        if (useTexStorage && allocateMemory) {\n          // TODO: Uniformly handle mipmap definitions\n          // Normal textures and compressed cube textures define base level + mips with their mipmap array\n          // Uncompressed cube textures use their mipmap array only for mips (no base level)\n          if (mipmaps.length > 0) levels++;\n          state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);\n        }\n\n        for (var _i134 = 0; _i134 < 6; _i134++) {\n          if (isDataTexture) {\n            if (useTexStorage) {\n              state.texSubImage2D(34069 + _i134, 0, 0, 0, cubeImage[_i134].width, cubeImage[_i134].height, glFormat, glType, cubeImage[_i134].data);\n            } else {\n              state.texImage2D(34069 + _i134, 0, glInternalFormat, cubeImage[_i134].width, cubeImage[_i134].height, 0, glFormat, glType, cubeImage[_i134].data);\n            }\n\n            for (var _j3 = 0; _j3 < mipmaps.length; _j3++) {\n              var _mipmap = mipmaps[_j3];\n              var mipmapImage = _mipmap.image[_i134].image;\n\n              if (useTexStorage) {\n                state.texSubImage2D(34069 + _i134, _j3 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);\n              } else {\n                state.texImage2D(34069 + _i134, _j3 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);\n              }\n            }\n          } else {\n            if (useTexStorage) {\n              state.texSubImage2D(34069 + _i134, 0, 0, 0, glFormat, glType, cubeImage[_i134]);\n            } else {\n              state.texImage2D(34069 + _i134, 0, glInternalFormat, glFormat, glType, cubeImage[_i134]);\n            }\n\n            for (var _j4 = 0; _j4 < mipmaps.length; _j4++) {\n              var _mipmap2 = mipmaps[_j4];\n\n              if (useTexStorage) {\n                state.texSubImage2D(34069 + _i134, _j4 + 1, 0, 0, glFormat, glType, _mipmap2.image[_i134]);\n              } else {\n                state.texImage2D(34069 + _i134, _j4 + 1, glInternalFormat, glFormat, glType, _mipmap2.image[_i134]);\n              }\n            }\n          }\n        }\n      }\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        // We assume images for cube map have the same size.\n        generateMipmap(34067);\n      }\n\n      source.__currentVersion = source.version;\n      if (texture.onUpdate) texture.onUpdate(texture);\n    }\n\n    textureProperties.__version = texture.version;\n  } // Render targets\n  // Setup storage for target texture and bind it to correct framebuffer\n\n\n  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {\n    var glFormat = utils.convert(texture.format, texture.encoding);\n    var glType = utils.convert(texture.type);\n    var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);\n    var renderTargetProperties = properties.get(renderTarget);\n\n    if (!renderTargetProperties.__hasExternalTextures) {\n      if (textureTarget === 32879 || textureTarget === 35866) {\n        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);\n      } else {\n        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n      }\n    }\n\n    state.bindFramebuffer(36160, framebuffer);\n\n    if (useMultisampledRTT(renderTarget)) {\n      multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));\n    } else {\n      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);\n    }\n\n    state.bindFramebuffer(36160, null);\n  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\n\n  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n    _gl.bindRenderbuffer(36161, renderbuffer);\n\n    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n      var glInternalFormat = 33189;\n\n      if (isMultisample || useMultisampledRTT(renderTarget)) {\n        var depthTexture = renderTarget.depthTexture;\n\n        if (depthTexture && depthTexture.isDepthTexture) {\n          if (depthTexture.type === FloatType) {\n            glInternalFormat = 36012;\n          } else if (depthTexture.type === UnsignedIntType) {\n            glInternalFormat = 33190;\n          }\n        }\n\n        var samples = getRenderTargetSamples(renderTarget);\n\n        if (useMultisampledRTT(renderTarget)) {\n          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n        } else {\n          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n        }\n      } else {\n        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);\n      }\n\n      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);\n    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n      var _samples = getRenderTargetSamples(renderTarget);\n\n      if (isMultisample && useMultisampledRTT(renderTarget) === false) {\n        _gl.renderbufferStorageMultisample(36161, _samples, 35056, renderTarget.width, renderTarget.height);\n      } else if (useMultisampledRTT(renderTarget)) {\n        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, _samples, 35056, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);\n      }\n\n      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);\n    } else {\n      var textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];\n\n      for (var _i135 = 0; _i135 < textures.length; _i135++) {\n        var texture = textures[_i135];\n        var glFormat = utils.convert(texture.format, texture.encoding);\n        var glType = utils.convert(texture.type);\n\n        var _glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);\n\n        var _samples2 = getRenderTargetSamples(renderTarget);\n\n        if (isMultisample && useMultisampledRTT(renderTarget) === false) {\n          _gl.renderbufferStorageMultisample(36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height);\n        } else if (useMultisampledRTT(renderTarget)) {\n          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, _samples2, _glInternalFormat, renderTarget.width, renderTarget.height);\n        } else {\n          _gl.renderbufferStorage(36161, _glInternalFormat, renderTarget.width, renderTarget.height);\n        }\n      }\n    }\n\n    _gl.bindRenderbuffer(36161, null);\n  } // Setup resources for a Depth Texture for a FBO (needs an extension)\n\n\n  function setupDepthTexture(framebuffer, renderTarget) {\n    var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n    if (isCube) throw new Error(\'Depth Texture with cube render targets is not supported\');\n    state.bindFramebuffer(36160, framebuffer);\n\n    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\n      throw new Error(\'renderTarget.depthTexture must be an instance of THREE.DepthTexture\');\n    } // upload an empty depth texture with framebuffer size\n\n\n    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {\n      renderTarget.depthTexture.image.width = renderTarget.width;\n      renderTarget.depthTexture.image.height = renderTarget.height;\n      renderTarget.depthTexture.needsUpdate = true;\n    }\n\n    setTexture2D(renderTarget.depthTexture, 0);\n\n    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;\n\n    var samples = getRenderTargetSamples(renderTarget);\n\n    if (renderTarget.depthTexture.format === DepthFormat) {\n      if (useMultisampledRTT(renderTarget)) {\n        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);\n      } else {\n        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);\n      }\n    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n      if (useMultisampledRTT(renderTarget)) {\n        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);\n      } else {\n        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);\n      }\n    } else {\n      throw new Error(\'Unknown depthTexture format\');\n    }\n  } // Setup GL resources for a non-texture depth buffer\n\n\n  function setupDepthRenderbuffer(renderTarget) {\n    var renderTargetProperties = properties.get(renderTarget);\n    var isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {\n      if (isCube) throw new Error(\'target.depthTexture not supported in Cube render targets\');\n      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\n    } else {\n      if (isCube) {\n        renderTargetProperties.__webglDepthbuffer = [];\n\n        for (var _i136 = 0; _i136 < 6; _i136++) {\n          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[_i136]);\n          renderTargetProperties.__webglDepthbuffer[_i136] = _gl.createRenderbuffer();\n          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[_i136], renderTarget, false);\n        }\n      } else {\n        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);\n        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);\n      }\n    }\n\n    state.bindFramebuffer(36160, null);\n  } // rebind framebuffer with external textures\n\n\n  function rebindTextures(renderTarget, colorTexture, depthTexture) {\n    var renderTargetProperties = properties.get(renderTarget);\n\n    if (colorTexture !== undefined) {\n      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);\n    }\n\n    if (depthTexture !== undefined) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  } // Set up GL resources for the render target\n\n\n  function setupRenderTarget(renderTarget) {\n    var texture = renderTarget.texture;\n    var renderTargetProperties = properties.get(renderTarget);\n    var textureProperties = properties.get(texture);\n    renderTarget.addEventListener(\'dispose\', onRenderTargetDispose);\n\n    if (renderTarget.isWebGLMultipleRenderTargets !== true) {\n      if (textureProperties.__webglTexture === undefined) {\n        textureProperties.__webglTexture = _gl.createTexture();\n      }\n\n      textureProperties.__version = texture.version;\n      info.memory.textures++;\n    }\n\n    var isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    var isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;\n    var supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Setup framebuffer\n\n    if (isCube) {\n      renderTargetProperties.__webglFramebuffer = [];\n\n      for (var _i137 = 0; _i137 < 6; _i137++) {\n        renderTargetProperties.__webglFramebuffer[_i137] = _gl.createFramebuffer();\n      }\n    } else {\n      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n      if (isMultipleRenderTargets) {\n        if (capabilities.drawBuffers) {\n          var textures = renderTarget.texture;\n\n          for (var _i138 = 0, il = textures.length; _i138 < il; _i138++) {\n            var attachmentProperties = properties.get(textures[_i138]);\n\n            if (attachmentProperties.__webglTexture === undefined) {\n              attachmentProperties.__webglTexture = _gl.createTexture();\n              info.memory.textures++;\n            }\n          }\n        } else {\n          console.warn(\'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.\');\n        }\n      }\n\n      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {\n        var _textures = isMultipleRenderTargets ? texture : [texture];\n\n        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n        renderTargetProperties.__webglColorRenderbuffer = [];\n        state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);\n\n        for (var _i139 = 0; _i139 < _textures.length; _i139++) {\n          var _texture = _textures[_i139];\n          renderTargetProperties.__webglColorRenderbuffer[_i139] = _gl.createRenderbuffer();\n\n          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer[_i139]);\n\n          var glFormat = utils.convert(_texture.format, _texture.encoding);\n          var glType = utils.convert(_texture.type);\n          var glInternalFormat = getInternalFormat(_texture.internalFormat, glFormat, glType, _texture.encoding);\n          var samples = getRenderTargetSamples(renderTarget);\n\n          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\n          _gl.framebufferRenderbuffer(36160, 36064 + _i139, 36161, renderTargetProperties.__webglColorRenderbuffer[_i139]);\n        }\n\n        _gl.bindRenderbuffer(36161, null);\n\n        if (renderTarget.depthBuffer) {\n          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\n        }\n\n        state.bindFramebuffer(36160, null);\n      }\n    } // Setup color buffer\n\n\n    if (isCube) {\n      state.bindTexture(34067, textureProperties.__webglTexture);\n      setTextureParameters(34067, texture, supportsMips);\n\n      for (var _i140 = 0; _i140 < 6; _i140++) {\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[_i140], renderTarget, texture, 36064, 34069 + _i140);\n      }\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(34067);\n      }\n\n      state.unbindTexture();\n    } else if (isMultipleRenderTargets) {\n      var _textures2 = renderTarget.texture;\n\n      for (var _i141 = 0, _il11 = _textures2.length; _i141 < _il11; _i141++) {\n        var attachment = _textures2[_i141];\n\n        var _attachmentProperties = properties.get(attachment);\n\n        state.bindTexture(3553, _attachmentProperties.__webglTexture);\n        setTextureParameters(3553, attachment, supportsMips);\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + _i141, 3553);\n\n        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {\n          generateMipmap(3553);\n        }\n      }\n\n      state.unbindTexture();\n    } else {\n      var glTextureType = 3553;\n\n      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {\n        if (isWebGL2) {\n          glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;\n        } else {\n          console.error(\'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.\');\n        }\n      }\n\n      state.bindTexture(glTextureType, textureProperties.__webglTexture);\n      setTextureParameters(glTextureType, texture, supportsMips);\n      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(glTextureType);\n      }\n\n      state.unbindTexture();\n    } // Setup depth and stencil buffers\n\n\n    if (renderTarget.depthBuffer) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  }\n\n  function updateRenderTargetMipmap(renderTarget) {\n    var supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n    var textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];\n\n    for (var _i142 = 0, il = textures.length; _i142 < il; _i142++) {\n      var texture = textures[_i142];\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;\n\n        var webglTexture = properties.get(texture).__webglTexture;\n\n        state.bindTexture(target, webglTexture);\n        generateMipmap(target);\n        state.unbindTexture();\n      }\n    }\n  }\n\n  function updateMultisampleRenderTarget(renderTarget) {\n    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {\n      var textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];\n      var width = renderTarget.width;\n      var height = renderTarget.height;\n      var mask = 16384;\n      var invalidationArray = [];\n      var depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;\n      var renderTargetProperties = properties.get(renderTarget);\n      var isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true; // If MRT we need to remove FBO attachments\n\n      if (isMultipleRenderTargets) {\n        for (var _i143 = 0; _i143 < textures.length; _i143++) {\n          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);\n\n          _gl.framebufferRenderbuffer(36160, 36064 + _i143, 36161, null);\n\n          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);\n\n          _gl.framebufferTexture2D(36009, 36064 + _i143, 3553, null, 0);\n        }\n      }\n\n      state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);\n      state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);\n\n      for (var _i144 = 0; _i144 < textures.length; _i144++) {\n        invalidationArray.push(36064 + _i144);\n\n        if (renderTarget.depthBuffer) {\n          invalidationArray.push(depthStyle);\n        }\n\n        var ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== undefined ? renderTargetProperties.__ignoreDepthValues : false;\n\n        if (ignoreDepthValues === false) {\n          if (renderTarget.depthBuffer) mask |= 256;\n          if (renderTarget.stencilBuffer) mask |= 1024;\n        }\n\n        if (isMultipleRenderTargets) {\n          _gl.framebufferRenderbuffer(36008, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer[_i144]);\n        }\n\n        if (ignoreDepthValues === true) {\n          _gl.invalidateFramebuffer(36008, [depthStyle]);\n\n          _gl.invalidateFramebuffer(36009, [depthStyle]);\n        }\n\n        if (isMultipleRenderTargets) {\n          var webglTexture = properties.get(textures[_i144]).__webglTexture;\n\n          _gl.framebufferTexture2D(36009, 36064, 3553, webglTexture, 0);\n        }\n\n        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);\n\n        if (supportsInvalidateFramebuffer) {\n          _gl.invalidateFramebuffer(36008, invalidationArray);\n        }\n      }\n\n      state.bindFramebuffer(36008, null);\n      state.bindFramebuffer(36009, null); // If MRT since pre-blit we removed the FBO we need to reconstruct the attachments\n\n      if (isMultipleRenderTargets) {\n        for (var _i145 = 0; _i145 < textures.length; _i145++) {\n          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);\n\n          _gl.framebufferRenderbuffer(36160, 36064 + _i145, 36161, renderTargetProperties.__webglColorRenderbuffer[_i145]);\n\n          var _webglTexture = properties.get(textures[_i145]).__webglTexture;\n\n          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);\n\n          _gl.framebufferTexture2D(36009, 36064 + _i145, 3553, _webglTexture, 0);\n        }\n      }\n\n      state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);\n    }\n  }\n\n  function getRenderTargetSamples(renderTarget) {\n    return Math.min(maxSamples, renderTarget.samples);\n  }\n\n  function useMultisampledRTT(renderTarget) {\n    var renderTargetProperties = properties.get(renderTarget);\n    return isWebGL2 && renderTarget.samples > 0 && extensions.has(\'WEBGL_multisampled_render_to_texture\') === true && renderTargetProperties.__useRenderToTexture !== false;\n  }\n\n  function updateVideoTexture(texture) {\n    var frame = info.render.frame; // Check the last frame we updated the VideoTexture\n\n    if (_videoTextures.get(texture) !== frame) {\n      _videoTextures.set(texture, frame);\n\n      texture.update();\n    }\n  }\n\n  function verifyColorSpace(texture, image) {\n    var encoding = texture.encoding;\n    var format = texture.format;\n    var type = texture.type;\n    if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat) return image;\n\n    if (encoding !== LinearEncoding) {\n      // sRGB\n      if (encoding === sRGBEncoding) {\n        if (isWebGL2 === false) {\n          // in WebGL 1, try to use EXT_sRGB extension and unsized formats\n          if (extensions.has(\'EXT_sRGB\') === true && format === RGBAFormat) {\n            texture.format = _SRGBAFormat; // it\'s not possible to generate mips in WebGL 1 with this extension\n\n            texture.minFilter = LinearFilter;\n            texture.generateMipmaps = false;\n          } else {\n            // slow fallback (CPU decode)\n            image = ImageUtils.sRGBToLinear(image);\n          }\n        } else {\n          // in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format\n          if (format !== RGBAFormat || type !== UnsignedByteType) {\n            console.warn(\'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.\');\n          }\n        }\n      } else {\n        console.error(\'THREE.WebGLTextures: Unsupported texture encoding:\', encoding);\n      }\n    }\n\n    return image;\n  } //\n\n\n  this.allocateTextureUnit = allocateTextureUnit;\n  this.resetTextureUnits = resetTextureUnits;\n  this.setTexture2D = setTexture2D;\n  this.setTexture2DArray = setTexture2DArray;\n  this.setTexture3D = setTexture3D;\n  this.setTextureCube = setTextureCube;\n  this.rebindTextures = rebindTextures;\n  this.setupRenderTarget = setupRenderTarget;\n  this.updateRenderTargetMipmap = updateRenderTargetMipmap;\n  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n  this.setupDepthRenderbuffer = setupDepthRenderbuffer;\n  this.setupFrameBufferTexture = setupFrameBufferTexture;\n  this.useMultisampledRTT = useMultisampledRTT;\n}\n\nfunction WebGLUtils(gl, extensions, capabilities) {\n  var isWebGL2 = capabilities.isWebGL2;\n\n  function convert(p) {\n    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var extension;\n    if (p === UnsignedByteType) return 5121;\n    if (p === UnsignedShort4444Type) return 32819;\n    if (p === UnsignedShort5551Type) return 32820;\n    if (p === ByteType) return 5120;\n    if (p === ShortType) return 5122;\n    if (p === UnsignedShortType) return 5123;\n    if (p === IntType) return 5124;\n    if (p === UnsignedIntType) return 5125;\n    if (p === FloatType) return 5126;\n\n    if (p === HalfFloatType) {\n      if (isWebGL2) return 5131;\n      extension = extensions.get(\'OES_texture_half_float\');\n\n      if (extension !== null) {\n        return extension.HALF_FLOAT_OES;\n      } else {\n        return null;\n      }\n    }\n\n    if (p === AlphaFormat) return 6406;\n    if (p === RGBAFormat) return 6408;\n    if (p === LuminanceFormat) return 6409;\n    if (p === LuminanceAlphaFormat) return 6410;\n    if (p === DepthFormat) return 6402;\n    if (p === DepthStencilFormat) return 34041;\n    if (p === RedFormat) return 6403;\n\n    if (p === RGBFormat) {\n      console.warn(\'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228\');\n      return 6408;\n    } // WebGL 1 sRGB fallback\n\n\n    if (p === _SRGBAFormat) {\n      extension = extensions.get(\'EXT_sRGB\');\n\n      if (extension !== null) {\n        return extension.SRGB_ALPHA_EXT;\n      } else {\n        return null;\n      }\n    } // WebGL2 formats.\n\n\n    if (p === RedIntegerFormat) return 36244;\n    if (p === RGFormat) return 33319;\n    if (p === RGIntegerFormat) return 33320;\n    if (p === RGBAIntegerFormat) return 36249; // S3TC\n\n    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n      if (encoding === sRGBEncoding) {\n        extension = extensions.get(\'WEBGL_compressed_texture_s3tc_srgb\');\n\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      } else {\n        extension = extensions.get(\'WEBGL_compressed_texture_s3tc\');\n\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      }\n    } // PVRTC\n\n\n    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n      extension = extensions.get(\'WEBGL_compressed_texture_pvrtc\');\n\n      if (extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return null;\n      }\n    } // ETC1\n\n\n    if (p === RGB_ETC1_Format) {\n      extension = extensions.get(\'WEBGL_compressed_texture_etc1\');\n\n      if (extension !== null) {\n        return extension.COMPRESSED_RGB_ETC1_WEBGL;\n      } else {\n        return null;\n      }\n    } // ETC2\n\n\n    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n      extension = extensions.get(\'WEBGL_compressed_texture_etc\');\n\n      if (extension !== null) {\n        if (p === RGB_ETC2_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n      } else {\n        return null;\n      }\n    } // ASTC\n\n\n    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {\n      extension = extensions.get(\'WEBGL_compressed_texture_astc\');\n\n      if (extension !== null) {\n        if (p === RGBA_ASTC_4x4_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n        if (p === RGBA_ASTC_5x4_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n        if (p === RGBA_ASTC_5x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n        if (p === RGBA_ASTC_6x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n        if (p === RGBA_ASTC_6x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n        if (p === RGBA_ASTC_8x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n        if (p === RGBA_ASTC_8x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n        if (p === RGBA_ASTC_8x8_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n        if (p === RGBA_ASTC_10x5_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n        if (p === RGBA_ASTC_10x6_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n        if (p === RGBA_ASTC_10x8_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n        if (p === RGBA_ASTC_10x10_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n        if (p === RGBA_ASTC_12x10_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n        if (p === RGBA_ASTC_12x12_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n      } else {\n        return null;\n      }\n    } // BPTC\n\n\n    if (p === RGBA_BPTC_Format) {\n      extension = extensions.get(\'EXT_texture_compression_bptc\');\n\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n      } else {\n        return null;\n      }\n    } //\n\n\n    if (p === UnsignedInt248Type) {\n      if (isWebGL2) return 34042;\n      extension = extensions.get(\'WEBGL_depth_texture\');\n\n      if (extension !== null) {\n        return extension.UNSIGNED_INT_24_8_WEBGL;\n      } else {\n        return null;\n      }\n    } // if "p" can\'t be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\n    return gl[p] !== undefined ? gl[p] : null;\n  }\n\n  return {\n    convert: convert\n  };\n}\n\nvar ArrayCamera = /*#__PURE__*/function (_PerspectiveCamera) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ArrayCamera, _PerspectiveCamera);\n\n  var _super34 = _createSuper(ArrayCamera);\n\n  function ArrayCamera() {\n    var _this26;\n\n    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ArrayCamera);\n\n    _this26 = _super34.call(this);\n    _this26.isArrayCamera = true;\n    _this26.cameras = array;\n    return _this26;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ArrayCamera);\n}(PerspectiveCamera);\n\nvar Group = /*#__PURE__*/function (_Object3D4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Group, _Object3D4);\n\n  var _super35 = _createSuper(Group);\n\n  function Group() {\n    var _this27;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Group);\n\n    _this27 = _super35.call(this);\n    _this27.isGroup = true;\n    _this27.type = \'Group\';\n    return _this27;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Group);\n}(Object3D);\n\nvar _moveEvent = {\n  type: \'move\'\n};\n\nvar WebXRController = /*#__PURE__*/function () {\n  function WebXRController() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebXRController);\n\n    this._targetRay = null;\n    this._grip = null;\n    this._hand = null;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebXRController, [{\n    key: "getHandSpace",\n    value: function getHandSpace() {\n      if (this._hand === null) {\n        this._hand = new Group();\n        this._hand.matrixAutoUpdate = false;\n        this._hand.visible = false;\n        this._hand.joints = {};\n        this._hand.inputState = {\n          pinching: false\n        };\n      }\n\n      return this._hand;\n    }\n  }, {\n    key: "getTargetRaySpace",\n    value: function getTargetRaySpace() {\n      if (this._targetRay === null) {\n        this._targetRay = new Group();\n        this._targetRay.matrixAutoUpdate = false;\n        this._targetRay.visible = false;\n        this._targetRay.hasLinearVelocity = false;\n        this._targetRay.linearVelocity = new Vector3();\n        this._targetRay.hasAngularVelocity = false;\n        this._targetRay.angularVelocity = new Vector3();\n      }\n\n      return this._targetRay;\n    }\n  }, {\n    key: "getGripSpace",\n    value: function getGripSpace() {\n      if (this._grip === null) {\n        this._grip = new Group();\n        this._grip.matrixAutoUpdate = false;\n        this._grip.visible = false;\n        this._grip.hasLinearVelocity = false;\n        this._grip.linearVelocity = new Vector3();\n        this._grip.hasAngularVelocity = false;\n        this._grip.angularVelocity = new Vector3();\n      }\n\n      return this._grip;\n    }\n  }, {\n    key: "dispatchEvent",\n    value: function dispatchEvent(event) {\n      if (this._targetRay !== null) {\n        this._targetRay.dispatchEvent(event);\n      }\n\n      if (this._grip !== null) {\n        this._grip.dispatchEvent(event);\n      }\n\n      if (this._hand !== null) {\n        this._hand.dispatchEvent(event);\n      }\n\n      return this;\n    }\n  }, {\n    key: "disconnect",\n    value: function disconnect(inputSource) {\n      this.dispatchEvent({\n        type: \'disconnected\',\n        data: inputSource\n      });\n\n      if (this._targetRay !== null) {\n        this._targetRay.visible = false;\n      }\n\n      if (this._grip !== null) {\n        this._grip.visible = false;\n      }\n\n      if (this._hand !== null) {\n        this._hand.visible = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: "update",\n    value: function update(inputSource, frame, referenceSpace) {\n      var inputPose = null;\n      var gripPose = null;\n      var handPose = null;\n      var targetRay = this._targetRay;\n      var grip = this._grip;\n      var hand = this._hand;\n\n      if (inputSource && frame.session.visibilityState !== \'visible-blurred\') {\n        if (targetRay !== null) {\n          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n\n          if (inputPose !== null) {\n            targetRay.matrix.fromArray(inputPose.transform.matrix);\n            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n\n            if (inputPose.linearVelocity) {\n              targetRay.hasLinearVelocity = true;\n              targetRay.linearVelocity.copy(inputPose.linearVelocity);\n            } else {\n              targetRay.hasLinearVelocity = false;\n            }\n\n            if (inputPose.angularVelocity) {\n              targetRay.hasAngularVelocity = true;\n              targetRay.angularVelocity.copy(inputPose.angularVelocity);\n            } else {\n              targetRay.hasAngularVelocity = false;\n            }\n\n            this.dispatchEvent(_moveEvent);\n          }\n        }\n\n        if (hand && inputSource.hand) {\n          handPose = true;\n\n          var _iterator2 = _createForOfIteratorHelper(inputSource.hand.values()),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var inputjoint = _step2.value;\n              // Update the joints groups with the XRJoint poses\n              var jointPose = frame.getJointPose(inputjoint, referenceSpace);\n\n              if (hand.joints[inputjoint.jointName] === undefined) {\n                // The transform of this joint will be updated with the joint pose on each frame\n                var _joint = new Group();\n\n                _joint.matrixAutoUpdate = false;\n                _joint.visible = false;\n                hand.joints[inputjoint.jointName] = _joint; // ??\n\n                hand.add(_joint);\n              }\n\n              var joint = hand.joints[inputjoint.jointName];\n\n              if (jointPose !== null) {\n                joint.matrix.fromArray(jointPose.transform.matrix);\n                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n                joint.jointRadius = jointPose.radius;\n              }\n\n              joint.visible = jointPose !== null;\n            } // Custom events\n            // Check pinchz\n\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          var indexTip = hand.joints[\'index-finger-tip\'];\n          var thumbTip = hand.joints[\'thumb-tip\'];\n          var distance = indexTip.position.distanceTo(thumbTip.position);\n          var distanceToPinch = 0.02;\n          var threshold = 0.005;\n\n          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n            hand.inputState.pinching = false;\n            this.dispatchEvent({\n              type: \'pinchend\',\n              handedness: inputSource.handedness,\n              target: this\n            });\n          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n            hand.inputState.pinching = true;\n            this.dispatchEvent({\n              type: \'pinchstart\',\n              handedness: inputSource.handedness,\n              target: this\n            });\n          }\n        } else {\n          if (grip !== null && inputSource.gripSpace) {\n            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n\n            if (gripPose !== null) {\n              grip.matrix.fromArray(gripPose.transform.matrix);\n              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n\n              if (gripPose.linearVelocity) {\n                grip.hasLinearVelocity = true;\n                grip.linearVelocity.copy(gripPose.linearVelocity);\n              } else {\n                grip.hasLinearVelocity = false;\n              }\n\n              if (gripPose.angularVelocity) {\n                grip.hasAngularVelocity = true;\n                grip.angularVelocity.copy(gripPose.angularVelocity);\n              } else {\n                grip.hasAngularVelocity = false;\n              }\n            }\n          }\n        }\n      }\n\n      if (targetRay !== null) {\n        targetRay.visible = inputPose !== null;\n      }\n\n      if (grip !== null) {\n        grip.visible = gripPose !== null;\n      }\n\n      if (hand !== null) {\n        hand.visible = handPose !== null;\n      }\n\n      return this;\n    }\n  }]);\n\n  return WebXRController;\n}();\n\nvar DepthTexture = /*#__PURE__*/function (_Texture4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DepthTexture, _Texture4);\n\n  var _super36 = _createSuper(DepthTexture);\n\n  function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {\n    var _this28;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DepthTexture);\n\n    format = format !== undefined ? format : DepthFormat;\n\n    if (format !== DepthFormat && format !== DepthStencilFormat) {\n      throw new Error(\'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat\');\n    }\n\n    if (type === undefined && format === DepthFormat) type = UnsignedIntType;\n    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;\n    _this28 = _super36.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    _this28.isDepthTexture = true;\n    _this28.image = {\n      width: width,\n      height: height\n    };\n    _this28.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n    _this28.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n    _this28.flipY = false;\n    _this28.generateMipmaps = false;\n    return _this28;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DepthTexture);\n}(Texture);\n\nvar WebXRManager = /*#__PURE__*/function (_EventDispatcher6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WebXRManager, _EventDispatcher6);\n\n  var _super37 = _createSuper(WebXRManager);\n\n  function WebXRManager(renderer, gl) {\n    var _this29;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebXRManager);\n\n    _this29 = _super37.call(this);\n\n    var scope = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this29);\n\n    var session = null;\n    var framebufferScaleFactor = 1.0;\n    var referenceSpace = null;\n    var referenceSpaceType = \'local-floor\';\n    var customReferenceSpace = null;\n    var pose = null;\n    var glBinding = null;\n    var glProjLayer = null;\n    var glBaseLayer = null;\n    var xrFrame = null;\n    var attributes = gl.getContextAttributes();\n    var initialRenderTarget = null;\n    var newRenderTarget = null;\n    var controllers = [];\n    var inputSourcesMap = new Map(); //\n\n    var cameraL = new PerspectiveCamera();\n    cameraL.layers.enable(1);\n    cameraL.viewport = new Vector4();\n    var cameraR = new PerspectiveCamera();\n    cameraR.layers.enable(2);\n    cameraR.viewport = new Vector4();\n    var cameras = [cameraL, cameraR];\n    var cameraVR = new ArrayCamera();\n    cameraVR.layers.enable(1);\n    cameraVR.layers.enable(2);\n    var _currentDepthNear = null;\n    var _currentDepthFar = null; //\n\n    _this29.cameraAutoUpdate = true;\n    _this29.enabled = false;\n    _this29.isPresenting = false;\n\n    _this29.getController = function (index) {\n      var controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getTargetRaySpace();\n    };\n\n    _this29.getControllerGrip = function (index) {\n      var controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getGripSpace();\n    };\n\n    _this29.getHand = function (index) {\n      var controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getHandSpace();\n    }; //\n\n\n    function onSessionEvent(event) {\n      var controller = inputSourcesMap.get(event.inputSource);\n\n      if (controller !== undefined) {\n        controller.dispatchEvent({\n          type: event.type,\n          data: event.inputSource\n        });\n      }\n    }\n\n    function onSessionEnd() {\n      session.removeEventListener(\'select\', onSessionEvent);\n      session.removeEventListener(\'selectstart\', onSessionEvent);\n      session.removeEventListener(\'selectend\', onSessionEvent);\n      session.removeEventListener(\'squeeze\', onSessionEvent);\n      session.removeEventListener(\'squeezestart\', onSessionEvent);\n      session.removeEventListener(\'squeezeend\', onSessionEvent);\n      session.removeEventListener(\'end\', onSessionEnd);\n      session.removeEventListener(\'inputsourceschange\', onInputSourcesChange);\n      inputSourcesMap.forEach(function (controller, inputSource) {\n        if (controller !== undefined) {\n          controller.disconnect(inputSource);\n        }\n      });\n      inputSourcesMap.clear();\n      _currentDepthNear = null;\n      _currentDepthFar = null; // restore framebuffer/rendering state\n\n      renderer.setRenderTarget(initialRenderTarget);\n      glBaseLayer = null;\n      glProjLayer = null;\n      glBinding = null;\n      session = null;\n      newRenderTarget = null; //\n\n      animation.stop();\n      scope.isPresenting = false;\n      scope.dispatchEvent({\n        type: \'sessionend\'\n      });\n    }\n\n    _this29.setFramebufferScaleFactor = function (value) {\n      framebufferScaleFactor = value;\n\n      if (scope.isPresenting === true) {\n        console.warn(\'THREE.WebXRManager: Cannot change framebuffer scale while presenting.\');\n      }\n    };\n\n    _this29.setReferenceSpaceType = function (value) {\n      referenceSpaceType = value;\n\n      if (scope.isPresenting === true) {\n        console.warn(\'THREE.WebXRManager: Cannot change reference space type while presenting.\');\n      }\n    };\n\n    _this29.getReferenceSpace = function () {\n      return customReferenceSpace || referenceSpace;\n    };\n\n    _this29.setReferenceSpace = function (space) {\n      customReferenceSpace = space;\n    };\n\n    _this29.getBaseLayer = function () {\n      return glProjLayer !== null ? glProjLayer : glBaseLayer;\n    };\n\n    _this29.getBinding = function () {\n      return glBinding;\n    };\n\n    _this29.getFrame = function () {\n      return xrFrame;\n    };\n\n    _this29.getSession = function () {\n      return session;\n    };\n\n    _this29.setSession = /*#__PURE__*/function () {\n      var _ref = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)( /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee(value) {\n        var layerInit, depthFormat, depthType, glDepthFormat, projectionlayerInit, renderTargetProperties;\n        return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                session = value;\n\n                if (!(session !== null)) {\n                  _context8.next = 25;\n                  break;\n                }\n\n                initialRenderTarget = renderer.getRenderTarget();\n                session.addEventListener(\'select\', onSessionEvent);\n                session.addEventListener(\'selectstart\', onSessionEvent);\n                session.addEventListener(\'selectend\', onSessionEvent);\n                session.addEventListener(\'squeeze\', onSessionEvent);\n                session.addEventListener(\'squeezestart\', onSessionEvent);\n                session.addEventListener(\'squeezeend\', onSessionEvent);\n                session.addEventListener(\'end\', onSessionEnd);\n                session.addEventListener(\'inputsourceschange\', onInputSourcesChange);\n\n                if (!(attributes.xrCompatible !== true)) {\n                  _context8.next = 14;\n                  break;\n                }\n\n                _context8.next = 14;\n                return gl.makeXRCompatible();\n\n              case 14:\n                if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {\n                  layerInit = {\n                    antialias: session.renderState.layers === undefined ? attributes.antialias : true,\n                    alpha: attributes.alpha,\n                    depth: attributes.depth,\n                    stencil: attributes.stencil,\n                    framebufferScaleFactor: framebufferScaleFactor\n                  };\n                  glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n                  session.updateRenderState({\n                    baseLayer: glBaseLayer\n                  });\n                  newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {\n                    format: RGBAFormat,\n                    type: UnsignedByteType,\n                    encoding: renderer.outputEncoding\n                  });\n                } else {\n                  depthFormat = null;\n                  depthType = null;\n                  glDepthFormat = null;\n\n                  if (attributes.depth) {\n                    glDepthFormat = attributes.stencil ? 35056 : 33190;\n                    depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n                    depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;\n                  }\n\n                  projectionlayerInit = {\n                    colorFormat: renderer.outputEncoding === sRGBEncoding ? 35907 : 32856,\n                    depthFormat: glDepthFormat,\n                    scaleFactor: framebufferScaleFactor\n                  };\n                  glBinding = new XRWebGLBinding(session, gl);\n                  glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);\n                  session.updateRenderState({\n                    layers: [glProjLayer]\n                  });\n                  newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {\n                    format: RGBAFormat,\n                    type: UnsignedByteType,\n                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),\n                    stencilBuffer: attributes.stencil,\n                    encoding: renderer.outputEncoding,\n                    samples: attributes.antialias ? 4 : 0\n                  });\n                  renderTargetProperties = renderer.properties.get(newRenderTarget);\n                  renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;\n                }\n\n                newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n                // Set foveation to maximum.\n\n                this.setFoveation(1.0);\n                customReferenceSpace = null;\n                _context8.next = 20;\n                return session.requestReferenceSpace(referenceSpaceType);\n\n              case 20:\n                referenceSpace = _context8.sent;\n                animation.setContext(session);\n                animation.start();\n                scope.isPresenting = true;\n                scope.dispatchEvent({\n                  type: \'sessionstart\'\n                });\n\n              case 25:\n              case "end":\n                return _context8.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function (_x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    function onInputSourcesChange(event) {\n      var inputSources = session.inputSources; // Assign controllers to available inputSources\n\n      for (var _i146 = 0; _i146 < inputSources.length; _i146++) {\n        var index = inputSources[_i146].handedness === \'right\' ? 1 : 0;\n        inputSourcesMap.set(inputSources[_i146], controllers[index]);\n      } // Notify disconnected\n\n\n      for (var _i147 = 0; _i147 < event.removed.length; _i147++) {\n        var inputSource = event.removed[_i147];\n        var controller = inputSourcesMap.get(inputSource);\n\n        if (controller) {\n          controller.dispatchEvent({\n            type: \'disconnected\',\n            data: inputSource\n          });\n          inputSourcesMap.delete(inputSource);\n        }\n      } // Notify connected\n\n\n      for (var _i148 = 0; _i148 < event.added.length; _i148++) {\n        var _inputSource = event.added[_i148];\n\n        var _controller = inputSourcesMap.get(_inputSource);\n\n        if (_controller) {\n          _controller.dispatchEvent({\n            type: \'connected\',\n            data: _inputSource\n          });\n        }\n      }\n    } //\n\n\n    var cameraLPos = new Vector3();\n    var cameraRPos = new Vector3();\n    /**\n     * Assumes 2 cameras that are parallel and share an X-axis, and that\n     * the cameras\' projection and world matrices have already been set.\n     * And that near and far planes are identical for both cameras.\n     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n     */\n\n    function setProjectionFromUnion(camera, cameraL, cameraR) {\n      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n      var ipd = cameraLPos.distanceTo(cameraRPos);\n      var projL = cameraL.projectionMatrix.elements;\n      var projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and\n      // most likely identical top and bottom frustum extents.\n      // Use the left camera for these values.\n\n      var near = projL[14] / (projL[10] - 1);\n      var far = projL[14] / (projL[10] + 1);\n      var topFov = (projL[9] + 1) / projL[5];\n      var bottomFov = (projL[9] - 1) / projL[5];\n      var leftFov = (projL[8] - 1) / projL[0];\n      var rightFov = (projR[8] + 1) / projR[0];\n      var left = near * leftFov;\n      var right = near * rightFov; // Calculate the new camera\'s position offset from the\n      // left camera. xOffset should be roughly half `ipd`.\n\n      var zOffset = ipd / (-leftFov + rightFov);\n      var xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?\n\n      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n      camera.translateX(xOffset);\n      camera.translateZ(zOffset);\n      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale\n      // the values so that the near plane\'s position does not change in world space,\n      // although must now be relative to the new union camera.\n\n      var near2 = near + zOffset;\n      var far2 = far + zOffset;\n      var left2 = left - xOffset;\n      var right2 = right + (ipd - xOffset);\n      var top2 = topFov * far / far2 * near2;\n      var bottom2 = bottomFov * far / far2 * near2;\n      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n    }\n\n    function updateCamera(camera, parent) {\n      if (parent === null) {\n        camera.matrixWorld.copy(camera.matrix);\n      } else {\n        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n      }\n\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    }\n\n    _this29.updateCamera = function (camera) {\n      if (session === null) return;\n      cameraVR.near = cameraR.near = cameraL.near = camera.near;\n      cameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n        // Note that the new renderState won\'t apply until the next frame. See #18320\n        session.updateRenderState({\n          depthNear: cameraVR.near,\n          depthFar: cameraVR.far\n        });\n        _currentDepthNear = cameraVR.near;\n        _currentDepthFar = cameraVR.far;\n      }\n\n      var parent = camera.parent;\n      var cameras = cameraVR.cameras;\n      updateCamera(cameraVR, parent);\n\n      for (var _i149 = 0; _i149 < cameras.length; _i149++) {\n        updateCamera(cameras[_i149], parent);\n      }\n\n      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children\n\n      camera.position.copy(cameraVR.position);\n      camera.quaternion.copy(cameraVR.quaternion);\n      camera.scale.copy(cameraVR.scale);\n      camera.matrix.copy(cameraVR.matrix);\n      camera.matrixWorld.copy(cameraVR.matrixWorld);\n      var children = camera.children;\n\n      for (var _i150 = 0, l = children.length; _i150 < l; _i150++) {\n        children[_i150].updateMatrixWorld(true);\n      } // update projection matrix for proper view frustum culling\n\n\n      if (cameras.length === 2) {\n        setProjectionFromUnion(cameraVR, cameraL, cameraR);\n      } else {\n        // assume single camera setup (AR)\n        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n      }\n    };\n\n    _this29.getCamera = function () {\n      return cameraVR;\n    };\n\n    _this29.getFoveation = function () {\n      if (glProjLayer !== null) {\n        return glProjLayer.fixedFoveation;\n      }\n\n      if (glBaseLayer !== null) {\n        return glBaseLayer.fixedFoveation;\n      }\n\n      return undefined;\n    };\n\n    _this29.setFoveation = function (foveation) {\n      // 0 = no foveation = full resolution\n      // 1 = maximum foveation = the edges render at lower resolution\n      if (glProjLayer !== null) {\n        glProjLayer.fixedFoveation = foveation;\n      }\n\n      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {\n        glBaseLayer.fixedFoveation = foveation;\n      }\n    }; // Animation Loop\n\n\n    var onAnimationFrameCallback = null;\n\n    function onAnimationFrame(time, frame) {\n      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);\n      xrFrame = frame;\n\n      if (pose !== null) {\n        var views = pose.views;\n\n        if (glBaseLayer !== null) {\n          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);\n          renderer.setRenderTarget(newRenderTarget);\n        }\n\n        var cameraVRNeedsUpdate = false; // check if it\'s necessary to rebuild cameraVR\'s camera list\n\n        if (views.length !== cameraVR.cameras.length) {\n          cameraVR.cameras.length = 0;\n          cameraVRNeedsUpdate = true;\n        }\n\n        for (var _i151 = 0; _i151 < views.length; _i151++) {\n          var view = views[_i151];\n          var viewport = null;\n\n          if (glBaseLayer !== null) {\n            viewport = glBaseLayer.getViewport(view);\n          } else {\n            var glSubImage = glBinding.getViewSubImage(glProjLayer, view);\n            viewport = glSubImage.viewport; // For side-by-side projection, we only produce a single texture for both eyes.\n\n            if (_i151 === 0) {\n              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);\n              renderer.setRenderTarget(newRenderTarget);\n            }\n          }\n\n          var camera = cameras[_i151];\n\n          if (camera === undefined) {\n            camera = new PerspectiveCamera();\n            camera.layers.enable(_i151);\n            camera.viewport = new Vector4();\n            cameras[_i151] = camera;\n          }\n\n          camera.matrix.fromArray(view.transform.matrix);\n          camera.projectionMatrix.fromArray(view.projectionMatrix);\n          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n\n          if (_i151 === 0) {\n            cameraVR.matrix.copy(camera.matrix);\n          }\n\n          if (cameraVRNeedsUpdate === true) {\n            cameraVR.cameras.push(camera);\n          }\n        }\n      } //\n\n\n      var inputSources = session.inputSources;\n\n      for (var _i152 = 0; _i152 < controllers.length; _i152++) {\n        var inputSource = inputSources[_i152];\n        var controller = inputSourcesMap.get(inputSource);\n\n        if (controller !== undefined) {\n          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);\n        }\n      }\n\n      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n      xrFrame = null;\n    }\n\n    var animation = new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n\n    _this29.setAnimationLoop = function (callback) {\n      onAnimationFrameCallback = callback;\n    };\n\n    _this29.dispose = function () {};\n\n    return _this29;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebXRManager);\n}(EventDispatcher);\n\nfunction WebGLMaterials(renderer, properties) {\n  function refreshFogUniforms(uniforms, fog) {\n    uniforms.fogColor.value.copy(fog.color);\n\n    if (fog.isFog) {\n      uniforms.fogNear.value = fog.near;\n      uniforms.fogFar.value = fog.far;\n    } else if (fog.isFogExp2) {\n      uniforms.fogDensity.value = fog.density;\n    }\n  }\n\n  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {\n    if (material.isMeshBasicMaterial) {\n      refreshUniformsCommon(uniforms, material);\n    } else if (material.isMeshLambertMaterial) {\n      refreshUniformsCommon(uniforms, material);\n    } else if (material.isMeshToonMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsToon(uniforms, material);\n    } else if (material.isMeshPhongMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsPhong(uniforms, material);\n    } else if (material.isMeshStandardMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsStandard(uniforms, material);\n\n      if (material.isMeshPhysicalMaterial) {\n        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);\n      }\n    } else if (material.isMeshMatcapMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsMatcap(uniforms, material);\n    } else if (material.isMeshDepthMaterial) {\n      refreshUniformsCommon(uniforms, material);\n    } else if (material.isMeshDistanceMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsDistance(uniforms, material);\n    } else if (material.isMeshNormalMaterial) {\n      refreshUniformsCommon(uniforms, material);\n    } else if (material.isLineBasicMaterial) {\n      refreshUniformsLine(uniforms, material);\n\n      if (material.isLineDashedMaterial) {\n        refreshUniformsDash(uniforms, material);\n      }\n    } else if (material.isPointsMaterial) {\n      refreshUniformsPoints(uniforms, material, pixelRatio, height);\n    } else if (material.isSpriteMaterial) {\n      refreshUniformsSprites(uniforms, material);\n    } else if (material.isShadowMaterial) {\n      uniforms.color.value.copy(material.color);\n      uniforms.opacity.value = material.opacity;\n    } else if (material.isShaderMaterial) {\n      material.uniformsNeedUpdate = false; // #15581\n    }\n  }\n\n  function refreshUniformsCommon(uniforms, material) {\n    uniforms.opacity.value = material.opacity;\n\n    if (material.color) {\n      uniforms.diffuse.value.copy(material.color);\n    }\n\n    if (material.emissive) {\n      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n    }\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) uniforms.bumpScale.value *= -1;\n    }\n\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) uniforms.normalScale.value.negate();\n    }\n\n    if (material.specularMap) {\n      uniforms.specularMap.value = material.specularMap;\n    }\n\n    if (material.alphaTest > 0) {\n      uniforms.alphaTest.value = material.alphaTest;\n    }\n\n    var envMap = properties.get(material).envMap;\n\n    if (envMap) {\n      uniforms.envMap.value = envMap;\n      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;\n      uniforms.reflectivity.value = material.reflectivity;\n      uniforms.ior.value = material.ior;\n      uniforms.refractionRatio.value = material.refractionRatio;\n    }\n\n    if (material.lightMap) {\n      uniforms.lightMap.value = material.lightMap; // artist-friendly light intensity scaling factor\n\n      var scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;\n      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;\n    }\n\n    if (material.aoMap) {\n      uniforms.aoMap.value = material.aoMap;\n      uniforms.aoMapIntensity.value = material.aoMapIntensity;\n    } // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. specular map\n    // 3. displacementMap map\n    // 4. normal map\n    // 5. bump map\n    // 6. roughnessMap map\n    // 7. metalnessMap map\n    // 8. alphaMap map\n    // 9. emissiveMap map\n    // 10. clearcoat map\n    // 11. clearcoat normal map\n    // 12. clearcoat roughnessMap map\n    // 13. iridescence map\n    // 14. iridescence thickness map\n    // 15. specular intensity map\n    // 16. specular tint map\n    // 17. transmission map\n    // 18. thickness map\n\n\n    var uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.specularMap) {\n      uvScaleMap = material.specularMap;\n    } else if (material.displacementMap) {\n      uvScaleMap = material.displacementMap;\n    } else if (material.normalMap) {\n      uvScaleMap = material.normalMap;\n    } else if (material.bumpMap) {\n      uvScaleMap = material.bumpMap;\n    } else if (material.roughnessMap) {\n      uvScaleMap = material.roughnessMap;\n    } else if (material.metalnessMap) {\n      uvScaleMap = material.metalnessMap;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    } else if (material.emissiveMap) {\n      uvScaleMap = material.emissiveMap;\n    } else if (material.clearcoatMap) {\n      uvScaleMap = material.clearcoatMap;\n    } else if (material.clearcoatNormalMap) {\n      uvScaleMap = material.clearcoatNormalMap;\n    } else if (material.clearcoatRoughnessMap) {\n      uvScaleMap = material.clearcoatRoughnessMap;\n    } else if (material.iridescenceMap) {\n      uvScaleMap = material.iridescenceMap;\n    } else if (material.iridescenceThicknessMap) {\n      uvScaleMap = material.iridescenceThicknessMap;\n    } else if (material.specularIntensityMap) {\n      uvScaleMap = material.specularIntensityMap;\n    } else if (material.specularColorMap) {\n      uvScaleMap = material.specularColorMap;\n    } else if (material.transmissionMap) {\n      uvScaleMap = material.transmissionMap;\n    } else if (material.thicknessMap) {\n      uvScaleMap = material.thicknessMap;\n    } else if (material.sheenColorMap) {\n      uvScaleMap = material.sheenColorMap;\n    } else if (material.sheenRoughnessMap) {\n      uvScaleMap = material.sheenRoughnessMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      // backwards compatibility\n      if (uvScaleMap.isWebGLRenderTarget) {\n        uvScaleMap = uvScaleMap.texture;\n      }\n\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    } // uv repeat and offset setting priorities for uv2\n    // 1. ao map\n    // 2. light map\n\n\n    var uv2ScaleMap;\n\n    if (material.aoMap) {\n      uv2ScaleMap = material.aoMap;\n    } else if (material.lightMap) {\n      uv2ScaleMap = material.lightMap;\n    }\n\n    if (uv2ScaleMap !== undefined) {\n      // backwards compatibility\n      if (uv2ScaleMap.isWebGLRenderTarget) {\n        uv2ScaleMap = uv2ScaleMap.texture;\n      }\n\n      if (uv2ScaleMap.matrixAutoUpdate === true) {\n        uv2ScaleMap.updateMatrix();\n      }\n\n      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsLine(uniforms, material) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n  }\n\n  function refreshUniformsDash(uniforms, material) {\n    uniforms.dashSize.value = material.dashSize;\n    uniforms.totalSize.value = material.dashSize + material.gapSize;\n    uniforms.scale.value = material.scale;\n  }\n\n  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n    uniforms.size.value = material.size * pixelRatio;\n    uniforms.scale.value = height * 0.5;\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n\n    if (material.alphaTest > 0) {\n      uniforms.alphaTest.value = material.alphaTest;\n    } // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. alpha map\n\n\n    var uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsSprites(uniforms, material) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n    uniforms.rotation.value = material.rotation;\n\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n\n    if (material.alphaTest > 0) {\n      uniforms.alphaTest.value = material.alphaTest;\n    } // uv repeat and offset setting priorities\n    // 1. color map\n    // 2. alpha map\n\n\n    var uvScaleMap;\n\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    }\n\n    if (uvScaleMap !== undefined) {\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n  }\n\n  function refreshUniformsPhong(uniforms, material) {\n    uniforms.specular.value.copy(material.specular);\n    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\n  }\n\n  function refreshUniformsToon(uniforms, material) {\n    if (material.gradientMap) {\n      uniforms.gradientMap.value = material.gradientMap;\n    }\n  }\n\n  function refreshUniformsStandard(uniforms, material) {\n    uniforms.roughness.value = material.roughness;\n    uniforms.metalness.value = material.metalness;\n\n    if (material.roughnessMap) {\n      uniforms.roughnessMap.value = material.roughnessMap;\n    }\n\n    if (material.metalnessMap) {\n      uniforms.metalnessMap.value = material.metalnessMap;\n    }\n\n    var envMap = properties.get(material).envMap;\n\n    if (envMap) {\n      //uniforms.envMap.value = material.envMap; // part of uniforms common\n      uniforms.envMapIntensity.value = material.envMapIntensity;\n    }\n  }\n\n  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {\n    uniforms.ior.value = material.ior; // also part of uniforms common\n\n    if (material.sheen > 0) {\n      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);\n      uniforms.sheenRoughness.value = material.sheenRoughness;\n\n      if (material.sheenColorMap) {\n        uniforms.sheenColorMap.value = material.sheenColorMap;\n      }\n\n      if (material.sheenRoughnessMap) {\n        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;\n      }\n    }\n\n    if (material.clearcoat > 0) {\n      uniforms.clearcoat.value = material.clearcoat;\n      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\n      if (material.clearcoatMap) {\n        uniforms.clearcoatMap.value = material.clearcoatMap;\n      }\n\n      if (material.clearcoatRoughnessMap) {\n        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n      }\n\n      if (material.clearcoatNormalMap) {\n        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n        if (material.side === BackSide) {\n          uniforms.clearcoatNormalScale.value.negate();\n        }\n      }\n    }\n\n    if (material.iridescence > 0) {\n      uniforms.iridescence.value = material.iridescence;\n      uniforms.iridescenceIOR.value = material.iridescenceIOR;\n      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];\n      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];\n\n      if (material.iridescenceMap) {\n        uniforms.iridescenceMap.value = material.iridescenceMap;\n      }\n\n      if (material.iridescenceThicknessMap) {\n        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;\n      }\n    }\n\n    if (material.transmission > 0) {\n      uniforms.transmission.value = material.transmission;\n      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);\n\n      if (material.transmissionMap) {\n        uniforms.transmissionMap.value = material.transmissionMap;\n      }\n\n      uniforms.thickness.value = material.thickness;\n\n      if (material.thicknessMap) {\n        uniforms.thicknessMap.value = material.thicknessMap;\n      }\n\n      uniforms.attenuationDistance.value = material.attenuationDistance;\n      uniforms.attenuationColor.value.copy(material.attenuationColor);\n    }\n\n    uniforms.specularIntensity.value = material.specularIntensity;\n    uniforms.specularColor.value.copy(material.specularColor);\n\n    if (material.specularIntensityMap) {\n      uniforms.specularIntensityMap.value = material.specularIntensityMap;\n    }\n\n    if (material.specularColorMap) {\n      uniforms.specularColorMap.value = material.specularColorMap;\n    }\n  }\n\n  function refreshUniformsMatcap(uniforms, material) {\n    if (material.matcap) {\n      uniforms.matcap.value = material.matcap;\n    }\n  }\n\n  function refreshUniformsDistance(uniforms, material) {\n    uniforms.referencePosition.value.copy(material.referencePosition);\n    uniforms.nearDistance.value = material.nearDistance;\n    uniforms.farDistance.value = material.farDistance;\n  }\n\n  return {\n    refreshFogUniforms: refreshFogUniforms,\n    refreshMaterialUniforms: refreshMaterialUniforms\n  };\n}\n\nfunction createCanvasElement() {\n  var canvas = createElementNS(\'canvas\');\n  canvas.style.display = \'block\';\n  return canvas;\n}\n\nfunction WebGLRenderer() {\n  var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  this.isWebGLRenderer = true;\n\n  var _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n      _context = parameters.context !== undefined ? parameters.context : null,\n      _depth = parameters.depth !== undefined ? parameters.depth : true,\n      _stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n      _antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n      _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n      _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n      _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : \'default\',\n      _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n  var _alpha;\n\n  if (_context !== null) {\n    _alpha = _context.getContextAttributes().alpha;\n  } else {\n    _alpha = parameters.alpha !== undefined ? parameters.alpha : false;\n  }\n\n  var currentRenderList = null;\n  var currentRenderState = null; // render() can be called from within a callback triggered by another render.\n  // We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n  var renderListStack = [];\n  var renderStateStack = []; // public properties\n\n  this.domElement = _canvas; // Debug configuration container\n\n  this.debug = {\n    /**\n     * Enables error checking and reporting when shader programs are being compiled\n     * @type {boolean}\n     */\n    checkShaderErrors: true\n  }; // clearing\n\n  this.autoClear = true;\n  this.autoClearColor = true;\n  this.autoClearDepth = true;\n  this.autoClearStencil = true; // scene graph\n\n  this.sortObjects = true; // user-defined clipping\n\n  this.clippingPlanes = [];\n  this.localClippingEnabled = false; // physically based shading\n\n  this.outputEncoding = LinearEncoding; // physical lights\n\n  this.physicallyCorrectLights = false; // tone mapping\n\n  this.toneMapping = NoToneMapping;\n  this.toneMappingExposure = 1.0; //\n\n  Object.defineProperties(this, {\n    // @deprecated since r136, 0e21088102b4de7e0a0a33140620b7a3424b9e6d\n    gammaFactor: {\n      get: function get() {\n        console.warn(\'THREE.WebGLRenderer: .gammaFactor has been removed.\');\n        return 2;\n      },\n      set: function set() {\n        console.warn(\'THREE.WebGLRenderer: .gammaFactor has been removed.\');\n      }\n    }\n  }); // internal properties\n\n  var _this = this;\n\n  var _isContextLost = false; // internal state cache\n\n  var _currentActiveCubeFace = 0;\n  var _currentActiveMipmapLevel = 0;\n  var _currentRenderTarget = null;\n\n  var _currentMaterialId = -1;\n\n  var _currentCamera = null;\n\n  var _currentViewport = new Vector4();\n\n  var _currentScissor = new Vector4();\n\n  var _currentScissorTest = null; //\n\n  var _width = _canvas.width;\n  var _height = _canvas.height;\n  var _pixelRatio = 1;\n  var _opaqueSort = null;\n  var _transparentSort = null;\n\n  var _viewport = new Vector4(0, 0, _width, _height);\n\n  var _scissor = new Vector4(0, 0, _width, _height);\n\n  var _scissorTest = false; // frustum\n\n  var _frustum = new Frustum(); // clipping\n\n\n  var _clippingEnabled = false;\n  var _localClippingEnabled = false; // transmission\n\n  var _transmissionRenderTarget = null; // camera matrices cache\n\n  var _projScreenMatrix = new Matrix4();\n\n  var _vector2 = new Vector2();\n\n  var _vector3 = new Vector3();\n\n  var _emptyScene = {\n    background: null,\n    fog: null,\n    environment: null,\n    overrideMaterial: null,\n    isScene: true\n  };\n\n  function getTargetPixelRatio() {\n    return _currentRenderTarget === null ? _pixelRatio : 1;\n  } // initialize\n\n\n  var _gl = _context;\n\n  function getContext(contextNames, contextAttributes) {\n    for (var _i153 = 0; _i153 < contextNames.length; _i153++) {\n      var contextName = contextNames[_i153];\n\n      var context = _canvas.getContext(contextName, contextAttributes);\n\n      if (context !== null) return context;\n    }\n\n    return null;\n  }\n\n  try {\n    var contextAttributes = {\n      alpha: true,\n      depth: _depth,\n      stencil: _stencil,\n      antialias: _antialias,\n      premultipliedAlpha: _premultipliedAlpha,\n      preserveDrawingBuffer: _preserveDrawingBuffer,\n      powerPreference: _powerPreference,\n      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n    }; // OffscreenCanvas does not have setAttribute, see #22811\n\n    if (\'setAttribute\' in _canvas) _canvas.setAttribute(\'data-engine\', "three.js r".concat(REVISION)); // event listeners must be registered before WebGL context is created, see #12753\n\n    _canvas.addEventListener(\'webglcontextlost\', onContextLost, false);\n\n    _canvas.addEventListener(\'webglcontextrestored\', onContextRestore, false);\n\n    _canvas.addEventListener(\'webglcontextcreationerror\', onContextCreationError, false);\n\n    if (_gl === null) {\n      var contextNames = [\'webgl2\', \'webgl\', \'experimental-webgl\'];\n\n      if (_this.isWebGL1Renderer === true) {\n        contextNames.shift();\n      }\n\n      _gl = getContext(contextNames, contextAttributes);\n\n      if (_gl === null) {\n        if (getContext(contextNames)) {\n          throw new Error(\'Error creating WebGL context with your selected attributes.\');\n        } else {\n          throw new Error(\'Error creating WebGL context.\');\n        }\n      }\n    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\n    if (_gl.getShaderPrecisionFormat === undefined) {\n      _gl.getShaderPrecisionFormat = function () {\n        return {\n          \'rangeMin\': 1,\n          \'rangeMax\': 1,\n          \'precision\': 1\n        };\n      };\n    }\n  } catch (error) {\n    console.error(\'THREE.WebGLRenderer: \' + error.message);\n    throw error;\n  }\n\n  var extensions, capabilities, state, info;\n  var properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n  var programCache, materials, renderLists, renderStates, clipping, shadowMap;\n  var background, morphtargets, bufferRenderer, indexedBufferRenderer;\n  var utils, bindingStates;\n\n  function initGLContext() {\n    extensions = new WebGLExtensions(_gl);\n    capabilities = new WebGLCapabilities(_gl, extensions, parameters);\n    extensions.init(capabilities);\n    utils = new WebGLUtils(_gl, extensions, capabilities);\n    state = new WebGLState(_gl, extensions, capabilities);\n    info = new WebGLInfo(_gl);\n    properties = new WebGLProperties();\n    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n    cubemaps = new WebGLCubeMaps(_this);\n    cubeuvmaps = new WebGLCubeUVMaps(_this);\n    attributes = new WebGLAttributes(_gl, capabilities);\n    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);\n    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n    objects = new WebGLObjects(_gl, geometries, attributes, info);\n    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);\n    clipping = new WebGLClipping(properties);\n    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);\n    materials = new WebGLMaterials(_this, properties);\n    renderLists = new WebGLRenderLists();\n    renderStates = new WebGLRenderStates(extensions, capabilities);\n    background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);\n    shadowMap = new WebGLShadowMap(_this, objects, capabilities);\n    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\n    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\n    info.programs = programCache.programs;\n    _this.capabilities = capabilities;\n    _this.extensions = extensions;\n    _this.properties = properties;\n    _this.renderLists = renderLists;\n    _this.shadowMap = shadowMap;\n    _this.state = state;\n    _this.info = info;\n  }\n\n  initGLContext(); // xr\n\n  var xr = new WebXRManager(_this, _gl);\n  this.xr = xr; // API\n\n  this.getContext = function () {\n    return _gl;\n  };\n\n  this.getContextAttributes = function () {\n    return _gl.getContextAttributes();\n  };\n\n  this.forceContextLoss = function () {\n    var extension = extensions.get(\'WEBGL_lose_context\');\n    if (extension) extension.loseContext();\n  };\n\n  this.forceContextRestore = function () {\n    var extension = extensions.get(\'WEBGL_lose_context\');\n    if (extension) extension.restoreContext();\n  };\n\n  this.getPixelRatio = function () {\n    return _pixelRatio;\n  };\n\n  this.setPixelRatio = function (value) {\n    if (value === undefined) return;\n    _pixelRatio = value;\n    this.setSize(_width, _height, false);\n  };\n\n  this.getSize = function (target) {\n    return target.set(_width, _height);\n  };\n\n  this.setSize = function (width, height, updateStyle) {\n    if (xr.isPresenting) {\n      console.warn(\'THREE.WebGLRenderer: Can\\\'t change size while VR device is presenting.\');\n      return;\n    }\n\n    _width = width;\n    _height = height;\n    _canvas.width = Math.floor(width * _pixelRatio);\n    _canvas.height = Math.floor(height * _pixelRatio);\n\n    if (updateStyle !== false) {\n      _canvas.style.width = width + \'px\';\n      _canvas.style.height = height + \'px\';\n    }\n\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.getDrawingBufferSize = function (target) {\n    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n  };\n\n  this.setDrawingBufferSize = function (width, height, pixelRatio) {\n    _width = width;\n    _height = height;\n    _pixelRatio = pixelRatio;\n    _canvas.width = Math.floor(width * pixelRatio);\n    _canvas.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.getCurrentViewport = function (target) {\n    return target.copy(_currentViewport);\n  };\n\n  this.getViewport = function (target) {\n    return target.copy(_viewport);\n  };\n\n  this.setViewport = function (x, y, width, height) {\n    if (x.isVector4) {\n      _viewport.set(x.x, x.y, x.z, x.w);\n    } else {\n      _viewport.set(x, y, width, height);\n    }\n\n    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\n  };\n\n  this.getScissor = function (target) {\n    return target.copy(_scissor);\n  };\n\n  this.setScissor = function (x, y, width, height) {\n    if (x.isVector4) {\n      _scissor.set(x.x, x.y, x.z, x.w);\n    } else {\n      _scissor.set(x, y, width, height);\n    }\n\n    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\n  };\n\n  this.getScissorTest = function () {\n    return _scissorTest;\n  };\n\n  this.setScissorTest = function (boolean) {\n    state.setScissorTest(_scissorTest = boolean);\n  };\n\n  this.setOpaqueSort = function (method) {\n    _opaqueSort = method;\n  };\n\n  this.setTransparentSort = function (method) {\n    _transparentSort = method;\n  }; // Clearing\n\n\n  this.getClearColor = function (target) {\n    return target.copy(background.getClearColor());\n  };\n\n  this.setClearColor = function () {\n    background.setClearColor.apply(background, arguments);\n  };\n\n  this.getClearAlpha = function () {\n    return background.getClearAlpha();\n  };\n\n  this.setClearAlpha = function () {\n    background.setClearAlpha.apply(background, arguments);\n  };\n\n  this.clear = function () {\n    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var bits = 0;\n    if (color) bits |= 16384;\n    if (depth) bits |= 256;\n    if (stencil) bits |= 1024;\n\n    _gl.clear(bits);\n  };\n\n  this.clearColor = function () {\n    this.clear(true, false, false);\n  };\n\n  this.clearDepth = function () {\n    this.clear(false, true, false);\n  };\n\n  this.clearStencil = function () {\n    this.clear(false, false, true);\n  }; //\n\n\n  this.dispose = function () {\n    _canvas.removeEventListener(\'webglcontextlost\', onContextLost, false);\n\n    _canvas.removeEventListener(\'webglcontextrestored\', onContextRestore, false);\n\n    _canvas.removeEventListener(\'webglcontextcreationerror\', onContextCreationError, false);\n\n    renderLists.dispose();\n    renderStates.dispose();\n    properties.dispose();\n    cubemaps.dispose();\n    cubeuvmaps.dispose();\n    objects.dispose();\n    bindingStates.dispose();\n    programCache.dispose();\n    xr.dispose();\n    xr.removeEventListener(\'sessionstart\', onXRSessionStart);\n    xr.removeEventListener(\'sessionend\', onXRSessionEnd);\n\n    if (_transmissionRenderTarget) {\n      _transmissionRenderTarget.dispose();\n\n      _transmissionRenderTarget = null;\n    }\n\n    animation.stop();\n  }; // Events\n\n\n  function onContextLost(event) {\n    event.preventDefault();\n    console.log(\'THREE.WebGLRenderer: Context Lost.\');\n    _isContextLost = true;\n  }\n\n  function\n    /* event */\n  onContextRestore() {\n    console.log(\'THREE.WebGLRenderer: Context Restored.\');\n    _isContextLost = false;\n    var infoAutoReset = info.autoReset;\n    var shadowMapEnabled = shadowMap.enabled;\n    var shadowMapAutoUpdate = shadowMap.autoUpdate;\n    var shadowMapNeedsUpdate = shadowMap.needsUpdate;\n    var shadowMapType = shadowMap.type;\n    initGLContext();\n    info.autoReset = infoAutoReset;\n    shadowMap.enabled = shadowMapEnabled;\n    shadowMap.autoUpdate = shadowMapAutoUpdate;\n    shadowMap.needsUpdate = shadowMapNeedsUpdate;\n    shadowMap.type = shadowMapType;\n  }\n\n  function onContextCreationError(event) {\n    console.error(\'THREE.WebGLRenderer: A WebGL context could not be created. Reason: \', event.statusMessage);\n  }\n\n  function onMaterialDispose(event) {\n    var material = event.target;\n    material.removeEventListener(\'dispose\', onMaterialDispose);\n    deallocateMaterial(material);\n  } // Buffer deallocation\n\n\n  function deallocateMaterial(material) {\n    releaseMaterialProgramReferences(material);\n    properties.remove(material);\n  }\n\n  function releaseMaterialProgramReferences(material) {\n    var programs = properties.get(material).programs;\n\n    if (programs !== undefined) {\n      programs.forEach(function (program) {\n        programCache.releaseProgram(program);\n      });\n\n      if (material.isShaderMaterial) {\n        programCache.releaseShaderCache(material);\n      }\n    }\n  } // Buffer rendering\n\n\n  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {\n    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n    var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n    var program = setProgram(camera, scene, geometry, material, object);\n    state.setMaterial(material, frontFaceCW); //\n\n    var index = geometry.index;\n    var position = geometry.attributes.position; //\n\n    if (index === null) {\n      if (position === undefined || position.count === 0) return;\n    } else if (index.count === 0) {\n      return;\n    } //\n\n\n    var rangeFactor = 1;\n\n    if (material.wireframe === true) {\n      index = geometries.getWireframeAttribute(geometry);\n      rangeFactor = 2;\n    }\n\n    bindingStates.setup(object, material, program, geometry, index);\n    var attribute;\n    var renderer = bufferRenderer;\n\n    if (index !== null) {\n      attribute = attributes.get(index);\n      renderer = indexedBufferRenderer;\n      renderer.setIndex(attribute);\n    } //\n\n\n    var dataCount = index !== null ? index.count : position.count;\n    var rangeStart = geometry.drawRange.start * rangeFactor;\n    var rangeCount = geometry.drawRange.count * rangeFactor;\n    var groupStart = group !== null ? group.start * rangeFactor : 0;\n    var groupCount = group !== null ? group.count * rangeFactor : Infinity;\n    var drawStart = Math.max(rangeStart, groupStart);\n    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\n    var drawCount = Math.max(0, drawEnd - drawStart + 1);\n    if (drawCount === 0) return; //\n\n    if (object.isMesh) {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n        renderer.setMode(1);\n      } else {\n        renderer.setMode(4);\n      }\n    } else if (object.isLine) {\n      var lineWidth = material.linewidth;\n      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n      state.setLineWidth(lineWidth * getTargetPixelRatio());\n\n      if (object.isLineSegments) {\n        renderer.setMode(1);\n      } else if (object.isLineLoop) {\n        renderer.setMode(2);\n      } else {\n        renderer.setMode(3);\n      }\n    } else if (object.isPoints) {\n      renderer.setMode(0);\n    } else if (object.isSprite) {\n      renderer.setMode(4);\n    }\n\n    if (object.isInstancedMesh) {\n      renderer.renderInstances(drawStart, drawCount, object.count);\n    } else if (geometry.isInstancedBufferGeometry) {\n      var instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);\n      renderer.renderInstances(drawStart, drawCount, instanceCount);\n    } else {\n      renderer.render(drawStart, drawCount);\n    }\n  }; // Compile\n\n\n  this.compile = function (scene, camera) {\n    currentRenderState = renderStates.get(scene);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n    scene.traverseVisible(function (object) {\n      if (object.isLight && object.layers.test(camera.layers)) {\n        currentRenderState.pushLight(object);\n\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      }\n    });\n    currentRenderState.setupLights(_this.physicallyCorrectLights);\n    scene.traverse(function (object) {\n      var material = object.material;\n\n      if (material) {\n        if (Array.isArray(material)) {\n          for (var _i154 = 0; _i154 < material.length; _i154++) {\n            var material2 = material[_i154];\n            getProgram(material2, scene, object);\n          }\n        } else {\n          getProgram(material, scene, object);\n        }\n      }\n    });\n    renderStateStack.pop();\n    currentRenderState = null;\n  }; // Animation Loop\n\n\n  var onAnimationFrameCallback = null;\n\n  function onAnimationFrame(time) {\n    if (onAnimationFrameCallback) onAnimationFrameCallback(time);\n  }\n\n  function onXRSessionStart() {\n    animation.stop();\n  }\n\n  function onXRSessionEnd() {\n    animation.start();\n  }\n\n  var animation = new WebGLAnimation();\n  animation.setAnimationLoop(onAnimationFrame);\n  if (typeof self !== \'undefined\') animation.setContext(self);\n\n  this.setAnimationLoop = function (callback) {\n    onAnimationFrameCallback = callback;\n    xr.setAnimationLoop(callback);\n    callback === null ? animation.stop() : animation.start();\n  };\n\n  xr.addEventListener(\'sessionstart\', onXRSessionStart);\n  xr.addEventListener(\'sessionend\', onXRSessionEnd); // Rendering\n\n  this.render = function (scene, camera) {\n    if (camera !== undefined && camera.isCamera !== true) {\n      console.error(\'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\');\n      return;\n    }\n\n    if (_isContextLost === true) return; // update scene graph\n\n    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum\n\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    if (xr.enabled === true && xr.isPresenting === true) {\n      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n      camera = xr.getCamera(); // use XR camera for rendering\n    } //\n\n\n    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n    currentRenderState = renderStates.get(scene, renderStateStack.length);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n    _frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n    _localClippingEnabled = this.localClippingEnabled;\n    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\n    currentRenderList = renderLists.get(scene, renderListStack.length);\n    currentRenderList.init();\n    renderListStack.push(currentRenderList);\n    projectObject(scene, camera, 0, _this.sortObjects);\n    currentRenderList.finish();\n\n    if (_this.sortObjects === true) {\n      currentRenderList.sort(_opaqueSort, _transparentSort);\n    } //\n\n\n    if (_clippingEnabled === true) clipping.beginShadows();\n    var shadowsArray = currentRenderState.state.shadowsArray;\n    shadowMap.render(shadowsArray, scene, camera);\n    if (_clippingEnabled === true) clipping.endShadows(); //\n\n    if (this.info.autoReset === true) this.info.reset(); //\n\n    background.render(currentRenderList, scene); // render scene\n\n    currentRenderState.setupLights(_this.physicallyCorrectLights);\n\n    if (camera.isArrayCamera) {\n      var cameras = camera.cameras;\n\n      for (var _i155 = 0, l = cameras.length; _i155 < l; _i155++) {\n        var camera2 = cameras[_i155];\n        renderScene(currentRenderList, scene, camera2, camera2.viewport);\n      }\n    } else {\n      renderScene(currentRenderList, scene, camera);\n    } //\n\n\n    if (_currentRenderTarget !== null) {\n      // resolve multisample renderbuffers to a single-sample texture if necessary\n      textures.updateMultisampleRenderTarget(_currentRenderTarget); // Generate mipmap if we\'re using any kind of mipmap filtering\n\n      textures.updateRenderTargetMipmap(_currentRenderTarget);\n    } //\n\n\n    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // _gl.finish();\n\n    bindingStates.resetDefaultState();\n    _currentMaterialId = -1;\n    _currentCamera = null;\n    renderStateStack.pop();\n\n    if (renderStateStack.length > 0) {\n      currentRenderState = renderStateStack[renderStateStack.length - 1];\n    } else {\n      currentRenderState = null;\n    }\n\n    renderListStack.pop();\n\n    if (renderListStack.length > 0) {\n      currentRenderList = renderListStack[renderListStack.length - 1];\n    } else {\n      currentRenderList = null;\n    }\n  };\n\n  function projectObject(object, camera, groupOrder, sortObjects) {\n    if (object.visible === false) return;\n    var visible = object.layers.test(camera.layers);\n\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        currentRenderState.pushLight(object);\n\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n\n          var geometry = objects.update(object);\n          var material = object.material;\n\n          if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.isSkinnedMesh) {\n          // update skeleton only once in a frame\n          if (object.skeleton.frame !== info.render.frame) {\n            object.skeleton.update();\n            object.skeleton.frame = info.render.frame;\n          }\n        }\n\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n\n          var _geometry2 = objects.update(object);\n\n          var _material = object.material;\n\n          if (Array.isArray(_material)) {\n            var groups = _geometry2.groups;\n\n            for (var _i156 = 0, l = groups.length; _i156 < l; _i156++) {\n              var group = groups[_i156];\n              var groupMaterial = _material[group.materialIndex];\n\n              if (groupMaterial && groupMaterial.visible) {\n                currentRenderList.push(object, _geometry2, groupMaterial, groupOrder, _vector3.z, group);\n              }\n            }\n          } else if (_material.visible) {\n            currentRenderList.push(object, _geometry2, _material, groupOrder, _vector3.z, null);\n          }\n        }\n      }\n    }\n\n    var children = object.children;\n\n    for (var _i157 = 0, _l6 = children.length; _i157 < _l6; _i157++) {\n      projectObject(children[_i157], camera, groupOrder, sortObjects);\n    }\n  }\n\n  function renderScene(currentRenderList, scene, camera, viewport) {\n    var opaqueObjects = currentRenderList.opaque;\n    var transmissiveObjects = currentRenderList.transmissive;\n    var transparentObjects = currentRenderList.transparent;\n    currentRenderState.setupLightsView(camera);\n    if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);\n    if (viewport) state.viewport(_currentViewport.copy(viewport));\n    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n    if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);\n    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n    state.buffers.depth.setTest(true);\n    state.buffers.depth.setMask(true);\n    state.buffers.color.setMask(true);\n    state.setPolygonOffset(false);\n  }\n\n  function renderTransmissionPass(opaqueObjects, scene, camera) {\n    var isWebGL2 = capabilities.isWebGL2;\n\n    if (_transmissionRenderTarget === null) {\n      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {\n        generateMipmaps: true,\n        type: extensions.has(\'EXT_color_buffer_half_float\') ? HalfFloatType : UnsignedByteType,\n        minFilter: LinearMipmapLinearFilter,\n        samples: isWebGL2 && _antialias === true ? 4 : 0\n      });\n    }\n\n    _this.getDrawingBufferSize(_vector2);\n\n    if (isWebGL2) {\n      _transmissionRenderTarget.setSize(_vector2.x, _vector2.y);\n    } else {\n      _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));\n    } //\n\n\n    var currentRenderTarget = _this.getRenderTarget();\n\n    _this.setRenderTarget(_transmissionRenderTarget);\n\n    _this.clear(); // Turn off the features which can affect the frag color for opaque objects pass.\n    // Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\n\n    var currentToneMapping = _this.toneMapping;\n    _this.toneMapping = NoToneMapping;\n    renderObjects(opaqueObjects, scene, camera);\n    _this.toneMapping = currentToneMapping;\n    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);\n    textures.updateRenderTargetMipmap(_transmissionRenderTarget);\n\n    _this.setRenderTarget(currentRenderTarget);\n  }\n\n  function renderObjects(renderList, scene, camera) {\n    var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n    for (var _i158 = 0, l = renderList.length; _i158 < l; _i158++) {\n      var renderItem = renderList[_i158];\n      var object = renderItem.object;\n      var geometry = renderItem.geometry;\n      var material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n      var group = renderItem.group;\n\n      if (object.layers.test(camera.layers)) {\n        renderObject(object, scene, camera, geometry, material, group);\n      }\n    }\n  }\n\n  function renderObject(object, scene, camera, geometry, material, group) {\n    object.onBeforeRender(_this, scene, camera, geometry, material, group);\n    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n    material.onBeforeRender(_this, scene, camera, geometry, object, group);\n\n    if (material.transparent === true && material.side === DoubleSide) {\n      material.side = BackSide;\n      material.needsUpdate = true;\n\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\n      material.side = FrontSide;\n      material.needsUpdate = true;\n\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\n      material.side = DoubleSide;\n    } else {\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n    }\n\n    object.onAfterRender(_this, scene, camera, geometry, material, group);\n  }\n\n  function getProgram(material, scene, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    var materialProperties = properties.get(material);\n    var lights = currentRenderState.state.lights;\n    var shadowsArray = currentRenderState.state.shadowsArray;\n    var lightsStateVersion = lights.state.version;\n    var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n    var programCacheKey = programCache.getProgramCacheKey(parameters);\n    var programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it\'s possible that the program doesn\'t change\n\n    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n    materialProperties.fog = scene.fog;\n    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);\n\n    if (programs === undefined) {\n      // new material\n      material.addEventListener(\'dispose\', onMaterialDispose);\n      programs = new Map();\n      materialProperties.programs = programs;\n    }\n\n    var program = programs.get(programCacheKey);\n\n    if (program !== undefined) {\n      // early out if program and light state is identical\n      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n        updateCommonMaterialProperties(material, parameters);\n        return program;\n      }\n    } else {\n      parameters.uniforms = programCache.getUniforms(material);\n      material.onBuild(object, parameters, _this);\n      material.onBeforeCompile(parameters, _this);\n      program = programCache.acquireProgram(parameters, programCacheKey);\n      programs.set(programCacheKey, program);\n      materialProperties.uniforms = parameters.uniforms;\n    }\n\n    var uniforms = materialProperties.uniforms;\n\n    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n      uniforms.clippingPlanes = clipping.uniform;\n    }\n\n    updateCommonMaterialProperties(material, parameters); // store the light setup it was created for\n\n    materialProperties.needsLights = materialNeedsLights(material);\n    materialProperties.lightsStateVersion = lightsStateVersion;\n\n    if (materialProperties.needsLights) {\n      // wire up the material to this renderer\'s lighting state\n      uniforms.ambientLightColor.value = lights.state.ambient;\n      uniforms.lightProbe.value = lights.state.probe;\n      uniforms.directionalLights.value = lights.state.directional;\n      uniforms.directionalLightShadows.value = lights.state.directionalShadow;\n      uniforms.spotLights.value = lights.state.spot;\n      uniforms.spotLightShadows.value = lights.state.spotShadow;\n      uniforms.rectAreaLights.value = lights.state.rectArea;\n      uniforms.ltc_1.value = lights.state.rectAreaLTC1;\n      uniforms.ltc_2.value = lights.state.rectAreaLTC2;\n      uniforms.pointLights.value = lights.state.point;\n      uniforms.pointLightShadows.value = lights.state.pointShadow;\n      uniforms.hemisphereLights.value = lights.state.hemi;\n      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n      uniforms.spotShadowMap.value = lights.state.spotShadowMap;\n      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n      uniforms.pointShadowMap.value = lights.state.pointShadowMap;\n      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms\n    }\n\n    var progUniforms = program.getUniforms();\n    var uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n    materialProperties.currentProgram = program;\n    materialProperties.uniformsList = uniformsList;\n    return program;\n  }\n\n  function updateCommonMaterialProperties(material, parameters) {\n    var materialProperties = properties.get(material);\n    materialProperties.outputEncoding = parameters.outputEncoding;\n    materialProperties.instancing = parameters.instancing;\n    materialProperties.skinning = parameters.skinning;\n    materialProperties.morphTargets = parameters.morphTargets;\n    materialProperties.morphNormals = parameters.morphNormals;\n    materialProperties.morphColors = parameters.morphColors;\n    materialProperties.morphTargetsCount = parameters.morphTargetsCount;\n    materialProperties.numClippingPlanes = parameters.numClippingPlanes;\n    materialProperties.numIntersection = parameters.numClipIntersection;\n    materialProperties.vertexAlphas = parameters.vertexAlphas;\n    materialProperties.vertexTangents = parameters.vertexTangents;\n    materialProperties.toneMapping = parameters.toneMapping;\n  }\n\n  function setProgram(camera, scene, geometry, material, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    textures.resetTextureUnits();\n    var fog = scene.fog;\n    var environment = material.isMeshStandardMaterial ? scene.environment : null;\n    var encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;\n    var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n    var vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n    var vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;\n    var morphTargets = !!geometry.morphAttributes.position;\n    var morphNormals = !!geometry.morphAttributes.normal;\n    var morphColors = !!geometry.morphAttributes.color;\n    var toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;\n    var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n    var materialProperties = properties.get(material);\n    var lights = currentRenderState.state.lights;\n\n    if (_clippingEnabled === true) {\n      if (_localClippingEnabled === true || camera !== _currentCamera) {\n        var useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup\n        // object instead of the material, once it becomes feasible\n        // (#8465, #8379)\n\n        clipping.setState(material, camera, useCache);\n      }\n    } //\n\n\n    var needsProgramChange = false;\n\n    if (material.version === materialProperties.__version) {\n      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n        needsProgramChange = true;\n      } else if (materialProperties.outputEncoding !== encoding) {\n        needsProgramChange = true;\n      } else if (object.isInstancedMesh && materialProperties.instancing === false) {\n        needsProgramChange = true;\n      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n        needsProgramChange = true;\n      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {\n        needsProgramChange = true;\n      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {\n        needsProgramChange = true;\n      } else if (materialProperties.envMap !== envMap) {\n        needsProgramChange = true;\n      } else if (material.fog === true && materialProperties.fog !== fog) {\n        needsProgramChange = true;\n      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexAlphas !== vertexAlphas) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexTangents !== vertexTangents) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphTargets !== morphTargets) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphNormals !== morphNormals) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphColors !== morphColors) {\n        needsProgramChange = true;\n      } else if (materialProperties.toneMapping !== toneMapping) {\n        needsProgramChange = true;\n      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {\n        needsProgramChange = true;\n      }\n    } else {\n      needsProgramChange = true;\n      materialProperties.__version = material.version;\n    } //\n\n\n    var program = materialProperties.currentProgram;\n\n    if (needsProgramChange === true) {\n      program = getProgram(material, scene, object);\n    }\n\n    var refreshProgram = false;\n    var refreshMaterial = false;\n    var refreshLights = false;\n    var p_uniforms = program.getUniforms(),\n        m_uniforms = materialProperties.uniforms;\n\n    if (state.useProgram(program.program)) {\n      refreshProgram = true;\n      refreshMaterial = true;\n      refreshLights = true;\n    }\n\n    if (material.id !== _currentMaterialId) {\n      _currentMaterialId = material.id;\n      refreshMaterial = true;\n    }\n\n    if (refreshProgram || _currentCamera !== camera) {\n      p_uniforms.setValue(_gl, \'projectionMatrix\', camera.projectionMatrix);\n\n      if (capabilities.logarithmicDepthBuffer) {\n        p_uniforms.setValue(_gl, \'logDepthBufFC\', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n      }\n\n      if (_currentCamera !== camera) {\n        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update\n        // now, in case this material supports lights - or later, when\n        // the next material that does gets activated:\n\n        refreshMaterial = true; // set to true on material change\n\n        refreshLights = true; // remains set until update done\n      } // load material specific uniforms\n      // (shader material also gets them for the sake of genericity)\n\n\n      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {\n        var uCamPos = p_uniforms.map.cameraPosition;\n\n        if (uCamPos !== undefined) {\n          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\n        }\n      }\n\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n        p_uniforms.setValue(_gl, \'isOrthographic\', camera.isOrthographicCamera === true);\n      }\n\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {\n        p_uniforms.setValue(_gl, \'viewMatrix\', camera.matrixWorldInverse);\n      }\n    } // skinning and morph target uniforms must be set even if material didn\'t change\n    // auto-setting of texture unit for bone and morph texture must go before other textures\n    // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n\n    if (object.isSkinnedMesh) {\n      p_uniforms.setOptional(_gl, object, \'bindMatrix\');\n      p_uniforms.setOptional(_gl, object, \'bindMatrixInverse\');\n      var skeleton = object.skeleton;\n\n      if (skeleton) {\n        if (capabilities.floatVertexTextures) {\n          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n          p_uniforms.setValue(_gl, \'boneTexture\', skeleton.boneTexture, textures);\n          p_uniforms.setValue(_gl, \'boneTextureSize\', skeleton.boneTextureSize);\n        } else {\n          console.warn(\'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.\');\n        }\n      }\n    }\n\n    var morphAttributes = geometry.morphAttributes;\n\n    if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true) {\n      morphtargets.update(object, geometry, material, program);\n    }\n\n    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n      materialProperties.receiveShadow = object.receiveShadow;\n      p_uniforms.setValue(_gl, \'receiveShadow\', object.receiveShadow);\n    }\n\n    if (refreshMaterial) {\n      p_uniforms.setValue(_gl, \'toneMappingExposure\', _this.toneMappingExposure);\n\n      if (materialProperties.needsLights) {\n        // the current material requires lighting info\n        // note: all lighting uniforms are always set correctly\n        // they simply reference the renderer\'s state for their\n        // values\n        //\n        // use the current material\'s .needsUpdate flags to set\n        // the GL state when required\n        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n      } // refresh uniforms common to several materials\n\n\n      if (fog && material.fog === true) {\n        materials.refreshFogUniforms(m_uniforms, fog);\n      }\n\n      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n    }\n\n    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n      material.uniformsNeedUpdate = false;\n    }\n\n    if (material.isSpriteMaterial) {\n      p_uniforms.setValue(_gl, \'center\', object.center);\n    } // common matrices\n\n\n    p_uniforms.setValue(_gl, \'modelViewMatrix\', object.modelViewMatrix);\n    p_uniforms.setValue(_gl, \'normalMatrix\', object.normalMatrix);\n    p_uniforms.setValue(_gl, \'modelMatrix\', object.matrixWorld);\n    return program;\n  } // If uniforms are marked as clean, they don\'t need to be loaded to the GPU.\n\n\n  function markUniformsLightsNeedsUpdate(uniforms, value) {\n    uniforms.ambientLightColor.needsUpdate = value;\n    uniforms.lightProbe.needsUpdate = value;\n    uniforms.directionalLights.needsUpdate = value;\n    uniforms.directionalLightShadows.needsUpdate = value;\n    uniforms.pointLights.needsUpdate = value;\n    uniforms.pointLightShadows.needsUpdate = value;\n    uniforms.spotLights.needsUpdate = value;\n    uniforms.spotLightShadows.needsUpdate = value;\n    uniforms.rectAreaLights.needsUpdate = value;\n    uniforms.hemisphereLights.needsUpdate = value;\n  }\n\n  function materialNeedsLights(material) {\n    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n  }\n\n  this.getActiveCubeFace = function () {\n    return _currentActiveCubeFace;\n  };\n\n  this.getActiveMipmapLevel = function () {\n    return _currentActiveMipmapLevel;\n  };\n\n  this.getRenderTarget = function () {\n    return _currentRenderTarget;\n  };\n\n  this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {\n    properties.get(renderTarget.texture).__webglTexture = colorTexture;\n    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;\n    var renderTargetProperties = properties.get(renderTarget);\n    renderTargetProperties.__hasExternalTextures = true;\n\n    if (renderTargetProperties.__hasExternalTextures) {\n      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\n\n      if (!renderTargetProperties.__autoAllocateDepthBuffer) {\n        // The multisample_render_to_texture extension doesn\'t work properly if there\n        // are midframe flushes and an external depth buffer. Disable use of the extension.\n        if (extensions.has(\'WEBGL_multisampled_render_to_texture\') === true) {\n          console.warn(\'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided\');\n          renderTargetProperties.__useRenderToTexture = false;\n        }\n      }\n    }\n  };\n\n  this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {\n    var renderTargetProperties = properties.get(renderTarget);\n    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n  };\n\n  this.setRenderTarget = function (renderTarget) {\n    var activeCubeFace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var activeMipmapLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    _currentRenderTarget = renderTarget;\n    _currentActiveCubeFace = activeCubeFace;\n    _currentActiveMipmapLevel = activeMipmapLevel;\n    var useDefaultFramebuffer = true;\n\n    if (renderTarget) {\n      var renderTargetProperties = properties.get(renderTarget);\n\n      if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {\n        // We need to make sure to rebind the framebuffer.\n        state.bindFramebuffer(36160, null);\n        useDefaultFramebuffer = false;\n      } else if (renderTargetProperties.__webglFramebuffer === undefined) {\n        textures.setupRenderTarget(renderTarget);\n      } else if (renderTargetProperties.__hasExternalTextures) {\n        // Color and depth texture must be rebound in order for the swapchain to update.\n        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);\n      }\n    }\n\n    var framebuffer = null;\n    var isCube = false;\n    var isRenderTarget3D = false;\n\n    if (renderTarget) {\n      var texture = renderTarget.texture;\n\n      if (texture.isData3DTexture || texture.isDataArrayTexture) {\n        isRenderTarget3D = true;\n      }\n\n      var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n      if (renderTarget.isWebGLCubeRenderTarget) {\n        framebuffer = __webglFramebuffer[activeCubeFace];\n        isCube = true;\n      } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {\n        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n      } else {\n        framebuffer = __webglFramebuffer;\n      }\n\n      _currentViewport.copy(renderTarget.viewport);\n\n      _currentScissor.copy(renderTarget.scissor);\n\n      _currentScissorTest = renderTarget.scissorTest;\n    } else {\n      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n\n      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n\n      _currentScissorTest = _scissorTest;\n    }\n\n    var framebufferBound = state.bindFramebuffer(36160, framebuffer);\n\n    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {\n      state.drawBuffers(renderTarget, framebuffer);\n    }\n\n    state.viewport(_currentViewport);\n    state.scissor(_currentScissor);\n    state.setScissorTest(_currentScissorTest);\n\n    if (isCube) {\n      var textureProperties = properties.get(renderTarget.texture);\n\n      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n    } else if (isRenderTarget3D) {\n      var _textureProperties = properties.get(renderTarget.texture);\n\n      var layer = activeCubeFace || 0;\n\n      _gl.framebufferTextureLayer(36160, 36064, _textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n    }\n\n    _currentMaterialId = -1; // reset current material to ensure correct uniform bindings\n  };\n\n  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n      console.error(\'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.\');\n      return;\n    }\n\n    var framebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {\n      framebuffer = framebuffer[activeCubeFaceIndex];\n    }\n\n    if (framebuffer) {\n      state.bindFramebuffer(36160, framebuffer);\n\n      try {\n        var texture = renderTarget.texture;\n        var textureFormat = texture.format;\n        var textureType = texture.type;\n\n        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {\n          console.error(\'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.\');\n          return;\n        }\n\n        var halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has(\'EXT_color_buffer_half_float\') || capabilities.isWebGL2 && extensions.has(\'EXT_color_buffer_float\'));\n\n        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)\n        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has(\'OES_texture_float\') || extensions.has(\'WEBGL_color_buffer_float\'))) && // Chrome Mac >= 52 and Firefox\n        !halfFloatSupportedByExt) {\n          console.error(\'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.\');\n          return;\n        } // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\n        if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {\n          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n        }\n      } finally {\n        // restore framebuffer of current render target if necessary\n        var _framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n\n        state.bindFramebuffer(36160, _framebuffer);\n      }\n    }\n  };\n\n  this.copyFramebufferToTexture = function (position, texture) {\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var levelScale = Math.pow(2, -level);\n    var width = Math.floor(texture.image.width * levelScale);\n    var height = Math.floor(texture.image.height * levelScale);\n    textures.setTexture2D(texture, 0);\n\n    _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);\n\n    state.unbindTexture();\n  };\n\n  this.copyTextureToTexture = function (position, srcTexture, dstTexture) {\n    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var width = srcTexture.image.width;\n    var height = srcTexture.image.height;\n    var glFormat = utils.convert(dstTexture.format);\n    var glType = utils.convert(dstTexture.type);\n    textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei\n    // parameters, make sure they are correct for the dstTexture\n\n    _gl.pixelStorei(37440, dstTexture.flipY);\n\n    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);\n\n    _gl.pixelStorei(3317, dstTexture.unpackAlignment);\n\n    if (srcTexture.isDataTexture) {\n      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);\n      } else {\n        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);\n      }\n    } // Generate mipmaps only when copying level 0\n\n\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);\n    state.unbindTexture();\n  };\n\n  this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture) {\n    var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    if (_this.isWebGL1Renderer) {\n      console.warn(\'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.\');\n      return;\n    }\n\n    var width = sourceBox.max.x - sourceBox.min.x + 1;\n    var height = sourceBox.max.y - sourceBox.min.y + 1;\n    var depth = sourceBox.max.z - sourceBox.min.z + 1;\n    var glFormat = utils.convert(dstTexture.format);\n    var glType = utils.convert(dstTexture.type);\n    var glTarget;\n\n    if (dstTexture.isData3DTexture) {\n      textures.setTexture3D(dstTexture, 0);\n      glTarget = 32879;\n    } else if (dstTexture.isDataArrayTexture) {\n      textures.setTexture2DArray(dstTexture, 0);\n      glTarget = 35866;\n    } else {\n      console.warn(\'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.\');\n      return;\n    }\n\n    _gl.pixelStorei(37440, dstTexture.flipY);\n\n    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);\n\n    _gl.pixelStorei(3317, dstTexture.unpackAlignment);\n\n    var unpackRowLen = _gl.getParameter(3314);\n\n    var unpackImageHeight = _gl.getParameter(32878);\n\n    var unpackSkipPixels = _gl.getParameter(3316);\n\n    var unpackSkipRows = _gl.getParameter(3315);\n\n    var unpackSkipImages = _gl.getParameter(32877);\n\n    var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;\n\n    _gl.pixelStorei(3314, image.width);\n\n    _gl.pixelStorei(32878, image.height);\n\n    _gl.pixelStorei(3316, sourceBox.min.x);\n\n    _gl.pixelStorei(3315, sourceBox.min.y);\n\n    _gl.pixelStorei(32877, sourceBox.min.z);\n\n    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {\n      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        console.warn(\'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.\');\n\n        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);\n      } else {\n        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);\n      }\n    }\n\n    _gl.pixelStorei(3314, unpackRowLen);\n\n    _gl.pixelStorei(32878, unpackImageHeight);\n\n    _gl.pixelStorei(3316, unpackSkipPixels);\n\n    _gl.pixelStorei(3315, unpackSkipRows);\n\n    _gl.pixelStorei(32877, unpackSkipImages); // Generate mipmaps only when copying level 0\n\n\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);\n    state.unbindTexture();\n  };\n\n  this.initTexture = function (texture) {\n    textures.setTexture2D(texture, 0);\n    state.unbindTexture();\n  };\n\n  this.resetState = function () {\n    _currentActiveCubeFace = 0;\n    _currentActiveMipmapLevel = 0;\n    _currentRenderTarget = null;\n    state.reset();\n    bindingStates.reset();\n  };\n\n  if (typeof __THREE_DEVTOOLS__ !== \'undefined\') {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\'observe\', {\n      detail: this\n    }));\n  }\n}\n\nvar WebGL1Renderer = /*#__PURE__*/function (_WebGLRenderer) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WebGL1Renderer, _WebGLRenderer);\n\n  var _super38 = _createSuper(WebGL1Renderer);\n\n  function WebGL1Renderer() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGL1Renderer);\n\n    return _super38.apply(this, arguments);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGL1Renderer);\n}(WebGLRenderer);\n\nWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\nvar FogExp2 = /*#__PURE__*/function () {\n  function FogExp2(color) {\n    var density = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00025;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, FogExp2);\n\n    this.isFogExp2 = true;\n    this.name = \'\';\n    this.color = new Color(color);\n    this.density = density;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(FogExp2, [{\n    key: "clone",\n    value: function clone() {\n      return new FogExp2(this.color, this.density);\n    }\n  }, {\n    key: "toJSON",\n    value: function\n      /* meta */\n    toJSON() {\n      return {\n        type: \'FogExp2\',\n        color: this.color.getHex(),\n        density: this.density\n      };\n    }\n  }]);\n\n  return FogExp2;\n}();\n\nvar Fog = /*#__PURE__*/function () {\n  function Fog(color) {\n    var near = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var far = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Fog);\n\n    this.isFog = true;\n    this.name = \'\';\n    this.color = new Color(color);\n    this.near = near;\n    this.far = far;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Fog, [{\n    key: "clone",\n    value: function clone() {\n      return new Fog(this.color, this.near, this.far);\n    }\n  }, {\n    key: "toJSON",\n    value: function\n      /* meta */\n    toJSON() {\n      return {\n        type: \'Fog\',\n        color: this.color.getHex(),\n        near: this.near,\n        far: this.far\n      };\n    }\n  }]);\n\n  return Fog;\n}();\n\nvar Scene = /*#__PURE__*/function (_Object3D5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Scene, _Object3D5);\n\n  var _super39 = _createSuper(Scene);\n\n  function Scene() {\n    var _this30;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Scene);\n\n    _this30 = _super39.call(this);\n    _this30.isScene = true;\n    _this30.type = \'Scene\';\n    _this30.background = null;\n    _this30.environment = null;\n    _this30.fog = null;\n    _this30.overrideMaterial = null;\n    _this30.autoUpdate = true; // checked by the renderer\n\n    if (typeof __THREE_DEVTOOLS__ !== \'undefined\') {\n      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\'observe\', {\n        detail: (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this30)\n      }));\n    }\n\n    return _this30;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Scene, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Scene.prototype), "copy", this).call(this, source, recursive);\n\n      if (source.background !== null) this.background = source.background.clone();\n      if (source.environment !== null) this.environment = source.environment.clone();\n      if (source.fog !== null) this.fog = source.fog.clone();\n      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n      this.autoUpdate = source.autoUpdate;\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Scene.prototype), "toJSON", this).call(this, meta);\n\n      if (this.fog !== null) data.object.fog = this.fog.toJSON();\n      return data;\n    }\n  }]);\n\n  return Scene;\n}(Object3D);\n\nvar InterleavedBuffer = /*#__PURE__*/function () {\n  function InterleavedBuffer(array, stride) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, InterleavedBuffer);\n\n    this.isInterleavedBuffer = true;\n    this.array = array;\n    this.stride = stride;\n    this.count = array !== undefined ? array.length / stride : 0;\n    this.usage = StaticDrawUsage;\n    this.updateRange = {\n      offset: 0,\n      count: -1\n    };\n    this.version = 0;\n    this.uuid = generateUUID();\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(InterleavedBuffer, [{\n    key: "onUploadCallback",\n    value: function onUploadCallback() {}\n  }, {\n    key: "needsUpdate",\n    set: function set(value) {\n      if (value === true) this.version++;\n    }\n  }, {\n    key: "setUsage",\n    value: function setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      this.array = new source.array.constructor(source.array);\n      this.count = source.count;\n      this.stride = source.stride;\n      this.usage = source.usage;\n      return this;\n    }\n  }, {\n    key: "copyAt",\n    value: function copyAt(index1, attribute, index2) {\n      index1 *= this.stride;\n      index2 *= attribute.stride;\n\n      for (var _i159 = 0, l = this.stride; _i159 < l; _i159++) {\n        this.array[index1 + _i159] = attribute.array[index2 + _i159];\n      }\n\n      return this;\n    }\n  }, {\n    key: "set",\n    value: function set(value) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.array.set(value, offset);\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone(data) {\n      if (data.arrayBuffers === undefined) {\n        data.arrayBuffers = {};\n      }\n\n      if (this.array.buffer._uuid === undefined) {\n        this.array.buffer._uuid = generateUUID();\n      }\n\n      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n      }\n\n      var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n      var ib = new this.constructor(array, this.stride);\n      ib.setUsage(this.usage);\n      return ib;\n    }\n  }, {\n    key: "onUpload",\n    value: function onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(data) {\n      if (data.arrayBuffers === undefined) {\n        data.arrayBuffers = {};\n      } // generate UUID for array buffer if necessary\n\n\n      if (this.array.buffer._uuid === undefined) {\n        this.array.buffer._uuid = generateUUID();\n      }\n\n      if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n        data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));\n      } //\n\n\n      return {\n        uuid: this.uuid,\n        buffer: this.array.buffer._uuid,\n        type: this.array.constructor.name,\n        stride: this.stride\n      };\n    }\n  }]);\n\n  return InterleavedBuffer;\n}();\n\nvar _vector$6 = /*@__PURE__*/new Vector3();\n\nvar InterleavedBufferAttribute = /*#__PURE__*/function () {\n  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset) {\n    var normalized = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, InterleavedBufferAttribute);\n\n    this.isInterleavedBufferAttribute = true;\n    this.name = \'\';\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n    this.normalized = normalized === true;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(InterleavedBufferAttribute, [{\n    key: "count",\n    get: function get() {\n      return this.data.count;\n    }\n  }, {\n    key: "array",\n    get: function get() {\n      return this.data.array;\n    }\n  }, {\n    key: "needsUpdate",\n    set: function set(value) {\n      this.data.needsUpdate = value;\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(m) {\n      for (var _i160 = 0, l = this.data.count; _i160 < l; _i160++) {\n        _vector$6.fromBufferAttribute(this, _i160);\n\n        _vector$6.applyMatrix4(m);\n\n        this.setXYZ(_i160, _vector$6.x, _vector$6.y, _vector$6.z);\n      }\n\n      return this;\n    }\n  }, {\n    key: "applyNormalMatrix",\n    value: function applyNormalMatrix(m) {\n      for (var _i161 = 0, l = this.count; _i161 < l; _i161++) {\n        _vector$6.fromBufferAttribute(this, _i161);\n\n        _vector$6.applyNormalMatrix(m);\n\n        this.setXYZ(_i161, _vector$6.x, _vector$6.y, _vector$6.z);\n      }\n\n      return this;\n    }\n  }, {\n    key: "transformDirection",\n    value: function transformDirection(m) {\n      for (var _i162 = 0, l = this.count; _i162 < l; _i162++) {\n        _vector$6.fromBufferAttribute(this, _i162);\n\n        _vector$6.transformDirection(m);\n\n        this.setXYZ(_i162, _vector$6.x, _vector$6.y, _vector$6.z);\n      }\n\n      return this;\n    }\n  }, {\n    key: "setX",\n    value: function setX(index, x) {\n      this.data.array[index * this.data.stride + this.offset] = x;\n      return this;\n    }\n  }, {\n    key: "setY",\n    value: function setY(index, y) {\n      this.data.array[index * this.data.stride + this.offset + 1] = y;\n      return this;\n    }\n  }, {\n    key: "setZ",\n    value: function setZ(index, z) {\n      this.data.array[index * this.data.stride + this.offset + 2] = z;\n      return this;\n    }\n  }, {\n    key: "setW",\n    value: function setW(index, w) {\n      this.data.array[index * this.data.stride + this.offset + 3] = w;\n      return this;\n    }\n  }, {\n    key: "getX",\n    value: function getX(index) {\n      return this.data.array[index * this.data.stride + this.offset];\n    }\n  }, {\n    key: "getY",\n    value: function getY(index) {\n      return this.data.array[index * this.data.stride + this.offset + 1];\n    }\n  }, {\n    key: "getZ",\n    value: function getZ(index) {\n      return this.data.array[index * this.data.stride + this.offset + 2];\n    }\n  }, {\n    key: "getW",\n    value: function getW(index) {\n      return this.data.array[index * this.data.stride + this.offset + 3];\n    }\n  }, {\n    key: "setXY",\n    value: function setXY(index, x, y) {\n      index = index * this.data.stride + this.offset;\n      this.data.array[index + 0] = x;\n      this.data.array[index + 1] = y;\n      return this;\n    }\n  }, {\n    key: "setXYZ",\n    value: function setXYZ(index, x, y, z) {\n      index = index * this.data.stride + this.offset;\n      this.data.array[index + 0] = x;\n      this.data.array[index + 1] = y;\n      this.data.array[index + 2] = z;\n      return this;\n    }\n  }, {\n    key: "setXYZW",\n    value: function setXYZW(index, x, y, z, w) {\n      index = index * this.data.stride + this.offset;\n      this.data.array[index + 0] = x;\n      this.data.array[index + 1] = y;\n      this.data.array[index + 2] = z;\n      this.data.array[index + 3] = w;\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone(data) {\n      if (data === undefined) {\n        console.log(\'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.\');\n        var array = [];\n\n        for (var _i163 = 0; _i163 < this.count; _i163++) {\n          var index = _i163 * this.data.stride + this.offset;\n\n          for (var j = 0; j < this.itemSize; j++) {\n            array.push(this.data.array[index + j]);\n          }\n        }\n\n        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n      } else {\n        if (data.interleavedBuffers === undefined) {\n          data.interleavedBuffers = {};\n        }\n\n        if (data.interleavedBuffers[this.data.uuid] === undefined) {\n          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n        }\n\n        return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n      }\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(data) {\n      if (data === undefined) {\n        console.log(\'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.\');\n        var array = [];\n\n        for (var _i164 = 0; _i164 < this.count; _i164++) {\n          var index = _i164 * this.data.stride + this.offset;\n\n          for (var j = 0; j < this.itemSize; j++) {\n            array.push(this.data.array[index + j]);\n          }\n        } // deinterleave data and save it as an ordinary buffer attribute for now\n\n\n        return {\n          itemSize: this.itemSize,\n          type: this.array.constructor.name,\n          array: array,\n          normalized: this.normalized\n        };\n      } else {\n        // save as true interlaved attribtue\n        if (data.interleavedBuffers === undefined) {\n          data.interleavedBuffers = {};\n        }\n\n        if (data.interleavedBuffers[this.data.uuid] === undefined) {\n          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n        }\n\n        return {\n          isInterleavedBufferAttribute: true,\n          itemSize: this.itemSize,\n          data: this.data.uuid,\n          offset: this.offset,\n          normalized: this.normalized\n        };\n      }\n    }\n  }]);\n\n  return InterleavedBufferAttribute;\n}();\n\nvar SpriteMaterial = /*#__PURE__*/function (_Material5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(SpriteMaterial, _Material5);\n\n  var _super40 = _createSuper(SpriteMaterial);\n\n  function SpriteMaterial(parameters) {\n    var _this31;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SpriteMaterial);\n\n    _this31 = _super40.call(this);\n    _this31.isSpriteMaterial = true;\n    _this31.type = \'SpriteMaterial\';\n    _this31.color = new Color(0xffffff);\n    _this31.map = null;\n    _this31.alphaMap = null;\n    _this31.rotation = 0;\n    _this31.sizeAttenuation = true;\n    _this31.transparent = true;\n    _this31.fog = true;\n\n    _this31.setValues(parameters);\n\n    return _this31;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SpriteMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SpriteMaterial.prototype), "copy", this).call(this, source);\n\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.alphaMap = source.alphaMap;\n      this.rotation = source.rotation;\n      this.sizeAttenuation = source.sizeAttenuation;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return SpriteMaterial;\n}(Material);\n\nvar _geometry;\n\nvar _intersectPoint = /*@__PURE__*/new Vector3();\n\nvar _worldScale = /*@__PURE__*/new Vector3();\n\nvar _mvPosition = /*@__PURE__*/new Vector3();\n\nvar _alignedPosition = /*@__PURE__*/new Vector2();\n\nvar _rotatedPosition = /*@__PURE__*/new Vector2();\n\nvar _viewWorldMatrix = /*@__PURE__*/new Matrix4();\n\nvar _vA = /*@__PURE__*/new Vector3();\n\nvar _vB = /*@__PURE__*/new Vector3();\n\nvar _vC = /*@__PURE__*/new Vector3();\n\nvar _uvA = /*@__PURE__*/new Vector2();\n\nvar _uvB = /*@__PURE__*/new Vector2();\n\nvar _uvC = /*@__PURE__*/new Vector2();\n\nvar Sprite = /*#__PURE__*/function (_Object3D6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Sprite, _Object3D6);\n\n  var _super41 = _createSuper(Sprite);\n\n  function Sprite(material) {\n    var _this32;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Sprite);\n\n    _this32 = _super41.call(this);\n    _this32.isSprite = true;\n    _this32.type = \'Sprite\';\n\n    if (_geometry === undefined) {\n      _geometry = new BufferGeometry();\n      var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);\n      var interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n\n      _geometry.setIndex([0, 1, 2, 0, 2, 3]);\n\n      _geometry.setAttribute(\'position\', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n\n      _geometry.setAttribute(\'uv\', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n    }\n\n    _this32.geometry = _geometry;\n    _this32.material = material !== undefined ? material : new SpriteMaterial();\n    _this32.center = new Vector2(0.5, 0.5);\n    return _this32;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Sprite, [{\n    key: "raycast",\n    value: function raycast(raycaster, intersects) {\n      if (raycaster.camera === null) {\n        console.error(\'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.\');\n      }\n\n      _worldScale.setFromMatrixScale(this.matrixWorld);\n\n      _viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n\n      this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n\n      _mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n\n      if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n        _worldScale.multiplyScalar(-_mvPosition.z);\n      }\n\n      var rotation = this.material.rotation;\n      var sin, cos;\n\n      if (rotation !== 0) {\n        cos = Math.cos(rotation);\n        sin = Math.sin(rotation);\n      }\n\n      var center = this.center;\n      transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n      _uvA.set(0, 0);\n\n      _uvB.set(1, 0);\n\n      _uvC.set(1, 1); // check first triangle\n\n\n      var intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n\n      if (intersect === null) {\n        // check second triangle\n        transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n        _uvB.set(0, 1);\n\n        intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n\n        if (intersect === null) {\n          return;\n        }\n      }\n\n      var distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n      if (distance < raycaster.near || distance > raycaster.far) return;\n      intersects.push({\n        distance: distance,\n        point: _intersectPoint.clone(),\n        uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n        face: null,\n        object: this\n      });\n    }\n  }, {\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Sprite.prototype), "copy", this).call(this, source, recursive);\n\n      if (source.center !== undefined) this.center.copy(source.center);\n      this.material = source.material;\n      return this;\n    }\n  }]);\n\n  return Sprite;\n}(Object3D);\n\nfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n  // compute position in camera space\n  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero\n\n\n  if (sin !== undefined) {\n    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n  } else {\n    _rotatedPosition.copy(_alignedPosition);\n  }\n\n  vertexPosition.copy(mvPosition);\n  vertexPosition.x += _rotatedPosition.x;\n  vertexPosition.y += _rotatedPosition.y; // transform to world space\n\n  vertexPosition.applyMatrix4(_viewWorldMatrix);\n}\n\nvar _v1$2 = /*@__PURE__*/new Vector3();\n\nvar _v2$1 = /*@__PURE__*/new Vector3();\n\nvar LOD = /*#__PURE__*/function (_Object3D7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LOD, _Object3D7);\n\n  var _super42 = _createSuper(LOD);\n\n  function LOD() {\n    var _this33;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LOD);\n\n    _this33 = _super42.call(this);\n    _this33._currentLevel = 0;\n    _this33.type = \'LOD\';\n    Object.defineProperties((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this33), {\n      levels: {\n        enumerable: true,\n        value: []\n      },\n      isLOD: {\n        value: true\n      }\n    });\n    _this33.autoUpdate = true;\n    return _this33;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LOD, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LOD.prototype), "copy", this).call(this, source, false);\n\n      var levels = source.levels;\n\n      for (var _i165 = 0, l = levels.length; _i165 < l; _i165++) {\n        var level = levels[_i165];\n        this.addLevel(level.object.clone(), level.distance);\n      }\n\n      this.autoUpdate = source.autoUpdate;\n      return this;\n    }\n  }, {\n    key: "addLevel",\n    value: function addLevel(object) {\n      var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      distance = Math.abs(distance);\n      var levels = this.levels;\n      var l;\n\n      for (l = 0; l < levels.length; l++) {\n        if (distance < levels[l].distance) {\n          break;\n        }\n      }\n\n      levels.splice(l, 0, {\n        distance: distance,\n        object: object\n      });\n      this.add(object);\n      return this;\n    }\n  }, {\n    key: "getCurrentLevel",\n    value: function getCurrentLevel() {\n      return this._currentLevel;\n    }\n  }, {\n    key: "getObjectForDistance",\n    value: function getObjectForDistance(distance) {\n      var levels = this.levels;\n\n      if (levels.length > 0) {\n        var _i166, l;\n\n        for (_i166 = 1, l = levels.length; _i166 < l; _i166++) {\n          if (distance < levels[_i166].distance) {\n            break;\n          }\n        }\n\n        return levels[_i166 - 1].object;\n      }\n\n      return null;\n    }\n  }, {\n    key: "raycast",\n    value: function raycast(raycaster, intersects) {\n      var levels = this.levels;\n\n      if (levels.length > 0) {\n        _v1$2.setFromMatrixPosition(this.matrixWorld);\n\n        var distance = raycaster.ray.origin.distanceTo(_v1$2);\n        this.getObjectForDistance(distance).raycast(raycaster, intersects);\n      }\n    }\n  }, {\n    key: "update",\n    value: function update(camera) {\n      var levels = this.levels;\n\n      if (levels.length > 1) {\n        _v1$2.setFromMatrixPosition(camera.matrixWorld);\n\n        _v2$1.setFromMatrixPosition(this.matrixWorld);\n\n        var distance = _v1$2.distanceTo(_v2$1) / camera.zoom;\n        levels[0].object.visible = true;\n\n        var _i167, l;\n\n        for (_i167 = 1, l = levels.length; _i167 < l; _i167++) {\n          if (distance >= levels[_i167].distance) {\n            levels[_i167 - 1].object.visible = false;\n            levels[_i167].object.visible = true;\n          } else {\n            break;\n          }\n        }\n\n        this._currentLevel = _i167 - 1;\n\n        for (; _i167 < l; _i167++) {\n          levels[_i167].object.visible = false;\n        }\n      }\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LOD.prototype), "toJSON", this).call(this, meta);\n\n      if (this.autoUpdate === false) data.object.autoUpdate = false;\n      data.object.levels = [];\n      var levels = this.levels;\n\n      for (var _i168 = 0, l = levels.length; _i168 < l; _i168++) {\n        var level = levels[_i168];\n        data.object.levels.push({\n          object: level.object.uuid,\n          distance: level.distance\n        });\n      }\n\n      return data;\n    }\n  }]);\n\n  return LOD;\n}(Object3D);\n\nvar _basePosition = /*@__PURE__*/new Vector3();\n\nvar _skinIndex = /*@__PURE__*/new Vector4();\n\nvar _skinWeight = /*@__PURE__*/new Vector4();\n\nvar _vector$5 = /*@__PURE__*/new Vector3();\n\nvar _matrix = /*@__PURE__*/new Matrix4();\n\nvar SkinnedMesh = /*#__PURE__*/function (_Mesh) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(SkinnedMesh, _Mesh);\n\n  var _super43 = _createSuper(SkinnedMesh);\n\n  function SkinnedMesh(geometry, material) {\n    var _this34;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SkinnedMesh);\n\n    _this34 = _super43.call(this, geometry, material);\n    _this34.isSkinnedMesh = true;\n    _this34.type = \'SkinnedMesh\';\n    _this34.bindMode = \'attached\';\n    _this34.bindMatrix = new Matrix4();\n    _this34.bindMatrixInverse = new Matrix4();\n    return _this34;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SkinnedMesh, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SkinnedMesh.prototype), "copy", this).call(this, source, recursive);\n\n      this.bindMode = source.bindMode;\n      this.bindMatrix.copy(source.bindMatrix);\n      this.bindMatrixInverse.copy(source.bindMatrixInverse);\n      this.skeleton = source.skeleton;\n      return this;\n    }\n  }, {\n    key: "bind",\n    value: function bind(skeleton, bindMatrix) {\n      this.skeleton = skeleton;\n\n      if (bindMatrix === undefined) {\n        this.updateMatrixWorld(true);\n        this.skeleton.calculateInverses();\n        bindMatrix = this.matrixWorld;\n      }\n\n      this.bindMatrix.copy(bindMatrix);\n      this.bindMatrixInverse.copy(bindMatrix).invert();\n    }\n  }, {\n    key: "pose",\n    value: function pose() {\n      this.skeleton.pose();\n    }\n  }, {\n    key: "normalizeSkinWeights",\n    value: function normalizeSkinWeights() {\n      var vector = new Vector4();\n      var skinWeight = this.geometry.attributes.skinWeight;\n\n      for (var _i169 = 0, l = skinWeight.count; _i169 < l; _i169++) {\n        vector.fromBufferAttribute(skinWeight, _i169);\n        var scale = 1.0 / vector.manhattanLength();\n\n        if (scale !== Infinity) {\n          vector.multiplyScalar(scale);\n        } else {\n          vector.set(1, 0, 0, 0); // do something reasonable\n        }\n\n        skinWeight.setXYZW(_i169, vector.x, vector.y, vector.z, vector.w);\n      }\n    }\n  }, {\n    key: "updateMatrixWorld",\n    value: function updateMatrixWorld(force) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SkinnedMesh.prototype), "updateMatrixWorld", this).call(this, force);\n\n      if (this.bindMode === \'attached\') {\n        this.bindMatrixInverse.copy(this.matrixWorld).invert();\n      } else if (this.bindMode === \'detached\') {\n        this.bindMatrixInverse.copy(this.bindMatrix).invert();\n      } else {\n        console.warn(\'THREE.SkinnedMesh: Unrecognized bindMode: \' + this.bindMode);\n      }\n    }\n  }, {\n    key: "boneTransform",\n    value: function boneTransform(index, target) {\n      var skeleton = this.skeleton;\n      var geometry = this.geometry;\n\n      _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n\n      _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n      _basePosition.copy(target).applyMatrix4(this.bindMatrix);\n\n      target.set(0, 0, 0);\n\n      for (var _i170 = 0; _i170 < 4; _i170++) {\n        var weight = _skinWeight.getComponent(_i170);\n\n        if (weight !== 0) {\n          var boneIndex = _skinIndex.getComponent(_i170);\n\n          _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n\n          target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);\n        }\n      }\n\n      return target.applyMatrix4(this.bindMatrixInverse);\n    }\n  }]);\n\n  return SkinnedMesh;\n}(Mesh);\n\nvar Bone = /*#__PURE__*/function (_Object3D8) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Bone, _Object3D8);\n\n  var _super44 = _createSuper(Bone);\n\n  function Bone() {\n    var _this35;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Bone);\n\n    _this35 = _super44.call(this);\n    _this35.isBone = true;\n    _this35.type = \'Bone\';\n    return _this35;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Bone);\n}(Object3D);\n\nvar DataTexture = /*#__PURE__*/function (_Texture5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DataTexture, _Texture5);\n\n  var _super45 = _createSuper(DataTexture);\n\n  function DataTexture() {\n    var _this36;\n\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var format = arguments.length > 3 ? arguments[3] : undefined;\n    var type = arguments.length > 4 ? arguments[4] : undefined;\n    var mapping = arguments.length > 5 ? arguments[5] : undefined;\n    var wrapS = arguments.length > 6 ? arguments[6] : undefined;\n    var wrapT = arguments.length > 7 ? arguments[7] : undefined;\n    var magFilter = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : NearestFilter;\n    var minFilter = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : NearestFilter;\n    var anisotropy = arguments.length > 10 ? arguments[10] : undefined;\n    var encoding = arguments.length > 11 ? arguments[11] : undefined;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DataTexture);\n\n    _this36 = _super45.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    _this36.isDataTexture = true;\n    _this36.image = {\n      data: data,\n      width: width,\n      height: height\n    };\n    _this36.generateMipmaps = false;\n    _this36.flipY = false;\n    _this36.unpackAlignment = 1;\n    return _this36;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DataTexture);\n}(Texture);\n\nvar _offsetMatrix = /*@__PURE__*/new Matrix4();\n\nvar _identityMatrix = /*@__PURE__*/new Matrix4();\n\nvar Skeleton = /*#__PURE__*/function () {\n  function Skeleton() {\n    var bones = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var boneInverses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Skeleton);\n\n    this.uuid = generateUUID();\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n    this.boneTexture = null;\n    this.boneTextureSize = 0;\n    this.frame = -1;\n    this.init();\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Skeleton, [{\n    key: "init",\n    value: function init() {\n      var bones = this.bones;\n      var boneInverses = this.boneInverses;\n      this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary\n\n      if (boneInverses.length === 0) {\n        this.calculateInverses();\n      } else {\n        // handle special case\n        if (bones.length !== boneInverses.length) {\n          console.warn(\'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.\');\n          this.boneInverses = [];\n\n          for (var _i171 = 0, il = this.bones.length; _i171 < il; _i171++) {\n            this.boneInverses.push(new Matrix4());\n          }\n        }\n      }\n    }\n  }, {\n    key: "calculateInverses",\n    value: function calculateInverses() {\n      this.boneInverses.length = 0;\n\n      for (var _i172 = 0, il = this.bones.length; _i172 < il; _i172++) {\n        var inverse = new Matrix4();\n\n        if (this.bones[_i172]) {\n          inverse.copy(this.bones[_i172].matrixWorld).invert();\n        }\n\n        this.boneInverses.push(inverse);\n      }\n    }\n  }, {\n    key: "pose",\n    value: function pose() {\n      // recover the bind-time world matrices\n      for (var _i173 = 0, il = this.bones.length; _i173 < il; _i173++) {\n        var bone = this.bones[_i173];\n\n        if (bone) {\n          bone.matrixWorld.copy(this.boneInverses[_i173]).invert();\n        }\n      } // compute the local matrices, positions, rotations and scales\n\n\n      for (var _i174 = 0, _il12 = this.bones.length; _i174 < _il12; _i174++) {\n        var _bone = this.bones[_i174];\n\n        if (_bone) {\n          if (_bone.parent && _bone.parent.isBone) {\n            _bone.matrix.copy(_bone.parent.matrixWorld).invert();\n\n            _bone.matrix.multiply(_bone.matrixWorld);\n          } else {\n            _bone.matrix.copy(_bone.matrixWorld);\n          }\n\n          _bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);\n        }\n      }\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      var bones = this.bones;\n      var boneInverses = this.boneInverses;\n      var boneMatrices = this.boneMatrices;\n      var boneTexture = this.boneTexture; // flatten bone matrices to array\n\n      for (var _i175 = 0, il = bones.length; _i175 < il; _i175++) {\n        // compute the offset between the current and the original transform\n        var matrix = bones[_i175] ? bones[_i175].matrixWorld : _identityMatrix;\n\n        _offsetMatrix.multiplyMatrices(matrix, boneInverses[_i175]);\n\n        _offsetMatrix.toArray(boneMatrices, _i175 * 16);\n      }\n\n      if (boneTexture !== null) {\n        boneTexture.needsUpdate = true;\n      }\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new Skeleton(this.bones, this.boneInverses);\n    }\n  }, {\n    key: "computeBoneTexture",\n    value: function computeBoneTexture() {\n      // layout (1 matrix = 4 pixels)\n      //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n      //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n      //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n      //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n      //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n      var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n\n      size = ceilPowerOfTwo(size);\n      size = Math.max(size, 4);\n      var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n\n      boneMatrices.set(this.boneMatrices); // copy current values\n\n      var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n      boneTexture.needsUpdate = true;\n      this.boneMatrices = boneMatrices;\n      this.boneTexture = boneTexture;\n      this.boneTextureSize = size;\n      return this;\n    }\n  }, {\n    key: "getBoneByName",\n    value: function getBoneByName(name) {\n      for (var _i176 = 0, il = this.bones.length; _i176 < il; _i176++) {\n        var bone = this.bones[_i176];\n\n        if (bone.name === name) {\n          return bone;\n        }\n      }\n\n      return undefined;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      if (this.boneTexture !== null) {\n        this.boneTexture.dispose();\n        this.boneTexture = null;\n      }\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json, bones) {\n      this.uuid = json.uuid;\n\n      for (var _i177 = 0, l = json.bones.length; _i177 < l; _i177++) {\n        var uuid = json.bones[_i177];\n        var bone = bones[uuid];\n\n        if (bone === undefined) {\n          console.warn(\'THREE.Skeleton: No bone found with UUID:\', uuid);\n          bone = new Bone();\n        }\n\n        this.bones.push(bone);\n        this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[_i177]));\n      }\n\n      this.init();\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = {\n        metadata: {\n          version: 4.5,\n          type: \'Skeleton\',\n          generator: \'Skeleton.toJSON\'\n        },\n        bones: [],\n        boneInverses: []\n      };\n      data.uuid = this.uuid;\n      var bones = this.bones;\n      var boneInverses = this.boneInverses;\n\n      for (var _i178 = 0, l = bones.length; _i178 < l; _i178++) {\n        var bone = bones[_i178];\n        data.bones.push(bone.uuid);\n        var boneInverse = boneInverses[_i178];\n        data.boneInverses.push(boneInverse.toArray());\n      }\n\n      return data;\n    }\n  }]);\n\n  return Skeleton;\n}();\n\nvar InstancedBufferAttribute = /*#__PURE__*/function (_BufferAttribute11) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(InstancedBufferAttribute, _BufferAttribute11);\n\n  var _super46 = _createSuper(InstancedBufferAttribute);\n\n  function InstancedBufferAttribute(array, itemSize, normalized) {\n    var _this37;\n\n    var meshPerAttribute = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, InstancedBufferAttribute);\n\n    if (typeof normalized === \'number\') {\n      meshPerAttribute = normalized;\n      normalized = false;\n      console.error(\'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.\');\n    }\n\n    _this37 = _super46.call(this, array, itemSize, normalized);\n    _this37.isInstancedBufferAttribute = true;\n    _this37.meshPerAttribute = meshPerAttribute;\n    return _this37;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(InstancedBufferAttribute, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(InstancedBufferAttribute.prototype), "copy", this).call(this, source);\n\n      this.meshPerAttribute = source.meshPerAttribute;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(InstancedBufferAttribute.prototype), "toJSON", this).call(this);\n\n      data.meshPerAttribute = this.meshPerAttribute;\n      data.isInstancedBufferAttribute = true;\n      return data;\n    }\n  }]);\n\n  return InstancedBufferAttribute;\n}(BufferAttribute);\n\nvar _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\n\nvar _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\n\nvar _instanceIntersects = [];\n\nvar _mesh = /*@__PURE__*/new Mesh();\n\nvar InstancedMesh = /*#__PURE__*/function (_Mesh2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(InstancedMesh, _Mesh2);\n\n  var _super47 = _createSuper(InstancedMesh);\n\n  function InstancedMesh(geometry, material, count) {\n    var _this38;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, InstancedMesh);\n\n    _this38 = _super47.call(this, geometry, material);\n    _this38.isInstancedMesh = true;\n    _this38.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);\n    _this38.instanceColor = null;\n    _this38.count = count;\n    _this38.frustumCulled = false;\n    return _this38;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(InstancedMesh, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(InstancedMesh.prototype), "copy", this).call(this, source, recursive);\n\n      this.instanceMatrix.copy(source.instanceMatrix);\n      if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n      this.count = source.count;\n      return this;\n    }\n  }, {\n    key: "getColorAt",\n    value: function getColorAt(index, color) {\n      color.fromArray(this.instanceColor.array, index * 3);\n    }\n  }, {\n    key: "getMatrixAt",\n    value: function getMatrixAt(index, matrix) {\n      matrix.fromArray(this.instanceMatrix.array, index * 16);\n    }\n  }, {\n    key: "raycast",\n    value: function raycast(raycaster, intersects) {\n      var matrixWorld = this.matrixWorld;\n      var raycastTimes = this.count;\n      _mesh.geometry = this.geometry;\n      _mesh.material = this.material;\n      if (_mesh.material === undefined) return;\n\n      for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {\n        // calculate the world matrix for each instance\n        this.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n        _mesh.matrixWorld = _instanceWorldMatrix;\n\n        _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n        for (var _i179 = 0, l = _instanceIntersects.length; _i179 < l; _i179++) {\n          var intersect = _instanceIntersects[_i179];\n          intersect.instanceId = instanceId;\n          intersect.object = this;\n          intersects.push(intersect);\n        }\n\n        _instanceIntersects.length = 0;\n      }\n    }\n  }, {\n    key: "setColorAt",\n    value: function setColorAt(index, color) {\n      if (this.instanceColor === null) {\n        this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);\n      }\n\n      color.toArray(this.instanceColor.array, index * 3);\n    }\n  }, {\n    key: "setMatrixAt",\n    value: function setMatrixAt(index, matrix) {\n      matrix.toArray(this.instanceMatrix.array, index * 16);\n    }\n  }, {\n    key: "updateMorphTargets",\n    value: function updateMorphTargets() {}\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: \'dispose\'\n      });\n    }\n  }]);\n\n  return InstancedMesh;\n}(Mesh);\n\nvar LineBasicMaterial = /*#__PURE__*/function (_Material6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LineBasicMaterial, _Material6);\n\n  var _super48 = _createSuper(LineBasicMaterial);\n\n  function LineBasicMaterial(parameters) {\n    var _this39;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LineBasicMaterial);\n\n    _this39 = _super48.call(this);\n    _this39.isLineBasicMaterial = true;\n    _this39.type = \'LineBasicMaterial\';\n    _this39.color = new Color(0xffffff);\n    _this39.linewidth = 1;\n    _this39.linecap = \'round\';\n    _this39.linejoin = \'round\';\n    _this39.fog = true;\n\n    _this39.setValues(parameters);\n\n    return _this39;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LineBasicMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LineBasicMaterial.prototype), "copy", this).call(this, source);\n\n      this.color.copy(source.color);\n      this.linewidth = source.linewidth;\n      this.linecap = source.linecap;\n      this.linejoin = source.linejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return LineBasicMaterial;\n}(Material);\n\nvar _start$1 = /*@__PURE__*/new Vector3();\n\nvar _end$1 = /*@__PURE__*/new Vector3();\n\nvar _inverseMatrix$1 = /*@__PURE__*/new Matrix4();\n\nvar _ray$1 = /*@__PURE__*/new Ray();\n\nvar _sphere$1 = /*@__PURE__*/new Sphere();\n\nvar Line = /*#__PURE__*/function (_Object3D9) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Line, _Object3D9);\n\n  var _super49 = _createSuper(Line);\n\n  function Line() {\n    var _this40;\n\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineBasicMaterial();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Line);\n\n    _this40 = _super49.call(this);\n    _this40.isLine = true;\n    _this40.type = \'Line\';\n    _this40.geometry = geometry;\n    _this40.material = material;\n\n    _this40.updateMorphTargets();\n\n    return _this40;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Line, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Line.prototype), "copy", this).call(this, source, recursive);\n\n      this.material = source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n  }, {\n    key: "computeLineDistances",\n    value: function computeLineDistances() {\n      var geometry = this.geometry; // we assume non-indexed geometry\n\n      if (geometry.index === null) {\n        var positionAttribute = geometry.attributes.position;\n        var lineDistances = [0];\n\n        for (var _i180 = 1, l = positionAttribute.count; _i180 < l; _i180++) {\n          _start$1.fromBufferAttribute(positionAttribute, _i180 - 1);\n\n          _end$1.fromBufferAttribute(positionAttribute, _i180);\n\n          lineDistances[_i180] = lineDistances[_i180 - 1];\n          lineDistances[_i180] += _start$1.distanceTo(_end$1);\n        }\n\n        geometry.setAttribute(\'lineDistance\', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn(\'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\');\n      }\n\n      return this;\n    }\n  }, {\n    key: "raycast",\n    value: function raycast(raycaster, intersects) {\n      var geometry = this.geometry;\n      var matrixWorld = this.matrixWorld;\n      var threshold = raycaster.params.Line.threshold;\n      var drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n      _sphere$1.copy(geometry.boundingSphere);\n\n      _sphere$1.applyMatrix4(matrixWorld);\n\n      _sphere$1.radius += threshold;\n      if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //\n\n      _inverseMatrix$1.copy(matrixWorld).invert();\n\n      _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n\n      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n      var localThresholdSq = localThreshold * localThreshold;\n      var vStart = new Vector3();\n      var vEnd = new Vector3();\n      var interSegment = new Vector3();\n      var interRay = new Vector3();\n      var step = this.isLineSegments ? 2 : 1;\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n      var positionAttribute = attributes.position;\n\n      if (index !== null) {\n        var start = Math.max(0, drawRange.start);\n        var end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (var _i181 = start, l = end - 1; _i181 < l; _i181 += step) {\n          var a = index.getX(_i181);\n          var b = index.getX(_i181 + 1);\n          vStart.fromBufferAttribute(positionAttribute, a);\n          vEnd.fromBufferAttribute(positionAttribute, b);\n\n          var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          var distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: _i181,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      } else {\n        var _start6 = Math.max(0, drawRange.start);\n\n        var _end5 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n        for (var _i182 = _start6, _l7 = _end5 - 1; _i182 < _l7; _i182 += step) {\n          vStart.fromBufferAttribute(positionAttribute, _i182);\n          vEnd.fromBufferAttribute(positionAttribute, _i182 + 1);\n\n          var _distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (_distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          var _distance = raycaster.ray.origin.distanceTo(interRay);\n\n          if (_distance < raycaster.near || _distance > raycaster.far) continue;\n          intersects.push({\n            distance: _distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: _i182,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      }\n    }\n  }, {\n    key: "updateMorphTargets",\n    value: function updateMorphTargets() {\n      var geometry = this.geometry;\n      var morphAttributes = geometry.morphAttributes;\n      var keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        var morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {\n            var name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Line;\n}(Object3D);\n\nvar _start = /*@__PURE__*/new Vector3();\n\nvar _end = /*@__PURE__*/new Vector3();\n\nvar LineSegments = /*#__PURE__*/function (_Line) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LineSegments, _Line);\n\n  var _super50 = _createSuper(LineSegments);\n\n  function LineSegments(geometry, material) {\n    var _this41;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LineSegments);\n\n    _this41 = _super50.call(this, geometry, material);\n    _this41.isLineSegments = true;\n    _this41.type = \'LineSegments\';\n    return _this41;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LineSegments, [{\n    key: "computeLineDistances",\n    value: function computeLineDistances() {\n      var geometry = this.geometry; // we assume non-indexed geometry\n\n      if (geometry.index === null) {\n        var positionAttribute = geometry.attributes.position;\n        var lineDistances = [];\n\n        for (var _i183 = 0, l = positionAttribute.count; _i183 < l; _i183 += 2) {\n          _start.fromBufferAttribute(positionAttribute, _i183);\n\n          _end.fromBufferAttribute(positionAttribute, _i183 + 1);\n\n          lineDistances[_i183] = _i183 === 0 ? 0 : lineDistances[_i183 - 1];\n          lineDistances[_i183 + 1] = lineDistances[_i183] + _start.distanceTo(_end);\n        }\n\n        geometry.setAttribute(\'lineDistance\', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn(\'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\');\n      }\n\n      return this;\n    }\n  }]);\n\n  return LineSegments;\n}(Line);\n\nvar LineLoop = /*#__PURE__*/function (_Line2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LineLoop, _Line2);\n\n  var _super51 = _createSuper(LineLoop);\n\n  function LineLoop(geometry, material) {\n    var _this42;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LineLoop);\n\n    _this42 = _super51.call(this, geometry, material);\n    _this42.isLineLoop = true;\n    _this42.type = \'LineLoop\';\n    return _this42;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LineLoop);\n}(Line);\n\nvar PointsMaterial = /*#__PURE__*/function (_Material7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PointsMaterial, _Material7);\n\n  var _super52 = _createSuper(PointsMaterial);\n\n  function PointsMaterial(parameters) {\n    var _this43;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PointsMaterial);\n\n    _this43 = _super52.call(this);\n    _this43.isPointsMaterial = true;\n    _this43.type = \'PointsMaterial\';\n    _this43.color = new Color(0xffffff);\n    _this43.map = null;\n    _this43.alphaMap = null;\n    _this43.size = 1;\n    _this43.sizeAttenuation = true;\n    _this43.fog = true;\n\n    _this43.setValues(parameters);\n\n    return _this43;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PointsMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(PointsMaterial.prototype), "copy", this).call(this, source);\n\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.alphaMap = source.alphaMap;\n      this.size = source.size;\n      this.sizeAttenuation = source.sizeAttenuation;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return PointsMaterial;\n}(Material);\n\nvar _inverseMatrix = /*@__PURE__*/new Matrix4();\n\nvar _ray = /*@__PURE__*/new Ray();\n\nvar _sphere = /*@__PURE__*/new Sphere();\n\nvar _position$2 = /*@__PURE__*/new Vector3();\n\nvar Points = /*#__PURE__*/function (_Object3D10) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Points, _Object3D10);\n\n  var _super53 = _createSuper(Points);\n\n  function Points() {\n    var _this44;\n\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PointsMaterial();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Points);\n\n    _this44 = _super53.call(this);\n    _this44.isPoints = true;\n    _this44.type = \'Points\';\n    _this44.geometry = geometry;\n    _this44.material = material;\n\n    _this44.updateMorphTargets();\n\n    return _this44;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Points, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Points.prototype), "copy", this).call(this, source, recursive);\n\n      this.material = source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n  }, {\n    key: "raycast",\n    value: function raycast(raycaster, intersects) {\n      var geometry = this.geometry;\n      var matrixWorld = this.matrixWorld;\n      var threshold = raycaster.params.Points.threshold;\n      var drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n      _sphere.copy(geometry.boundingSphere);\n\n      _sphere.applyMatrix4(matrixWorld);\n\n      _sphere.radius += threshold;\n      if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n      _inverseMatrix.copy(matrixWorld).invert();\n\n      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n      var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n      var localThresholdSq = localThreshold * localThreshold;\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n      var positionAttribute = attributes.position;\n\n      if (index !== null) {\n        var start = Math.max(0, drawRange.start);\n        var end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (var _i184 = start, il = end; _i184 < il; _i184++) {\n          var a = index.getX(_i184);\n\n          _position$2.fromBufferAttribute(positionAttribute, a);\n\n          testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      } else {\n        var _start7 = Math.max(0, drawRange.start);\n\n        var _end6 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n        for (var _i185 = _start7, l = _end6; _i185 < l; _i185++) {\n          _position$2.fromBufferAttribute(positionAttribute, _i185);\n\n          testPoint(_position$2, _i185, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      }\n    }\n  }, {\n    key: "updateMorphTargets",\n    value: function updateMorphTargets() {\n      var geometry = this.geometry;\n      var morphAttributes = geometry.morphAttributes;\n      var keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        var morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (var m = 0, ml = morphAttribute.length; m < ml; m++) {\n            var name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Points;\n}(Object3D);\n\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n  var rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n  if (rayPointDistanceSq < localThresholdSq) {\n    var intersectPoint = new Vector3();\n\n    _ray.closestPointToPoint(point, intersectPoint);\n\n    intersectPoint.applyMatrix4(matrixWorld);\n    var distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index: index,\n      face: null,\n      object: object\n    });\n  }\n}\n\nvar VideoTexture = /*#__PURE__*/function (_Texture6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(VideoTexture, _Texture6);\n\n  var _super54 = _createSuper(VideoTexture);\n\n  function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    var _this45;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, VideoTexture);\n\n    _this45 = _super54.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    _this45.isVideoTexture = true;\n    _this45.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n    _this45.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n    _this45.generateMipmaps = false;\n\n    var scope = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this45);\n\n    function updateVideo() {\n      scope.needsUpdate = true;\n      video.requestVideoFrameCallback(updateVideo);\n    }\n\n    if (\'requestVideoFrameCallback\' in video) {\n      video.requestVideoFrameCallback(updateVideo);\n    }\n\n    return _this45;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(VideoTexture, [{\n    key: "clone",\n    value: function clone() {\n      return new this.constructor(this.image).copy(this);\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      var video = this.image;\n      var hasVideoFrameCallback = (\'requestVideoFrameCallback\' in video);\n\n      if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {\n        this.needsUpdate = true;\n      }\n    }\n  }]);\n\n  return VideoTexture;\n}(Texture);\n\nvar FramebufferTexture = /*#__PURE__*/function (_Texture7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(FramebufferTexture, _Texture7);\n\n  var _super55 = _createSuper(FramebufferTexture);\n\n  function FramebufferTexture(width, height, format) {\n    var _this46;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, FramebufferTexture);\n\n    _this46 = _super55.call(this, {\n      width: width,\n      height: height\n    });\n    _this46.isFramebufferTexture = true;\n    _this46.format = format;\n    _this46.magFilter = NearestFilter;\n    _this46.minFilter = NearestFilter;\n    _this46.generateMipmaps = false;\n    _this46.needsUpdate = true;\n    return _this46;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(FramebufferTexture);\n}(Texture);\n\nvar CompressedTexture = /*#__PURE__*/function (_Texture8) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CompressedTexture, _Texture8);\n\n  var _super56 = _createSuper(CompressedTexture);\n\n  function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n    var _this47;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CompressedTexture);\n\n    _this47 = _super56.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    _this47.isCompressedTexture = true;\n    _this47.image = {\n      width: width,\n      height: height\n    };\n    _this47.mipmaps = mipmaps; // no flipping for cube textures\n    // (also flipping doesn\'t work for compressed textures )\n\n    _this47.flipY = false; // can\'t generate mipmaps for compressed textures\n    // mips must be embedded in DDS files\n\n    _this47.generateMipmaps = false;\n    return _this47;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CompressedTexture);\n}(Texture);\n\nvar CanvasTexture = /*#__PURE__*/function (_Texture9) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CanvasTexture, _Texture9);\n\n  var _super57 = _createSuper(CanvasTexture);\n\n  function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    var _this48;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CanvasTexture);\n\n    _this48 = _super57.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    _this48.isCanvasTexture = true;\n    _this48.needsUpdate = true;\n    return _this48;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CanvasTexture);\n}(Texture);\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\n\nvar Curve = /*#__PURE__*/function () {\n  function Curve() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Curve);\n\n    this.type = \'Curve\';\n    this.arcLengthDivisions = 200;\n  } // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Curve, [{\n    key: "getPoint",\n    value: function\n      /* t, optionalTarget */\n    getPoint() {\n      console.warn(\'THREE.Curve: .getPoint() not implemented.\');\n      return null;\n    } // Get point at relative position in curve according to arc length\n    // - u [0 .. 1]\n\n  }, {\n    key: "getPointAt",\n    value: function getPointAt(u, optionalTarget) {\n      var t = this.getUtoTmapping(u);\n      return this.getPoint(t, optionalTarget);\n    } // Get sequence of points using getPoint( t )\n\n  }, {\n    key: "getPoints",\n    value: function getPoints() {\n      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      var points = [];\n\n      for (var d = 0; d <= divisions; d++) {\n        points.push(this.getPoint(d / divisions));\n      }\n\n      return points;\n    } // Get sequence of points using getPointAt( u )\n\n  }, {\n    key: "getSpacedPoints",\n    value: function getSpacedPoints() {\n      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      var points = [];\n\n      for (var d = 0; d <= divisions; d++) {\n        points.push(this.getPointAt(d / divisions));\n      }\n\n      return points;\n    } // Get total curve arc length\n\n  }, {\n    key: "getLength",\n    value: function getLength() {\n      var lengths = this.getLengths();\n      return lengths[lengths.length - 1];\n    } // Get list of cumulative segment lengths\n\n  }, {\n    key: "getLengths",\n    value: function getLengths() {\n      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.arcLengthDivisions;\n\n      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n        return this.cacheArcLengths;\n      }\n\n      this.needsUpdate = false;\n      var cache = [];\n      var current,\n          last = this.getPoint(0);\n      var sum = 0;\n      cache.push(0);\n\n      for (var p = 1; p <= divisions; p++) {\n        current = this.getPoint(p / divisions);\n        sum += current.distanceTo(last);\n        cache.push(sum);\n        last = current;\n      }\n\n      this.cacheArcLengths = cache;\n      return cache; // { sums: cache, sum: sum }; Sum is in the last element.\n    }\n  }, {\n    key: "updateArcLengths",\n    value: function updateArcLengths() {\n      this.needsUpdate = true;\n      this.getLengths();\n    } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n  }, {\n    key: "getUtoTmapping",\n    value: function getUtoTmapping(u, distance) {\n      var arcLengths = this.getLengths();\n      var i = 0;\n      var il = arcLengths.length;\n      var targetArcLength; // The targeted u distance value to get\n\n      if (distance) {\n        targetArcLength = distance;\n      } else {\n        targetArcLength = u * arcLengths[il - 1];\n      } // binary search for the index with largest value smaller than target u distance\n\n\n      var low = 0,\n          high = il - 1,\n          comparison;\n\n      while (low <= high) {\n        i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn\'t really have integers, all numbers are floats\n\n        comparison = arcLengths[i] - targetArcLength;\n\n        if (comparison < 0) {\n          low = i + 1;\n        } else if (comparison > 0) {\n          high = i - 1;\n        } else {\n          high = i;\n          break; // DONE\n        }\n      }\n\n      i = high;\n\n      if (arcLengths[i] === targetArcLength) {\n        return i / (il - 1);\n      } // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n      var lengthBefore = arcLengths[i];\n      var lengthAfter = arcLengths[i + 1];\n      var segmentLength = lengthAfter - lengthBefore; // determine where we are between the \'before\' and \'after\' points\n\n      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n      var t = (i + segmentFraction) / (il - 1);\n      return t;\n    } // Returns a unit vector tangent at t\n    // In case any sub curve does not implement its tangent derivation,\n    // 2 points a small delta apart will be used to find its gradient\n    // which seems to give a reasonable approximation\n\n  }, {\n    key: "getTangent",\n    value: function getTangent(t, optionalTarget) {\n      var delta = 0.0001;\n      var t1 = t - delta;\n      var t2 = t + delta; // Capping in case of danger\n\n      if (t1 < 0) t1 = 0;\n      if (t2 > 1) t2 = 1;\n      var pt1 = this.getPoint(t1);\n      var pt2 = this.getPoint(t2);\n      var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n      tangent.copy(pt2).sub(pt1).normalize();\n      return tangent;\n    }\n  }, {\n    key: "getTangentAt",\n    value: function getTangentAt(u, optionalTarget) {\n      var t = this.getUtoTmapping(u);\n      return this.getTangent(t, optionalTarget);\n    }\n  }, {\n    key: "computeFrenetFrames",\n    value: function computeFrenetFrames(segments, closed) {\n      // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n      var normal = new Vector3();\n      var tangents = [];\n      var normals = [];\n      var binormals = [];\n      var vec = new Vector3();\n      var mat = new Matrix4(); // compute the tangent vectors for each segment on the curve\n\n      for (var _i186 = 0; _i186 <= segments; _i186++) {\n        var u = _i186 / segments;\n        tangents[_i186] = this.getTangentAt(u, new Vector3());\n      } // select an initial normal vector perpendicular to the first tangent vector,\n      // and in the direction of the minimum tangent xyz component\n\n\n      normals[0] = new Vector3();\n      binormals[0] = new Vector3();\n      var min = Number.MAX_VALUE;\n      var tx = Math.abs(tangents[0].x);\n      var ty = Math.abs(tangents[0].y);\n      var tz = Math.abs(tangents[0].z);\n\n      if (tx <= min) {\n        min = tx;\n        normal.set(1, 0, 0);\n      }\n\n      if (ty <= min) {\n        min = ty;\n        normal.set(0, 1, 0);\n      }\n\n      if (tz <= min) {\n        normal.set(0, 0, 1);\n      }\n\n      vec.crossVectors(tangents[0], normal).normalize();\n      normals[0].crossVectors(tangents[0], vec);\n      binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n      for (var _i187 = 1; _i187 <= segments; _i187++) {\n        normals[_i187] = normals[_i187 - 1].clone();\n        binormals[_i187] = binormals[_i187 - 1].clone();\n        vec.crossVectors(tangents[_i187 - 1], tangents[_i187]);\n\n        if (vec.length() > Number.EPSILON) {\n          vec.normalize();\n          var theta = Math.acos(clamp(tangents[_i187 - 1].dot(tangents[_i187]), -1, 1)); // clamp for floating pt errors\n\n          normals[_i187].applyMatrix4(mat.makeRotationAxis(vec, theta));\n        }\n\n        binormals[_i187].crossVectors(tangents[_i187], normals[_i187]);\n      } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n      if (closed === true) {\n        var _theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));\n\n        _theta /= segments;\n\n        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n          _theta = -_theta;\n        }\n\n        for (var _i188 = 1; _i188 <= segments; _i188++) {\n          // twist a little...\n          normals[_i188].applyMatrix4(mat.makeRotationAxis(tangents[_i188], _theta * _i188));\n\n          binormals[_i188].crossVectors(tangents[_i188], normals[_i188]);\n        }\n      }\n\n      return {\n        tangents: tangents,\n        normals: normals,\n        binormals: binormals\n      };\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      this.arcLengthDivisions = source.arcLengthDivisions;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = {\n        metadata: {\n          version: 4.5,\n          type: \'Curve\',\n          generator: \'Curve.toJSON\'\n        }\n      };\n      data.arcLengthDivisions = this.arcLengthDivisions;\n      data.type = this.type;\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      this.arcLengthDivisions = json.arcLengthDivisions;\n      return this;\n    }\n  }]);\n\n  return Curve;\n}();\n\nvar EllipseCurve = /*#__PURE__*/function (_Curve) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(EllipseCurve, _Curve);\n\n  var _super58 = _createSuper(EllipseCurve);\n\n  function EllipseCurve() {\n    var _this49;\n\n    var aX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var aY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var xRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var yRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var aStartAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var aEndAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;\n    var aClockwise = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    var aRotation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, EllipseCurve);\n\n    _this49 = _super58.call(this);\n    _this49.isEllipseCurve = true;\n    _this49.type = \'EllipseCurve\';\n    _this49.aX = aX;\n    _this49.aY = aY;\n    _this49.xRadius = xRadius;\n    _this49.yRadius = yRadius;\n    _this49.aStartAngle = aStartAngle;\n    _this49.aEndAngle = aEndAngle;\n    _this49.aClockwise = aClockwise;\n    _this49.aRotation = aRotation;\n    return _this49;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(EllipseCurve, [{\n    key: "getPoint",\n    value: function getPoint(t, optionalTarget) {\n      var point = optionalTarget || new Vector2();\n      var twoPi = Math.PI * 2;\n      var deltaAngle = this.aEndAngle - this.aStartAngle;\n      var samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI\n\n      while (deltaAngle < 0) {\n        deltaAngle += twoPi;\n      }\n\n      while (deltaAngle > twoPi) {\n        deltaAngle -= twoPi;\n      }\n\n      if (deltaAngle < Number.EPSILON) {\n        if (samePoints) {\n          deltaAngle = 0;\n        } else {\n          deltaAngle = twoPi;\n        }\n      }\n\n      if (this.aClockwise === true && !samePoints) {\n        if (deltaAngle === twoPi) {\n          deltaAngle = -twoPi;\n        } else {\n          deltaAngle = deltaAngle - twoPi;\n        }\n      }\n\n      var angle = this.aStartAngle + t * deltaAngle;\n      var x = this.aX + this.xRadius * Math.cos(angle);\n      var y = this.aY + this.yRadius * Math.sin(angle);\n\n      if (this.aRotation !== 0) {\n        var cos = Math.cos(this.aRotation);\n        var sin = Math.sin(this.aRotation);\n        var tx = x - this.aX;\n        var ty = y - this.aY; // Rotate the point about the center of the ellipse.\n\n        x = tx * cos - ty * sin + this.aX;\n        y = tx * sin + ty * cos + this.aY;\n      }\n\n      return point.set(x, y);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(EllipseCurve.prototype), "copy", this).call(this, source);\n\n      this.aX = source.aX;\n      this.aY = source.aY;\n      this.xRadius = source.xRadius;\n      this.yRadius = source.yRadius;\n      this.aStartAngle = source.aStartAngle;\n      this.aEndAngle = source.aEndAngle;\n      this.aClockwise = source.aClockwise;\n      this.aRotation = source.aRotation;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(EllipseCurve.prototype), "toJSON", this).call(this);\n\n      data.aX = this.aX;\n      data.aY = this.aY;\n      data.xRadius = this.xRadius;\n      data.yRadius = this.yRadius;\n      data.aStartAngle = this.aStartAngle;\n      data.aEndAngle = this.aEndAngle;\n      data.aClockwise = this.aClockwise;\n      data.aRotation = this.aRotation;\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(EllipseCurve.prototype), "fromJSON", this).call(this, json);\n\n      this.aX = json.aX;\n      this.aY = json.aY;\n      this.xRadius = json.xRadius;\n      this.yRadius = json.yRadius;\n      this.aStartAngle = json.aStartAngle;\n      this.aEndAngle = json.aEndAngle;\n      this.aClockwise = json.aClockwise;\n      this.aRotation = json.aRotation;\n      return this;\n    }\n  }]);\n\n  return EllipseCurve;\n}(Curve);\n\nvar ArcCurve = /*#__PURE__*/function (_EllipseCurve) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ArcCurve, _EllipseCurve);\n\n  var _super59 = _createSuper(ArcCurve);\n\n  function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    var _this50;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ArcCurve);\n\n    _this50 = _super59.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    _this50.isArcCurve = true;\n    _this50.type = \'ArcCurve\';\n    return _this50;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ArcCurve);\n}(EllipseCurve);\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\n\nfunction CubicPoly() {\n  var c0 = 0,\n      c1 = 0,\n      c2 = 0,\n      c3 = 0;\n  /*\n   * Compute coefficients for a cubic polynomial\n   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n   * such that\n   *   p(0) = x0, p(1) = x1\n   *  and\n   *   p\'(0) = t0, p\'(1) = t1.\n   */\n\n  function init(x0, x1, t0, t1) {\n    c0 = x0;\n    c1 = t0;\n    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n    c3 = 2 * x0 - 2 * x1 + t0 + t1;\n  }\n\n  return {\n    initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {\n      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n    },\n    initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {\n      // compute tangents when parameterized in [t1,t2]\n      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]\n\n      t1 *= dt1;\n      t2 *= dt1;\n      init(x1, x2, t1, t2);\n    },\n    calc: function calc(t) {\n      var t2 = t * t;\n      var t3 = t2 * t;\n      return c0 + c1 * t + c2 * t2 + c3 * t3;\n    }\n  };\n} //\n\n\nvar tmp = new Vector3();\nvar px = new CubicPoly(),\n    py = new CubicPoly(),\n    pz = new CubicPoly();\n\nvar CatmullRomCurve3 = /*#__PURE__*/function (_Curve2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CatmullRomCurve3, _Curve2);\n\n  var _super60 = _createSuper(CatmullRomCurve3);\n\n  function CatmullRomCurve3() {\n    var _this51;\n\n    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var curveType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'centripetal\';\n    var tension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CatmullRomCurve3);\n\n    _this51 = _super60.call(this);\n    _this51.isCatmullRomCurve3 = true;\n    _this51.type = \'CatmullRomCurve3\';\n    _this51.points = points;\n    _this51.closed = closed;\n    _this51.curveType = curveType;\n    _this51.tension = tension;\n    return _this51;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CatmullRomCurve3, [{\n    key: "getPoint",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n      var point = optionalTarget;\n      var points = this.points;\n      var l = points.length;\n      var p = (l - (this.closed ? 0 : 1)) * t;\n      var intPoint = Math.floor(p);\n      var weight = p - intPoint;\n\n      if (this.closed) {\n        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n      } else if (weight === 0 && intPoint === l - 1) {\n        intPoint = l - 2;\n        weight = 1;\n      }\n\n      var p0, p3; // 4 points (p1 & p2 defined below)\n\n      if (this.closed || intPoint > 0) {\n        p0 = points[(intPoint - 1) % l];\n      } else {\n        // extrapolate first point\n        tmp.subVectors(points[0], points[1]).add(points[0]);\n        p0 = tmp;\n      }\n\n      var p1 = points[intPoint % l];\n      var p2 = points[(intPoint + 1) % l];\n\n      if (this.closed || intPoint + 2 < l) {\n        p3 = points[(intPoint + 2) % l];\n      } else {\n        // extrapolate last point\n        tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n        p3 = tmp;\n      }\n\n      if (this.curveType === \'centripetal\' || this.curveType === \'chordal\') {\n        // init Centripetal / Chordal Catmull-Rom\n        var pow = this.curveType === \'chordal\' ? 0.5 : 0.25;\n        var dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n        var dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n        var dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points\n\n        if (dt1 < 1e-4) dt1 = 1.0;\n        if (dt0 < 1e-4) dt0 = dt1;\n        if (dt2 < 1e-4) dt2 = dt1;\n        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n      } else if (this.curveType === \'catmullrom\') {\n        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n      }\n\n      point.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n      return point;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CatmullRomCurve3.prototype), "copy", this).call(this, source);\n\n      this.points = [];\n\n      for (var _i189 = 0, l = source.points.length; _i189 < l; _i189++) {\n        var point = source.points[_i189];\n        this.points.push(point.clone());\n      }\n\n      this.closed = source.closed;\n      this.curveType = source.curveType;\n      this.tension = source.tension;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CatmullRomCurve3.prototype), "toJSON", this).call(this);\n\n      data.points = [];\n\n      for (var _i190 = 0, l = this.points.length; _i190 < l; _i190++) {\n        var point = this.points[_i190];\n        data.points.push(point.toArray());\n      }\n\n      data.closed = this.closed;\n      data.curveType = this.curveType;\n      data.tension = this.tension;\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CatmullRomCurve3.prototype), "fromJSON", this).call(this, json);\n\n      this.points = [];\n\n      for (var _i191 = 0, l = json.points.length; _i191 < l; _i191++) {\n        var point = json.points[_i191];\n        this.points.push(new Vector3().fromArray(point));\n      }\n\n      this.closed = json.closed;\n      this.curveType = json.curveType;\n      this.tension = json.tension;\n      return this;\n    }\n  }]);\n\n  return CatmullRomCurve3;\n}(Curve);\n/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\n\nfunction CatmullRom(t, p0, p1, p2, p3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  var t2 = t * t;\n  var t3 = t * t2;\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n} //\n\n\nfunction QuadraticBezierP0(t, p) {\n  var k = 1 - t;\n  return k * k * p;\n}\n\nfunction QuadraticBezierP1(t, p) {\n  return 2 * (1 - t) * t * p;\n}\n\nfunction QuadraticBezierP2(t, p) {\n  return t * t * p;\n}\n\nfunction QuadraticBezier(t, p0, p1, p2) {\n  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\n} //\n\n\nfunction CubicBezierP0(t, p) {\n  var k = 1 - t;\n  return k * k * k * p;\n}\n\nfunction CubicBezierP1(t, p) {\n  var k = 1 - t;\n  return 3 * k * k * t * p;\n}\n\nfunction CubicBezierP2(t, p) {\n  return 3 * (1 - t) * t * t * p;\n}\n\nfunction CubicBezierP3(t, p) {\n  return t * t * t * p;\n}\n\nfunction CubicBezier(t, p0, p1, p2, p3) {\n  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n}\n\nvar CubicBezierCurve = /*#__PURE__*/function (_Curve3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CubicBezierCurve, _Curve3);\n\n  var _super61 = _createSuper(CubicBezierCurve);\n\n  function CubicBezierCurve() {\n    var _this52;\n\n    var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();\n    var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\n    var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();\n    var v3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector2();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CubicBezierCurve);\n\n    _this52 = _super61.call(this);\n    _this52.isCubicBezierCurve = true;\n    _this52.type = \'CubicBezierCurve\';\n    _this52.v0 = v0;\n    _this52.v1 = v1;\n    _this52.v2 = v2;\n    _this52.v3 = v3;\n    return _this52;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CubicBezierCurve, [{\n    key: "getPoint",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\n      var point = optionalTarget;\n      var v0 = this.v0,\n          v1 = this.v1,\n          v2 = this.v2,\n          v3 = this.v3;\n      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\n      return point;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CubicBezierCurve.prototype), "copy", this).call(this, source);\n\n      this.v0.copy(source.v0);\n      this.v1.copy(source.v1);\n      this.v2.copy(source.v2);\n      this.v3.copy(source.v3);\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CubicBezierCurve.prototype), "toJSON", this).call(this);\n\n      data.v0 = this.v0.toArray();\n      data.v1 = this.v1.toArray();\n      data.v2 = this.v2.toArray();\n      data.v3 = this.v3.toArray();\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CubicBezierCurve.prototype), "fromJSON", this).call(this, json);\n\n      this.v0.fromArray(json.v0);\n      this.v1.fromArray(json.v1);\n      this.v2.fromArray(json.v2);\n      this.v3.fromArray(json.v3);\n      return this;\n    }\n  }]);\n\n  return CubicBezierCurve;\n}(Curve);\n\nvar CubicBezierCurve3 = /*#__PURE__*/function (_Curve4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CubicBezierCurve3, _Curve4);\n\n  var _super62 = _createSuper(CubicBezierCurve3);\n\n  function CubicBezierCurve3() {\n    var _this53;\n\n    var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n    var v3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector3();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CubicBezierCurve3);\n\n    _this53 = _super62.call(this);\n    _this53.isCubicBezierCurve3 = true;\n    _this53.type = \'CubicBezierCurve3\';\n    _this53.v0 = v0;\n    _this53.v1 = v1;\n    _this53.v2 = v2;\n    _this53.v3 = v3;\n    return _this53;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CubicBezierCurve3, [{\n    key: "getPoint",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n      var point = optionalTarget;\n      var v0 = this.v0,\n          v1 = this.v1,\n          v2 = this.v2,\n          v3 = this.v3;\n      point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\n      return point;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CubicBezierCurve3.prototype), "copy", this).call(this, source);\n\n      this.v0.copy(source.v0);\n      this.v1.copy(source.v1);\n      this.v2.copy(source.v2);\n      this.v3.copy(source.v3);\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CubicBezierCurve3.prototype), "toJSON", this).call(this);\n\n      data.v0 = this.v0.toArray();\n      data.v1 = this.v1.toArray();\n      data.v2 = this.v2.toArray();\n      data.v3 = this.v3.toArray();\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CubicBezierCurve3.prototype), "fromJSON", this).call(this, json);\n\n      this.v0.fromArray(json.v0);\n      this.v1.fromArray(json.v1);\n      this.v2.fromArray(json.v2);\n      this.v3.fromArray(json.v3);\n      return this;\n    }\n  }]);\n\n  return CubicBezierCurve3;\n}(Curve);\n\nvar LineCurve = /*#__PURE__*/function (_Curve5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LineCurve, _Curve5);\n\n  var _super63 = _createSuper(LineCurve);\n\n  function LineCurve() {\n    var _this54;\n\n    var v1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();\n    var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LineCurve);\n\n    _this54 = _super63.call(this);\n    _this54.isLineCurve = true;\n    _this54.type = \'LineCurve\';\n    _this54.v1 = v1;\n    _this54.v2 = v2;\n    return _this54;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LineCurve, [{\n    key: "getPoint",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\n      var point = optionalTarget;\n\n      if (t === 1) {\n        point.copy(this.v2);\n      } else {\n        point.copy(this.v2).sub(this.v1);\n        point.multiplyScalar(t).add(this.v1);\n      }\n\n      return point;\n    } // Line curve is linear, so we can overwrite default getPointAt\n\n  }, {\n    key: "getPointAt",\n    value: function getPointAt(u, optionalTarget) {\n      return this.getPoint(u, optionalTarget);\n    }\n  }, {\n    key: "getTangent",\n    value: function getTangent(t, optionalTarget) {\n      var tangent = optionalTarget || new Vector2();\n      tangent.copy(this.v2).sub(this.v1).normalize();\n      return tangent;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LineCurve.prototype), "copy", this).call(this, source);\n\n      this.v1.copy(source.v1);\n      this.v2.copy(source.v2);\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LineCurve.prototype), "toJSON", this).call(this);\n\n      data.v1 = this.v1.toArray();\n      data.v2 = this.v2.toArray();\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LineCurve.prototype), "fromJSON", this).call(this, json);\n\n      this.v1.fromArray(json.v1);\n      this.v2.fromArray(json.v2);\n      return this;\n    }\n  }]);\n\n  return LineCurve;\n}(Curve);\n\nvar LineCurve3 = /*#__PURE__*/function (_Curve6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LineCurve3, _Curve6);\n\n  var _super64 = _createSuper(LineCurve3);\n\n  function LineCurve3() {\n    var _this55;\n\n    var v1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LineCurve3);\n\n    _this55 = _super64.call(this);\n    _this55.isLineCurve3 = true;\n    _this55.type = \'LineCurve3\';\n    _this55.v1 = v1;\n    _this55.v2 = v2;\n    return _this55;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LineCurve3, [{\n    key: "getPoint",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n      var point = optionalTarget;\n\n      if (t === 1) {\n        point.copy(this.v2);\n      } else {\n        point.copy(this.v2).sub(this.v1);\n        point.multiplyScalar(t).add(this.v1);\n      }\n\n      return point;\n    } // Line curve is linear, so we can overwrite default getPointAt\n\n  }, {\n    key: "getPointAt",\n    value: function getPointAt(u, optionalTarget) {\n      return this.getPoint(u, optionalTarget);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LineCurve3.prototype), "copy", this).call(this, source);\n\n      this.v1.copy(source.v1);\n      this.v2.copy(source.v2);\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LineCurve3.prototype), "toJSON", this).call(this);\n\n      data.v1 = this.v1.toArray();\n      data.v2 = this.v2.toArray();\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LineCurve3.prototype), "fromJSON", this).call(this, json);\n\n      this.v1.fromArray(json.v1);\n      this.v2.fromArray(json.v2);\n      return this;\n    }\n  }]);\n\n  return LineCurve3;\n}(Curve);\n\nvar QuadraticBezierCurve = /*#__PURE__*/function (_Curve7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(QuadraticBezierCurve, _Curve7);\n\n  var _super65 = _createSuper(QuadraticBezierCurve);\n\n  function QuadraticBezierCurve() {\n    var _this56;\n\n    var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();\n    var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\n    var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, QuadraticBezierCurve);\n\n    _this56 = _super65.call(this);\n    _this56.isQuadraticBezierCurve = true;\n    _this56.type = \'QuadraticBezierCurve\';\n    _this56.v0 = v0;\n    _this56.v1 = v1;\n    _this56.v2 = v2;\n    return _this56;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(QuadraticBezierCurve, [{\n    key: "getPoint",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\n      var point = optionalTarget;\n      var v0 = this.v0,\n          v1 = this.v1,\n          v2 = this.v2;\n      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\n      return point;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(QuadraticBezierCurve.prototype), "copy", this).call(this, source);\n\n      this.v0.copy(source.v0);\n      this.v1.copy(source.v1);\n      this.v2.copy(source.v2);\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(QuadraticBezierCurve.prototype), "toJSON", this).call(this);\n\n      data.v0 = this.v0.toArray();\n      data.v1 = this.v1.toArray();\n      data.v2 = this.v2.toArray();\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(QuadraticBezierCurve.prototype), "fromJSON", this).call(this, json);\n\n      this.v0.fromArray(json.v0);\n      this.v1.fromArray(json.v1);\n      this.v2.fromArray(json.v2);\n      return this;\n    }\n  }]);\n\n  return QuadraticBezierCurve;\n}(Curve);\n\nvar QuadraticBezierCurve3 = /*#__PURE__*/function (_Curve8) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(QuadraticBezierCurve3, _Curve8);\n\n  var _super66 = _createSuper(QuadraticBezierCurve3);\n\n  function QuadraticBezierCurve3() {\n    var _this57;\n\n    var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n    var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, QuadraticBezierCurve3);\n\n    _this57 = _super66.call(this);\n    _this57.isQuadraticBezierCurve3 = true;\n    _this57.type = \'QuadraticBezierCurve3\';\n    _this57.v0 = v0;\n    _this57.v1 = v1;\n    _this57.v2 = v2;\n    return _this57;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(QuadraticBezierCurve3, [{\n    key: "getPoint",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n      var point = optionalTarget;\n      var v0 = this.v0,\n          v1 = this.v1,\n          v2 = this.v2;\n      point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\n      return point;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(QuadraticBezierCurve3.prototype), "copy", this).call(this, source);\n\n      this.v0.copy(source.v0);\n      this.v1.copy(source.v1);\n      this.v2.copy(source.v2);\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(QuadraticBezierCurve3.prototype), "toJSON", this).call(this);\n\n      data.v0 = this.v0.toArray();\n      data.v1 = this.v1.toArray();\n      data.v2 = this.v2.toArray();\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(QuadraticBezierCurve3.prototype), "fromJSON", this).call(this, json);\n\n      this.v0.fromArray(json.v0);\n      this.v1.fromArray(json.v1);\n      this.v2.fromArray(json.v2);\n      return this;\n    }\n  }]);\n\n  return QuadraticBezierCurve3;\n}(Curve);\n\nvar SplineCurve = /*#__PURE__*/function (_Curve9) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(SplineCurve, _Curve9);\n\n  var _super67 = _createSuper(SplineCurve);\n\n  function SplineCurve() {\n    var _this58;\n\n    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SplineCurve);\n\n    _this58 = _super67.call(this);\n    _this58.isSplineCurve = true;\n    _this58.type = \'SplineCurve\';\n    _this58.points = points;\n    return _this58;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SplineCurve, [{\n    key: "getPoint",\n    value: function getPoint(t) {\n      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();\n      var point = optionalTarget;\n      var points = this.points;\n      var p = (points.length - 1) * t;\n      var intPoint = Math.floor(p);\n      var weight = p - intPoint;\n      var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n      var p1 = points[intPoint];\n      var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n      var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n      point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n      return point;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SplineCurve.prototype), "copy", this).call(this, source);\n\n      this.points = [];\n\n      for (var _i192 = 0, l = source.points.length; _i192 < l; _i192++) {\n        var point = source.points[_i192];\n        this.points.push(point.clone());\n      }\n\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SplineCurve.prototype), "toJSON", this).call(this);\n\n      data.points = [];\n\n      for (var _i193 = 0, l = this.points.length; _i193 < l; _i193++) {\n        var point = this.points[_i193];\n        data.points.push(point.toArray());\n      }\n\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SplineCurve.prototype), "fromJSON", this).call(this, json);\n\n      this.points = [];\n\n      for (var _i194 = 0, l = json.points.length; _i194 < l; _i194++) {\n        var point = json.points[_i194];\n        this.points.push(new Vector2().fromArray(point));\n      }\n\n      return this;\n    }\n  }]);\n\n  return SplineCurve;\n}(Curve);\n\nvar Curves = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ArcCurve: ArcCurve,\n  CatmullRomCurve3: CatmullRomCurve3,\n  CubicBezierCurve: CubicBezierCurve,\n  CubicBezierCurve3: CubicBezierCurve3,\n  EllipseCurve: EllipseCurve,\n  LineCurve: LineCurve,\n  LineCurve3: LineCurve3,\n  QuadraticBezierCurve: QuadraticBezierCurve,\n  QuadraticBezierCurve3: QuadraticBezierCurve3,\n  SplineCurve: SplineCurve\n});\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nvar CurvePath = /*#__PURE__*/function (_Curve10) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CurvePath, _Curve10);\n\n  var _super68 = _createSuper(CurvePath);\n\n  function CurvePath() {\n    var _this59;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CurvePath);\n\n    _this59 = _super68.call(this);\n    _this59.type = \'CurvePath\';\n    _this59.curves = [];\n    _this59.autoClose = false; // Automatically closes the path\n\n    return _this59;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CurvePath, [{\n    key: "add",\n    value: function add(curve) {\n      this.curves.push(curve);\n    }\n  }, {\n    key: "closePath",\n    value: function closePath() {\n      // Add a line curve if start and end of lines are not connected\n      var startPoint = this.curves[0].getPoint(0);\n      var endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n      if (!startPoint.equals(endPoint)) {\n        this.curves.push(new LineCurve(endPoint, startPoint));\n      }\n    } // To get accurate point with reference to\n    // entire path distance at time t,\n    // following has to be done:\n    // 1. Length of each sub path have to be known\n    // 2. Locate and identify type of curve\n    // 3. Get t for the curve\n    // 4. Return curve.getPointAt(t\')\n\n  }, {\n    key: "getPoint",\n    value: function getPoint(t, optionalTarget) {\n      var d = t * this.getLength();\n      var curveLengths = this.getCurveLengths();\n      var i = 0; // To think about boundaries points.\n\n      while (i < curveLengths.length) {\n        if (curveLengths[i] >= d) {\n          var diff = curveLengths[i] - d;\n          var curve = this.curves[i];\n          var segmentLength = curve.getLength();\n          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n          return curve.getPointAt(u, optionalTarget);\n        }\n\n        i++;\n      }\n\n      return null; // loop where sum != 0, sum > d , sum+1 <d\n    } // We cannot use the default THREE.Curve getPoint() with getLength() because in\n    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n    // getPoint() depends on getLength\n\n  }, {\n    key: "getLength",\n    value: function getLength() {\n      var lens = this.getCurveLengths();\n      return lens[lens.length - 1];\n    } // cacheLengths must be recalculated.\n\n  }, {\n    key: "updateArcLengths",\n    value: function updateArcLengths() {\n      this.needsUpdate = true;\n      this.cacheLengths = null;\n      this.getCurveLengths();\n    } // Compute lengths and cache them\n    // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n  }, {\n    key: "getCurveLengths",\n    value: function getCurveLengths() {\n      // We use cache values if curves and cache array are same length\n      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n        return this.cacheLengths;\n      } // Get length of sub-curve\n      // Push sums into cached array\n\n\n      var lengths = [];\n      var sums = 0;\n\n      for (var _i195 = 0, l = this.curves.length; _i195 < l; _i195++) {\n        sums += this.curves[_i195].getLength();\n        lengths.push(sums);\n      }\n\n      this.cacheLengths = lengths;\n      return lengths;\n    }\n  }, {\n    key: "getSpacedPoints",\n    value: function getSpacedPoints() {\n      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;\n      var points = [];\n\n      for (var _i196 = 0; _i196 <= divisions; _i196++) {\n        points.push(this.getPoint(_i196 / divisions));\n      }\n\n      if (this.autoClose) {\n        points.push(points[0]);\n      }\n\n      return points;\n    }\n  }, {\n    key: "getPoints",\n    value: function getPoints() {\n      var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;\n      var points = [];\n      var last;\n\n      for (var _i197 = 0, curves = this.curves; _i197 < curves.length; _i197++) {\n        var curve = curves[_i197];\n        var resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;\n        var pts = curve.getPoints(resolution);\n\n        for (var j = 0; j < pts.length; j++) {\n          var point = pts[j];\n          if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n          points.push(point);\n          last = point;\n        }\n      }\n\n      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n        points.push(points[0]);\n      }\n\n      return points;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CurvePath.prototype), "copy", this).call(this, source);\n\n      this.curves = [];\n\n      for (var _i198 = 0, l = source.curves.length; _i198 < l; _i198++) {\n        var curve = source.curves[_i198];\n        this.curves.push(curve.clone());\n      }\n\n      this.autoClose = source.autoClose;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CurvePath.prototype), "toJSON", this).call(this);\n\n      data.autoClose = this.autoClose;\n      data.curves = [];\n\n      for (var _i199 = 0, l = this.curves.length; _i199 < l; _i199++) {\n        var curve = this.curves[_i199];\n        data.curves.push(curve.toJSON());\n      }\n\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(CurvePath.prototype), "fromJSON", this).call(this, json);\n\n      this.autoClose = json.autoClose;\n      this.curves = [];\n\n      for (var _i200 = 0, l = json.curves.length; _i200 < l; _i200++) {\n        var curve = json.curves[_i200];\n        this.curves.push(new Curves[curve.type]().fromJSON(curve));\n      }\n\n      return this;\n    }\n  }]);\n\n  return CurvePath;\n}(Curve);\n\nvar Path = /*#__PURE__*/function (_CurvePath) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Path, _CurvePath);\n\n  var _super69 = _createSuper(Path);\n\n  function Path(points) {\n    var _this60;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Path);\n\n    _this60 = _super69.call(this);\n    _this60.type = \'Path\';\n    _this60.currentPoint = new Vector2();\n\n    if (points) {\n      _this60.setFromPoints(points);\n    }\n\n    return _this60;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Path, [{\n    key: "setFromPoints",\n    value: function setFromPoints(points) {\n      this.moveTo(points[0].x, points[0].y);\n\n      for (var _i201 = 1, l = points.length; _i201 < l; _i201++) {\n        this.lineTo(points[_i201].x, points[_i201].y);\n      }\n\n      return this;\n    }\n  }, {\n    key: "moveTo",\n    value: function moveTo(x, y) {\n      this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n      return this;\n    }\n  }, {\n    key: "lineTo",\n    value: function lineTo(x, y) {\n      var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n      this.curves.push(curve);\n      this.currentPoint.set(x, y);\n      return this;\n    }\n  }, {\n    key: "quadraticCurveTo",\n    value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {\n      var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n      this.curves.push(curve);\n      this.currentPoint.set(aX, aY);\n      return this;\n    }\n  }, {\n    key: "bezierCurveTo",\n    value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n      var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n      this.curves.push(curve);\n      this.currentPoint.set(aX, aY);\n      return this;\n    }\n  }, {\n    key: "splineThru",\n    value: function splineThru(pts\n    /*Array of Vector*/\n    ) {\n      var npts = [this.currentPoint.clone()].concat(pts);\n      var curve = new SplineCurve(npts);\n      this.curves.push(curve);\n      this.currentPoint.copy(pts[pts.length - 1]);\n      return this;\n    }\n  }, {\n    key: "arc",\n    value: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n      var x0 = this.currentPoint.x;\n      var y0 = this.currentPoint.y;\n      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n      return this;\n    }\n  }, {\n    key: "absarc",\n    value: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n      return this;\n    }\n  }, {\n    key: "ellipse",\n    value: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n      var x0 = this.currentPoint.x;\n      var y0 = this.currentPoint.y;\n      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n      return this;\n    }\n  }, {\n    key: "absellipse",\n    value: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n      var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\n      if (this.curves.length > 0) {\n        // if a previous curve is present, attempt to join\n        var firstPoint = curve.getPoint(0);\n\n        if (!firstPoint.equals(this.currentPoint)) {\n          this.lineTo(firstPoint.x, firstPoint.y);\n        }\n      }\n\n      this.curves.push(curve);\n      var lastPoint = curve.getPoint(1);\n      this.currentPoint.copy(lastPoint);\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Path.prototype), "copy", this).call(this, source);\n\n      this.currentPoint.copy(source.currentPoint);\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Path.prototype), "toJSON", this).call(this);\n\n      data.currentPoint = this.currentPoint.toArray();\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Path.prototype), "fromJSON", this).call(this, json);\n\n      this.currentPoint.fromArray(json.currentPoint);\n      return this;\n    }\n  }]);\n\n  return Path;\n}(CurvePath);\n\nvar LatheGeometry = /*#__PURE__*/function (_BufferGeometry3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LatheGeometry, _BufferGeometry3);\n\n  var _super70 = _createSuper(LatheGeometry);\n\n  function LatheGeometry() {\n    var _this61;\n\n    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)];\n    var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n    var phiStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var phiLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LatheGeometry);\n\n    _this61 = _super70.call(this);\n    _this61.type = \'LatheGeometry\';\n    _this61.parameters = {\n      points: points,\n      segments: segments,\n      phiStart: phiStart,\n      phiLength: phiLength\n    };\n    segments = Math.floor(segments); // clamp phiLength so it\'s in range of [ 0, 2PI ]\n\n    phiLength = clamp(phiLength, 0, Math.PI * 2); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var uvs = [];\n    var initNormals = [];\n    var normals = []; // helper variables\n\n    var inverseSegments = 1.0 / segments;\n    var vertex = new Vector3();\n    var uv = new Vector2();\n    var normal = new Vector3();\n    var curNormal = new Vector3();\n    var prevNormal = new Vector3();\n    var dx = 0;\n    var dy = 0; // pre-compute normals for initial "meridian"\n\n    for (var j = 0; j <= points.length - 1; j++) {\n      switch (j) {\n        case 0:\n          // special handling for 1st vertex on path\n          dx = points[j + 1].x - points[j].x;\n          dy = points[j + 1].y - points[j].y;\n          normal.x = dy * 1.0;\n          normal.y = -dx;\n          normal.z = dy * 0.0;\n          prevNormal.copy(normal);\n          normal.normalize();\n          initNormals.push(normal.x, normal.y, normal.z);\n          break;\n\n        case points.length - 1:\n          // special handling for last Vertex on path\n          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);\n          break;\n\n        default:\n          // default handling for all vertices in between\n          dx = points[j + 1].x - points[j].x;\n          dy = points[j + 1].y - points[j].y;\n          normal.x = dy * 1.0;\n          normal.y = -dx;\n          normal.z = dy * 0.0;\n          curNormal.copy(normal);\n          normal.x += prevNormal.x;\n          normal.y += prevNormal.y;\n          normal.z += prevNormal.z;\n          normal.normalize();\n          initNormals.push(normal.x, normal.y, normal.z);\n          prevNormal.copy(curNormal);\n      }\n    } // generate vertices, uvs and normals\n\n\n    for (var _i202 = 0; _i202 <= segments; _i202++) {\n      var phi = phiStart + _i202 * inverseSegments * phiLength;\n      var sin = Math.sin(phi);\n      var cos = Math.cos(phi);\n\n      for (var _j5 = 0; _j5 <= points.length - 1; _j5++) {\n        // vertex\n        vertex.x = points[_j5].x * sin;\n        vertex.y = points[_j5].y;\n        vertex.z = points[_j5].x * cos;\n        vertices.push(vertex.x, vertex.y, vertex.z); // uv\n\n        uv.x = _i202 / segments;\n        uv.y = _j5 / (points.length - 1);\n        uvs.push(uv.x, uv.y); // normal\n\n        var x = initNormals[3 * _j5 + 0] * sin;\n        var y = initNormals[3 * _j5 + 1];\n        var z = initNormals[3 * _j5 + 0] * cos;\n        normals.push(x, y, z);\n      }\n    } // indices\n\n\n    for (var _i203 = 0; _i203 < segments; _i203++) {\n      for (var _j6 = 0; _j6 < points.length - 1; _j6++) {\n        var base = _j6 + _i203 * points.length;\n        var a = base;\n        var b = base + points.length;\n        var c = base + points.length + 1;\n        var d = base + 1; // faces\n\n        indices.push(a, b, d);\n        indices.push(c, d, b);\n      }\n    } // build geometry\n\n\n    _this61.setIndex(indices);\n\n    _this61.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this61.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2));\n\n    _this61.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    return _this61;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LatheGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);\n    }\n  }]);\n\n  return LatheGeometry;\n}(BufferGeometry);\n\nvar CapsuleGeometry = /*#__PURE__*/function (_LatheGeometry) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CapsuleGeometry, _LatheGeometry);\n\n  var _super71 = _createSuper(CapsuleGeometry);\n\n  function CapsuleGeometry() {\n    var _this62;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var capSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n    var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CapsuleGeometry);\n\n    var path = new Path();\n    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);\n    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);\n    _this62 = _super71.call(this, path.getPoints(capSegments), radialSegments);\n    _this62.type = \'CapsuleGeometry\';\n    _this62.parameters = {\n      radius: radius,\n      height: length,\n      capSegments: capSegments,\n      radialSegments: radialSegments\n    };\n    return _this62;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CapsuleGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);\n    }\n  }]);\n\n  return CapsuleGeometry;\n}(LatheGeometry);\n\nvar CircleGeometry = /*#__PURE__*/function (_BufferGeometry4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CircleGeometry, _BufferGeometry4);\n\n  var _super72 = _createSuper(CircleGeometry);\n\n  function CircleGeometry() {\n    var _this63;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n    var thetaStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var thetaLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CircleGeometry);\n\n    _this63 = _super72.call(this);\n    _this63.type = \'CircleGeometry\';\n    _this63.parameters = {\n      radius: radius,\n      segments: segments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    segments = Math.max(3, segments); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var vertex = new Vector3();\n    var uv = new Vector2(); // center point\n\n    vertices.push(0, 0, 0);\n    normals.push(0, 0, 1);\n    uvs.push(0.5, 0.5);\n\n    for (var s = 0, _i204 = 3; s <= segments; s++, _i204 += 3) {\n      var segment = thetaStart + s / segments * thetaLength; // vertex\n\n      vertex.x = radius * Math.cos(segment);\n      vertex.y = radius * Math.sin(segment);\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normals.push(0, 0, 1); // uvs\n\n      uv.x = (vertices[_i204] / radius + 1) / 2;\n      uv.y = (vertices[_i204 + 1] / radius + 1) / 2;\n      uvs.push(uv.x, uv.y);\n    } // indices\n\n\n    for (var _i205 = 1; _i205 <= segments; _i205++) {\n      indices.push(_i205, _i205 + 1, 0);\n    } // build geometry\n\n\n    _this63.setIndex(indices);\n\n    _this63.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this63.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this63.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2));\n\n    return _this63;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CircleGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);\n    }\n  }]);\n\n  return CircleGeometry;\n}(BufferGeometry);\n\nvar CylinderGeometry = /*#__PURE__*/function (_BufferGeometry5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CylinderGeometry, _BufferGeometry5);\n\n  var _super73 = _createSuper(CylinderGeometry);\n\n  function CylinderGeometry() {\n    var _this64;\n\n    var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n    var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var openEnded = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    var thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var thetaLength = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI * 2;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CylinderGeometry);\n\n    _this64 = _super73.call(this);\n    _this64.type = \'CylinderGeometry\';\n    _this64.parameters = {\n      radiusTop: radiusTop,\n      radiusBottom: radiusBottom,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n\n    var scope = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this64);\n\n    radialSegments = Math.floor(radialSegments);\n    heightSegments = Math.floor(heightSegments); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var index = 0;\n    var indexArray = [];\n    var halfHeight = height / 2;\n    var groupStart = 0; // generate geometry\n\n    generateTorso();\n\n    if (openEnded === false) {\n      if (radiusTop > 0) generateCap(true);\n      if (radiusBottom > 0) generateCap(false);\n    } // build geometry\n\n\n    _this64.setIndex(indices);\n\n    _this64.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this64.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this64.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2));\n\n    function generateTorso() {\n      var normal = new Vector3();\n      var vertex = new Vector3();\n      var groupCount = 0; // this will be used to calculate the normal\n\n      var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs\n\n      for (var y = 0; y <= heightSegments; y++) {\n        var indexRow = [];\n        var v = y / heightSegments; // calculate the radius of the current row\n\n        var radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n        for (var x = 0; x <= radialSegments; x++) {\n          var u = x / radialSegments;\n          var theta = u * thetaLength + thetaStart;\n          var sinTheta = Math.sin(theta);\n          var cosTheta = Math.cos(theta); // vertex\n\n          vertex.x = radius * sinTheta;\n          vertex.y = -v * height + halfHeight;\n          vertex.z = radius * cosTheta;\n          vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n          normal.set(sinTheta, slope, cosTheta).normalize();\n          normals.push(normal.x, normal.y, normal.z); // uv\n\n          uvs.push(u, 1 - v); // save index of vertex in respective row\n\n          indexRow.push(index++);\n        } // now save vertices of the row in our index array\n\n\n        indexArray.push(indexRow);\n      } // generate indices\n\n\n      for (var _x4 = 0; _x4 < radialSegments; _x4++) {\n        for (var _y2 = 0; _y2 < heightSegments; _y2++) {\n          // we use the index array to access the correct indices\n          var a = indexArray[_y2][_x4];\n          var b = indexArray[_y2 + 1][_x4];\n          var c = indexArray[_y2 + 1][_x4 + 1];\n          var d = indexArray[_y2][_x4 + 1]; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d); // update group counter\n\n          groupCount += 6;\n        }\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n\n    function generateCap(top) {\n      // save the index of the first center vertex\n      var centerIndexStart = index;\n      var uv = new Vector2();\n      var vertex = new Vector3();\n      var groupCount = 0;\n      var radius = top === true ? radiusTop : radiusBottom;\n      var sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.\n      // because the geometry needs one set of uvs per face,\n      // we must generate a center vertex per face/segment\n\n      for (var x = 1; x <= radialSegments; x++) {\n        // vertex\n        vertices.push(0, halfHeight * sign, 0); // normal\n\n        normals.push(0, sign, 0); // uv\n\n        uvs.push(0.5, 0.5); // increase index\n\n        index++;\n      } // save the index of the last center vertex\n\n\n      var centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs\n\n      for (var _x5 = 0; _x5 <= radialSegments; _x5++) {\n        var u = _x5 / radialSegments;\n        var theta = u * thetaLength + thetaStart;\n        var cosTheta = Math.cos(theta);\n        var sinTheta = Math.sin(theta); // vertex\n\n        vertex.x = radius * sinTheta;\n        vertex.y = halfHeight * sign;\n        vertex.z = radius * cosTheta;\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normals.push(0, sign, 0); // uv\n\n        uv.x = cosTheta * 0.5 + 0.5;\n        uv.y = sinTheta * 0.5 * sign + 0.5;\n        uvs.push(uv.x, uv.y); // increase index\n\n        index++;\n      } // generate indices\n\n\n      for (var _x6 = 0; _x6 < radialSegments; _x6++) {\n        var c = centerIndexStart + _x6;\n\n        var _i206 = centerIndexEnd + _x6;\n\n        if (top === true) {\n          // face top\n          indices.push(_i206, _i206 + 1, c);\n        } else {\n          // face bottom\n          indices.push(_i206 + 1, _i206, c);\n        }\n\n        groupCount += 3;\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n\n    return _this64;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CylinderGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n    }\n  }]);\n\n  return CylinderGeometry;\n}(BufferGeometry);\n\nvar ConeGeometry = /*#__PURE__*/function (_CylinderGeometry) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ConeGeometry, _CylinderGeometry);\n\n  var _super74 = _createSuper(ConeGeometry);\n\n  function ConeGeometry() {\n    var _this65;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var openEnded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI * 2;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ConeGeometry);\n\n    _this65 = _super74.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);\n    _this65.type = \'ConeGeometry\';\n    _this65.parameters = {\n      radius: radius,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    return _this65;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ConeGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n    }\n  }]);\n\n  return ConeGeometry;\n}(CylinderGeometry);\n\nvar PolyhedronGeometry = /*#__PURE__*/function (_BufferGeometry6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PolyhedronGeometry, _BufferGeometry6);\n\n  var _super75 = _createSuper(PolyhedronGeometry);\n\n  function PolyhedronGeometry() {\n    var _this66;\n\n    var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PolyhedronGeometry);\n\n    _this66 = _super75.call(this);\n    _this66.type = \'PolyhedronGeometry\';\n    _this66.parameters = {\n      vertices: vertices,\n      indices: indices,\n      radius: radius,\n      detail: detail\n    }; // default buffer data\n\n    var vertexBuffer = [];\n    var uvBuffer = []; // the subdivision creates the vertex buffer data\n\n    subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius\n\n    applyRadius(radius); // finally, create the uv data\n\n    generateUVs(); // build non-indexed geometry\n\n    _this66.setAttribute(\'position\', new Float32BufferAttribute(vertexBuffer, 3));\n\n    _this66.setAttribute(\'normal\', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n\n    _this66.setAttribute(\'uv\', new Float32BufferAttribute(uvBuffer, 2));\n\n    if (detail === 0) {\n      _this66.computeVertexNormals(); // flat normals\n\n    } else {\n      _this66.normalizeNormals(); // smooth normals\n\n    } // helper functions\n\n\n    function subdivide(detail) {\n      var a = new Vector3();\n      var b = new Vector3();\n      var c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value\n\n      for (var _i207 = 0; _i207 < indices.length; _i207 += 3) {\n        // get the vertices of the face\n        getVertexByIndex(indices[_i207 + 0], a);\n        getVertexByIndex(indices[_i207 + 1], b);\n        getVertexByIndex(indices[_i207 + 2], c); // perform subdivision\n\n        subdivideFace(a, b, c, detail);\n      }\n    }\n\n    function subdivideFace(a, b, c, detail) {\n      var cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision\n\n      var v = []; // construct all of the vertices for this subdivision\n\n      for (var _i208 = 0; _i208 <= cols; _i208++) {\n        v[_i208] = [];\n        var aj = a.clone().lerp(c, _i208 / cols);\n        var bj = b.clone().lerp(c, _i208 / cols);\n        var rows = cols - _i208;\n\n        for (var j = 0; j <= rows; j++) {\n          if (j === 0 && _i208 === cols) {\n            v[_i208][j] = aj;\n          } else {\n            v[_i208][j] = aj.clone().lerp(bj, j / rows);\n          }\n        }\n      } // construct all of the faces\n\n\n      for (var _i209 = 0; _i209 < cols; _i209++) {\n        for (var _j7 = 0; _j7 < 2 * (cols - _i209) - 1; _j7++) {\n          var k = Math.floor(_j7 / 2);\n\n          if (_j7 % 2 === 0) {\n            pushVertex(v[_i209][k + 1]);\n            pushVertex(v[_i209 + 1][k]);\n            pushVertex(v[_i209][k]);\n          } else {\n            pushVertex(v[_i209][k + 1]);\n            pushVertex(v[_i209 + 1][k + 1]);\n            pushVertex(v[_i209 + 1][k]);\n          }\n        }\n      }\n    }\n\n    function applyRadius(radius) {\n      var vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex\n\n      for (var _i210 = 0; _i210 < vertexBuffer.length; _i210 += 3) {\n        vertex.x = vertexBuffer[_i210 + 0];\n        vertex.y = vertexBuffer[_i210 + 1];\n        vertex.z = vertexBuffer[_i210 + 2];\n        vertex.normalize().multiplyScalar(radius);\n        vertexBuffer[_i210 + 0] = vertex.x;\n        vertexBuffer[_i210 + 1] = vertex.y;\n        vertexBuffer[_i210 + 2] = vertex.z;\n      }\n    }\n\n    function generateUVs() {\n      var vertex = new Vector3();\n\n      for (var _i211 = 0; _i211 < vertexBuffer.length; _i211 += 3) {\n        vertex.x = vertexBuffer[_i211 + 0];\n        vertex.y = vertexBuffer[_i211 + 1];\n        vertex.z = vertexBuffer[_i211 + 2];\n        var u = azimuth(vertex) / 2 / Math.PI + 0.5;\n        var v = inclination(vertex) / Math.PI + 0.5;\n        uvBuffer.push(u, 1 - v);\n      }\n\n      correctUVs();\n      correctSeam();\n    }\n\n    function correctSeam() {\n      // handle case when face straddles the seam, see #3269\n      for (var _i212 = 0; _i212 < uvBuffer.length; _i212 += 6) {\n        // uv data of a single face\n        var x0 = uvBuffer[_i212 + 0];\n        var x1 = uvBuffer[_i212 + 2];\n        var x2 = uvBuffer[_i212 + 4];\n        var max = Math.max(x0, x1, x2);\n        var min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary\n\n        if (max > 0.9 && min < 0.1) {\n          if (x0 < 0.2) uvBuffer[_i212 + 0] += 1;\n          if (x1 < 0.2) uvBuffer[_i212 + 2] += 1;\n          if (x2 < 0.2) uvBuffer[_i212 + 4] += 1;\n        }\n      }\n    }\n\n    function pushVertex(vertex) {\n      vertexBuffer.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    function getVertexByIndex(index, vertex) {\n      var stride = index * 3;\n      vertex.x = vertices[stride + 0];\n      vertex.y = vertices[stride + 1];\n      vertex.z = vertices[stride + 2];\n    }\n\n    function correctUVs() {\n      var a = new Vector3();\n      var b = new Vector3();\n      var c = new Vector3();\n      var centroid = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n\n      for (var _i213 = 0, j = 0; _i213 < vertexBuffer.length; _i213 += 9, j += 6) {\n        a.set(vertexBuffer[_i213 + 0], vertexBuffer[_i213 + 1], vertexBuffer[_i213 + 2]);\n        b.set(vertexBuffer[_i213 + 3], vertexBuffer[_i213 + 4], vertexBuffer[_i213 + 5]);\n        c.set(vertexBuffer[_i213 + 6], vertexBuffer[_i213 + 7], vertexBuffer[_i213 + 8]);\n        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n        centroid.copy(a).add(b).add(c).divideScalar(3);\n        var azi = azimuth(centroid);\n        correctUV(uvA, j + 0, a, azi);\n        correctUV(uvB, j + 2, b, azi);\n        correctUV(uvC, j + 4, c, azi);\n      }\n    }\n\n    function correctUV(uv, stride, vector, azimuth) {\n      if (azimuth < 0 && uv.x === 1) {\n        uvBuffer[stride] = uv.x - 1;\n      }\n\n      if (vector.x === 0 && vector.z === 0) {\n        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n      }\n    } // Angle around the Y axis, counter-clockwise when looking from above.\n\n\n    function azimuth(vector) {\n      return Math.atan2(vector.z, -vector.x);\n    } // Angle above the XZ plane.\n\n\n    function inclination(vector) {\n      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n    }\n\n    return _this66;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PolyhedronGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);\n    }\n  }]);\n\n  return PolyhedronGeometry;\n}(BufferGeometry);\n\nvar DodecahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DodecahedronGeometry, _PolyhedronGeometry);\n\n  var _super76 = _createSuper(DodecahedronGeometry);\n\n  function DodecahedronGeometry() {\n    var _this67;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DodecahedronGeometry);\n\n    var t = (1 + Math.sqrt(5)) / 2;\n    var r = 1 / t;\n    var vertices = [// (±1, ±1, ±1)\n    -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)\n    0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)\n    -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)\n    -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];\n    var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];\n    _this67 = _super76.call(this, vertices, indices, radius, detail);\n    _this67.type = \'DodecahedronGeometry\';\n    _this67.parameters = {\n      radius: radius,\n      detail: detail\n    };\n    return _this67;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DodecahedronGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new DodecahedronGeometry(data.radius, data.detail);\n    }\n  }]);\n\n  return DodecahedronGeometry;\n}(PolyhedronGeometry);\n\nvar _v0 = new Vector3();\n\nvar _v1$1 = new Vector3();\n\nvar _normal = new Vector3();\n\nvar _triangle = new Triangle();\n\nvar EdgesGeometry = /*#__PURE__*/function (_BufferGeometry7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(EdgesGeometry, _BufferGeometry7);\n\n  var _super77 = _createSuper(EdgesGeometry);\n\n  function EdgesGeometry() {\n    var _this68;\n\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var thresholdAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, EdgesGeometry);\n\n    _this68 = _super77.call(this);\n    _this68.type = \'EdgesGeometry\';\n    _this68.parameters = {\n      geometry: geometry,\n      thresholdAngle: thresholdAngle\n    };\n\n    if (geometry !== null) {\n      var precisionPoints = 4;\n      var precision = Math.pow(10, precisionPoints);\n      var thresholdDot = Math.cos(DEG2RAD * thresholdAngle);\n      var indexAttr = geometry.getIndex();\n      var positionAttr = geometry.getAttribute(\'position\');\n      var indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n      var indexArr = [0, 0, 0];\n      var vertKeys = [\'a\', \'b\', \'c\'];\n      var hashes = new Array(3);\n      var edgeData = {};\n      var vertices = [];\n\n      for (var _i214 = 0; _i214 < indexCount; _i214 += 3) {\n        if (indexAttr) {\n          indexArr[0] = indexAttr.getX(_i214);\n          indexArr[1] = indexAttr.getX(_i214 + 1);\n          indexArr[2] = indexAttr.getX(_i214 + 2);\n        } else {\n          indexArr[0] = _i214;\n          indexArr[1] = _i214 + 1;\n          indexArr[2] = _i214 + 2;\n        }\n\n        var a = _triangle.a,\n            b = _triangle.b,\n            c = _triangle.c;\n        a.fromBufferAttribute(positionAttr, indexArr[0]);\n        b.fromBufferAttribute(positionAttr, indexArr[1]);\n        c.fromBufferAttribute(positionAttr, indexArr[2]);\n\n        _triangle.getNormal(_normal); // create hashes for the edge from the vertices\n\n\n        hashes[0] = "".concat(Math.round(a.x * precision), ",").concat(Math.round(a.y * precision), ",").concat(Math.round(a.z * precision));\n        hashes[1] = "".concat(Math.round(b.x * precision), ",").concat(Math.round(b.y * precision), ",").concat(Math.round(b.z * precision));\n        hashes[2] = "".concat(Math.round(c.x * precision), ",").concat(Math.round(c.y * precision), ",").concat(Math.round(c.z * precision)); // skip degenerate triangles\n\n        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n          continue;\n        } // iterate over every edge\n\n\n        for (var j = 0; j < 3; j++) {\n          // get the first and next vertex making up the edge\n          var jNext = (j + 1) % 3;\n          var vecHash0 = hashes[j];\n          var vecHash1 = hashes[jNext];\n          var v0 = _triangle[vertKeys[j]];\n          var v1 = _triangle[vertKeys[jNext]];\n          var hash = "".concat(vecHash0, "_").concat(vecHash1);\n          var reverseHash = "".concat(vecHash1, "_").concat(vecHash0);\n\n          if (reverseHash in edgeData && edgeData[reverseHash]) {\n            // if we found a sibling edge add it into the vertex array if\n            // it meets the angle threshold and delete the edge from the map.\n            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n              vertices.push(v0.x, v0.y, v0.z);\n              vertices.push(v1.x, v1.y, v1.z);\n            }\n\n            edgeData[reverseHash] = null;\n          } else if (!(hash in edgeData)) {\n            // if we\'ve already got an edge here then skip adding a new one\n            edgeData[hash] = {\n              index0: indexArr[j],\n              index1: indexArr[jNext],\n              normal: _normal.clone()\n            };\n          }\n        }\n      } // iterate over all remaining, unmatched edges and add them to the vertex array\n\n\n      for (var key in edgeData) {\n        if (edgeData[key]) {\n          var _edgeData$key = edgeData[key],\n              index0 = _edgeData$key.index0,\n              index1 = _edgeData$key.index1;\n\n          _v0.fromBufferAttribute(positionAttr, index0);\n\n          _v1$1.fromBufferAttribute(positionAttr, index1);\n\n          vertices.push(_v0.x, _v0.y, _v0.z);\n          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);\n        }\n      }\n\n      _this68.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n    }\n\n    return _this68;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(EdgesGeometry);\n}(BufferGeometry);\n\nvar Shape = /*#__PURE__*/function (_Path) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Shape, _Path);\n\n  var _super78 = _createSuper(Shape);\n\n  function Shape(points) {\n    var _this69;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Shape);\n\n    _this69 = _super78.call(this, points);\n    _this69.uuid = generateUUID();\n    _this69.type = \'Shape\';\n    _this69.holes = [];\n    return _this69;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Shape, [{\n    key: "getPointsHoles",\n    value: function getPointsHoles(divisions) {\n      var holesPts = [];\n\n      for (var _i215 = 0, l = this.holes.length; _i215 < l; _i215++) {\n        holesPts[_i215] = this.holes[_i215].getPoints(divisions);\n      }\n\n      return holesPts;\n    } // get points of shape and holes (keypoints based on segments parameter)\n\n  }, {\n    key: "extractPoints",\n    value: function extractPoints(divisions) {\n      return {\n        shape: this.getPoints(divisions),\n        holes: this.getPointsHoles(divisions)\n      };\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Shape.prototype), "copy", this).call(this, source);\n\n      this.holes = [];\n\n      for (var _i216 = 0, l = source.holes.length; _i216 < l; _i216++) {\n        var hole = source.holes[_i216];\n        this.holes.push(hole.clone());\n      }\n\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Shape.prototype), "toJSON", this).call(this);\n\n      data.uuid = this.uuid;\n      data.holes = [];\n\n      for (var _i217 = 0, l = this.holes.length; _i217 < l; _i217++) {\n        var hole = this.holes[_i217];\n        data.holes.push(hole.toJSON());\n      }\n\n      return data;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Shape.prototype), "fromJSON", this).call(this, json);\n\n      this.uuid = json.uuid;\n      this.holes = [];\n\n      for (var _i218 = 0, l = json.holes.length; _i218 < l; _i218++) {\n        var hole = json.holes[_i218];\n        this.holes.push(new Path().fromJSON(hole));\n      }\n\n      return this;\n    }\n  }]);\n\n  return Shape;\n}(Path);\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.2)\n */\n\n\nvar Earcut = {\n  triangulate: function triangulate(data, holeIndices) {\n    var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    var outerNode = linkedList(data, 0, outerLen, dim, true);\n    var triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    var minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we\'ll use z-order curve hash later; calculate polygon bbox\n\n    if (data.length > 80 * dim) {\n      minX = maxX = data[0];\n      minY = maxY = data[1];\n\n      for (var _i219 = dim; _i219 < outerLen; _i219 += dim) {\n        x = data[_i219];\n        y = data[_i219 + 1];\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\n      invSize = Math.max(maxX - minX, maxY - minY);\n      invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n    return triangles;\n  }\n}; // create a circular doubly linked list from polygon points in the specified winding order\n\nfunction linkedList(data, start, end, dim, clockwise) {\n  var i, last;\n\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (i = start; i < end; i += dim) {\n      last = insertNode(i, data[i], data[i + 1], last);\n    }\n  } else {\n    for (i = end - dim; i >= start; i -= dim) {\n      last = insertNode(i, data[i], data[i + 1], last);\n    }\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n} // eliminate colinear or duplicate points\n\n\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  var p = start,\n      again;\n\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n} // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return; // interlink polygon nodes in z-order\n\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  var stop = ear,\n      prev,\n      next; // iterate through ears, slicing them one by one\n\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n      removeNode(ear); // skipping the next vertex leads to less sliver triangles\n\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n\n    ear = next; // if we looped through the whole remaining polygon and can\'t find any more ears\n\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn\'t work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n} // check whether a polygon node forms a valid ear with adjacent nodes\n\n\nfunction isEar(ear) {\n  var a = ear.prev,\n      b = ear,\n      c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can\'t be an ear\n  // now make sure we don\'t have other points inside the potential ear\n\n  var p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  var a = ear.prev,\n      b = ear,\n      c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can\'t be an ear\n  // triangle bbox; min & max are calculated like this for speed\n\n  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;\n\n  var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n  var p = ear.prevZ,\n      n = ear.nextZ; // look for points inside the triangle in both directions\n\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  } // look for remaining points in decreasing z-order\n\n\n  while (p && p.z >= minZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  } // look for remaining points in increasing z-order\n\n\n  while (n && n.z <= maxZ) {\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  return true;\n} // go through all polygon nodes and cure small local self-intersections\n\n\nfunction cureLocalIntersections(start, triangles, dim) {\n  var p = start;\n\n  do {\n    var a = p.prev,\n        b = p.next.next;\n\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim); // remove two nodes involved\n\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n} // try splitting polygon into two and triangulate them independently\n\n\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  var a = start;\n\n  do {\n    var b = a.next.next;\n\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        var c = splitPolygon(a, b); // filter colinear points around the cuts\n\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next); // run earcut on each half\n\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n\n      b = b.next;\n    }\n\n    a = a.next;\n  } while (a !== start);\n} // link every hole into the outer loop, producing a single-ring polygon without holes\n\n\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  var queue = [];\n  var i, len, start, end, list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX); // process holes from left to right\n\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n} // find a bridge between vertices that connects hole with an outer ring and link it\n\n\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n\n  if (outerNode) {\n    var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts\n\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n} // David Eberly\'s algorithm for finding a bridge between hole and outer polygon\n\n\nfunction findHoleBridge(hole, outerNode) {\n  var p = outerNode;\n  var hx = hole.x;\n  var hy = hole.y;\n  var qx = -Infinity,\n      m; // find a segment intersected by a ray from the hole\'s leftmost point to the left;\n  // segment\'s endpoint with lesser x will be potential connection point\n\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n      if (x <= hx && x > qx) {\n        qx = x;\n\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  var stop = m,\n      mx = m.x,\n      my = m.y;\n  var tanMin = Infinity,\n      tan;\n  p = m;\n\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n} // whether sector in vertex m contains sector in vertex p in the same coordinates\n\n\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n} // interlink polygon nodes in z-order\n\n\nfunction indexCurve(start, minX, minY, invSize) {\n  var p = start;\n\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n} // Simon Tatham\'s linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n\nfunction sortLinked(list) {\n  var i,\n      p,\n      q,\n      e,\n      tail,\n      numMerges,\n      pSize,\n      qSize,\n      inSize = 1;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n\n      qSize = inSize;\n\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n} // z-order of a point given coords and inverse of the longer side of data bbox\n\n\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n  x = (x | x << 8) & 0x00FF00FF;\n  x = (x | x << 4) & 0x0F0F0F0F;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00FF00FF;\n  y = (y | y << 4) & 0x0F0F0F0F;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n} // find the leftmost node of a polygon ring\n\n\nfunction getLeftmost(start) {\n  var p = start,\n      leftmost = start;\n\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n} // check if a point lies within a convex triangle\n\n\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // doesn\'t intersect other edges\n  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible\n  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n} // signed area of a triangle\n\n\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n} // check if two points are equal\n\n\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n} // check if two segments intersect\n\n\nfunction intersects(p1, q1, p2, q2) {\n  var o1 = sign(area(p1, q1, p2));\n  var o2 = sign(area(p1, q1, q2));\n  var o3 = sign(area(p2, q2, p1));\n  var o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n} // for collinear points p, q, r, check if point q lies on segment pr\n\n\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n} // check if a polygon diagonal intersects any polygon segments\n\n\nfunction intersectsPolygon(a, b) {\n  var p = a;\n\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n} // check if a polygon diagonal is locally inside the polygon\n\n\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n} // check if the middle point of a polygon diagonal is inside the polygon\n\n\nfunction middleInside(a, b) {\n  var p = a,\n      inside = false;\n  var px = (a.x + b.x) / 2,\n      py = (a.y + b.y) / 2;\n\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n\nfunction splitPolygon(a, b) {\n  var a2 = new Node(a.i, a.x, a.y),\n      b2 = new Node(b.i, b.x, b.y),\n      an = a.next,\n      bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n} // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n\nfunction insertNode(i, x, y, last) {\n  var p = new Node(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n  // vertex index in coordinates array\n  this.i = i; // vertex coordinates\n\n  this.x = x;\n  this.y = y; // previous and next vertex nodes in a polygon ring\n\n  this.prev = null;\n  this.next = null; // z-order curve value\n\n  this.z = null; // previous and next nodes in z-order\n\n  this.prevZ = null;\n  this.nextZ = null; // indicates whether this is a steiner point\n\n  this.steiner = false;\n}\n\nfunction signedArea(data, start, end, dim) {\n  var sum = 0;\n\n  for (var _i220 = start, j = end - dim; _i220 < end; _i220 += dim) {\n    sum += (data[j] - data[_i220]) * (data[_i220 + 1] + data[j + 1]);\n    j = _i220;\n  }\n\n  return sum;\n}\n\nvar ShapeUtils = /*#__PURE__*/function () {\n  function ShapeUtils() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ShapeUtils);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ShapeUtils, null, [{\n    key: "area",\n    value: // calculate area of the contour polygon\n    function area(contour) {\n      var n = contour.length;\n      var a = 0.0;\n\n      for (var p = n - 1, q = 0; q < n; p = q++) {\n        a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n      }\n\n      return a * 0.5;\n    }\n  }, {\n    key: "isClockWise",\n    value: function isClockWise(pts) {\n      return ShapeUtils.area(pts) < 0;\n    }\n  }, {\n    key: "triangulateShape",\n    value: function triangulateShape(contour, holes) {\n      var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\n      var holeIndices = []; // array of hole indices\n\n      var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n      removeDupEndPts(contour);\n      addContour(vertices, contour); //\n\n      var holeIndex = contour.length;\n      holes.forEach(removeDupEndPts);\n\n      for (var _i221 = 0; _i221 < holes.length; _i221++) {\n        holeIndices.push(holeIndex);\n        holeIndex += holes[_i221].length;\n        addContour(vertices, holes[_i221]);\n      } //\n\n\n      var triangles = Earcut.triangulate(vertices, holeIndices); //\n\n      for (var _i222 = 0; _i222 < triangles.length; _i222 += 3) {\n        faces.push(triangles.slice(_i222, _i222 + 3));\n      }\n\n      return faces;\n    }\n  }]);\n\n  return ShapeUtils;\n}();\n\nfunction removeDupEndPts(points) {\n  var l = points.length;\n\n  if (l > 2 && points[l - 1].equals(points[0])) {\n    points.pop();\n  }\n}\n\nfunction addContour(vertices, contour) {\n  for (var _i223 = 0; _i223 < contour.length; _i223++) {\n    vertices.push(contour[_i223].x);\n    vertices.push(contour[_i223].y);\n  }\n}\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n\nvar ExtrudeGeometry = /*#__PURE__*/function (_BufferGeometry8) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ExtrudeGeometry, _BufferGeometry8);\n\n  var _super79 = _createSuper(ExtrudeGeometry);\n\n  function ExtrudeGeometry() {\n    var _this70;\n\n    var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ExtrudeGeometry);\n\n    _this70 = _super79.call(this);\n    _this70.type = \'ExtrudeGeometry\';\n    _this70.parameters = {\n      shapes: shapes,\n      options: options\n    };\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\n\n    var scope = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this70);\n\n    var verticesArray = [];\n    var uvArray = [];\n\n    for (var _i224 = 0, l = shapes.length; _i224 < l; _i224++) {\n      var shape = shapes[_i224];\n      addShape(shape);\n    } // build geometry\n\n\n    _this70.setAttribute(\'position\', new Float32BufferAttribute(verticesArray, 3));\n\n    _this70.setAttribute(\'uv\', new Float32BufferAttribute(uvArray, 2));\n\n    _this70.computeVertexNormals(); // functions\n\n\n    function addShape(shape) {\n      var placeholder = []; // options\n\n      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n      var steps = options.steps !== undefined ? options.steps : 1;\n      var depth = options.depth !== undefined ? options.depth : 1;\n      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n      var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n      var extrudePath = options.extrudePath;\n      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options\n\n      if (options.amount !== undefined) {\n        console.warn(\'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.\');\n        depth = options.amount;\n      } //\n\n\n      var extrudePts,\n          extrudeByPath = false;\n      var splineTube, binormal, normal, position2;\n\n      if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n        extrudeByPath = true;\n        bevelEnabled = false; // bevels not supported for path extrusion\n        // SETUP TNB variables\n        // TODO1 - have a .isClosed in spline?\n\n        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, \'splineTube\', splineTube.normals.length, \'steps\', steps, \'extrudePts\', extrudePts.length);\n\n        binormal = new Vector3();\n        normal = new Vector3();\n        position2 = new Vector3();\n      } // Safeguards if bevels are not enabled\n\n\n      if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n        bevelOffset = 0;\n      } // Variables initialization\n\n\n      var shapePoints = shape.extractPoints(curveSegments);\n      var vertices = shapePoints.shape;\n      var holes = shapePoints.holes;\n      var reverse = !ShapeUtils.isClockWise(vertices);\n\n      if (reverse) {\n        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n        for (var h = 0, hl = holes.length; h < hl; h++) {\n          var ahole = holes[h];\n\n          if (ShapeUtils.isClockWise(ahole)) {\n            holes[h] = ahole.reverse();\n          }\n        }\n      }\n\n      var faces = ShapeUtils.triangulateShape(vertices, holes);\n      /* Vertices */\n\n      var contour = vertices; // vertices has all points but contour has only points of circumference\n\n      for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {\n        var _ahole = holes[_h];\n        vertices = vertices.concat(_ahole);\n      }\n\n      function scalePt2(pt, vec, size) {\n        if (!vec) console.error(\'THREE.ExtrudeGeometry: vec does not exist\');\n        return vec.clone().multiplyScalar(size).add(pt);\n      }\n\n      var vlen = vertices.length,\n          flen = faces.length; // Find directions for point movement\n\n      function getBevelVec(inPt, inPrev, inNext) {\n        // computes for inPt the corresponding point inPt\' on a new contour\n        //   shifted by 1 unit (length of normalized vector) to the left\n        // if we walk along contour clockwise, this new contour is outside the old one\n        //\n        // inPt\' is the intersection of the two lines parallel to the two\n        //  adjacent edges of inPt at a distance of 1 unit on the left side.\n        var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n        // good reading for geometry algorithms (here: line-line intersection)\n        // http://geomalgorithms.com/a05-_intersect-1.html\n\n        var v_prev_x = inPt.x - inPrev.x,\n            v_prev_y = inPt.y - inPrev.y;\n        var v_next_x = inNext.x - inPt.x,\n            v_next_y = inNext.y - inPt.y;\n        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n        var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n        if (Math.abs(collinear0) > Number.EPSILON) {\n          // not collinear\n          // length of vectors for normalizing\n          var v_prev_len = Math.sqrt(v_prev_lensq);\n          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n          var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n          var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n          var ptNextShift_x = inNext.x - v_next_y / v_next_len;\n          var ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don\'t normalize!, otherwise sharp corners become ugly\n          //  but prevent crazy spikes\n\n          var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n          if (v_trans_lensq <= 2) {\n            return new Vector2(v_trans_x, v_trans_y);\n          } else {\n            shrink_by = Math.sqrt(v_trans_lensq / 2);\n          }\n        } else {\n          // handle special case of collinear edges\n          var direction_eq = false; // assumes: opposite\n\n          if (v_prev_x > Number.EPSILON) {\n            if (v_next_x > Number.EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (v_prev_x < -Number.EPSILON) {\n              if (v_next_x < -Number.EPSILON) {\n                direction_eq = true;\n              }\n            } else {\n              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n                direction_eq = true;\n              }\n            }\n          }\n\n          if (direction_eq) {\n            // console.log("Warning: lines are a straight sequence");\n            v_trans_x = -v_prev_y;\n            v_trans_y = v_prev_x;\n            shrink_by = Math.sqrt(v_prev_lensq);\n          } else {\n            // console.log("Warning: lines are a straight spike");\n            v_trans_x = v_prev_x;\n            v_trans_y = v_prev_y;\n            shrink_by = Math.sqrt(v_prev_lensq / 2);\n          }\n        }\n\n        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n      }\n\n      var contourMovements = [];\n\n      for (var _i225 = 0, il = contour.length, j = il - 1, k = _i225 + 1; _i225 < il; _i225++, j++, k++) {\n        if (j === il) j = 0;\n        if (k === il) k = 0; //  (j)---(i)---(k)\n        // console.log(\'i,j,k\', i, j , k)\n\n        contourMovements[_i225] = getBevelVec(contour[_i225], contour[j], contour[k]);\n      }\n\n      var holesMovements = [];\n      var oneHoleMovements,\n          verticesMovements = contourMovements.concat();\n\n      for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {\n        var _ahole2 = holes[_h2];\n        oneHoleMovements = [];\n\n        for (var _i226 = 0, _il13 = _ahole2.length, _j8 = _il13 - 1, _k = _i226 + 1; _i226 < _il13; _i226++, _j8++, _k++) {\n          if (_j8 === _il13) _j8 = 0;\n          if (_k === _il13) _k = 0; //  (j)---(i)---(k)\n\n          oneHoleMovements[_i226] = getBevelVec(_ahole2[_i226], _ahole2[_j8], _ahole2[_k]);\n        }\n\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n      } // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n      for (var b = 0; b < bevelSegments; b++) {\n        //for ( b = bevelSegments; b > 0; b -- ) {\n        var t = b / bevelSegments;\n        var z = bevelThickness * Math.cos(t * Math.PI / 2);\n\n        var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n\n        for (var _i227 = 0, _il14 = contour.length; _i227 < _il14; _i227++) {\n          var vert = scalePt2(contour[_i227], contourMovements[_i227], _bs);\n          v(vert.x, vert.y, -z);\n        } // expand holes\n\n\n        for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {\n          var _ahole3 = holes[_h3];\n          oneHoleMovements = holesMovements[_h3];\n\n          for (var _i228 = 0, _il15 = _ahole3.length; _i228 < _il15; _i228++) {\n            var _vert = scalePt2(_ahole3[_i228], oneHoleMovements[_i228], _bs);\n\n            v(_vert.x, _vert.y, -z);\n          }\n        }\n      }\n\n      var bs = bevelSize + bevelOffset; // Back facing vertices\n\n      for (var _i229 = 0; _i229 < vlen; _i229++) {\n        var _vert2 = bevelEnabled ? scalePt2(vertices[_i229], verticesMovements[_i229], bs) : vertices[_i229];\n\n        if (!extrudeByPath) {\n          v(_vert2.x, _vert2.y, 0);\n        } else {\n          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n          normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);\n          binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);\n          position2.copy(extrudePts[0]).add(normal).add(binormal);\n          v(position2.x, position2.y, position2.z);\n        }\n      } // Add stepped vertices...\n      // Including front facing vertices\n\n\n      for (var s = 1; s <= steps; s++) {\n        for (var _i230 = 0; _i230 < vlen; _i230++) {\n          var _vert3 = bevelEnabled ? scalePt2(vertices[_i230], verticesMovements[_i230], bs) : vertices[_i230];\n\n          if (!extrudeByPath) {\n            v(_vert3.x, _vert3.y, depth / steps * s);\n          } else {\n            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n            normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n          }\n        }\n      } // Add bevel segments planes\n      //for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n      for (var _b5 = bevelSegments - 1; _b5 >= 0; _b5--) {\n        var _t = _b5 / bevelSegments;\n\n        var _z2 = bevelThickness * Math.cos(_t * Math.PI / 2);\n\n        var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset; // contract shape\n\n\n        for (var _i231 = 0, _il16 = contour.length; _i231 < _il16; _i231++) {\n          var _vert4 = scalePt2(contour[_i231], contourMovements[_i231], _bs2);\n\n          v(_vert4.x, _vert4.y, depth + _z2);\n        } // expand holes\n\n\n        for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {\n          var _ahole4 = holes[_h4];\n          oneHoleMovements = holesMovements[_h4];\n\n          for (var _i232 = 0, _il17 = _ahole4.length; _i232 < _il17; _i232++) {\n            var _vert5 = scalePt2(_ahole4[_i232], oneHoleMovements[_i232], _bs2);\n\n            if (!extrudeByPath) {\n              v(_vert5.x, _vert5.y, depth + _z2);\n            } else {\n              v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z2);\n            }\n          }\n        }\n      }\n      /* Faces */\n      // Top and bottom faces\n\n\n      buildLidFaces(); // Sides faces\n\n      buildSideFaces(); /////  Internal functions\n\n      function buildLidFaces() {\n        var start = verticesArray.length / 3;\n\n        if (bevelEnabled) {\n          var layer = 0; // steps + 1\n\n          var offset = vlen * layer; // Bottom faces\n\n          for (var _i233 = 0; _i233 < flen; _i233++) {\n            var face = faces[_i233];\n            f3(face[2] + offset, face[1] + offset, face[0] + offset);\n          }\n\n          layer = steps + bevelSegments * 2;\n          offset = vlen * layer; // Top faces\n\n          for (var _i234 = 0; _i234 < flen; _i234++) {\n            var _face = faces[_i234];\n            f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);\n          }\n        } else {\n          // Bottom faces\n          for (var _i235 = 0; _i235 < flen; _i235++) {\n            var _face2 = faces[_i235];\n            f3(_face2[2], _face2[1], _face2[0]);\n          } // Top faces\n\n\n          for (var _i236 = 0; _i236 < flen; _i236++) {\n            var _face3 = faces[_i236];\n            f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);\n          }\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 0);\n      } // Create faces for the z-sides of the shape\n\n\n      function buildSideFaces() {\n        var start = verticesArray.length / 3;\n        var layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n\n        for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {\n          var _ahole5 = holes[_h5];\n          sidewalls(_ahole5, layeroffset); //, true\n\n          layeroffset += _ahole5.length;\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 1);\n      }\n\n      function sidewalls(contour, layeroffset) {\n        var i = contour.length;\n\n        while (--i >= 0) {\n          var _j9 = i;\n\n          var _k2 = i - 1;\n\n          if (_k2 < 0) _k2 = contour.length - 1; //console.log(\'b\', i,j, i-1, k,vertices.length);\n\n          for (var _s4 = 0, sl = steps + bevelSegments * 2; _s4 < sl; _s4++) {\n            var slen1 = vlen * _s4;\n            var slen2 = vlen * (_s4 + 1);\n\n            var a = layeroffset + _j9 + slen1,\n                _b6 = layeroffset + _k2 + slen1,\n                c = layeroffset + _k2 + slen2,\n                d = layeroffset + _j9 + slen2;\n\n            f4(a, _b6, c, d);\n          }\n        }\n      }\n\n      function v(x, y, z) {\n        placeholder.push(x);\n        placeholder.push(y);\n        placeholder.push(z);\n      }\n\n      function f3(a, b, c) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(c);\n        var nextIndex = verticesArray.length / 3;\n        var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n      }\n\n      function f4(a, b, c, d) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(d);\n        addVertex(b);\n        addVertex(c);\n        addVertex(d);\n        var nextIndex = verticesArray.length / 3;\n        var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[3]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n        addUV(uvs[3]);\n      }\n\n      function addVertex(index) {\n        verticesArray.push(placeholder[index * 3 + 0]);\n        verticesArray.push(placeholder[index * 3 + 1]);\n        verticesArray.push(placeholder[index * 3 + 2]);\n      }\n\n      function addUV(vector2) {\n        uvArray.push(vector2.x);\n        uvArray.push(vector2.y);\n      }\n    }\n\n    return _this70;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ExtrudeGeometry, [{\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(ExtrudeGeometry.prototype), "toJSON", this).call(this);\n\n      var shapes = this.parameters.shapes;\n      var options = this.parameters.options;\n      return toJSON$1(shapes, options, data);\n    }\n  }], [{\n    key: "fromJSON",\n    value: function fromJSON(data, shapes) {\n      var geometryShapes = [];\n\n      for (var j = 0, jl = data.shapes.length; j < jl; j++) {\n        var shape = shapes[data.shapes[j]];\n        geometryShapes.push(shape);\n      }\n\n      var extrudePath = data.options.extrudePath;\n\n      if (extrudePath !== undefined) {\n        data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n      }\n\n      return new ExtrudeGeometry(geometryShapes, data.options);\n    }\n  }]);\n\n  return ExtrudeGeometry;\n}(BufferGeometry);\n\nvar WorldUVGenerator = {\n  generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {\n    var a_x = vertices[indexA * 3];\n    var a_y = vertices[indexA * 3 + 1];\n    var b_x = vertices[indexB * 3];\n    var b_y = vertices[indexB * 3 + 1];\n    var c_x = vertices[indexC * 3];\n    var c_y = vertices[indexC * 3 + 1];\n    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n  },\n  generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {\n    var a_x = vertices[indexA * 3];\n    var a_y = vertices[indexA * 3 + 1];\n    var a_z = vertices[indexA * 3 + 2];\n    var b_x = vertices[indexB * 3];\n    var b_y = vertices[indexB * 3 + 1];\n    var b_z = vertices[indexB * 3 + 2];\n    var c_x = vertices[indexC * 3];\n    var c_y = vertices[indexC * 3 + 1];\n    var c_z = vertices[indexC * 3 + 2];\n    var d_x = vertices[indexD * 3];\n    var d_y = vertices[indexD * 3 + 1];\n    var d_z = vertices[indexD * 3 + 2];\n\n    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n    } else {\n      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n    }\n  }\n};\n\nfunction toJSON$1(shapes, options, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (var _i237 = 0, l = shapes.length; _i237 < l; _i237++) {\n      var shape = shapes[_i237];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  data.options = Object.assign({}, options);\n  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\n\nvar IcosahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(IcosahedronGeometry, _PolyhedronGeometry2);\n\n  var _super80 = _createSuper(IcosahedronGeometry);\n\n  function IcosahedronGeometry() {\n    var _this71;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, IcosahedronGeometry);\n\n    var t = (1 + Math.sqrt(5)) / 2;\n    var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];\n    var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];\n    _this71 = _super80.call(this, vertices, indices, radius, detail);\n    _this71.type = \'IcosahedronGeometry\';\n    _this71.parameters = {\n      radius: radius,\n      detail: detail\n    };\n    return _this71;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(IcosahedronGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new IcosahedronGeometry(data.radius, data.detail);\n    }\n  }]);\n\n  return IcosahedronGeometry;\n}(PolyhedronGeometry);\n\nvar OctahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(OctahedronGeometry, _PolyhedronGeometry3);\n\n  var _super81 = _createSuper(OctahedronGeometry);\n\n  function OctahedronGeometry() {\n    var _this72;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, OctahedronGeometry);\n\n    var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];\n    var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];\n    _this72 = _super81.call(this, vertices, indices, radius, detail);\n    _this72.type = \'OctahedronGeometry\';\n    _this72.parameters = {\n      radius: radius,\n      detail: detail\n    };\n    return _this72;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(OctahedronGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new OctahedronGeometry(data.radius, data.detail);\n    }\n  }]);\n\n  return OctahedronGeometry;\n}(PolyhedronGeometry);\n\nvar RingGeometry = /*#__PURE__*/function (_BufferGeometry9) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(RingGeometry, _BufferGeometry9);\n\n  var _super82 = _createSuper(RingGeometry);\n\n  function RingGeometry() {\n    var _this73;\n\n    var innerRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;\n    var outerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var thetaSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    var phiSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var thetaStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var thetaLength = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, RingGeometry);\n\n    _this73 = _super82.call(this);\n    _this73.type = \'RingGeometry\';\n    _this73.parameters = {\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      thetaSegments: thetaSegments,\n      phiSegments: phiSegments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    thetaSegments = Math.max(3, thetaSegments);\n    phiSegments = Math.max(1, phiSegments); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // some helper variables\n\n    var radius = innerRadius;\n    var radiusStep = (outerRadius - innerRadius) / phiSegments;\n    var vertex = new Vector3();\n    var uv = new Vector2(); // generate vertices, normals and uvs\n\n    for (var j = 0; j <= phiSegments; j++) {\n      for (var _i238 = 0; _i238 <= thetaSegments; _i238++) {\n        // values are generate from the inside of the ring to the outside\n        var segment = thetaStart + _i238 / thetaSegments * thetaLength; // vertex\n\n        vertex.x = radius * Math.cos(segment);\n        vertex.y = radius * Math.sin(segment);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normals.push(0, 0, 1); // uv\n\n        uv.x = (vertex.x / outerRadius + 1) / 2;\n        uv.y = (vertex.y / outerRadius + 1) / 2;\n        uvs.push(uv.x, uv.y);\n      } // increase the radius for next row of vertices\n\n\n      radius += radiusStep;\n    } // indices\n\n\n    for (var _j10 = 0; _j10 < phiSegments; _j10++) {\n      var thetaSegmentLevel = _j10 * (thetaSegments + 1);\n\n      for (var _i239 = 0; _i239 < thetaSegments; _i239++) {\n        var _segment = _i239 + thetaSegmentLevel;\n\n        var a = _segment;\n        var b = _segment + thetaSegments + 1;\n        var c = _segment + thetaSegments + 2;\n        var d = _segment + 1; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    _this73.setIndex(indices);\n\n    _this73.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this73.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this73.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2));\n\n    return _this73;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(RingGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n    }\n  }]);\n\n  return RingGeometry;\n}(BufferGeometry);\n\nvar ShapeGeometry = /*#__PURE__*/function (_BufferGeometry10) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ShapeGeometry, _BufferGeometry10);\n\n  var _super83 = _createSuper(ShapeGeometry);\n\n  function ShapeGeometry() {\n    var _this74;\n\n    var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);\n    var curveSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ShapeGeometry);\n\n    _this74 = _super83.call(this);\n    _this74.type = \'ShapeGeometry\';\n    _this74.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    }; // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var groupStart = 0;\n    var groupCount = 0; // allow single and array values for "shapes" parameter\n\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (var _i240 = 0; _i240 < shapes.length; _i240++) {\n        addShape(shapes[_i240]);\n\n        _this74.addGroup(groupStart, groupCount, _i240); // enables MultiMaterial support\n\n\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    } // build geometry\n\n\n    _this74.setIndex(indices);\n\n    _this74.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this74.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this74.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n\n    function addShape(shape) {\n      var indexOffset = vertices.length / 3;\n      var points = shape.extractPoints(curveSegments);\n      var shapeVertices = points.shape;\n      var shapeHoles = points.holes; // check direction of vertices\n\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n\n      for (var _i241 = 0, l = shapeHoles.length; _i241 < l; _i241++) {\n        var shapeHole = shapeHoles[_i241];\n\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[_i241] = shapeHole.reverse();\n        }\n      }\n\n      var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n      for (var _i242 = 0, _l8 = shapeHoles.length; _i242 < _l8; _i242++) {\n        var _shapeHole = shapeHoles[_i242];\n        shapeVertices = shapeVertices.concat(_shapeHole);\n      } // vertices, normals, uvs\n\n\n      for (var _i243 = 0, _l9 = shapeVertices.length; _i243 < _l9; _i243++) {\n        var _vertex = shapeVertices[_i243];\n        vertices.push(_vertex.x, _vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(_vertex.x, _vertex.y); // world uvs\n      } // incides\n\n\n      for (var _i244 = 0, _l10 = faces.length; _i244 < _l10; _i244++) {\n        var face = faces[_i244];\n        var a = face[0] + indexOffset;\n        var b = face[1] + indexOffset;\n        var c = face[2] + indexOffset;\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n\n    return _this74;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ShapeGeometry, [{\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(ShapeGeometry.prototype), "toJSON", this).call(this);\n\n      var shapes = this.parameters.shapes;\n      return _toJSON(shapes, data);\n    }\n  }], [{\n    key: "fromJSON",\n    value: function fromJSON(data, shapes) {\n      var geometryShapes = [];\n\n      for (var j = 0, jl = data.shapes.length; j < jl; j++) {\n        var shape = shapes[data.shapes[j]];\n        geometryShapes.push(shape);\n      }\n\n      return new ShapeGeometry(geometryShapes, data.curveSegments);\n    }\n  }]);\n\n  return ShapeGeometry;\n}(BufferGeometry);\n\nfunction _toJSON(shapes, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (var _i245 = 0, l = shapes.length; _i245 < l; _i245++) {\n      var shape = shapes[_i245];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  return data;\n}\n\nvar SphereGeometry = /*#__PURE__*/function (_BufferGeometry11) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(SphereGeometry, _BufferGeometry11);\n\n  var _super84 = _createSuper(SphereGeometry);\n\n  function SphereGeometry() {\n    var _this75;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    var heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;\n    var phiStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var phiLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;\n    var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SphereGeometry);\n\n    _this75 = _super84.call(this);\n    _this75.type = \'SphereGeometry\';\n    _this75.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    var index = 0;\n    var grid = [];\n    var vertex = new Vector3();\n    var normal = new Vector3(); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // generate vertices, normals and uvs\n\n    for (var iy = 0; iy <= heightSegments; iy++) {\n      var verticesRow = [];\n      var v = iy / heightSegments; // special case for the poles\n\n      var uOffset = 0;\n\n      if (iy == 0 && thetaStart == 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy == heightSegments && thetaEnd == Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n\n      for (var ix = 0; ix <= widthSegments; ix++) {\n        var u = ix / widthSegments; // vertex\n\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normal.copy(vertex).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n      }\n\n      grid.push(verticesRow);\n    } // indices\n\n\n    for (var _iy3 = 0; _iy3 < heightSegments; _iy3++) {\n      for (var _ix3 = 0; _ix3 < widthSegments; _ix3++) {\n        var a = grid[_iy3][_ix3 + 1];\n        var b = grid[_iy3][_ix3];\n        var c = grid[_iy3 + 1][_ix3];\n        var d = grid[_iy3 + 1][_ix3 + 1];\n        if (_iy3 !== 0 || thetaStart > 0) indices.push(a, b, d);\n        if (_iy3 !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    _this75.setIndex(indices);\n\n    _this75.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this75.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this75.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2));\n\n    return _this75;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SphereGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n    }\n  }]);\n\n  return SphereGeometry;\n}(BufferGeometry);\n\nvar TetrahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(TetrahedronGeometry, _PolyhedronGeometry4);\n\n  var _super85 = _createSuper(TetrahedronGeometry);\n\n  function TetrahedronGeometry() {\n    var _this76;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, TetrahedronGeometry);\n\n    var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];\n    var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];\n    _this76 = _super85.call(this, vertices, indices, radius, detail);\n    _this76.type = \'TetrahedronGeometry\';\n    _this76.parameters = {\n      radius: radius,\n      detail: detail\n    };\n    return _this76;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(TetrahedronGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new TetrahedronGeometry(data.radius, data.detail);\n    }\n  }]);\n\n  return TetrahedronGeometry;\n}(PolyhedronGeometry);\n\nvar TorusGeometry = /*#__PURE__*/function (_BufferGeometry12) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(TorusGeometry, _BufferGeometry12);\n\n  var _super86 = _createSuper(TorusGeometry);\n\n  function TorusGeometry() {\n    var _this77;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;\n    var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    var tubularSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 6;\n    var arc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, TorusGeometry);\n\n    _this77 = _super86.call(this);\n    _this77.type = \'TorusGeometry\';\n    _this77.parameters = {\n      radius: radius,\n      tube: tube,\n      radialSegments: radialSegments,\n      tubularSegments: tubularSegments,\n      arc: arc\n    };\n    radialSegments = Math.floor(radialSegments);\n    tubularSegments = Math.floor(tubularSegments); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var center = new Vector3();\n    var vertex = new Vector3();\n    var normal = new Vector3(); // generate vertices, normals and uvs\n\n    for (var j = 0; j <= radialSegments; j++) {\n      for (var _i246 = 0; _i246 <= tubularSegments; _i246++) {\n        var u = _i246 / tubularSegments * arc;\n        var v = j / radialSegments * Math.PI * 2; // vertex\n\n        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n        vertex.z = tube * Math.sin(v);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        center.x = radius * Math.cos(u);\n        center.y = radius * Math.sin(u);\n        normal.subVectors(vertex, center).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(_i246 / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    } // generate indices\n\n\n    for (var _j11 = 1; _j11 <= radialSegments; _j11++) {\n      for (var _i247 = 1; _i247 <= tubularSegments; _i247++) {\n        // indices\n        var a = (tubularSegments + 1) * _j11 + _i247 - 1;\n        var b = (tubularSegments + 1) * (_j11 - 1) + _i247 - 1;\n        var c = (tubularSegments + 1) * (_j11 - 1) + _i247;\n        var d = (tubularSegments + 1) * _j11 + _i247; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    _this77.setIndex(indices);\n\n    _this77.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this77.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this77.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2));\n\n    return _this77;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(TorusGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\n    }\n  }]);\n\n  return TorusGeometry;\n}(BufferGeometry);\n\nvar TorusKnotGeometry = /*#__PURE__*/function (_BufferGeometry13) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(TorusKnotGeometry, _BufferGeometry13);\n\n  var _super87 = _createSuper(TorusKnotGeometry);\n\n  function TorusKnotGeometry() {\n    var _this78;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;\n    var tubularSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 64;\n    var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n    var p = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;\n    var q = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, TorusKnotGeometry);\n\n    _this78 = _super87.call(this);\n    _this78.type = \'TorusKnotGeometry\';\n    _this78.parameters = {\n      radius: radius,\n      tube: tube,\n      tubularSegments: tubularSegments,\n      radialSegments: radialSegments,\n      p: p,\n      q: q\n    };\n    tubularSegments = Math.floor(tubularSegments);\n    radialSegments = Math.floor(radialSegments); // buffers\n\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = []; // helper variables\n\n    var vertex = new Vector3();\n    var normal = new Vector3();\n    var P1 = new Vector3();\n    var P2 = new Vector3();\n    var B = new Vector3();\n    var T = new Vector3();\n    var N = new Vector3(); // generate vertices, normals and uvs\n\n    for (var _i248 = 0; _i248 <= tubularSegments; ++_i248) {\n      // the radian "u" is used to calculate the position on the torus curve of the current tubular segment\n      var u = _i248 / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n      // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions\n\n      calculatePositionOnCurve(u, p, q, radius, P1);\n      calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis\n\n      T.subVectors(P2, P1);\n      N.addVectors(P2, P1);\n      B.crossVectors(T, N);\n      N.crossVectors(B, T); // normalize B, N. T can be ignored, we don\'t use it\n\n      B.normalize();\n      N.normalize();\n\n      for (var j = 0; j <= radialSegments; ++j) {\n        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n        var v = j / radialSegments * Math.PI * 2;\n        var cx = -tube * Math.cos(v);\n        var cy = tube * Math.sin(v); // now calculate the final vertex position.\n        // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n        vertex.x = P1.x + (cx * N.x + cy * B.x);\n        vertex.y = P1.y + (cx * N.y + cy * B.y);\n        vertex.z = P1.z + (cx * N.z + cy * B.z);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n        normal.subVectors(vertex, P1).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(_i248 / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    } // generate indices\n\n\n    for (var _j12 = 1; _j12 <= tubularSegments; _j12++) {\n      for (var _i249 = 1; _i249 <= radialSegments; _i249++) {\n        // indices\n        var a = (radialSegments + 1) * (_j12 - 1) + (_i249 - 1);\n        var b = (radialSegments + 1) * _j12 + (_i249 - 1);\n        var c = (radialSegments + 1) * _j12 + _i249;\n        var d = (radialSegments + 1) * (_j12 - 1) + _i249; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    _this78.setIndex(indices);\n\n    _this78.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this78.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this78.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve\n\n\n    function calculatePositionOnCurve(u, p, q, radius, position) {\n      var cu = Math.cos(u);\n      var su = Math.sin(u);\n      var quOverP = q / p * u;\n      var cs = Math.cos(quOverP);\n      position.x = radius * (2 + cs) * 0.5 * cu;\n      position.y = radius * (2 + cs) * su * 0.5;\n      position.z = radius * Math.sin(quOverP) * 0.5;\n    }\n\n    return _this78;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(TorusKnotGeometry, null, [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\n    }\n  }]);\n\n  return TorusKnotGeometry;\n}(BufferGeometry);\n\nvar TubeGeometry = /*#__PURE__*/function (_BufferGeometry14) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(TubeGeometry, _BufferGeometry14);\n\n  var _super88 = _createSuper(TubeGeometry);\n\n  function TubeGeometry() {\n    var _this79;\n\n    var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0));\n    var tubularSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n    var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;\n    var closed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, TubeGeometry);\n\n    _this79 = _super88.call(this);\n    _this79.type = \'TubeGeometry\';\n    _this79.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed\n    };\n    var frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals\n\n    _this79.tangents = frames.tangents;\n    _this79.normals = frames.normals;\n    _this79.binormals = frames.binormals; // helper variables\n\n    var vertex = new Vector3();\n    var normal = new Vector3();\n    var uv = new Vector2();\n    var P = new Vector3(); // buffer\n\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n    var indices = []; // create buffer data\n\n    generateBufferData(); // build geometry\n\n    _this79.setIndex(indices);\n\n    _this79.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n\n    _this79.setAttribute(\'normal\', new Float32BufferAttribute(normals, 3));\n\n    _this79.setAttribute(\'uv\', new Float32BufferAttribute(uvs, 2)); // functions\n\n\n    function generateBufferData() {\n      for (var _i250 = 0; _i250 < tubularSegments; _i250++) {\n        generateSegment(_i250);\n      } // if the geometry is not closed, generate the last row of vertices and normals\n      // at the regular position on the given path\n      //\n      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\n      generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.\n      // this makes it easy compute correct values for closed geometries\n\n      generateUVs(); // finally create faces\n\n      generateIndices();\n    }\n\n    function generateSegment(i) {\n      // we use getPointAt to sample evenly distributed points from the given path\n      P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal\n\n      var N = frames.normals[i];\n      var B = frames.binormals[i]; // generate normals and vertices for the current segment\n\n      for (var j = 0; j <= radialSegments; j++) {\n        var v = j / radialSegments * Math.PI * 2;\n        var sin = Math.sin(v);\n        var cos = -Math.cos(v); // normal\n\n        normal.x = cos * N.x + sin * B.x;\n        normal.y = cos * N.y + sin * B.y;\n        normal.z = cos * N.z + sin * B.z;\n        normal.normalize();\n        normals.push(normal.x, normal.y, normal.z); // vertex\n\n        vertex.x = P.x + radius * normal.x;\n        vertex.y = P.y + radius * normal.y;\n        vertex.z = P.z + radius * normal.z;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    }\n\n    function generateIndices() {\n      for (var j = 1; j <= tubularSegments; j++) {\n        for (var _i251 = 1; _i251 <= radialSegments; _i251++) {\n          var a = (radialSegments + 1) * (j - 1) + (_i251 - 1);\n          var b = (radialSegments + 1) * j + (_i251 - 1);\n          var c = (radialSegments + 1) * j + _i251;\n          var d = (radialSegments + 1) * (j - 1) + _i251; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n    }\n\n    function generateUVs() {\n      for (var _i252 = 0; _i252 <= tubularSegments; _i252++) {\n        for (var j = 0; j <= radialSegments; j++) {\n          uv.x = _i252 / tubularSegments;\n          uv.y = j / radialSegments;\n          uvs.push(uv.x, uv.y);\n        }\n      }\n    }\n\n    return _this79;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(TubeGeometry, [{\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(TubeGeometry.prototype), "toJSON", this).call(this);\n\n      data.path = this.parameters.path.toJSON();\n      return data;\n    }\n  }], [{\n    key: "fromJSON",\n    value: function fromJSON(data) {\n      // This only works for built-in curves (e.g. CatmullRomCurve3).\n      // User defined curves or instances of CurvePath will not be deserialized.\n      return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\n    }\n  }]);\n\n  return TubeGeometry;\n}(BufferGeometry);\n\nvar WireframeGeometry = /*#__PURE__*/function (_BufferGeometry15) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WireframeGeometry, _BufferGeometry15);\n\n  var _super89 = _createSuper(WireframeGeometry);\n\n  function WireframeGeometry() {\n    var _this80;\n\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WireframeGeometry);\n\n    _this80 = _super89.call(this);\n    _this80.type = \'WireframeGeometry\';\n    _this80.parameters = {\n      geometry: geometry\n    };\n\n    if (geometry !== null) {\n      // buffer\n      var vertices = [];\n      var edges = new Set(); // helper variables\n\n      var start = new Vector3();\n      var end = new Vector3();\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        var position = geometry.attributes.position;\n        var indices = geometry.index;\n        var groups = geometry.groups;\n\n        if (groups.length === 0) {\n          groups = [{\n            start: 0,\n            count: indices.count,\n            materialIndex: 0\n          }];\n        } // create a data structure that contains all edges without duplicates\n\n\n        for (var o = 0, ol = groups.length; o < ol; ++o) {\n          var group = groups[o];\n          var groupStart = group.start;\n          var groupCount = group.count;\n\n          for (var _i253 = groupStart, l = groupStart + groupCount; _i253 < l; _i253 += 3) {\n            for (var j = 0; j < 3; j++) {\n              var index1 = indices.getX(_i253 + j);\n              var index2 = indices.getX(_i253 + (j + 1) % 3);\n              start.fromBufferAttribute(position, index1);\n              end.fromBufferAttribute(position, index2);\n\n              if (isUniqueEdge(start, end, edges) === true) {\n                vertices.push(start.x, start.y, start.z);\n                vertices.push(end.x, end.y, end.z);\n              }\n            }\n          }\n        }\n      } else {\n        // non-indexed BufferGeometry\n        var _position2 = geometry.attributes.position;\n\n        for (var _i254 = 0, _l11 = _position2.count / 3; _i254 < _l11; _i254++) {\n          for (var _j13 = 0; _j13 < 3; _j13++) {\n            // three edges per triangle, an edge is represented as (index1, index2)\n            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n            var _index = 3 * _i254 + _j13;\n\n            var _index2 = 3 * _i254 + (_j13 + 1) % 3;\n\n            start.fromBufferAttribute(_position2, _index);\n            end.fromBufferAttribute(_position2, _index2);\n\n            if (isUniqueEdge(start, end, edges) === true) {\n              vertices.push(start.x, start.y, start.z);\n              vertices.push(end.x, end.y, end.z);\n            }\n          }\n        }\n      } // build geometry\n\n\n      _this80.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n    }\n\n    return _this80;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WireframeGeometry);\n}(BufferGeometry);\n\nfunction isUniqueEdge(start, end, edges) {\n  var hash1 = "".concat(start.x, ",").concat(start.y, ",").concat(start.z, "-").concat(end.x, ",").concat(end.y, ",").concat(end.z);\n  var hash2 = "".concat(end.x, ",").concat(end.y, ",").concat(end.z, "-").concat(start.x, ",").concat(start.y, ",").concat(start.z); // coincident edge\n\n  if (edges.has(hash1) === true || edges.has(hash2) === true) {\n    return false;\n  } else {\n    edges.add(hash1);\n    edges.add(hash2);\n    return true;\n  }\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BoxGeometry: BoxGeometry,\n  BoxBufferGeometry: BoxGeometry,\n  CapsuleGeometry: CapsuleGeometry,\n  CapsuleBufferGeometry: CapsuleGeometry,\n  CircleGeometry: CircleGeometry,\n  CircleBufferGeometry: CircleGeometry,\n  ConeGeometry: ConeGeometry,\n  ConeBufferGeometry: ConeGeometry,\n  CylinderGeometry: CylinderGeometry,\n  CylinderBufferGeometry: CylinderGeometry,\n  DodecahedronGeometry: DodecahedronGeometry,\n  DodecahedronBufferGeometry: DodecahedronGeometry,\n  EdgesGeometry: EdgesGeometry,\n  ExtrudeGeometry: ExtrudeGeometry,\n  ExtrudeBufferGeometry: ExtrudeGeometry,\n  IcosahedronGeometry: IcosahedronGeometry,\n  IcosahedronBufferGeometry: IcosahedronGeometry,\n  LatheGeometry: LatheGeometry,\n  LatheBufferGeometry: LatheGeometry,\n  OctahedronGeometry: OctahedronGeometry,\n  OctahedronBufferGeometry: OctahedronGeometry,\n  PlaneGeometry: PlaneGeometry,\n  PlaneBufferGeometry: PlaneGeometry,\n  PolyhedronGeometry: PolyhedronGeometry,\n  PolyhedronBufferGeometry: PolyhedronGeometry,\n  RingGeometry: RingGeometry,\n  RingBufferGeometry: RingGeometry,\n  ShapeGeometry: ShapeGeometry,\n  ShapeBufferGeometry: ShapeGeometry,\n  SphereGeometry: SphereGeometry,\n  SphereBufferGeometry: SphereGeometry,\n  TetrahedronGeometry: TetrahedronGeometry,\n  TetrahedronBufferGeometry: TetrahedronGeometry,\n  TorusGeometry: TorusGeometry,\n  TorusBufferGeometry: TorusGeometry,\n  TorusKnotGeometry: TorusKnotGeometry,\n  TorusKnotBufferGeometry: TorusKnotGeometry,\n  TubeGeometry: TubeGeometry,\n  TubeBufferGeometry: TubeGeometry,\n  WireframeGeometry: WireframeGeometry\n});\n\nvar ShadowMaterial = /*#__PURE__*/function (_Material8) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ShadowMaterial, _Material8);\n\n  var _super90 = _createSuper(ShadowMaterial);\n\n  function ShadowMaterial(parameters) {\n    var _this81;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ShadowMaterial);\n\n    _this81 = _super90.call(this);\n    _this81.isShadowMaterial = true;\n    _this81.type = \'ShadowMaterial\';\n    _this81.color = new Color(0x000000);\n    _this81.transparent = true;\n    _this81.fog = true;\n\n    _this81.setValues(parameters);\n\n    return _this81;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ShadowMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(ShadowMaterial.prototype), "copy", this).call(this, source);\n\n      this.color.copy(source.color);\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return ShadowMaterial;\n}(Material);\n\nvar RawShaderMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(RawShaderMaterial, _ShaderMaterial);\n\n  var _super91 = _createSuper(RawShaderMaterial);\n\n  function RawShaderMaterial(parameters) {\n    var _this82;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, RawShaderMaterial);\n\n    _this82 = _super91.call(this, parameters);\n    _this82.isRawShaderMaterial = true;\n    _this82.type = \'RawShaderMaterial\';\n    return _this82;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(RawShaderMaterial);\n}(ShaderMaterial);\n\nvar MeshStandardMaterial = /*#__PURE__*/function (_Material9) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshStandardMaterial, _Material9);\n\n  var _super92 = _createSuper(MeshStandardMaterial);\n\n  function MeshStandardMaterial(parameters) {\n    var _this83;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshStandardMaterial);\n\n    _this83 = _super92.call(this);\n    _this83.isMeshStandardMaterial = true;\n    _this83.defines = {\n      \'STANDARD\': \'\'\n    };\n    _this83.type = \'MeshStandardMaterial\';\n    _this83.color = new Color(0xffffff); // diffuse\n\n    _this83.roughness = 1.0;\n    _this83.metalness = 0.0;\n    _this83.map = null;\n    _this83.lightMap = null;\n    _this83.lightMapIntensity = 1.0;\n    _this83.aoMap = null;\n    _this83.aoMapIntensity = 1.0;\n    _this83.emissive = new Color(0x000000);\n    _this83.emissiveIntensity = 1.0;\n    _this83.emissiveMap = null;\n    _this83.bumpMap = null;\n    _this83.bumpScale = 1;\n    _this83.normalMap = null;\n    _this83.normalMapType = TangentSpaceNormalMap;\n    _this83.normalScale = new Vector2(1, 1);\n    _this83.displacementMap = null;\n    _this83.displacementScale = 1;\n    _this83.displacementBias = 0;\n    _this83.roughnessMap = null;\n    _this83.metalnessMap = null;\n    _this83.alphaMap = null;\n    _this83.envMap = null;\n    _this83.envMapIntensity = 1.0;\n    _this83.wireframe = false;\n    _this83.wireframeLinewidth = 1;\n    _this83.wireframeLinecap = \'round\';\n    _this83.wireframeLinejoin = \'round\';\n    _this83.flatShading = false;\n    _this83.fog = true;\n\n    _this83.setValues(parameters);\n\n    return _this83;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshStandardMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshStandardMaterial.prototype), "copy", this).call(this, source);\n\n      this.defines = {\n        \'STANDARD\': \'\'\n      };\n      this.color.copy(source.color);\n      this.roughness = source.roughness;\n      this.metalness = source.metalness;\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.emissive.copy(source.emissive);\n      this.emissiveMap = source.emissiveMap;\n      this.emissiveIntensity = source.emissiveIntensity;\n      this.bumpMap = source.bumpMap;\n      this.bumpScale = source.bumpScale;\n      this.normalMap = source.normalMap;\n      this.normalMapType = source.normalMapType;\n      this.normalScale.copy(source.normalScale);\n      this.displacementMap = source.displacementMap;\n      this.displacementScale = source.displacementScale;\n      this.displacementBias = source.displacementBias;\n      this.roughnessMap = source.roughnessMap;\n      this.metalnessMap = source.metalnessMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.envMapIntensity = source.envMapIntensity;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.flatShading = source.flatShading;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return MeshStandardMaterial;\n}(Material);\n\nvar MeshPhysicalMaterial = /*#__PURE__*/function (_MeshStandardMaterial) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshPhysicalMaterial, _MeshStandardMaterial);\n\n  var _super93 = _createSuper(MeshPhysicalMaterial);\n\n  function MeshPhysicalMaterial(parameters) {\n    var _this84;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshPhysicalMaterial);\n\n    _this84 = _super93.call(this);\n    _this84.isMeshPhysicalMaterial = true;\n    _this84.defines = {\n      \'STANDARD\': \'\',\n      \'PHYSICAL\': \'\'\n    };\n    _this84.type = \'MeshPhysicalMaterial\';\n    _this84.clearcoatMap = null;\n    _this84.clearcoatRoughness = 0.0;\n    _this84.clearcoatRoughnessMap = null;\n    _this84.clearcoatNormalScale = new Vector2(1, 1);\n    _this84.clearcoatNormalMap = null;\n    _this84.ior = 1.5;\n    Object.defineProperty((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .Z)(_this84), \'reflectivity\', {\n      get: function get() {\n        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);\n      },\n      set: function set(reflectivity) {\n        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);\n      }\n    });\n    _this84.iridescenceMap = null;\n    _this84.iridescenceIOR = 1.3;\n    _this84.iridescenceThicknessRange = [100, 400];\n    _this84.iridescenceThicknessMap = null;\n    _this84.sheenColor = new Color(0x000000);\n    _this84.sheenColorMap = null;\n    _this84.sheenRoughness = 1.0;\n    _this84.sheenRoughnessMap = null;\n    _this84.transmissionMap = null;\n    _this84.thickness = 0;\n    _this84.thicknessMap = null;\n    _this84.attenuationDistance = 0.0;\n    _this84.attenuationColor = new Color(1, 1, 1);\n    _this84.specularIntensity = 1.0;\n    _this84.specularIntensityMap = null;\n    _this84.specularColor = new Color(1, 1, 1);\n    _this84.specularColorMap = null;\n    _this84._sheen = 0.0;\n    _this84._clearcoat = 0;\n    _this84._iridescence = 0;\n    _this84._transmission = 0;\n\n    _this84.setValues(parameters);\n\n    return _this84;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshPhysicalMaterial, [{\n    key: "sheen",\n    get: function get() {\n      return this._sheen;\n    },\n    set: function set(value) {\n      if (this._sheen > 0 !== value > 0) {\n        this.version++;\n      }\n\n      this._sheen = value;\n    }\n  }, {\n    key: "clearcoat",\n    get: function get() {\n      return this._clearcoat;\n    },\n    set: function set(value) {\n      if (this._clearcoat > 0 !== value > 0) {\n        this.version++;\n      }\n\n      this._clearcoat = value;\n    }\n  }, {\n    key: "iridescence",\n    get: function get() {\n      return this._iridescence;\n    },\n    set: function set(value) {\n      if (this._iridescence > 0 !== value > 0) {\n        this.version++;\n      }\n\n      this._iridescence = value;\n    }\n  }, {\n    key: "transmission",\n    get: function get() {\n      return this._transmission;\n    },\n    set: function set(value) {\n      if (this._transmission > 0 !== value > 0) {\n        this.version++;\n      }\n\n      this._transmission = value;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshPhysicalMaterial.prototype), "copy", this).call(this, source);\n\n      this.defines = {\n        \'STANDARD\': \'\',\n        \'PHYSICAL\': \'\'\n      };\n      this.clearcoat = source.clearcoat;\n      this.clearcoatMap = source.clearcoatMap;\n      this.clearcoatRoughness = source.clearcoatRoughness;\n      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n      this.clearcoatNormalMap = source.clearcoatNormalMap;\n      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n      this.ior = source.ior;\n      this.iridescence = source.iridescence;\n      this.iridescenceMap = source.iridescenceMap;\n      this.iridescenceIOR = source.iridescenceIOR;\n      this.iridescenceThicknessRange = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_12__/* ["default"] */ .Z)(source.iridescenceThicknessRange);\n      this.iridescenceThicknessMap = source.iridescenceThicknessMap;\n      this.sheen = source.sheen;\n      this.sheenColor.copy(source.sheenColor);\n      this.sheenColorMap = source.sheenColorMap;\n      this.sheenRoughness = source.sheenRoughness;\n      this.sheenRoughnessMap = source.sheenRoughnessMap;\n      this.transmission = source.transmission;\n      this.transmissionMap = source.transmissionMap;\n      this.thickness = source.thickness;\n      this.thicknessMap = source.thicknessMap;\n      this.attenuationDistance = source.attenuationDistance;\n      this.attenuationColor.copy(source.attenuationColor);\n      this.specularIntensity = source.specularIntensity;\n      this.specularIntensityMap = source.specularIntensityMap;\n      this.specularColor.copy(source.specularColor);\n      this.specularColorMap = source.specularColorMap;\n      return this;\n    }\n  }]);\n\n  return MeshPhysicalMaterial;\n}(MeshStandardMaterial);\n\nvar MeshPhongMaterial = /*#__PURE__*/function (_Material10) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshPhongMaterial, _Material10);\n\n  var _super94 = _createSuper(MeshPhongMaterial);\n\n  function MeshPhongMaterial(parameters) {\n    var _this85;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshPhongMaterial);\n\n    _this85 = _super94.call(this);\n    _this85.isMeshPhongMaterial = true;\n    _this85.type = \'MeshPhongMaterial\';\n    _this85.color = new Color(0xffffff); // diffuse\n\n    _this85.specular = new Color(0x111111);\n    _this85.shininess = 30;\n    _this85.map = null;\n    _this85.lightMap = null;\n    _this85.lightMapIntensity = 1.0;\n    _this85.aoMap = null;\n    _this85.aoMapIntensity = 1.0;\n    _this85.emissive = new Color(0x000000);\n    _this85.emissiveIntensity = 1.0;\n    _this85.emissiveMap = null;\n    _this85.bumpMap = null;\n    _this85.bumpScale = 1;\n    _this85.normalMap = null;\n    _this85.normalMapType = TangentSpaceNormalMap;\n    _this85.normalScale = new Vector2(1, 1);\n    _this85.displacementMap = null;\n    _this85.displacementScale = 1;\n    _this85.displacementBias = 0;\n    _this85.specularMap = null;\n    _this85.alphaMap = null;\n    _this85.envMap = null;\n    _this85.combine = MultiplyOperation;\n    _this85.reflectivity = 1;\n    _this85.refractionRatio = 0.98;\n    _this85.wireframe = false;\n    _this85.wireframeLinewidth = 1;\n    _this85.wireframeLinecap = \'round\';\n    _this85.wireframeLinejoin = \'round\';\n    _this85.flatShading = false;\n    _this85.fog = true;\n\n    _this85.setValues(parameters);\n\n    return _this85;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshPhongMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshPhongMaterial.prototype), "copy", this).call(this, source);\n\n      this.color.copy(source.color);\n      this.specular.copy(source.specular);\n      this.shininess = source.shininess;\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.emissive.copy(source.emissive);\n      this.emissiveMap = source.emissiveMap;\n      this.emissiveIntensity = source.emissiveIntensity;\n      this.bumpMap = source.bumpMap;\n      this.bumpScale = source.bumpScale;\n      this.normalMap = source.normalMap;\n      this.normalMapType = source.normalMapType;\n      this.normalScale.copy(source.normalScale);\n      this.displacementMap = source.displacementMap;\n      this.displacementScale = source.displacementScale;\n      this.displacementBias = source.displacementBias;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.flatShading = source.flatShading;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return MeshPhongMaterial;\n}(Material);\n\nvar MeshToonMaterial = /*#__PURE__*/function (_Material11) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshToonMaterial, _Material11);\n\n  var _super95 = _createSuper(MeshToonMaterial);\n\n  function MeshToonMaterial(parameters) {\n    var _this86;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshToonMaterial);\n\n    _this86 = _super95.call(this);\n    _this86.isMeshToonMaterial = true;\n    _this86.defines = {\n      \'TOON\': \'\'\n    };\n    _this86.type = \'MeshToonMaterial\';\n    _this86.color = new Color(0xffffff);\n    _this86.map = null;\n    _this86.gradientMap = null;\n    _this86.lightMap = null;\n    _this86.lightMapIntensity = 1.0;\n    _this86.aoMap = null;\n    _this86.aoMapIntensity = 1.0;\n    _this86.emissive = new Color(0x000000);\n    _this86.emissiveIntensity = 1.0;\n    _this86.emissiveMap = null;\n    _this86.bumpMap = null;\n    _this86.bumpScale = 1;\n    _this86.normalMap = null;\n    _this86.normalMapType = TangentSpaceNormalMap;\n    _this86.normalScale = new Vector2(1, 1);\n    _this86.displacementMap = null;\n    _this86.displacementScale = 1;\n    _this86.displacementBias = 0;\n    _this86.alphaMap = null;\n    _this86.wireframe = false;\n    _this86.wireframeLinewidth = 1;\n    _this86.wireframeLinecap = \'round\';\n    _this86.wireframeLinejoin = \'round\';\n    _this86.fog = true;\n\n    _this86.setValues(parameters);\n\n    return _this86;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshToonMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshToonMaterial.prototype), "copy", this).call(this, source);\n\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.gradientMap = source.gradientMap;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.emissive.copy(source.emissive);\n      this.emissiveMap = source.emissiveMap;\n      this.emissiveIntensity = source.emissiveIntensity;\n      this.bumpMap = source.bumpMap;\n      this.bumpScale = source.bumpScale;\n      this.normalMap = source.normalMap;\n      this.normalMapType = source.normalMapType;\n      this.normalScale.copy(source.normalScale);\n      this.displacementMap = source.displacementMap;\n      this.displacementScale = source.displacementScale;\n      this.displacementBias = source.displacementBias;\n      this.alphaMap = source.alphaMap;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return MeshToonMaterial;\n}(Material);\n\nvar MeshNormalMaterial = /*#__PURE__*/function (_Material12) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshNormalMaterial, _Material12);\n\n  var _super96 = _createSuper(MeshNormalMaterial);\n\n  function MeshNormalMaterial(parameters) {\n    var _this87;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshNormalMaterial);\n\n    _this87 = _super96.call(this);\n    _this87.isMeshNormalMaterial = true;\n    _this87.type = \'MeshNormalMaterial\';\n    _this87.bumpMap = null;\n    _this87.bumpScale = 1;\n    _this87.normalMap = null;\n    _this87.normalMapType = TangentSpaceNormalMap;\n    _this87.normalScale = new Vector2(1, 1);\n    _this87.displacementMap = null;\n    _this87.displacementScale = 1;\n    _this87.displacementBias = 0;\n    _this87.wireframe = false;\n    _this87.wireframeLinewidth = 1;\n    _this87.flatShading = false;\n\n    _this87.setValues(parameters);\n\n    return _this87;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshNormalMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshNormalMaterial.prototype), "copy", this).call(this, source);\n\n      this.bumpMap = source.bumpMap;\n      this.bumpScale = source.bumpScale;\n      this.normalMap = source.normalMap;\n      this.normalMapType = source.normalMapType;\n      this.normalScale.copy(source.normalScale);\n      this.displacementMap = source.displacementMap;\n      this.displacementScale = source.displacementScale;\n      this.displacementBias = source.displacementBias;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.flatShading = source.flatShading;\n      return this;\n    }\n  }]);\n\n  return MeshNormalMaterial;\n}(Material);\n\nvar MeshLambertMaterial = /*#__PURE__*/function (_Material13) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshLambertMaterial, _Material13);\n\n  var _super97 = _createSuper(MeshLambertMaterial);\n\n  function MeshLambertMaterial(parameters) {\n    var _this88;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshLambertMaterial);\n\n    _this88 = _super97.call(this);\n    _this88.isMeshLambertMaterial = true;\n    _this88.type = \'MeshLambertMaterial\';\n    _this88.color = new Color(0xffffff); // diffuse\n\n    _this88.map = null;\n    _this88.lightMap = null;\n    _this88.lightMapIntensity = 1.0;\n    _this88.aoMap = null;\n    _this88.aoMapIntensity = 1.0;\n    _this88.emissive = new Color(0x000000);\n    _this88.emissiveIntensity = 1.0;\n    _this88.emissiveMap = null;\n    _this88.specularMap = null;\n    _this88.alphaMap = null;\n    _this88.envMap = null;\n    _this88.combine = MultiplyOperation;\n    _this88.reflectivity = 1;\n    _this88.refractionRatio = 0.98;\n    _this88.wireframe = false;\n    _this88.wireframeLinewidth = 1;\n    _this88.wireframeLinecap = \'round\';\n    _this88.wireframeLinejoin = \'round\';\n    _this88.fog = true;\n\n    _this88.setValues(parameters);\n\n    return _this88;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshLambertMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshLambertMaterial.prototype), "copy", this).call(this, source);\n\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.emissive.copy(source.emissive);\n      this.emissiveMap = source.emissiveMap;\n      this.emissiveIntensity = source.emissiveIntensity;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return MeshLambertMaterial;\n}(Material);\n\nvar MeshMatcapMaterial = /*#__PURE__*/function (_Material14) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MeshMatcapMaterial, _Material14);\n\n  var _super98 = _createSuper(MeshMatcapMaterial);\n\n  function MeshMatcapMaterial(parameters) {\n    var _this89;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MeshMatcapMaterial);\n\n    _this89 = _super98.call(this);\n    _this89.isMeshMatcapMaterial = true;\n    _this89.defines = {\n      \'MATCAP\': \'\'\n    };\n    _this89.type = \'MeshMatcapMaterial\';\n    _this89.color = new Color(0xffffff); // diffuse\n\n    _this89.matcap = null;\n    _this89.map = null;\n    _this89.bumpMap = null;\n    _this89.bumpScale = 1;\n    _this89.normalMap = null;\n    _this89.normalMapType = TangentSpaceNormalMap;\n    _this89.normalScale = new Vector2(1, 1);\n    _this89.displacementMap = null;\n    _this89.displacementScale = 1;\n    _this89.displacementBias = 0;\n    _this89.alphaMap = null;\n    _this89.flatShading = false;\n    _this89.fog = true;\n\n    _this89.setValues(parameters);\n\n    return _this89;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MeshMatcapMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(MeshMatcapMaterial.prototype), "copy", this).call(this, source);\n\n      this.defines = {\n        \'MATCAP\': \'\'\n      };\n      this.color.copy(source.color);\n      this.matcap = source.matcap;\n      this.map = source.map;\n      this.bumpMap = source.bumpMap;\n      this.bumpScale = source.bumpScale;\n      this.normalMap = source.normalMap;\n      this.normalMapType = source.normalMapType;\n      this.normalScale.copy(source.normalScale);\n      this.displacementMap = source.displacementMap;\n      this.displacementScale = source.displacementScale;\n      this.displacementBias = source.displacementBias;\n      this.alphaMap = source.alphaMap;\n      this.flatShading = source.flatShading;\n      this.fog = source.fog;\n      return this;\n    }\n  }]);\n\n  return MeshMatcapMaterial;\n}(Material);\n\nvar LineDashedMaterial = /*#__PURE__*/function (_LineBasicMaterial) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LineDashedMaterial, _LineBasicMaterial);\n\n  var _super99 = _createSuper(LineDashedMaterial);\n\n  function LineDashedMaterial(parameters) {\n    var _this90;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LineDashedMaterial);\n\n    _this90 = _super99.call(this);\n    _this90.isLineDashedMaterial = true;\n    _this90.type = \'LineDashedMaterial\';\n    _this90.scale = 1;\n    _this90.dashSize = 3;\n    _this90.gapSize = 1;\n\n    _this90.setValues(parameters);\n\n    return _this90;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LineDashedMaterial, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LineDashedMaterial.prototype), "copy", this).call(this, source);\n\n      this.scale = source.scale;\n      this.dashSize = source.dashSize;\n      this.gapSize = source.gapSize;\n      return this;\n    }\n  }]);\n\n  return LineDashedMaterial;\n}(LineBasicMaterial);\n\nvar materialLib = {\n  ShadowMaterial: ShadowMaterial,\n  SpriteMaterial: SpriteMaterial,\n  RawShaderMaterial: RawShaderMaterial,\n  ShaderMaterial: ShaderMaterial,\n  PointsMaterial: PointsMaterial,\n  MeshPhysicalMaterial: MeshPhysicalMaterial,\n  MeshStandardMaterial: MeshStandardMaterial,\n  MeshPhongMaterial: MeshPhongMaterial,\n  MeshToonMaterial: MeshToonMaterial,\n  MeshNormalMaterial: MeshNormalMaterial,\n  MeshLambertMaterial: MeshLambertMaterial,\n  MeshDepthMaterial: MeshDepthMaterial,\n  MeshDistanceMaterial: MeshDistanceMaterial,\n  MeshBasicMaterial: MeshBasicMaterial,\n  MeshMatcapMaterial: MeshMatcapMaterial,\n  LineDashedMaterial: LineDashedMaterial,\n  LineBasicMaterial: LineBasicMaterial,\n  Material: Material\n};\n\nMaterial.fromType = function (type) {\n  return new materialLib[type]();\n};\n\nvar AnimationUtils = {\n  // same as Array.prototype.slice, but also works on typed arrays\n  arraySlice: function arraySlice(array, from, to) {\n    if (AnimationUtils.isTypedArray(array)) {\n      // in ios9 array.subarray(from, undefined) will return empty array\n      // but array.subarray(from) or array.subarray(from, len) is correct\n      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n    }\n\n    return array.slice(from, to);\n  },\n  // converts an array to a specific type\n  convertArray: function convertArray(array, type, forceClone) {\n    if (!array || // let \'undefined\' and \'null\' pass\n    !forceClone && array.constructor === type) return array;\n\n    if (typeof type.BYTES_PER_ELEMENT === \'number\') {\n      return new type(array); // create typed array\n    }\n\n    return Array.prototype.slice.call(array); // create Array\n  },\n  isTypedArray: function isTypedArray(object) {\n    return ArrayBuffer.isView(object) && !(object instanceof DataView);\n  },\n  // returns an array by which times and values can be sorted\n  getKeyframeOrder: function getKeyframeOrder(times) {\n    function compareTime(i, j) {\n      return times[i] - times[j];\n    }\n\n    var n = times.length;\n    var result = new Array(n);\n\n    for (var _i255 = 0; _i255 !== n; ++_i255) {\n      result[_i255] = _i255;\n    }\n\n    result.sort(compareTime);\n    return result;\n  },\n  // uses the array previously returned by \'getKeyframeOrder\' to sort data\n  sortedArray: function sortedArray(values, stride, order) {\n    var nValues = values.length;\n    var result = new values.constructor(nValues);\n\n    for (var _i256 = 0, dstOffset = 0; dstOffset !== nValues; ++_i256) {\n      var srcOffset = order[_i256] * stride;\n\n      for (var j = 0; j !== stride; ++j) {\n        result[dstOffset++] = values[srcOffset + j];\n      }\n    }\n\n    return result;\n  },\n  // function for parsing AOS keyframe formats\n  flattenJSON: function flattenJSON(jsonKeys, times, values, valuePropertyName) {\n    var i = 1,\n        key = jsonKeys[0];\n\n    while (key !== undefined && key[valuePropertyName] === undefined) {\n      key = jsonKeys[i++];\n    }\n\n    if (key === undefined) return; // no data\n\n    var value = key[valuePropertyName];\n    if (value === undefined) return; // no data\n\n    if (Array.isArray(value)) {\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push.apply(values, value); // push all elements\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else if (value.toArray !== undefined) {\n      // ...assume THREE.Math-ish\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          value.toArray(values, values.length);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else {\n      // otherwise push as-is\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push(value);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    }\n  },\n  subclip: function subclip(sourceClip, name, startFrame, endFrame) {\n    var fps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 30;\n    var clip = sourceClip.clone();\n    clip.name = name;\n    var tracks = [];\n\n    for (var _i257 = 0; _i257 < clip.tracks.length; ++_i257) {\n      var track = clip.tracks[_i257];\n      var valueSize = track.getValueSize();\n      var times = [];\n      var values = [];\n\n      for (var j = 0; j < track.times.length; ++j) {\n        var frame = track.times[j] * fps;\n        if (frame < startFrame || frame >= endFrame) continue;\n        times.push(track.times[j]);\n\n        for (var k = 0; k < valueSize; ++k) {\n          values.push(track.values[j * valueSize + k]);\n        }\n      }\n\n      if (times.length === 0) continue;\n      track.times = AnimationUtils.convertArray(times, track.times.constructor);\n      track.values = AnimationUtils.convertArray(values, track.values.constructor);\n      tracks.push(track);\n    }\n\n    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip\n\n    var minStartTime = Infinity;\n\n    for (var _i258 = 0; _i258 < clip.tracks.length; ++_i258) {\n      if (minStartTime > clip.tracks[_i258].times[0]) {\n        minStartTime = clip.tracks[_i258].times[0];\n      }\n    } // shift all tracks such that clip begins at t=0\n\n\n    for (var _i259 = 0; _i259 < clip.tracks.length; ++_i259) {\n      clip.tracks[_i259].shift(-1 * minStartTime);\n    }\n\n    clip.resetDuration();\n    return clip;\n  },\n  makeClipAdditive: function makeClipAdditive(targetClip) {\n    var referenceFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var referenceClip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : targetClip;\n    var fps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;\n    if (fps <= 0) fps = 30;\n    var numTracks = referenceClip.tracks.length;\n    var referenceTime = referenceFrame / fps; // Make each track\'s values relative to the values at the reference frame\n\n    var _loop = function _loop(_i260) {\n      var referenceTrack = referenceClip.tracks[_i260];\n      var referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it\'s non-numeric\n\n      if (referenceTrackType === \'bool\' || referenceTrackType === \'string\') return "continue"; // Find the track in the target clip whose name and type matches the reference track\n\n      var targetTrack = targetClip.tracks.find(function (track) {\n        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n      });\n      if (targetTrack === undefined) return "continue";\n      var referenceOffset = 0;\n      var referenceValueSize = referenceTrack.getValueSize();\n\n      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        referenceOffset = referenceValueSize / 3;\n      }\n\n      var targetOffset = 0;\n      var targetValueSize = targetTrack.getValueSize();\n\n      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        targetOffset = targetValueSize / 3;\n      }\n\n      var lastIndex = referenceTrack.times.length - 1;\n      var referenceValue = void 0; // Find the value to subtract out of the track\n\n      if (referenceTime <= referenceTrack.times[0]) {\n        // Reference frame is earlier than the first keyframe, so just use the first keyframe\n        var startIndex = referenceOffset;\n        var endIndex = referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n        // Reference frame is after the last keyframe, so just use the last keyframe\n        var _startIndex = lastIndex * referenceValueSize + referenceOffset;\n\n        var _endIndex = _startIndex + referenceValueSize - referenceOffset;\n\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, _startIndex, _endIndex);\n      } else {\n        // Interpolate to the reference value\n        var interpolant = referenceTrack.createInterpolant();\n        var _startIndex2 = referenceOffset;\n\n        var _endIndex2 = referenceValueSize - referenceOffset;\n\n        interpolant.evaluate(referenceTime);\n        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, _startIndex2, _endIndex2);\n      } // Conjugate the quaternion\n\n\n      if (referenceTrackType === \'quaternion\') {\n        var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n        referenceQuat.toArray(referenceValue);\n      } // Subtract the reference value from all of the track values\n\n\n      var numTimes = targetTrack.times.length;\n\n      for (var j = 0; j < numTimes; ++j) {\n        var valueStart = j * targetValueSize + targetOffset;\n\n        if (referenceTrackType === \'quaternion\') {\n          // Multiply the conjugate for quaternion track types\n          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n        } else {\n          var valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types\n\n          for (var k = 0; k < valueEnd; ++k) {\n            targetTrack.values[valueStart + k] -= referenceValue[k];\n          }\n        }\n      }\n    };\n\n    for (var _i260 = 0; _i260 < numTracks; ++_i260) {\n      var _ret = _loop(_i260);\n\n      if (_ret === "continue") continue;\n    }\n\n    targetClip.blendMode = AdditiveAnimationBlendMode;\n    return targetClip;\n  }\n};\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nvar Interpolant = /*#__PURE__*/function () {\n  function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Interpolant);\n\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n    this.DefaultSettings_ = {};\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Interpolant, [{\n    key: "evaluate",\n    value: function evaluate(t) {\n      var pp = this.parameterPositions;\n      var i1 = this._cachedIndex,\n          t1 = pp[i1],\n          t0 = pp[i1 - 1];\n\n      validate_interval: {\n        seek: {\n          var right;\n\n          linear_scan: {\n            //- See http://jsperf.com/comparison-to-undefined/3\n            //- slower code:\n            //-\n            //- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n            forward_scan: if (!(t < t1)) {\n              for (var giveUpAt = i1 + 2;;) {\n                if (t1 === undefined) {\n                  if (t < t0) break forward_scan; // after end\n\n                  i1 = pp.length;\n                  this._cachedIndex = i1;\n                  return this.copySampleValue_(i1 - 1);\n                }\n\n                if (i1 === giveUpAt) break; // this loop\n\n                t0 = t1;\n                t1 = pp[++i1];\n\n                if (t < t1) {\n                  // we have arrived at the sought interval\n                  break seek;\n                }\n              } // prepare binary search on the right side of the index\n\n\n              right = pp.length;\n              break linear_scan;\n            } //- slower code:\n            //-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\n\n            if (!(t >= t0)) {\n              // looping?\n              var t1global = pp[1];\n\n              if (t < t1global) {\n                i1 = 2; // + 1, using the scan for the details\n\n                t0 = t1global;\n              } // linear reverse scan\n\n\n              for (var _giveUpAt = i1 - 2;;) {\n                if (t0 === undefined) {\n                  // before start\n                  this._cachedIndex = 0;\n                  return this.copySampleValue_(0);\n                }\n\n                if (i1 === _giveUpAt) break; // this loop\n\n                t1 = t0;\n                t0 = pp[--i1 - 1];\n\n                if (t >= t0) {\n                  // we have arrived at the sought interval\n                  break seek;\n                }\n              } // prepare binary search on the left side of the index\n\n\n              right = i1;\n              i1 = 0;\n              break linear_scan;\n            } // the interval is valid\n\n\n            break validate_interval;\n          } // linear scan\n          // binary search\n\n\n          while (i1 < right) {\n            var mid = i1 + right >>> 1;\n\n            if (t < pp[mid]) {\n              right = mid;\n            } else {\n              i1 = mid + 1;\n            }\n          }\n\n          t1 = pp[i1];\n          t0 = pp[i1 - 1]; // check boundary cases, again\n\n          if (t0 === undefined) {\n            this._cachedIndex = 0;\n            return this.copySampleValue_(0);\n          }\n\n          if (t1 === undefined) {\n            i1 = pp.length;\n            this._cachedIndex = i1;\n            return this.copySampleValue_(i1 - 1);\n          }\n        } // seek\n\n\n        this._cachedIndex = i1;\n        this.intervalChanged_(i1, t0, t1);\n      } // validate_interval\n\n\n      return this.interpolate_(i1, t0, t, t1);\n    }\n  }, {\n    key: "getSettings_",\n    value: function getSettings_() {\n      return this.settings || this.DefaultSettings_;\n    }\n  }, {\n    key: "copySampleValue_",\n    value: function copySampleValue_(index) {\n      // copies a sample value to the result buffer\n      var result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          offset = index * stride;\n\n      for (var _i261 = 0; _i261 !== stride; ++_i261) {\n        result[_i261] = values[offset + _i261];\n      }\n\n      return result;\n    } // Template methods for derived classes:\n\n  }, {\n    key: "interpolate_",\n    value: function\n      /* i1, t0, t, t1 */\n    interpolate_() {\n      throw new Error(\'call to abstract method\'); // implementations shall return this.resultBuffer\n    }\n  }, {\n    key: "intervalChanged_",\n    value: function\n      /* i1, t0, t1 */\n    intervalChanged_() {// empty\n    }\n  }]);\n\n  return Interpolant;\n}();\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\n\nvar CubicInterpolant = /*#__PURE__*/function (_Interpolant) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CubicInterpolant, _Interpolant);\n\n  var _super100 = _createSuper(CubicInterpolant);\n\n  function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    var _this91;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CubicInterpolant);\n\n    _this91 = _super100.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n    _this91._weightPrev = -0;\n    _this91._offsetPrev = -0;\n    _this91._weightNext = -0;\n    _this91._offsetNext = -0;\n    _this91.DefaultSettings_ = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n    return _this91;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CubicInterpolant, [{\n    key: "intervalChanged_",\n    value: function intervalChanged_(i1, t0, t1) {\n      var pp = this.parameterPositions;\n      var iPrev = i1 - 2,\n          iNext = i1 + 1,\n          tPrev = pp[iPrev],\n          tNext = pp[iNext];\n\n      if (tPrev === undefined) {\n        switch (this.getSettings_().endingStart) {\n          case ZeroSlopeEnding:\n            // f\'(t0) = 0\n            iPrev = i1;\n            tPrev = 2 * t0 - t1;\n            break;\n\n          case WrapAroundEnding:\n            // use the other end of the curve\n            iPrev = pp.length - 2;\n            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n            break;\n\n          default:\n            // ZeroCurvatureEnding\n            // f\'\'(t0) = 0 a.k.a. Natural Spline\n            iPrev = i1;\n            tPrev = t1;\n        }\n      }\n\n      if (tNext === undefined) {\n        switch (this.getSettings_().endingEnd) {\n          case ZeroSlopeEnding:\n            // f\'(tN) = 0\n            iNext = i1;\n            tNext = 2 * t1 - t0;\n            break;\n\n          case WrapAroundEnding:\n            // use the other end of the curve\n            iNext = 1;\n            tNext = t1 + pp[1] - pp[0];\n            break;\n\n          default:\n            // ZeroCurvatureEnding\n            // f\'\'(tN) = 0, a.k.a. Natural Spline\n            iNext = i1 - 1;\n            tNext = t0;\n        }\n      }\n\n      var halfDt = (t1 - t0) * 0.5,\n          stride = this.valueSize;\n      this._weightPrev = halfDt / (t0 - tPrev);\n      this._weightNext = halfDt / (tNext - t1);\n      this._offsetPrev = iPrev * stride;\n      this._offsetNext = iNext * stride;\n    }\n  }, {\n    key: "interpolate_",\n    value: function interpolate_(i1, t0, t, t1) {\n      var result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          o1 = i1 * stride,\n          o0 = o1 - stride,\n          oP = this._offsetPrev,\n          oN = this._offsetNext,\n          wP = this._weightPrev,\n          wN = this._weightNext,\n          p = (t - t0) / (t1 - t0),\n          pp = p * p,\n          ppp = pp * p; // evaluate polynomials\n\n      var sP = -wP * ppp + 2 * wP * pp - wP * p;\n      var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n      var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n      var sN = wN * ppp - wN * pp; // combine data linearly\n\n      for (var _i262 = 0; _i262 !== stride; ++_i262) {\n        result[_i262] = sP * values[oP + _i262] + s0 * values[o0 + _i262] + s1 * values[o1 + _i262] + sN * values[oN + _i262];\n      }\n\n      return result;\n    }\n  }]);\n\n  return CubicInterpolant;\n}(Interpolant);\n\nvar LinearInterpolant = /*#__PURE__*/function (_Interpolant2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LinearInterpolant, _Interpolant2);\n\n  var _super101 = _createSuper(LinearInterpolant);\n\n  function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LinearInterpolant);\n\n    return _super101.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LinearInterpolant, [{\n    key: "interpolate_",\n    value: function interpolate_(i1, t0, t, t1) {\n      var result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          offset1 = i1 * stride,\n          offset0 = offset1 - stride,\n          weight1 = (t - t0) / (t1 - t0),\n          weight0 = 1 - weight1;\n\n      for (var _i263 = 0; _i263 !== stride; ++_i263) {\n        result[_i263] = values[offset0 + _i263] * weight0 + values[offset1 + _i263] * weight1;\n      }\n\n      return result;\n    }\n  }]);\n\n  return LinearInterpolant;\n}(Interpolant);\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\n\nvar DiscreteInterpolant = /*#__PURE__*/function (_Interpolant3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DiscreteInterpolant, _Interpolant3);\n\n  var _super102 = _createSuper(DiscreteInterpolant);\n\n  function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DiscreteInterpolant);\n\n    return _super102.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DiscreteInterpolant, [{\n    key: "interpolate_",\n    value: function interpolate_(i1\n    /*, t0, t, t1 */\n    ) {\n      return this.copySampleValue_(i1 - 1);\n    }\n  }]);\n\n  return DiscreteInterpolant;\n}(Interpolant);\n\nvar KeyframeTrack = /*#__PURE__*/function () {\n  function KeyframeTrack(name, times, values, interpolation) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, KeyframeTrack);\n\n    if (name === undefined) throw new Error(\'THREE.KeyframeTrack: track name is undefined\');\n    if (times === undefined || times.length === 0) throw new Error(\'THREE.KeyframeTrack: no keyframes in track named \' + name);\n    this.name = name;\n    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\n  } // Serialization (in static context, because of constructor invocation\n  // and automatic invocation of .toJSON):\n\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(KeyframeTrack, [{\n    key: "InterpolantFactoryMethodDiscrete",\n    value: function InterpolantFactoryMethodDiscrete(result) {\n      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n    }\n  }, {\n    key: "InterpolantFactoryMethodLinear",\n    value: function InterpolantFactoryMethodLinear(result) {\n      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n    }\n  }, {\n    key: "InterpolantFactoryMethodSmooth",\n    value: function InterpolantFactoryMethodSmooth(result) {\n      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n    }\n  }, {\n    key: "setInterpolation",\n    value: function setInterpolation(interpolation) {\n      var factoryMethod;\n\n      switch (interpolation) {\n        case InterpolateDiscrete:\n          factoryMethod = this.InterpolantFactoryMethodDiscrete;\n          break;\n\n        case InterpolateLinear:\n          factoryMethod = this.InterpolantFactoryMethodLinear;\n          break;\n\n        case InterpolateSmooth:\n          factoryMethod = this.InterpolantFactoryMethodSmooth;\n          break;\n      }\n\n      if (factoryMethod === undefined) {\n        var message = \'unsupported interpolation for \' + this.ValueTypeName + \' keyframe track named \' + this.name;\n\n        if (this.createInterpolant === undefined) {\n          // fall back to default, unless the default itself is messed up\n          if (interpolation !== this.DefaultInterpolation) {\n            this.setInterpolation(this.DefaultInterpolation);\n          } else {\n            throw new Error(message); // fatal, in this case\n          }\n        }\n\n        console.warn(\'THREE.KeyframeTrack:\', message);\n        return this;\n      }\n\n      this.createInterpolant = factoryMethod;\n      return this;\n    }\n  }, {\n    key: "getInterpolation",\n    value: function getInterpolation() {\n      switch (this.createInterpolant) {\n        case this.InterpolantFactoryMethodDiscrete:\n          return InterpolateDiscrete;\n\n        case this.InterpolantFactoryMethodLinear:\n          return InterpolateLinear;\n\n        case this.InterpolantFactoryMethodSmooth:\n          return InterpolateSmooth;\n      }\n    }\n  }, {\n    key: "getValueSize",\n    value: function getValueSize() {\n      return this.values.length / this.times.length;\n    } // move all keyframes either forwards or backwards in time\n\n  }, {\n    key: "shift",\n    value: function shift(timeOffset) {\n      if (timeOffset !== 0.0) {\n        var times = this.times;\n\n        for (var _i264 = 0, n = times.length; _i264 !== n; ++_i264) {\n          times[_i264] += timeOffset;\n        }\n      }\n\n      return this;\n    } // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\n  }, {\n    key: "scale",\n    value: function scale(timeScale) {\n      if (timeScale !== 1.0) {\n        var times = this.times;\n\n        for (var _i265 = 0, n = times.length; _i265 !== n; ++_i265) {\n          times[_i265] *= timeScale;\n        }\n      }\n\n      return this;\n    } // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\n  }, {\n    key: "trim",\n    value: function trim(startTime, endTime) {\n      var times = this.times,\n          nKeys = times.length;\n      var from = 0,\n          to = nKeys - 1;\n\n      while (from !== nKeys && times[from] < startTime) {\n        ++from;\n      }\n\n      while (to !== -1 && times[to] > endTime) {\n        --to;\n      }\n\n      ++to; // inclusive -> exclusive bound\n\n      if (from !== 0 || to !== nKeys) {\n        // empty tracks are forbidden, so keep at least one keyframe\n        if (from >= to) {\n          to = Math.max(to, 1);\n          from = to - 1;\n        }\n\n        var stride = this.getValueSize();\n        this.times = AnimationUtils.arraySlice(times, from, to);\n        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n      }\n\n      return this;\n    } // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\n  }, {\n    key: "validate",\n    value: function validate() {\n      var valid = true;\n      var valueSize = this.getValueSize();\n\n      if (valueSize - Math.floor(valueSize) !== 0) {\n        console.error(\'THREE.KeyframeTrack: Invalid value size in track.\', this);\n        valid = false;\n      }\n\n      var times = this.times,\n          values = this.values,\n          nKeys = times.length;\n\n      if (nKeys === 0) {\n        console.error(\'THREE.KeyframeTrack: Track is empty.\', this);\n        valid = false;\n      }\n\n      var prevTime = null;\n\n      for (var _i266 = 0; _i266 !== nKeys; _i266++) {\n        var currTime = times[_i266];\n\n        if (typeof currTime === \'number\' && isNaN(currTime)) {\n          console.error(\'THREE.KeyframeTrack: Time is not a valid number.\', this, _i266, currTime);\n          valid = false;\n          break;\n        }\n\n        if (prevTime !== null && prevTime > currTime) {\n          console.error(\'THREE.KeyframeTrack: Out of order keys.\', this, _i266, currTime, prevTime);\n          valid = false;\n          break;\n        }\n\n        prevTime = currTime;\n      }\n\n      if (values !== undefined) {\n        if (AnimationUtils.isTypedArray(values)) {\n          for (var _i267 = 0, n = values.length; _i267 !== n; ++_i267) {\n            var _value5 = values[_i267];\n\n            if (isNaN(_value5)) {\n              console.error(\'THREE.KeyframeTrack: Value is not a valid number.\', this, _i267, _value5);\n              valid = false;\n              break;\n            }\n          }\n        }\n      }\n\n      return valid;\n    } // removes equivalent sequential keys as common in morph target sequences\n    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --\x3e (0,0,1,1,0,0)\n\n  }, {\n    key: "optimize",\n    value: function optimize() {\n      // times or values may be shared with other tracks, so overwriting is unsafe\n      var times = AnimationUtils.arraySlice(this.times),\n          values = AnimationUtils.arraySlice(this.values),\n          stride = this.getValueSize(),\n          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n          lastIndex = times.length - 1;\n      var writeIndex = 1;\n\n      for (var _i268 = 1; _i268 < lastIndex; ++_i268) {\n        var keep = false;\n        var time = times[_i268];\n        var timeNext = times[_i268 + 1]; // remove adjacent keyframes scheduled at the same time\n\n        if (time !== timeNext && (_i268 !== 1 || time !== times[0])) {\n          if (!smoothInterpolation) {\n            // remove unnecessary keyframes same as their neighbors\n            var offset = _i268 * stride,\n                offsetP = offset - stride,\n                offsetN = offset + stride;\n\n            for (var j = 0; j !== stride; ++j) {\n              var _value6 = values[offset + j];\n\n              if (_value6 !== values[offsetP + j] || _value6 !== values[offsetN + j]) {\n                keep = true;\n                break;\n              }\n            }\n          } else {\n            keep = true;\n          }\n        } // in-place compaction\n\n\n        if (keep) {\n          if (_i268 !== writeIndex) {\n            times[writeIndex] = times[_i268];\n            var readOffset = _i268 * stride,\n                writeOffset = writeIndex * stride;\n\n            for (var _j14 = 0; _j14 !== stride; ++_j14) {\n              values[writeOffset + _j14] = values[readOffset + _j14];\n            }\n          }\n\n          ++writeIndex;\n        }\n      } // flush last keyframe (compaction looks ahead)\n\n\n      if (lastIndex > 0) {\n        times[writeIndex] = times[lastIndex];\n\n        for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j15 = 0; _j15 !== stride; ++_j15) {\n          values[_writeOffset + _j15] = values[_readOffset + _j15];\n        }\n\n        ++writeIndex;\n      }\n\n      if (writeIndex !== times.length) {\n        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n      } else {\n        this.times = times;\n        this.values = values;\n      }\n\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      var times = AnimationUtils.arraySlice(this.times, 0);\n      var values = AnimationUtils.arraySlice(this.values, 0);\n      var TypedKeyframeTrack = this.constructor;\n      var track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.\n\n      track.createInterpolant = this.createInterpolant;\n      return track;\n    }\n  }], [{\n    key: "toJSON",\n    value: function toJSON(track) {\n      var trackType = track.constructor;\n      var json; // derived classes can define a static toJSON method\n\n      if (trackType.toJSON !== this.toJSON) {\n        json = trackType.toJSON(track);\n      } else {\n        // by default, we assume the data can be serialized as-is\n        json = {\n          \'name\': track.name,\n          \'times\': AnimationUtils.convertArray(track.times, Array),\n          \'values\': AnimationUtils.convertArray(track.values, Array)\n        };\n        var interpolation = track.getInterpolation();\n\n        if (interpolation !== track.DefaultInterpolation) {\n          json.interpolation = interpolation;\n        }\n      }\n\n      json.type = track.ValueTypeName; // mandatory\n\n      return json;\n    }\n  }]);\n\n  return KeyframeTrack;\n}();\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n/**\n * A Track of Boolean keyframe values.\n */\n\nvar BooleanKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(BooleanKeyframeTrack, _KeyframeTrack);\n\n  var _super103 = _createSuper(BooleanKeyframeTrack);\n\n  function BooleanKeyframeTrack() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, BooleanKeyframeTrack);\n\n    return _super103.apply(this, arguments);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(BooleanKeyframeTrack);\n}(KeyframeTrack);\n\nBooleanKeyframeTrack.prototype.ValueTypeName = \'bool\';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n/**\n * A Track of keyframe values that represent color.\n */\n\nvar ColorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ColorKeyframeTrack, _KeyframeTrack2);\n\n  var _super104 = _createSuper(ColorKeyframeTrack);\n\n  function ColorKeyframeTrack() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ColorKeyframeTrack);\n\n    return _super104.apply(this, arguments);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ColorKeyframeTrack);\n}(KeyframeTrack);\n\nColorKeyframeTrack.prototype.ValueTypeName = \'color\';\n/**\n * A Track of numeric keyframe values.\n */\n\nvar NumberKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(NumberKeyframeTrack, _KeyframeTrack3);\n\n  var _super105 = _createSuper(NumberKeyframeTrack);\n\n  function NumberKeyframeTrack() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, NumberKeyframeTrack);\n\n    return _super105.apply(this, arguments);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(NumberKeyframeTrack);\n}(KeyframeTrack);\n\nNumberKeyframeTrack.prototype.ValueTypeName = \'number\';\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nvar QuaternionLinearInterpolant = /*#__PURE__*/function (_Interpolant4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(QuaternionLinearInterpolant, _Interpolant4);\n\n  var _super106 = _createSuper(QuaternionLinearInterpolant);\n\n  function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, QuaternionLinearInterpolant);\n\n    return _super106.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(QuaternionLinearInterpolant, [{\n    key: "interpolate_",\n    value: function interpolate_(i1, t0, t, t1) {\n      var result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          alpha = (t - t0) / (t1 - t0);\n      var offset = i1 * stride;\n\n      for (var end = offset + stride; offset !== end; offset += 4) {\n        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\n      }\n\n      return result;\n    }\n  }]);\n\n  return QuaternionLinearInterpolant;\n}(Interpolant);\n/**\n * A Track of quaternion keyframe values.\n */\n\n\nvar QuaternionKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(QuaternionKeyframeTrack, _KeyframeTrack4);\n\n  var _super107 = _createSuper(QuaternionKeyframeTrack);\n\n  function QuaternionKeyframeTrack() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, QuaternionKeyframeTrack);\n\n    return _super107.apply(this, arguments);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(QuaternionKeyframeTrack, [{\n    key: "InterpolantFactoryMethodLinear",\n    value: function InterpolantFactoryMethodLinear(result) {\n      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\n    }\n  }]);\n\n  return QuaternionKeyframeTrack;\n}(KeyframeTrack);\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = \'quaternion\'; // ValueBufferType is inherited\n\nQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n/**\n * A Track that interpolates Strings\n */\n\nvar StringKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(StringKeyframeTrack, _KeyframeTrack5);\n\n  var _super108 = _createSuper(StringKeyframeTrack);\n\n  function StringKeyframeTrack() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, StringKeyframeTrack);\n\n    return _super108.apply(this, arguments);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(StringKeyframeTrack);\n}(KeyframeTrack);\n\nStringKeyframeTrack.prototype.ValueTypeName = \'string\';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n/**\n * A Track of vectored keyframe values.\n */\n\nvar VectorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(VectorKeyframeTrack, _KeyframeTrack6);\n\n  var _super109 = _createSuper(VectorKeyframeTrack);\n\n  function VectorKeyframeTrack() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, VectorKeyframeTrack);\n\n    return _super109.apply(this, arguments);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(VectorKeyframeTrack);\n}(KeyframeTrack);\n\nVectorKeyframeTrack.prototype.ValueTypeName = \'vector\';\n\nvar AnimationClip = /*#__PURE__*/function () {\n  function AnimationClip(name) {\n    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    var tracks = arguments.length > 2 ? arguments[2] : undefined;\n    var blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NormalAnimationBlendMode;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AnimationClip);\n\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = duration;\n    this.blendMode = blendMode;\n    this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks\n\n    if (this.duration < 0) {\n      this.resetDuration();\n    }\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AnimationClip, [{\n    key: "resetDuration",\n    value: function resetDuration() {\n      var tracks = this.tracks;\n      var duration = 0;\n\n      for (var _i269 = 0, n = tracks.length; _i269 !== n; ++_i269) {\n        var track = this.tracks[_i269];\n        duration = Math.max(duration, track.times[track.times.length - 1]);\n      }\n\n      this.duration = duration;\n      return this;\n    }\n  }, {\n    key: "trim",\n    value: function trim() {\n      for (var _i270 = 0; _i270 < this.tracks.length; _i270++) {\n        this.tracks[_i270].trim(0, this.duration);\n      }\n\n      return this;\n    }\n  }, {\n    key: "validate",\n    value: function validate() {\n      var valid = true;\n\n      for (var _i271 = 0; _i271 < this.tracks.length; _i271++) {\n        valid = valid && this.tracks[_i271].validate();\n      }\n\n      return valid;\n    }\n  }, {\n    key: "optimize",\n    value: function optimize() {\n      for (var _i272 = 0; _i272 < this.tracks.length; _i272++) {\n        this.tracks[_i272].optimize();\n      }\n\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      var tracks = [];\n\n      for (var _i273 = 0; _i273 < this.tracks.length; _i273++) {\n        tracks.push(this.tracks[_i273].clone());\n      }\n\n      return new this.constructor(this.name, this.duration, tracks, this.blendMode);\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      return this.constructor.toJSON(this);\n    }\n  }], [{\n    key: "parse",\n    value: function parse(json) {\n      var tracks = [],\n          jsonTracks = json.tracks,\n          frameTime = 1.0 / (json.fps || 1.0);\n\n      for (var _i274 = 0, n = jsonTracks.length; _i274 !== n; ++_i274) {\n        tracks.push(parseKeyframeTrack(jsonTracks[_i274]).scale(frameTime));\n      }\n\n      var clip = new this(json.name, json.duration, tracks, json.blendMode);\n      clip.uuid = json.uuid;\n      return clip;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(clip) {\n      var tracks = [],\n          clipTracks = clip.tracks;\n      var json = {\n        \'name\': clip.name,\n        \'duration\': clip.duration,\n        \'tracks\': tracks,\n        \'uuid\': clip.uuid,\n        \'blendMode\': clip.blendMode\n      };\n\n      for (var _i275 = 0, n = clipTracks.length; _i275 !== n; ++_i275) {\n        tracks.push(KeyframeTrack.toJSON(clipTracks[_i275]));\n      }\n\n      return json;\n    }\n  }, {\n    key: "CreateFromMorphTargetSequence",\n    value: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n      var numMorphTargets = morphTargetSequence.length;\n      var tracks = [];\n\n      for (var _i276 = 0; _i276 < numMorphTargets; _i276++) {\n        var times = [];\n        var values = [];\n        times.push((_i276 + numMorphTargets - 1) % numMorphTargets, _i276, (_i276 + 1) % numMorphTargets);\n        values.push(0, 1, 0);\n        var order = AnimationUtils.getKeyframeOrder(times);\n        times = AnimationUtils.sortedArray(times, 1, order);\n        values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the\n        // last frame as well for perfect loop.\n\n        if (!noLoop && times[0] === 0) {\n          times.push(numMorphTargets);\n          values.push(values[0]);\n        }\n\n        tracks.push(new NumberKeyframeTrack(\'.morphTargetInfluences[\' + morphTargetSequence[_i276].name + \']\', times, values).scale(1.0 / fps));\n      }\n\n      return new this(name, -1, tracks);\n    }\n  }, {\n    key: "findByName",\n    value: function findByName(objectOrClipArray, name) {\n      var clipArray = objectOrClipArray;\n\n      if (!Array.isArray(objectOrClipArray)) {\n        var o = objectOrClipArray;\n        clipArray = o.geometry && o.geometry.animations || o.animations;\n      }\n\n      for (var _i277 = 0; _i277 < clipArray.length; _i277++) {\n        if (clipArray[_i277].name === name) {\n          return clipArray[_i277];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: "CreateClipsFromMorphTargetSequences",\n    value: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n      var animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences\n      // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\n      var pattern = /^([\\w-]*?)([\\d]+)$/; // sort morph target names into animation groups based\n      // patterns like Walk_001, Walk_002, Run_001, Run_002\n\n      for (var _i278 = 0, il = morphTargets.length; _i278 < il; _i278++) {\n        var morphTarget = morphTargets[_i278];\n        var parts = morphTarget.name.match(pattern);\n\n        if (parts && parts.length > 1) {\n          var name = parts[1];\n          var animationMorphTargets = animationToMorphTargets[name];\n\n          if (!animationMorphTargets) {\n            animationToMorphTargets[name] = animationMorphTargets = [];\n          }\n\n          animationMorphTargets.push(morphTarget);\n        }\n      }\n\n      var clips = [];\n\n      for (var _name4 in animationToMorphTargets) {\n        clips.push(this.CreateFromMorphTargetSequence(_name4, animationToMorphTargets[_name4], fps, noLoop));\n      }\n\n      return clips;\n    } // parse the animation.hierarchy format\n\n  }, {\n    key: "parseAnimation",\n    value: function parseAnimation(animation, bones) {\n      if (!animation) {\n        console.error(\'THREE.AnimationClip: No animation in JSONLoader data.\');\n        return null;\n      }\n\n      var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {\n        // only return track if there are actually keys.\n        if (animationKeys.length !== 0) {\n          var times = [];\n          var values = [];\n          AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again\n\n          if (times.length !== 0) {\n            destTracks.push(new trackType(trackName, times, values));\n          }\n        }\n      };\n\n      var tracks = [];\n      var clipName = animation.name || \'default\';\n      var fps = animation.fps || 30;\n      var blendMode = animation.blendMode; // automatic length determination in AnimationClip.\n\n      var duration = animation.length || -1;\n      var hierarchyTracks = animation.hierarchy || [];\n\n      for (var h = 0; h < hierarchyTracks.length; h++) {\n        var animationKeys = hierarchyTracks[h].keys; // skip empty tracks\n\n        if (!animationKeys || animationKeys.length === 0) continue; // process morph targets\n\n        if (animationKeys[0].morphTargets) {\n          // figure out all morph targets used in this track\n          var morphTargetNames = {};\n          var k = void 0;\n\n          for (k = 0; k < animationKeys.length; k++) {\n            if (animationKeys[k].morphTargets) {\n              for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {\n                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n              }\n            }\n          } // create a track for each morph target with all zero\n          // morphTargetInfluences except for the keys in which\n          // the morphTarget is named.\n\n\n          for (var morphTargetName in morphTargetNames) {\n            var times = [];\n            var values = [];\n\n            for (var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m) {\n              var animationKey = animationKeys[k];\n              times.push(animationKey.time);\n              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n            }\n\n            tracks.push(new NumberKeyframeTrack(\'.morphTargetInfluence[\' + morphTargetName + \']\', times, values));\n          }\n\n          duration = morphTargetNames.length * fps;\n        } else {\n          // ...assume skeletal animation\n          var boneName = \'.bones[\' + bones[h].name + \']\';\n          addNonemptyTrack(VectorKeyframeTrack, boneName + \'.position\', animationKeys, \'pos\', tracks);\n          addNonemptyTrack(QuaternionKeyframeTrack, boneName + \'.quaternion\', animationKeys, \'rot\', tracks);\n          addNonemptyTrack(VectorKeyframeTrack, boneName + \'.scale\', animationKeys, \'scl\', tracks);\n        }\n      }\n\n      if (tracks.length === 0) {\n        return null;\n      }\n\n      var clip = new this(clipName, duration, tracks, blendMode);\n      return clip;\n    }\n  }]);\n\n  return AnimationClip;\n}();\n\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case \'scalar\':\n    case \'double\':\n    case \'float\':\n    case \'number\':\n    case \'integer\':\n      return NumberKeyframeTrack;\n\n    case \'vector\':\n    case \'vector2\':\n    case \'vector3\':\n    case \'vector4\':\n      return VectorKeyframeTrack;\n\n    case \'color\':\n      return ColorKeyframeTrack;\n\n    case \'quaternion\':\n      return QuaternionKeyframeTrack;\n\n    case \'bool\':\n    case \'boolean\':\n      return BooleanKeyframeTrack;\n\n    case \'string\':\n      return StringKeyframeTrack;\n  }\n\n  throw new Error(\'THREE.KeyframeTrack: Unsupported typeName: \' + typeName);\n}\n\nfunction parseKeyframeTrack(json) {\n  if (json.type === undefined) {\n    throw new Error(\'THREE.KeyframeTrack: track type undefined, can not parse\');\n  }\n\n  var trackType = getTrackTypeForValueTypeName(json.type);\n\n  if (json.times === undefined) {\n    var times = [],\n        values = [];\n    AnimationUtils.flattenJSON(json.keys, times, values, \'value\');\n    json.times = times;\n    json.values = values;\n  } // derived classes can define a static parse method\n\n\n  if (trackType.parse !== undefined) {\n    return trackType.parse(json);\n  } else {\n    // by default, we assume a constructor compatible with the base\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\n\nvar Cache = {\n  enabled: false,\n  files: {},\n  add: function add(key, file) {\n    if (this.enabled === false) return; // console.log( \'THREE.Cache\', \'Adding key:\', key );\n\n    this.files[key] = file;\n  },\n  get: function get(key) {\n    if (this.enabled === false) return; // console.log( \'THREE.Cache\', \'Checking key:\', key );\n\n    return this.files[key];\n  },\n  remove: function remove(key) {\n    delete this.files[key];\n  },\n  clear: function clear() {\n    this.files = {};\n  }\n};\n\nvar LoadingManager = /*#__PURE__*/(0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(function LoadingManager(onLoad, onProgress, onError) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LoadingManager);\n\n  var scope = this;\n  var isLoading = false;\n  var itemsLoaded = 0;\n  var itemsTotal = 0;\n  var urlModifier = undefined;\n  var handlers = []; // Refer to #5689 for the reason why we don\'t set .onStart\n  // in the constructor\n\n  this.onStart = undefined;\n  this.onLoad = onLoad;\n  this.onProgress = onProgress;\n  this.onError = onError;\n\n  this.itemStart = function (url) {\n    itemsTotal++;\n\n    if (isLoading === false) {\n      if (scope.onStart !== undefined) {\n        scope.onStart(url, itemsLoaded, itemsTotal);\n      }\n    }\n\n    isLoading = true;\n  };\n\n  this.itemEnd = function (url) {\n    itemsLoaded++;\n\n    if (scope.onProgress !== undefined) {\n      scope.onProgress(url, itemsLoaded, itemsTotal);\n    }\n\n    if (itemsLoaded === itemsTotal) {\n      isLoading = false;\n\n      if (scope.onLoad !== undefined) {\n        scope.onLoad();\n      }\n    }\n  };\n\n  this.itemError = function (url) {\n    if (scope.onError !== undefined) {\n      scope.onError(url);\n    }\n  };\n\n  this.resolveURL = function (url) {\n    if (urlModifier) {\n      return urlModifier(url);\n    }\n\n    return url;\n  };\n\n  this.setURLModifier = function (transform) {\n    urlModifier = transform;\n    return this;\n  };\n\n  this.addHandler = function (regex, loader) {\n    handlers.push(regex, loader);\n    return this;\n  };\n\n  this.removeHandler = function (regex) {\n    var index = handlers.indexOf(regex);\n\n    if (index !== -1) {\n      handlers.splice(index, 2);\n    }\n\n    return this;\n  };\n\n  this.getHandler = function (file) {\n    for (var _i279 = 0, l = handlers.length; _i279 < l; _i279 += 2) {\n      var regex = handlers[_i279];\n      var loader = handlers[_i279 + 1];\n      if (regex.global) regex.lastIndex = 0; // see #17920\n\n      if (regex.test(file)) {\n        return loader;\n      }\n    }\n\n    return null;\n  };\n});\n\nvar DefaultLoadingManager = new LoadingManager();\n\nvar Loader = /*#__PURE__*/function () {\n  function Loader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Loader);\n\n    this.manager = manager !== undefined ? manager : DefaultLoadingManager;\n    this.crossOrigin = \'anonymous\';\n    this.withCredentials = false;\n    this.path = \'\';\n    this.resourcePath = \'\';\n    this.requestHeader = {};\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Loader, [{\n    key: "load",\n    value: function\n      /* url, onLoad, onProgress, onError */\n    load() {}\n  }, {\n    key: "loadAsync",\n    value: function loadAsync(url, onProgress) {\n      var scope = this;\n      return new Promise(function (resolve, reject) {\n        scope.load(url, resolve, onProgress, reject);\n      });\n    }\n  }, {\n    key: "parse",\n    value: function\n      /* data */\n    parse() {}\n  }, {\n    key: "setCrossOrigin",\n    value: function setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n  }, {\n    key: "setWithCredentials",\n    value: function setWithCredentials(value) {\n      this.withCredentials = value;\n      return this;\n    }\n  }, {\n    key: "setPath",\n    value: function setPath(path) {\n      this.path = path;\n      return this;\n    }\n  }, {\n    key: "setResourcePath",\n    value: function setResourcePath(resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    }\n  }, {\n    key: "setRequestHeader",\n    value: function setRequestHeader(requestHeader) {\n      this.requestHeader = requestHeader;\n      return this;\n    }\n  }]);\n\n  return Loader;\n}();\n\nvar loading = {};\n\nvar FileLoader = /*#__PURE__*/function (_Loader) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(FileLoader, _Loader);\n\n  var _super110 = _createSuper(FileLoader);\n\n  function FileLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, FileLoader);\n\n    return _super110.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(FileLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this92 = this;\n\n      if (url === undefined) url = \'\';\n      if (this.path !== undefined) url = this.path + url;\n      url = this.manager.resolveURL(url);\n      var cached = Cache.get(url);\n\n      if (cached !== undefined) {\n        this.manager.itemStart(url);\n        setTimeout(function () {\n          if (onLoad) onLoad(cached);\n\n          _this92.manager.itemEnd(url);\n        }, 0);\n        return cached;\n      } // Check if request is duplicate\n\n\n      if (loading[url] !== undefined) {\n        loading[url].push({\n          onLoad: onLoad,\n          onProgress: onProgress,\n          onError: onError\n        });\n        return;\n      } // Initialise array for duplicate requests\n\n\n      loading[url] = [];\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      }); // create request\n\n      var req = new Request(url, {\n        headers: new Headers(this.requestHeader),\n        credentials: this.withCredentials ? \'include\' : \'same-origin\' // An abort controller could be added within a future PR\n\n      }); // record states ( avoid data race )\n\n      var mimeType = this.mimeType;\n      var responseType = this.responseType; // start the fetch\n\n      fetch(req).then(function (response) {\n        if (response.status === 200 || response.status === 0) {\n          // Some browsers return HTTP Status 0 when using non-http protocol\n          // e.g. \'file://\' or \'data://\'. Handle as success.\n          if (response.status === 0) {\n            console.warn(\'THREE.FileLoader: HTTP Status 0 received.\');\n          } // Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\n          if (typeof ReadableStream === \'undefined\' || response.body === undefined || response.body.getReader === undefined) {\n            return response;\n          }\n\n          var callbacks = loading[url];\n          var reader = response.body.getReader();\n          var contentLength = response.headers.get(\'Content-Length\');\n          var total = contentLength ? parseInt(contentLength) : 0;\n          var lengthComputable = total !== 0;\n          var loaded = 0; // periodically read data into the new stream tracking while download progress\n\n          var stream = new ReadableStream({\n            start: function start(controller) {\n              readData();\n\n              function readData() {\n                reader.read().then(function (_ref2) {\n                  var done = _ref2.done,\n                      value = _ref2.value;\n\n                  if (done) {\n                    controller.close();\n                  } else {\n                    loaded += value.byteLength;\n                    var event = new ProgressEvent(\'progress\', {\n                      lengthComputable: lengthComputable,\n                      loaded: loaded,\n                      total: total\n                    });\n\n                    for (var _i280 = 0, il = callbacks.length; _i280 < il; _i280++) {\n                      var callback = callbacks[_i280];\n                      if (callback.onProgress) callback.onProgress(event);\n                    }\n\n                    controller.enqueue(value);\n                    readData();\n                  }\n                });\n              }\n            }\n          });\n          return new Response(stream);\n        } else {\n          throw Error("fetch for \\"".concat(response.url, "\\" responded with ").concat(response.status, ": ").concat(response.statusText));\n        }\n      }).then(function (response) {\n        switch (responseType) {\n          case \'arraybuffer\':\n            return response.arrayBuffer();\n\n          case \'blob\':\n            return response.blob();\n\n          case \'document\':\n            return response.text().then(function (text) {\n              var parser = new DOMParser();\n              return parser.parseFromString(text, mimeType);\n            });\n\n          case \'json\':\n            return response.json();\n\n          default:\n            if (mimeType === undefined) {\n              return response.text();\n            } else {\n              // sniff encoding\n              var re = /charset="?([^;"\\s]*)"?/i;\n              var exec = re.exec(mimeType);\n              var label = exec && exec[1] ? exec[1].toLowerCase() : undefined;\n              var decoder = new TextDecoder(label);\n              return response.arrayBuffer().then(function (ab) {\n                return decoder.decode(ab);\n              });\n            }\n\n        }\n      }).then(function (data) {\n        // Add to cache only on HTTP success, so that we do not cache\n        // error response bodies as proper responses to requests.\n        Cache.add(url, data);\n        var callbacks = loading[url];\n        delete loading[url];\n\n        for (var _i281 = 0, il = callbacks.length; _i281 < il; _i281++) {\n          var callback = callbacks[_i281];\n          if (callback.onLoad) callback.onLoad(data);\n        }\n      }).catch(function (err) {\n        // Abort errors and other errors are handled the same\n        var callbacks = loading[url];\n\n        if (callbacks === undefined) {\n          // When onLoad was called and url was deleted in `loading`\n          _this92.manager.itemError(url);\n\n          throw err;\n        }\n\n        delete loading[url];\n\n        for (var _i282 = 0, il = callbacks.length; _i282 < il; _i282++) {\n          var callback = callbacks[_i282];\n          if (callback.onError) callback.onError(err);\n        }\n\n        _this92.manager.itemError(url);\n      }).finally(function () {\n        _this92.manager.itemEnd(url);\n      });\n      this.manager.itemStart(url);\n    }\n  }, {\n    key: "setResponseType",\n    value: function setResponseType(value) {\n      this.responseType = value;\n      return this;\n    }\n  }, {\n    key: "setMimeType",\n    value: function setMimeType(value) {\n      this.mimeType = value;\n      return this;\n    }\n  }]);\n\n  return FileLoader;\n}(Loader);\n\nvar AnimationLoader = /*#__PURE__*/function (_Loader2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(AnimationLoader, _Loader2);\n\n  var _super111 = _createSuper(AnimationLoader);\n\n  function AnimationLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AnimationLoader);\n\n    return _super111.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AnimationLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(JSON.parse(text)));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: "parse",\n    value: function parse(json) {\n      var animations = [];\n\n      for (var _i283 = 0; _i283 < json.length; _i283++) {\n        var clip = AnimationClip.parse(json[_i283]);\n        animations.push(clip);\n      }\n\n      return animations;\n    }\n  }]);\n\n  return AnimationLoader;\n}(Loader);\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\n\nvar CompressedTextureLoader = /*#__PURE__*/function (_Loader3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CompressedTextureLoader, _Loader3);\n\n  var _super112 = _createSuper(CompressedTextureLoader);\n\n  function CompressedTextureLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CompressedTextureLoader);\n\n    return _super112.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CompressedTextureLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var images = [];\n      var texture = new CompressedTexture();\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\'arraybuffer\');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      var loaded = 0;\n\n      function loadTexture(i) {\n        loader.load(url[i], function (buffer) {\n          var texDatas = scope.parse(buffer, true);\n          images[i] = {\n            width: texDatas.width,\n            height: texDatas.height,\n            format: texDatas.format,\n            mipmaps: texDatas.mipmaps\n          };\n          loaded += 1;\n\n          if (loaded === 6) {\n            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n            texture.image = images;\n            texture.format = texDatas.format;\n            texture.needsUpdate = true;\n            if (onLoad) onLoad(texture);\n          }\n        }, onProgress, onError);\n      }\n\n      if (Array.isArray(url)) {\n        for (var _i284 = 0, il = url.length; _i284 < il; ++_i284) {\n          loadTexture(_i284);\n        }\n      } else {\n        // compressed cubemap texture stored in a single DDS file\n        loader.load(url, function (buffer) {\n          var texDatas = scope.parse(buffer, true);\n\n          if (texDatas.isCubemap) {\n            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n            for (var f = 0; f < faces; f++) {\n              images[f] = {\n                mipmaps: []\n              };\n\n              for (var _i285 = 0; _i285 < texDatas.mipmapCount; _i285++) {\n                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i285]);\n                images[f].format = texDatas.format;\n                images[f].width = texDatas.width;\n                images[f].height = texDatas.height;\n              }\n            }\n\n            texture.image = images;\n          } else {\n            texture.image.width = texDatas.width;\n            texture.image.height = texDatas.height;\n            texture.mipmaps = texDatas.mipmaps;\n          }\n\n          if (texDatas.mipmapCount === 1) {\n            texture.minFilter = LinearFilter;\n          }\n\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }, onProgress, onError);\n      }\n\n      return texture;\n    }\n  }]);\n\n  return CompressedTextureLoader;\n}(Loader);\n\nvar ImageLoader = /*#__PURE__*/function (_Loader4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ImageLoader, _Loader4);\n\n  var _super113 = _createSuper(ImageLoader);\n\n  function ImageLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ImageLoader);\n\n    return _super113.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ImageLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      if (this.path !== undefined) url = this.path + url;\n      url = this.manager.resolveURL(url);\n      var scope = this;\n      var cached = Cache.get(url);\n\n      if (cached !== undefined) {\n        scope.manager.itemStart(url);\n        setTimeout(function () {\n          if (onLoad) onLoad(cached);\n          scope.manager.itemEnd(url);\n        }, 0);\n        return cached;\n      }\n\n      var image = createElementNS(\'img\');\n\n      function onImageLoad() {\n        removeEventListeners();\n        Cache.add(url, this);\n        if (onLoad) onLoad(this);\n        scope.manager.itemEnd(url);\n      }\n\n      function onImageError(event) {\n        removeEventListeners();\n        if (onError) onError(event);\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      }\n\n      function removeEventListeners() {\n        image.removeEventListener(\'load\', onImageLoad, false);\n        image.removeEventListener(\'error\', onImageError, false);\n      }\n\n      image.addEventListener(\'load\', onImageLoad, false);\n      image.addEventListener(\'error\', onImageError, false);\n\n      if (url.slice(0, 5) !== \'data:\') {\n        if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n      }\n\n      scope.manager.itemStart(url);\n      image.src = url;\n      return image;\n    }\n  }]);\n\n  return ImageLoader;\n}(Loader);\n\nvar CubeTextureLoader = /*#__PURE__*/function (_Loader5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CubeTextureLoader, _Loader5);\n\n  var _super114 = _createSuper(CubeTextureLoader);\n\n  function CubeTextureLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CubeTextureLoader);\n\n    return _super114.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CubeTextureLoader, [{\n    key: "load",\n    value: function load(urls, onLoad, onProgress, onError) {\n      var texture = new CubeTexture();\n      var loader = new ImageLoader(this.manager);\n      loader.setCrossOrigin(this.crossOrigin);\n      loader.setPath(this.path);\n      var loaded = 0;\n\n      function loadTexture(i) {\n        loader.load(urls[i], function (image) {\n          texture.images[i] = image;\n          loaded++;\n\n          if (loaded === 6) {\n            texture.needsUpdate = true;\n            if (onLoad) onLoad(texture);\n          }\n        }, undefined, onError);\n      }\n\n      for (var _i286 = 0; _i286 < urls.length; ++_i286) {\n        loadTexture(_i286);\n      }\n\n      return texture;\n    }\n  }]);\n\n  return CubeTextureLoader;\n}(Loader);\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\n\nvar DataTextureLoader = /*#__PURE__*/function (_Loader6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DataTextureLoader, _Loader6);\n\n  var _super115 = _createSuper(DataTextureLoader);\n\n  function DataTextureLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DataTextureLoader);\n\n    return _super115.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DataTextureLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var texture = new DataTexture();\n      var loader = new FileLoader(this.manager);\n      loader.setResponseType(\'arraybuffer\');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setPath(this.path);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (buffer) {\n        var texData = scope.parse(buffer);\n        if (!texData) return;\n\n        if (texData.image !== undefined) {\n          texture.image = texData.image;\n        } else if (texData.data !== undefined) {\n          texture.image.width = texData.width;\n          texture.image.height = texData.height;\n          texture.image.data = texData.data;\n        }\n\n        texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n        texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n        texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n        texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n        texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n        if (texData.encoding !== undefined) {\n          texture.encoding = texData.encoding;\n        }\n\n        if (texData.flipY !== undefined) {\n          texture.flipY = texData.flipY;\n        }\n\n        if (texData.format !== undefined) {\n          texture.format = texData.format;\n        }\n\n        if (texData.type !== undefined) {\n          texture.type = texData.type;\n        }\n\n        if (texData.mipmaps !== undefined) {\n          texture.mipmaps = texData.mipmaps;\n          texture.minFilter = LinearMipmapLinearFilter; // presumably...\n        }\n\n        if (texData.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n\n        if (texData.generateMipmaps !== undefined) {\n          texture.generateMipmaps = texData.generateMipmaps;\n        }\n\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture, texData);\n      }, onProgress, onError);\n      return texture;\n    }\n  }]);\n\n  return DataTextureLoader;\n}(Loader);\n\nvar TextureLoader = /*#__PURE__*/function (_Loader7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(TextureLoader, _Loader7);\n\n  var _super116 = _createSuper(TextureLoader);\n\n  function TextureLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, TextureLoader);\n\n    return _super116.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(TextureLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var texture = new Texture();\n      var loader = new ImageLoader(this.manager);\n      loader.setCrossOrigin(this.crossOrigin);\n      loader.setPath(this.path);\n      loader.load(url, function (image) {\n        texture.image = image;\n        texture.needsUpdate = true;\n\n        if (onLoad !== undefined) {\n          onLoad(texture);\n        }\n      }, onProgress, onError);\n      return texture;\n    }\n  }]);\n\n  return TextureLoader;\n}(Loader);\n\nvar Light = /*#__PURE__*/function (_Object3D11) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Light, _Object3D11);\n\n  var _super117 = _createSuper(Light);\n\n  function Light(color) {\n    var _this93;\n\n    var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Light);\n\n    _this93 = _super117.call(this);\n    _this93.isLight = true;\n    _this93.type = \'Light\';\n    _this93.color = new Color(color);\n    _this93.intensity = intensity;\n    return _this93;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Light, [{\n    key: "dispose",\n    value: function dispose() {// Empty here in base class; some subclasses override.\n    }\n  }, {\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Light.prototype), "copy", this).call(this, source, recursive);\n\n      this.color.copy(source.color);\n      this.intensity = source.intensity;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Light.prototype), "toJSON", this).call(this, meta);\n\n      data.object.color = this.color.getHex();\n      data.object.intensity = this.intensity;\n      if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();\n      if (this.distance !== undefined) data.object.distance = this.distance;\n      if (this.angle !== undefined) data.object.angle = this.angle;\n      if (this.decay !== undefined) data.object.decay = this.decay;\n      if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;\n      if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();\n      return data;\n    }\n  }]);\n\n  return Light;\n}(Object3D);\n\nvar HemisphereLight = /*#__PURE__*/function (_Light) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(HemisphereLight, _Light);\n\n  var _super118 = _createSuper(HemisphereLight);\n\n  function HemisphereLight(skyColor, groundColor, intensity) {\n    var _this94;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, HemisphereLight);\n\n    _this94 = _super118.call(this, skyColor, intensity);\n    _this94.isHemisphereLight = true;\n    _this94.type = \'HemisphereLight\';\n\n    _this94.position.copy(Object3D.DefaultUp);\n\n    _this94.updateMatrix();\n\n    _this94.groundColor = new Color(groundColor);\n    return _this94;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(HemisphereLight, [{\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(HemisphereLight.prototype), "copy", this).call(this, source, recursive);\n\n      this.groundColor.copy(source.groundColor);\n      return this;\n    }\n  }]);\n\n  return HemisphereLight;\n}(Light);\n\nvar _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();\n\nvar _lightPositionWorld$1 = /*@__PURE__*/new Vector3();\n\nvar _lookTarget$1 = /*@__PURE__*/new Vector3();\n\nvar LightShadow = /*#__PURE__*/function () {\n  function LightShadow(camera) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LightShadow);\n\n    this.camera = camera;\n    this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n    this.blurSamples = 8;\n    this.mapSize = new Vector2(512, 512);\n    this.map = null;\n    this.mapPass = null;\n    this.matrix = new Matrix4();\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n    this._frustum = new Frustum();\n    this._frameExtents = new Vector2(1, 1);\n    this._viewportCount = 1;\n    this._viewports = [new Vector4(0, 0, 1, 1)];\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LightShadow, [{\n    key: "getViewportCount",\n    value: function getViewportCount() {\n      return this._viewportCount;\n    }\n  }, {\n    key: "getFrustum",\n    value: function getFrustum() {\n      return this._frustum;\n    }\n  }, {\n    key: "updateMatrices",\n    value: function updateMatrices(light) {\n      var shadowCamera = this.camera;\n      var shadowMatrix = this.matrix;\n\n      _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n\n      shadowCamera.position.copy(_lightPositionWorld$1);\n\n      _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n\n      shadowCamera.lookAt(_lookTarget$1);\n      shadowCamera.updateMatrixWorld();\n\n      _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n\n      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n\n      shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      shadowMatrix.multiply(shadowCamera.projectionMatrix);\n      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n    }\n  }, {\n    key: "getViewport",\n    value: function getViewport(viewportIndex) {\n      return this._viewports[viewportIndex];\n    }\n  }, {\n    key: "getFrameExtents",\n    value: function getFrameExtents() {\n      return this._frameExtents;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      if (this.map) {\n        this.map.dispose();\n      }\n\n      if (this.mapPass) {\n        this.mapPass.dispose();\n      }\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      this.camera = source.camera.clone();\n      this.bias = source.bias;\n      this.radius = source.radius;\n      this.mapSize.copy(source.mapSize);\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var object = {};\n      if (this.bias !== 0) object.bias = this.bias;\n      if (this.normalBias !== 0) object.normalBias = this.normalBias;\n      if (this.radius !== 1) object.radius = this.radius;\n      if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();\n      object.camera = this.camera.toJSON(false).object;\n      delete object.camera.matrix;\n      return object;\n    }\n  }]);\n\n  return LightShadow;\n}();\n\nvar SpotLightShadow = /*#__PURE__*/function (_LightShadow) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(SpotLightShadow, _LightShadow);\n\n  var _super119 = _createSuper(SpotLightShadow);\n\n  function SpotLightShadow() {\n    var _this95;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SpotLightShadow);\n\n    _this95 = _super119.call(this, new PerspectiveCamera(50, 1, 0.5, 500));\n    _this95.isSpotLightShadow = true;\n    _this95.focus = 1;\n    return _this95;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SpotLightShadow, [{\n    key: "updateMatrices",\n    value: function updateMatrices(light) {\n      var camera = this.camera;\n      var fov = RAD2DEG * 2 * light.angle * this.focus;\n      var aspect = this.mapSize.width / this.mapSize.height;\n      var far = light.distance || camera.far;\n\n      if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {\n        camera.fov = fov;\n        camera.aspect = aspect;\n        camera.far = far;\n        camera.updateProjectionMatrix();\n      }\n\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SpotLightShadow.prototype), "updateMatrices", this).call(this, light);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SpotLightShadow.prototype), "copy", this).call(this, source);\n\n      this.focus = source.focus;\n      return this;\n    }\n  }]);\n\n  return SpotLightShadow;\n}(LightShadow);\n\nvar SpotLight = /*#__PURE__*/function (_Light2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(SpotLight, _Light2);\n\n  var _super120 = _createSuper(SpotLight);\n\n  function SpotLight(color, intensity) {\n    var _this96;\n\n    var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var angle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI / 3;\n    var penumbra = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var decay = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SpotLight);\n\n    _this96 = _super120.call(this, color, intensity);\n    _this96.isSpotLight = true;\n    _this96.type = \'SpotLight\';\n\n    _this96.position.copy(Object3D.DefaultUp);\n\n    _this96.updateMatrix();\n\n    _this96.target = new Object3D();\n    _this96.distance = distance;\n    _this96.angle = angle;\n    _this96.penumbra = penumbra;\n    _this96.decay = decay; // for physically correct lights, should be 2.\n\n    _this96.shadow = new SpotLightShadow();\n    return _this96;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SpotLight, [{\n    key: "power",\n    get: function get() {\n      // compute the light\'s luminous power (in lumens) from its intensity (in candela)\n      // by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)\n      return this.intensity * Math.PI;\n    },\n    set: function set(power) {\n      // set the light\'s intensity (in candela) from the desired luminous power (in lumens)\n      this.intensity = power / Math.PI;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.shadow.dispose();\n    }\n  }, {\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SpotLight.prototype), "copy", this).call(this, source, recursive);\n\n      this.distance = source.distance;\n      this.angle = source.angle;\n      this.penumbra = source.penumbra;\n      this.decay = source.decay;\n      this.target = source.target.clone();\n      this.shadow = source.shadow.clone();\n      return this;\n    }\n  }]);\n\n  return SpotLight;\n}(Light);\n\nvar _projScreenMatrix = /*@__PURE__*/new Matrix4();\n\nvar _lightPositionWorld = /*@__PURE__*/new Vector3();\n\nvar _lookTarget = /*@__PURE__*/new Vector3();\n\nvar PointLightShadow = /*#__PURE__*/function (_LightShadow2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PointLightShadow, _LightShadow2);\n\n  var _super121 = _createSuper(PointLightShadow);\n\n  function PointLightShadow() {\n    var _this97;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PointLightShadow);\n\n    _this97 = _super121.call(this, new PerspectiveCamera(90, 1, 0.5, 500));\n    _this97.isPointLightShadow = true;\n    _this97._frameExtents = new Vector2(4, 2);\n    _this97._viewportCount = 6;\n    _this97._viewports = [// These viewports map a cube-map onto a 2D texture with the\n    // following orientation:\n    //\n    //  xzXZ\n    //   y Y\n    //\n    // X - Positive x direction\n    // x - Negative x direction\n    // Y - Positive y direction\n    // y - Negative y direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    // positive X\n    new Vector4(2, 1, 1, 1), // negative X\n    new Vector4(0, 1, 1, 1), // positive Z\n    new Vector4(3, 1, 1, 1), // negative Z\n    new Vector4(1, 1, 1, 1), // positive Y\n    new Vector4(3, 0, 1, 1), // negative Y\n    new Vector4(1, 0, 1, 1)];\n    _this97._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];\n    _this97._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];\n    return _this97;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PointLightShadow, [{\n    key: "updateMatrices",\n    value: function updateMatrices(light) {\n      var viewportIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var camera = this.camera;\n      var shadowMatrix = this.matrix;\n      var far = light.distance || camera.far;\n\n      if (far !== camera.far) {\n        camera.far = far;\n        camera.updateProjectionMatrix();\n      }\n\n      _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n\n      camera.position.copy(_lightPositionWorld);\n\n      _lookTarget.copy(camera.position);\n\n      _lookTarget.add(this._cubeDirections[viewportIndex]);\n\n      camera.up.copy(this._cubeUps[viewportIndex]);\n      camera.lookAt(_lookTarget);\n      camera.updateMatrixWorld();\n      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\n\n      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n      this._frustum.setFromProjectionMatrix(_projScreenMatrix);\n    }\n  }]);\n\n  return PointLightShadow;\n}(LightShadow);\n\nvar PointLight = /*#__PURE__*/function (_Light3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PointLight, _Light3);\n\n  var _super122 = _createSuper(PointLight);\n\n  function PointLight(color, intensity) {\n    var _this98;\n\n    var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var decay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PointLight);\n\n    _this98 = _super122.call(this, color, intensity);\n    _this98.isPointLight = true;\n    _this98.type = \'PointLight\';\n    _this98.distance = distance;\n    _this98.decay = decay; // for physically correct lights, should be 2.\n\n    _this98.shadow = new PointLightShadow();\n    return _this98;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PointLight, [{\n    key: "power",\n    get: function get() {\n      // compute the light\'s luminous power (in lumens) from its intensity (in candela)\n      // for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)\n      return this.intensity * 4 * Math.PI;\n    },\n    set: function set(power) {\n      // set the light\'s intensity (in candela) from the desired luminous power (in lumens)\n      this.intensity = power / (4 * Math.PI);\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.shadow.dispose();\n    }\n  }, {\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(PointLight.prototype), "copy", this).call(this, source, recursive);\n\n      this.distance = source.distance;\n      this.decay = source.decay;\n      this.shadow = source.shadow.clone();\n      return this;\n    }\n  }]);\n\n  return PointLight;\n}(Light);\n\nvar DirectionalLightShadow = /*#__PURE__*/function (_LightShadow3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DirectionalLightShadow, _LightShadow3);\n\n  var _super123 = _createSuper(DirectionalLightShadow);\n\n  function DirectionalLightShadow() {\n    var _this99;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DirectionalLightShadow);\n\n    _this99 = _super123.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n    _this99.isDirectionalLightShadow = true;\n    return _this99;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DirectionalLightShadow);\n}(LightShadow);\n\nvar DirectionalLight = /*#__PURE__*/function (_Light4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DirectionalLight, _Light4);\n\n  var _super124 = _createSuper(DirectionalLight);\n\n  function DirectionalLight(color, intensity) {\n    var _this100;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DirectionalLight);\n\n    _this100 = _super124.call(this, color, intensity);\n    _this100.isDirectionalLight = true;\n    _this100.type = \'DirectionalLight\';\n\n    _this100.position.copy(Object3D.DefaultUp);\n\n    _this100.updateMatrix();\n\n    _this100.target = new Object3D();\n    _this100.shadow = new DirectionalLightShadow();\n    return _this100;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DirectionalLight, [{\n    key: "dispose",\n    value: function dispose() {\n      this.shadow.dispose();\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(DirectionalLight.prototype), "copy", this).call(this, source);\n\n      this.target = source.target.clone();\n      this.shadow = source.shadow.clone();\n      return this;\n    }\n  }]);\n\n  return DirectionalLight;\n}(Light);\n\nvar AmbientLight = /*#__PURE__*/function (_Light5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(AmbientLight, _Light5);\n\n  var _super125 = _createSuper(AmbientLight);\n\n  function AmbientLight(color, intensity) {\n    var _this101;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AmbientLight);\n\n    _this101 = _super125.call(this, color, intensity);\n    _this101.isAmbientLight = true;\n    _this101.type = \'AmbientLight\';\n    return _this101;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AmbientLight);\n}(Light);\n\nvar RectAreaLight = /*#__PURE__*/function (_Light6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(RectAreaLight, _Light6);\n\n  var _super126 = _createSuper(RectAreaLight);\n\n  function RectAreaLight(color, intensity) {\n    var _this102;\n\n    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, RectAreaLight);\n\n    _this102 = _super126.call(this, color, intensity);\n    _this102.isRectAreaLight = true;\n    _this102.type = \'RectAreaLight\';\n    _this102.width = width;\n    _this102.height = height;\n    return _this102;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(RectAreaLight, [{\n    key: "power",\n    get: function get() {\n      // compute the light\'s luminous power (in lumens) from its intensity (in nits)\n      return this.intensity * this.width * this.height * Math.PI;\n    },\n    set: function set(power) {\n      // set the light\'s intensity (in nits) from the desired luminous power (in lumens)\n      this.intensity = power / (this.width * this.height * Math.PI);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(RectAreaLight.prototype), "copy", this).call(this, source);\n\n      this.width = source.width;\n      this.height = source.height;\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(RectAreaLight.prototype), "toJSON", this).call(this, meta);\n\n      data.object.width = this.width;\n      data.object.height = this.height;\n      return data;\n    }\n  }]);\n\n  return RectAreaLight;\n}(Light);\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n// 3-band SH defined by 9 coefficients\n\n\nvar SphericalHarmonics3 = /*#__PURE__*/function () {\n  function SphericalHarmonics3() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SphericalHarmonics3);\n\n    this.isSphericalHarmonics3 = true;\n    this.coefficients = [];\n\n    for (var _i287 = 0; _i287 < 9; _i287++) {\n      this.coefficients.push(new Vector3());\n    }\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SphericalHarmonics3, [{\n    key: "set",\n    value: function set(coefficients) {\n      for (var _i288 = 0; _i288 < 9; _i288++) {\n        this.coefficients[_i288].copy(coefficients[_i288]);\n      }\n\n      return this;\n    }\n  }, {\n    key: "zero",\n    value: function zero() {\n      for (var _i289 = 0; _i289 < 9; _i289++) {\n        this.coefficients[_i289].set(0, 0, 0);\n      }\n\n      return this;\n    } // get the radiance in the direction of the normal\n    // target is a Vector3\n\n  }, {\n    key: "getAt",\n    value: function getAt(normal, target) {\n      // normal is assumed to be unit length\n      var x = normal.x,\n          y = normal.y,\n          z = normal.z;\n      var coeff = this.coefficients; // band 0\n\n      target.copy(coeff[0]).multiplyScalar(0.282095); // band 1\n\n      target.addScaledVector(coeff[1], 0.488603 * y);\n      target.addScaledVector(coeff[2], 0.488603 * z);\n      target.addScaledVector(coeff[3], 0.488603 * x); // band 2\n\n      target.addScaledVector(coeff[4], 1.092548 * (x * y));\n      target.addScaledVector(coeff[5], 1.092548 * (y * z));\n      target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\n      target.addScaledVector(coeff[7], 1.092548 * (x * z));\n      target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n      return target;\n    } // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n    // target is a Vector3\n    // https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\n  }, {\n    key: "getIrradianceAt",\n    value: function getIrradianceAt(normal, target) {\n      // normal is assumed to be unit length\n      var x = normal.x,\n          y = normal.y,\n          z = normal.z;\n      var coeff = this.coefficients; // band 0\n\n      target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095\n      // band 1\n\n      target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603\n\n      target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);\n      target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2\n\n      target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548\n\n      target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);\n      target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3\n\n      target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);\n      target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274\n\n      return target;\n    }\n  }, {\n    key: "add",\n    value: function add(sh) {\n      for (var _i290 = 0; _i290 < 9; _i290++) {\n        this.coefficients[_i290].add(sh.coefficients[_i290]);\n      }\n\n      return this;\n    }\n  }, {\n    key: "addScaledSH",\n    value: function addScaledSH(sh, s) {\n      for (var _i291 = 0; _i291 < 9; _i291++) {\n        this.coefficients[_i291].addScaledVector(sh.coefficients[_i291], s);\n      }\n\n      return this;\n    }\n  }, {\n    key: "scale",\n    value: function scale(s) {\n      for (var _i292 = 0; _i292 < 9; _i292++) {\n        this.coefficients[_i292].multiplyScalar(s);\n      }\n\n      return this;\n    }\n  }, {\n    key: "lerp",\n    value: function lerp(sh, alpha) {\n      for (var _i293 = 0; _i293 < 9; _i293++) {\n        this.coefficients[_i293].lerp(sh.coefficients[_i293], alpha);\n      }\n\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(sh) {\n      for (var _i294 = 0; _i294 < 9; _i294++) {\n        if (!this.coefficients[_i294].equals(sh.coefficients[_i294])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: "copy",\n    value: function copy(sh) {\n      return this.set(sh.coefficients);\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "fromArray",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var coefficients = this.coefficients;\n\n      for (var _i295 = 0; _i295 < 9; _i295++) {\n        coefficients[_i295].fromArray(array, offset + _i295 * 3);\n      }\n\n      return this;\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var coefficients = this.coefficients;\n\n      for (var _i296 = 0; _i296 < 9; _i296++) {\n        coefficients[_i296].toArray(array, offset + _i296 * 3);\n      }\n\n      return array;\n    } // evaluate the basis functions\n    // shBasis is an Array[ 9 ]\n\n  }], [{\n    key: "getBasisAt",\n    value: function getBasisAt(normal, shBasis) {\n      // normal is assumed to be unit length\n      var x = normal.x,\n          y = normal.y,\n          z = normal.z; // band 0\n\n      shBasis[0] = 0.282095; // band 1\n\n      shBasis[1] = 0.488603 * y;\n      shBasis[2] = 0.488603 * z;\n      shBasis[3] = 0.488603 * x; // band 2\n\n      shBasis[4] = 1.092548 * x * y;\n      shBasis[5] = 1.092548 * y * z;\n      shBasis[6] = 0.315392 * (3 * z * z - 1);\n      shBasis[7] = 1.092548 * x * z;\n      shBasis[8] = 0.546274 * (x * x - y * y);\n    }\n  }]);\n\n  return SphericalHarmonics3;\n}();\n\nvar LightProbe = /*#__PURE__*/function (_Light7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(LightProbe, _Light7);\n\n  var _super127 = _createSuper(LightProbe);\n\n  function LightProbe() {\n    var _this103;\n\n    var sh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new SphericalHarmonics3();\n    var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LightProbe);\n\n    _this103 = _super127.call(this, undefined, intensity);\n    _this103.isLightProbe = true;\n    _this103.sh = sh;\n    return _this103;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LightProbe, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LightProbe.prototype), "copy", this).call(this, source);\n\n      this.sh.copy(source.sh);\n      return this;\n    }\n  }, {\n    key: "fromJSON",\n    value: function fromJSON(json) {\n      this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\n      this.sh.fromArray(json.sh);\n      return this;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(meta) {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(LightProbe.prototype), "toJSON", this).call(this, meta);\n\n      data.object.sh = this.sh.toArray();\n      return data;\n    }\n  }]);\n\n  return LightProbe;\n}(Light);\n\nvar MaterialLoader = /*#__PURE__*/function (_Loader8) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(MaterialLoader, _Loader8);\n\n  var _super128 = _createSuper(MaterialLoader);\n\n  function MaterialLoader(manager) {\n    var _this104;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, MaterialLoader);\n\n    _this104 = _super128.call(this, manager);\n    _this104.textures = {};\n    return _this104;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(MaterialLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(JSON.parse(text)));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: "parse",\n    value: function parse(json) {\n      var textures = this.textures;\n\n      function getTexture(name) {\n        if (textures[name] === undefined) {\n          console.warn(\'THREE.MaterialLoader: Undefined texture\', name);\n        }\n\n        return textures[name];\n      }\n\n      var material = Material.fromType(json.type);\n      if (json.uuid !== undefined) material.uuid = json.uuid;\n      if (json.name !== undefined) material.name = json.name;\n      if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);\n      if (json.roughness !== undefined) material.roughness = json.roughness;\n      if (json.metalness !== undefined) material.metalness = json.metalness;\n      if (json.sheen !== undefined) material.sheen = json.sheen;\n      if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);\n      if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;\n      if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);\n      if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);\n      if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;\n      if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);\n      if (json.shininess !== undefined) material.shininess = json.shininess;\n      if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;\n      if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;\n      if (json.iridescence !== undefined) material.iridescence = json.iridescence;\n      if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;\n      if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;\n      if (json.transmission !== undefined) material.transmission = json.transmission;\n      if (json.thickness !== undefined) material.thickness = json.thickness;\n      if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;\n      if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);\n      if (json.fog !== undefined) material.fog = json.fog;\n      if (json.flatShading !== undefined) material.flatShading = json.flatShading;\n      if (json.blending !== undefined) material.blending = json.blending;\n      if (json.combine !== undefined) material.combine = json.combine;\n      if (json.side !== undefined) material.side = json.side;\n      if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;\n      if (json.opacity !== undefined) material.opacity = json.opacity;\n      if (json.transparent !== undefined) material.transparent = json.transparent;\n      if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;\n      if (json.depthTest !== undefined) material.depthTest = json.depthTest;\n      if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;\n      if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;\n      if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;\n      if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;\n      if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;\n      if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;\n      if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;\n      if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;\n      if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;\n      if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;\n      if (json.wireframe !== undefined) material.wireframe = json.wireframe;\n      if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;\n      if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;\n      if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;\n      if (json.rotation !== undefined) material.rotation = json.rotation;\n      if (json.linewidth !== 1) material.linewidth = json.linewidth;\n      if (json.dashSize !== undefined) material.dashSize = json.dashSize;\n      if (json.gapSize !== undefined) material.gapSize = json.gapSize;\n      if (json.scale !== undefined) material.scale = json.scale;\n      if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;\n      if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;\n      if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;\n      if (json.dithering !== undefined) material.dithering = json.dithering;\n      if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;\n      if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;\n      if (json.visible !== undefined) material.visible = json.visible;\n      if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;\n      if (json.userData !== undefined) material.userData = json.userData;\n\n      if (json.vertexColors !== undefined) {\n        if (typeof json.vertexColors === \'number\') {\n          material.vertexColors = json.vertexColors > 0 ? true : false;\n        } else {\n          material.vertexColors = json.vertexColors;\n        }\n      } // Shader Material\n\n\n      if (json.uniforms !== undefined) {\n        for (var name in json.uniforms) {\n          var uniform = json.uniforms[name];\n          material.uniforms[name] = {};\n\n          switch (uniform.type) {\n            case \'t\':\n              material.uniforms[name].value = getTexture(uniform.value);\n              break;\n\n            case \'c\':\n              material.uniforms[name].value = new Color().setHex(uniform.value);\n              break;\n\n            case \'v2\':\n              material.uniforms[name].value = new Vector2().fromArray(uniform.value);\n              break;\n\n            case \'v3\':\n              material.uniforms[name].value = new Vector3().fromArray(uniform.value);\n              break;\n\n            case \'v4\':\n              material.uniforms[name].value = new Vector4().fromArray(uniform.value);\n              break;\n\n            case \'m3\':\n              material.uniforms[name].value = new Matrix3().fromArray(uniform.value);\n              break;\n\n            case \'m4\':\n              material.uniforms[name].value = new Matrix4().fromArray(uniform.value);\n              break;\n\n            default:\n              material.uniforms[name].value = uniform.value;\n          }\n        }\n      }\n\n      if (json.defines !== undefined) material.defines = json.defines;\n      if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;\n      if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;\n\n      if (json.extensions !== undefined) {\n        for (var key in json.extensions) {\n          material.extensions[key] = json.extensions[key];\n        }\n      } // Deprecated\n\n\n      if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading\n      // for PointsMaterial\n\n      if (json.size !== undefined) material.size = json.size;\n      if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps\n\n      if (json.map !== undefined) material.map = getTexture(json.map);\n      if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);\n      if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);\n      if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);\n      if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;\n      if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);\n      if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;\n\n      if (json.normalScale !== undefined) {\n        var normalScale = json.normalScale;\n\n        if (Array.isArray(normalScale) === false) {\n          // Blender exporter used to export a scalar. See #7459\n          normalScale = [normalScale, normalScale];\n        }\n\n        material.normalScale = new Vector2().fromArray(normalScale);\n      }\n\n      if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);\n      if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;\n      if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;\n      if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);\n      if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);\n      if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);\n      if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;\n      if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);\n      if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);\n      if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);\n      if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);\n      if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;\n      if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;\n      if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;\n      if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);\n      if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;\n      if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);\n      if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;\n      if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);\n      if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);\n      if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);\n      if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);\n      if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);\n      if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);\n      if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);\n      if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);\n      if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);\n      if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);\n      if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);\n      return material;\n    }\n  }, {\n    key: "setTextures",\n    value: function setTextures(value) {\n      this.textures = value;\n      return this;\n    }\n  }]);\n\n  return MaterialLoader;\n}(Loader);\n\nvar LoaderUtils = /*#__PURE__*/function () {\n  function LoaderUtils() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, LoaderUtils);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(LoaderUtils, null, [{\n    key: "decodeText",\n    value: function decodeText(array) {\n      if (typeof TextDecoder !== \'undefined\') {\n        return new TextDecoder().decode(array);\n      } // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n      // throws a "maximum call stack size exceeded" error for large arrays.\n\n\n      var s = \'\';\n\n      for (var _i297 = 0, il = array.length; _i297 < il; _i297++) {\n        // Implicitly assumes little-endian.\n        s += String.fromCharCode(array[_i297]);\n      }\n\n      try {\n        // merges multi-byte utf-8 characters.\n        return decodeURIComponent(escape(s));\n      } catch (e) {\n        // see #16358\n        return s;\n      }\n    }\n  }, {\n    key: "extractUrlBase",\n    value: function extractUrlBase(url) {\n      var index = url.lastIndexOf(\'/\');\n      if (index === -1) return \'./\';\n      return url.slice(0, index + 1);\n    }\n  }, {\n    key: "resolveURL",\n    value: function resolveURL(url, path) {\n      // Invalid URL\n      if (typeof url !== \'string\' || url === \'\') return \'\'; // Host Relative URL\n\n      if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n        path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, \'$1\');\n      } // Absolute URL http://,https://,//\n\n\n      if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n      if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n      if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n      return path + url;\n    }\n  }]);\n\n  return LoaderUtils;\n}();\n\nvar InstancedBufferGeometry = /*#__PURE__*/function (_BufferGeometry16) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(InstancedBufferGeometry, _BufferGeometry16);\n\n  var _super129 = _createSuper(InstancedBufferGeometry);\n\n  function InstancedBufferGeometry() {\n    var _this105;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, InstancedBufferGeometry);\n\n    _this105 = _super129.call(this);\n    _this105.isInstancedBufferGeometry = true;\n    _this105.type = \'InstancedBufferGeometry\';\n    _this105.instanceCount = Infinity;\n    return _this105;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(InstancedBufferGeometry, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(InstancedBufferGeometry.prototype), "copy", this).call(this, source);\n\n      this.instanceCount = source.instanceCount;\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON() {\n      var data = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(InstancedBufferGeometry.prototype), "toJSON", this).call(this, this);\n\n      data.instanceCount = this.instanceCount;\n      data.isInstancedBufferGeometry = true;\n      return data;\n    }\n  }]);\n\n  return InstancedBufferGeometry;\n}(BufferGeometry);\n\nvar BufferGeometryLoader = /*#__PURE__*/function (_Loader9) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(BufferGeometryLoader, _Loader9);\n\n  var _super130 = _createSuper(BufferGeometryLoader);\n\n  function BufferGeometryLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, BufferGeometryLoader);\n\n    return _super130.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(BufferGeometryLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(JSON.parse(text)));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: "parse",\n    value: function parse(json) {\n      var interleavedBufferMap = {};\n      var arrayBufferMap = {};\n\n      function getInterleavedBuffer(json, uuid) {\n        if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];\n        var interleavedBuffers = json.interleavedBuffers;\n        var interleavedBuffer = interleavedBuffers[uuid];\n        var buffer = getArrayBuffer(json, interleavedBuffer.buffer);\n        var array = getTypedArray(interleavedBuffer.type, buffer);\n        var ib = new InterleavedBuffer(array, interleavedBuffer.stride);\n        ib.uuid = interleavedBuffer.uuid;\n        interleavedBufferMap[uuid] = ib;\n        return ib;\n      }\n\n      function getArrayBuffer(json, uuid) {\n        if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];\n        var arrayBuffers = json.arrayBuffers;\n        var arrayBuffer = arrayBuffers[uuid];\n        var ab = new Uint32Array(arrayBuffer).buffer;\n        arrayBufferMap[uuid] = ab;\n        return ab;\n      }\n\n      var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n      var index = json.data.index;\n\n      if (index !== undefined) {\n        var typedArray = getTypedArray(index.type, index.array);\n        geometry.setIndex(new BufferAttribute(typedArray, 1));\n      }\n\n      var attributes = json.data.attributes;\n\n      for (var key in attributes) {\n        var attribute = attributes[key];\n        var bufferAttribute = void 0;\n\n        if (attribute.isInterleavedBufferAttribute) {\n          var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n          bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n        } else {\n          var _typedArray = getTypedArray(attribute.type, attribute.array);\n\n          var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n          bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);\n        }\n\n        if (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n        if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);\n\n        if (attribute.updateRange !== undefined) {\n          bufferAttribute.updateRange.offset = attribute.updateRange.offset;\n          bufferAttribute.updateRange.count = attribute.updateRange.count;\n        }\n\n        geometry.setAttribute(key, bufferAttribute);\n      }\n\n      var morphAttributes = json.data.morphAttributes;\n\n      if (morphAttributes) {\n        for (var _key3 in morphAttributes) {\n          var attributeArray = morphAttributes[_key3];\n          var array = [];\n\n          for (var _i298 = 0, il = attributeArray.length; _i298 < il; _i298++) {\n            var _attribute3 = attributeArray[_i298];\n\n            var _bufferAttribute = void 0;\n\n            if (_attribute3.isInterleavedBufferAttribute) {\n              var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute3.data);\n\n              _bufferAttribute = new InterleavedBufferAttribute(_interleavedBuffer, _attribute3.itemSize, _attribute3.offset, _attribute3.normalized);\n            } else {\n              var _typedArray2 = getTypedArray(_attribute3.type, _attribute3.array);\n\n              _bufferAttribute = new BufferAttribute(_typedArray2, _attribute3.itemSize, _attribute3.normalized);\n            }\n\n            if (_attribute3.name !== undefined) _bufferAttribute.name = _attribute3.name;\n            array.push(_bufferAttribute);\n          }\n\n          geometry.morphAttributes[_key3] = array;\n        }\n      }\n\n      var morphTargetsRelative = json.data.morphTargetsRelative;\n\n      if (morphTargetsRelative) {\n        geometry.morphTargetsRelative = true;\n      }\n\n      var groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n      if (groups !== undefined) {\n        for (var _i299 = 0, n = groups.length; _i299 !== n; ++_i299) {\n          var group = groups[_i299];\n          geometry.addGroup(group.start, group.count, group.materialIndex);\n        }\n      }\n\n      var boundingSphere = json.data.boundingSphere;\n\n      if (boundingSphere !== undefined) {\n        var center = new Vector3();\n\n        if (boundingSphere.center !== undefined) {\n          center.fromArray(boundingSphere.center);\n        }\n\n        geometry.boundingSphere = new Sphere(center, boundingSphere.radius);\n      }\n\n      if (json.name) geometry.name = json.name;\n      if (json.userData) geometry.userData = json.userData;\n      return geometry;\n    }\n  }]);\n\n  return BufferGeometryLoader;\n}(Loader);\n\nvar ObjectLoader = /*#__PURE__*/function (_Loader10) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ObjectLoader, _Loader10);\n\n  var _super131 = _createSuper(ObjectLoader);\n\n  function ObjectLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ObjectLoader);\n\n    return _super131.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ObjectLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = this.path === \'\' ? LoaderUtils.extractUrlBase(url) : this.path;\n      this.resourcePath = this.resourcePath || path;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        var json = null;\n\n        try {\n          json = JSON.parse(text);\n        } catch (error) {\n          if (onError !== undefined) onError(error);\n          console.error(\'THREE:ObjectLoader: Can\\\'t parse \' + url + \'.\', error.message);\n          return;\n        }\n\n        var metadata = json.metadata;\n\n        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === \'geometry\') {\n          console.error(\'THREE.ObjectLoader: Can\\\'t load \' + url);\n          return;\n        }\n\n        scope.parse(json, onLoad);\n      }, onProgress, onError);\n    }\n  }, {\n    key: "loadAsync",\n    value: function () {\n      var _loadAsync = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)( /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee2(url, onProgress) {\n        var scope, path, loader, text, json, metadata;\n        return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee2$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                scope = this;\n                path = this.path === \'\' ? LoaderUtils.extractUrlBase(url) : this.path;\n                this.resourcePath = this.resourcePath || path;\n                loader = new FileLoader(this.manager);\n                loader.setPath(this.path);\n                loader.setRequestHeader(this.requestHeader);\n                loader.setWithCredentials(this.withCredentials);\n                _context9.next = 9;\n                return loader.loadAsync(url, onProgress);\n\n              case 9:\n                text = _context9.sent;\n                json = JSON.parse(text);\n                metadata = json.metadata;\n\n                if (!(metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === \'geometry\')) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                throw new Error(\'THREE.ObjectLoader: Can\\\'t load \' + url);\n\n              case 14:\n                _context9.next = 16;\n                return scope.parseAsync(json);\n\n              case 16:\n                return _context9.abrupt("return", _context9.sent);\n\n              case 17:\n              case "end":\n                return _context9.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function loadAsync(_x7, _x8) {\n        return _loadAsync.apply(this, arguments);\n      }\n\n      return loadAsync;\n    }()\n  }, {\n    key: "parse",\n    value: function parse(json, onLoad) {\n      var animations = this.parseAnimations(json.animations);\n      var shapes = this.parseShapes(json.shapes);\n      var geometries = this.parseGeometries(json.geometries, shapes);\n      var images = this.parseImages(json.images, function () {\n        if (onLoad !== undefined) onLoad(object);\n      });\n      var textures = this.parseTextures(json.textures, images);\n      var materials = this.parseMaterials(json.materials, textures);\n      var object = this.parseObject(json.object, geometries, materials, textures, animations);\n      var skeletons = this.parseSkeletons(json.skeletons, object);\n      this.bindSkeletons(object, skeletons); //\n\n      if (onLoad !== undefined) {\n        var hasImages = false;\n\n        for (var uuid in images) {\n          if (images[uuid].data instanceof HTMLImageElement) {\n            hasImages = true;\n            break;\n          }\n        }\n\n        if (hasImages === false) onLoad(object);\n      }\n\n      return object;\n    }\n  }, {\n    key: "parseAsync",\n    value: function () {\n      var _parseAsync = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)( /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee3(json) {\n        var animations, shapes, geometries, images, textures, materials, object, skeletons;\n        return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee3$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                animations = this.parseAnimations(json.animations);\n                shapes = this.parseShapes(json.shapes);\n                geometries = this.parseGeometries(json.geometries, shapes);\n                _context10.next = 5;\n                return this.parseImagesAsync(json.images);\n\n              case 5:\n                images = _context10.sent;\n                textures = this.parseTextures(json.textures, images);\n                materials = this.parseMaterials(json.materials, textures);\n                object = this.parseObject(json.object, geometries, materials, textures, animations);\n                skeletons = this.parseSkeletons(json.skeletons, object);\n                this.bindSkeletons(object, skeletons);\n                return _context10.abrupt("return", object);\n\n              case 12:\n              case "end":\n                return _context10.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function parseAsync(_x9) {\n        return _parseAsync.apply(this, arguments);\n      }\n\n      return parseAsync;\n    }()\n  }, {\n    key: "parseShapes",\n    value: function parseShapes(json) {\n      var shapes = {};\n\n      if (json !== undefined) {\n        for (var _i300 = 0, l = json.length; _i300 < l; _i300++) {\n          var shape = new Shape().fromJSON(json[_i300]);\n          shapes[shape.uuid] = shape;\n        }\n      }\n\n      return shapes;\n    }\n  }, {\n    key: "parseSkeletons",\n    value: function parseSkeletons(json, object) {\n      var skeletons = {};\n      var bones = {}; // generate bone lookup table\n\n      object.traverse(function (child) {\n        if (child.isBone) bones[child.uuid] = child;\n      }); // create skeletons\n\n      if (json !== undefined) {\n        for (var _i301 = 0, l = json.length; _i301 < l; _i301++) {\n          var skeleton = new Skeleton().fromJSON(json[_i301], bones);\n          skeletons[skeleton.uuid] = skeleton;\n        }\n      }\n\n      return skeletons;\n    }\n  }, {\n    key: "parseGeometries",\n    value: function parseGeometries(json, shapes) {\n      var geometries = {};\n\n      if (json !== undefined) {\n        var bufferGeometryLoader = new BufferGeometryLoader();\n\n        for (var _i302 = 0, l = json.length; _i302 < l; _i302++) {\n          var geometry = void 0;\n          var data = json[_i302];\n\n          switch (data.type) {\n            case \'BufferGeometry\':\n            case \'InstancedBufferGeometry\':\n              geometry = bufferGeometryLoader.parse(data);\n              break;\n\n            case \'Geometry\':\n              console.error(\'THREE.ObjectLoader: The legacy Geometry type is no longer supported.\');\n              break;\n\n            default:\n              if (data.type in Geometries) {\n                geometry = Geometries[data.type].fromJSON(data, shapes);\n              } else {\n                console.warn("THREE.ObjectLoader: Unsupported geometry type \\"".concat(data.type, "\\""));\n              }\n\n          }\n\n          geometry.uuid = data.uuid;\n          if (data.name !== undefined) geometry.name = data.name;\n          if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;\n          geometries[data.uuid] = geometry;\n        }\n      }\n\n      return geometries;\n    }\n  }, {\n    key: "parseMaterials",\n    value: function parseMaterials(json, textures) {\n      var cache = {}; // MultiMaterial\n\n      var materials = {};\n\n      if (json !== undefined) {\n        var loader = new MaterialLoader();\n        loader.setTextures(textures);\n\n        for (var _i303 = 0, l = json.length; _i303 < l; _i303++) {\n          var data = json[_i303];\n\n          if (data.type === \'MultiMaterial\') {\n            // Deprecated\n            var array = [];\n\n            for (var j = 0; j < data.materials.length; j++) {\n              var material = data.materials[j];\n\n              if (cache[material.uuid] === undefined) {\n                cache[material.uuid] = loader.parse(material);\n              }\n\n              array.push(cache[material.uuid]);\n            }\n\n            materials[data.uuid] = array;\n          } else {\n            if (cache[data.uuid] === undefined) {\n              cache[data.uuid] = loader.parse(data);\n            }\n\n            materials[data.uuid] = cache[data.uuid];\n          }\n        }\n      }\n\n      return materials;\n    }\n  }, {\n    key: "parseAnimations",\n    value: function parseAnimations(json) {\n      var animations = {};\n\n      if (json !== undefined) {\n        for (var _i304 = 0; _i304 < json.length; _i304++) {\n          var data = json[_i304];\n          var clip = AnimationClip.parse(data);\n          animations[clip.uuid] = clip;\n        }\n      }\n\n      return animations;\n    }\n  }, {\n    key: "parseImages",\n    value: function parseImages(json, onLoad) {\n      var scope = this;\n      var images = {};\n      var loader;\n\n      function loadImage(url) {\n        scope.manager.itemStart(url);\n        return loader.load(url, function () {\n          scope.manager.itemEnd(url);\n        }, undefined, function () {\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        });\n      }\n\n      function deserializeImage(image) {\n        if (typeof image === \'string\') {\n          var url = image;\n          var path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n          return loadImage(path);\n        } else {\n          if (image.data) {\n            return {\n              data: getTypedArray(image.type, image.data),\n              width: image.width,\n              height: image.height\n            };\n          } else {\n            return null;\n          }\n        }\n      }\n\n      if (json !== undefined && json.length > 0) {\n        var manager = new LoadingManager(onLoad);\n        loader = new ImageLoader(manager);\n        loader.setCrossOrigin(this.crossOrigin);\n\n        for (var _i305 = 0, il = json.length; _i305 < il; _i305++) {\n          var image = json[_i305];\n          var url = image.url;\n\n          if (Array.isArray(url)) {\n            // load array of images e.g CubeTexture\n            var imageArray = [];\n\n            for (var j = 0, jl = url.length; j < jl; j++) {\n              var currentUrl = url[j];\n              var deserializedImage = deserializeImage(currentUrl);\n\n              if (deserializedImage !== null) {\n                if (deserializedImage instanceof HTMLImageElement) {\n                  imageArray.push(deserializedImage);\n                } else {\n                  // special case: handle array of data textures for cube textures\n                  imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n                }\n              }\n            }\n\n            images[image.uuid] = new Source(imageArray);\n          } else {\n            // load single image\n            var _deserializedImage = deserializeImage(image.url);\n\n            images[image.uuid] = new Source(_deserializedImage);\n          }\n        }\n      }\n\n      return images;\n    }\n  }, {\n    key: "parseImagesAsync",\n    value: function () {\n      var _parseImagesAsync = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)( /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee5(json) {\n        var scope, images, loader, deserializeImage, _deserializeImage, _i306, il, image, url, imageArray, j, jl, currentUrl, deserializedImage, _deserializedImage2;\n\n        return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee5$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _deserializeImage = function _deserializeImage3() {\n                  _deserializeImage = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_11__/* ["default"] */ .Z)( /*#__PURE__*/_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().mark(function _callee4(image) {\n                    var _url, path;\n\n                    return _Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_regenerator_index_js__WEBPACK_IMPORTED_MODULE_3___default().wrap(function _callee4$(_context11) {\n                      while (1) {\n                        switch (_context11.prev = _context11.next) {\n                          case 0:\n                            if (!(typeof image === \'string\')) {\n                              _context11.next = 8;\n                              break;\n                            }\n\n                            _url = image;\n                            path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(_url) ? _url : scope.resourcePath + _url;\n                            _context11.next = 5;\n                            return loader.loadAsync(path);\n\n                          case 5:\n                            return _context11.abrupt("return", _context11.sent);\n\n                          case 8:\n                            if (!image.data) {\n                              _context11.next = 12;\n                              break;\n                            }\n\n                            return _context11.abrupt("return", {\n                              data: getTypedArray(image.type, image.data),\n                              width: image.width,\n                              height: image.height\n                            });\n\n                          case 12:\n                            return _context11.abrupt("return", null);\n\n                          case 13:\n                          case "end":\n                            return _context11.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n                  return _deserializeImage.apply(this, arguments);\n                };\n\n                deserializeImage = function _deserializeImage2(_x11) {\n                  return _deserializeImage.apply(this, arguments);\n                };\n\n                scope = this;\n                images = {};\n\n                if (!(json !== undefined && json.length > 0)) {\n                  _context12.next = 33;\n                  break;\n                }\n\n                loader = new ImageLoader(this.manager);\n                loader.setCrossOrigin(this.crossOrigin);\n                _i306 = 0, il = json.length;\n\n              case 8:\n                if (!(_i306 < il)) {\n                  _context12.next = 33;\n                  break;\n                }\n\n                image = json[_i306];\n                url = image.url;\n\n                if (!Array.isArray(url)) {\n                  _context12.next = 26;\n                  break;\n                }\n\n                // load array of images e.g CubeTexture\n                imageArray = [];\n                j = 0, jl = url.length;\n\n              case 14:\n                if (!(j < jl)) {\n                  _context12.next = 23;\n                  break;\n                }\n\n                currentUrl = url[j];\n                _context12.next = 18;\n                return deserializeImage(currentUrl);\n\n              case 18:\n                deserializedImage = _context12.sent;\n\n                if (deserializedImage !== null) {\n                  if (deserializedImage instanceof HTMLImageElement) {\n                    imageArray.push(deserializedImage);\n                  } else {\n                    // special case: handle array of data textures for cube textures\n                    imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n                  }\n                }\n\n              case 20:\n                j++;\n                _context12.next = 14;\n                break;\n\n              case 23:\n                images[image.uuid] = new Source(imageArray);\n                _context12.next = 30;\n                break;\n\n              case 26:\n                _context12.next = 28;\n                return deserializeImage(image.url);\n\n              case 28:\n                _deserializedImage2 = _context12.sent;\n                images[image.uuid] = new Source(_deserializedImage2);\n\n              case 30:\n                _i306++;\n                _context12.next = 8;\n                break;\n\n              case 33:\n                return _context12.abrupt("return", images);\n\n              case 34:\n              case "end":\n                return _context12.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function parseImagesAsync(_x10) {\n        return _parseImagesAsync.apply(this, arguments);\n      }\n\n      return parseImagesAsync;\n    }()\n  }, {\n    key: "parseTextures",\n    value: function parseTextures(json, images) {\n      function parseConstant(value, type) {\n        if (typeof value === \'number\') return value;\n        console.warn(\'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.\', value);\n        return type[value];\n      }\n\n      var textures = {};\n\n      if (json !== undefined) {\n        for (var _i307 = 0, l = json.length; _i307 < l; _i307++) {\n          var data = json[_i307];\n\n          if (data.image === undefined) {\n            console.warn(\'THREE.ObjectLoader: No "image" specified for\', data.uuid);\n          }\n\n          if (images[data.image] === undefined) {\n            console.warn(\'THREE.ObjectLoader: Undefined image\', data.image);\n          }\n\n          var source = images[data.image];\n          var image = source.data;\n          var texture = void 0;\n\n          if (Array.isArray(image)) {\n            texture = new CubeTexture();\n            if (image.length === 6) texture.needsUpdate = true;\n          } else {\n            if (image && image.data) {\n              texture = new DataTexture();\n            } else {\n              texture = new Texture();\n            }\n\n            if (image) texture.needsUpdate = true; // textures can have undefined image data\n          }\n\n          texture.source = source;\n          texture.uuid = data.uuid;\n          if (data.name !== undefined) texture.name = data.name;\n          if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\n          if (data.offset !== undefined) texture.offset.fromArray(data.offset);\n          if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);\n          if (data.center !== undefined) texture.center.fromArray(data.center);\n          if (data.rotation !== undefined) texture.rotation = data.rotation;\n\n          if (data.wrap !== undefined) {\n            texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\n            texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\n          }\n\n          if (data.format !== undefined) texture.format = data.format;\n          if (data.type !== undefined) texture.type = data.type;\n          if (data.encoding !== undefined) texture.encoding = data.encoding;\n          if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\n          if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\n          if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;\n          if (data.flipY !== undefined) texture.flipY = data.flipY;\n          if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;\n          if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;\n          if (data.userData !== undefined) texture.userData = data.userData;\n          textures[data.uuid] = texture;\n        }\n      }\n\n      return textures;\n    }\n  }, {\n    key: "parseObject",\n    value: function parseObject(data, geometries, materials, textures, animations) {\n      var object;\n\n      function getGeometry(name) {\n        if (geometries[name] === undefined) {\n          console.warn(\'THREE.ObjectLoader: Undefined geometry\', name);\n        }\n\n        return geometries[name];\n      }\n\n      function getMaterial(name) {\n        if (name === undefined) return undefined;\n\n        if (Array.isArray(name)) {\n          var array = [];\n\n          for (var _i308 = 0, l = name.length; _i308 < l; _i308++) {\n            var uuid = name[_i308];\n\n            if (materials[uuid] === undefined) {\n              console.warn(\'THREE.ObjectLoader: Undefined material\', uuid);\n            }\n\n            array.push(materials[uuid]);\n          }\n\n          return array;\n        }\n\n        if (materials[name] === undefined) {\n          console.warn(\'THREE.ObjectLoader: Undefined material\', name);\n        }\n\n        return materials[name];\n      }\n\n      function getTexture(uuid) {\n        if (textures[uuid] === undefined) {\n          console.warn(\'THREE.ObjectLoader: Undefined texture\', uuid);\n        }\n\n        return textures[uuid];\n      }\n\n      var geometry, material;\n\n      switch (data.type) {\n        case \'Scene\':\n          object = new Scene();\n\n          if (data.background !== undefined) {\n            if (Number.isInteger(data.background)) {\n              object.background = new Color(data.background);\n            } else {\n              object.background = getTexture(data.background);\n            }\n          }\n\n          if (data.environment !== undefined) {\n            object.environment = getTexture(data.environment);\n          }\n\n          if (data.fog !== undefined) {\n            if (data.fog.type === \'Fog\') {\n              object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\n            } else if (data.fog.type === \'FogExp2\') {\n              object.fog = new FogExp2(data.fog.color, data.fog.density);\n            }\n          }\n\n          break;\n\n        case \'PerspectiveCamera\':\n          object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n          if (data.focus !== undefined) object.focus = data.focus;\n          if (data.zoom !== undefined) object.zoom = data.zoom;\n          if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;\n          if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;\n          if (data.view !== undefined) object.view = Object.assign({}, data.view);\n          break;\n\n        case \'OrthographicCamera\':\n          object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n          if (data.zoom !== undefined) object.zoom = data.zoom;\n          if (data.view !== undefined) object.view = Object.assign({}, data.view);\n          break;\n\n        case \'AmbientLight\':\n          object = new AmbientLight(data.color, data.intensity);\n          break;\n\n        case \'DirectionalLight\':\n          object = new DirectionalLight(data.color, data.intensity);\n          break;\n\n        case \'PointLight\':\n          object = new PointLight(data.color, data.intensity, data.distance, data.decay);\n          break;\n\n        case \'RectAreaLight\':\n          object = new RectAreaLight(data.color, data.intensity, data.width, data.height);\n          break;\n\n        case \'SpotLight\':\n          object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\n          break;\n\n        case \'HemisphereLight\':\n          object = new HemisphereLight(data.color, data.groundColor, data.intensity);\n          break;\n\n        case \'LightProbe\':\n          object = new LightProbe().fromJSON(data);\n          break;\n\n        case \'SkinnedMesh\':\n          geometry = getGeometry(data.geometry);\n          material = getMaterial(data.material);\n          object = new SkinnedMesh(geometry, material);\n          if (data.bindMode !== undefined) object.bindMode = data.bindMode;\n          if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);\n          if (data.skeleton !== undefined) object.skeleton = data.skeleton;\n          break;\n\n        case \'Mesh\':\n          geometry = getGeometry(data.geometry);\n          material = getMaterial(data.material);\n          object = new Mesh(geometry, material);\n          break;\n\n        case \'InstancedMesh\':\n          geometry = getGeometry(data.geometry);\n          material = getMaterial(data.material);\n          var count = data.count;\n          var instanceMatrix = data.instanceMatrix;\n          var instanceColor = data.instanceColor;\n          object = new InstancedMesh(geometry, material, count);\n          object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);\n          if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);\n          break;\n\n        case \'LOD\':\n          object = new LOD();\n          break;\n\n        case \'Line\':\n          object = new Line(getGeometry(data.geometry), getMaterial(data.material));\n          break;\n\n        case \'LineLoop\':\n          object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\n          break;\n\n        case \'LineSegments\':\n          object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\n          break;\n\n        case \'PointCloud\':\n        case \'Points\':\n          object = new Points(getGeometry(data.geometry), getMaterial(data.material));\n          break;\n\n        case \'Sprite\':\n          object = new Sprite(getMaterial(data.material));\n          break;\n\n        case \'Group\':\n          object = new Group();\n          break;\n\n        case \'Bone\':\n          object = new Bone();\n          break;\n\n        default:\n          object = new Object3D();\n      }\n\n      object.uuid = data.uuid;\n      if (data.name !== undefined) object.name = data.name;\n\n      if (data.matrix !== undefined) {\n        object.matrix.fromArray(data.matrix);\n        if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;\n        if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);\n      } else {\n        if (data.position !== undefined) object.position.fromArray(data.position);\n        if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);\n        if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);\n        if (data.scale !== undefined) object.scale.fromArray(data.scale);\n      }\n\n      if (data.castShadow !== undefined) object.castShadow = data.castShadow;\n      if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;\n\n      if (data.shadow) {\n        if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;\n        if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;\n        if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;\n        if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);\n        if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);\n      }\n\n      if (data.visible !== undefined) object.visible = data.visible;\n      if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;\n      if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;\n      if (data.userData !== undefined) object.userData = data.userData;\n      if (data.layers !== undefined) object.layers.mask = data.layers;\n\n      if (data.children !== undefined) {\n        var children = data.children;\n\n        for (var _i309 = 0; _i309 < children.length; _i309++) {\n          object.add(this.parseObject(children[_i309], geometries, materials, textures, animations));\n        }\n      }\n\n      if (data.animations !== undefined) {\n        var objectAnimations = data.animations;\n\n        for (var _i310 = 0; _i310 < objectAnimations.length; _i310++) {\n          var uuid = objectAnimations[_i310];\n          object.animations.push(animations[uuid]);\n        }\n      }\n\n      if (data.type === \'LOD\') {\n        if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;\n        var levels = data.levels;\n\n        for (var l = 0; l < levels.length; l++) {\n          var level = levels[l];\n          var child = object.getObjectByProperty(\'uuid\', level.object);\n\n          if (child !== undefined) {\n            object.addLevel(child, level.distance);\n          }\n        }\n      }\n\n      return object;\n    }\n  }, {\n    key: "bindSkeletons",\n    value: function bindSkeletons(object, skeletons) {\n      if (Object.keys(skeletons).length === 0) return;\n      object.traverse(function (child) {\n        if (child.isSkinnedMesh === true && child.skeleton !== undefined) {\n          var skeleton = skeletons[child.skeleton];\n\n          if (skeleton === undefined) {\n            console.warn(\'THREE.ObjectLoader: No skeleton found with UUID:\', child.skeleton);\n          } else {\n            child.bind(skeleton, child.bindMatrix);\n          }\n        }\n      });\n    }\n    /* DEPRECATED */\n\n  }, {\n    key: "setTexturePath",\n    value: function setTexturePath(value) {\n      console.warn(\'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().\');\n      return this.setResourcePath(value);\n    }\n  }]);\n\n  return ObjectLoader;\n}(Loader);\n\nvar TEXTURE_MAPPING = {\n  UVMapping: UVMapping,\n  CubeReflectionMapping: CubeReflectionMapping,\n  CubeRefractionMapping: CubeRefractionMapping,\n  EquirectangularReflectionMapping: EquirectangularReflectionMapping,\n  EquirectangularRefractionMapping: EquirectangularRefractionMapping,\n  CubeUVReflectionMapping: CubeUVReflectionMapping\n};\nvar TEXTURE_WRAPPING = {\n  RepeatWrapping: RepeatWrapping,\n  ClampToEdgeWrapping: ClampToEdgeWrapping,\n  MirroredRepeatWrapping: MirroredRepeatWrapping\n};\nvar TEXTURE_FILTER = {\n  NearestFilter: NearestFilter,\n  NearestMipmapNearestFilter: NearestMipmapNearestFilter,\n  NearestMipmapLinearFilter: NearestMipmapLinearFilter,\n  LinearFilter: LinearFilter,\n  LinearMipmapNearestFilter: LinearMipmapNearestFilter,\n  LinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nvar ImageBitmapLoader = /*#__PURE__*/function (_Loader11) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ImageBitmapLoader, _Loader11);\n\n  var _super132 = _createSuper(ImageBitmapLoader);\n\n  function ImageBitmapLoader(manager) {\n    var _this106;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ImageBitmapLoader);\n\n    _this106 = _super132.call(this, manager);\n    _this106.isImageBitmapLoader = true;\n\n    if (typeof createImageBitmap === \'undefined\') {\n      console.warn(\'THREE.ImageBitmapLoader: createImageBitmap() not supported.\');\n    }\n\n    if (typeof fetch === \'undefined\') {\n      console.warn(\'THREE.ImageBitmapLoader: fetch() not supported.\');\n    }\n\n    _this106.options = {\n      premultiplyAlpha: \'none\'\n    };\n    return _this106;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ImageBitmapLoader, [{\n    key: "setOptions",\n    value: function setOptions(options) {\n      this.options = options;\n      return this;\n    }\n  }, {\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      if (url === undefined) url = \'\';\n      if (this.path !== undefined) url = this.path + url;\n      url = this.manager.resolveURL(url);\n      var scope = this;\n      var cached = Cache.get(url);\n\n      if (cached !== undefined) {\n        scope.manager.itemStart(url);\n        setTimeout(function () {\n          if (onLoad) onLoad(cached);\n          scope.manager.itemEnd(url);\n        }, 0);\n        return cached;\n      }\n\n      var fetchOptions = {};\n      fetchOptions.credentials = this.crossOrigin === \'anonymous\' ? \'same-origin\' : \'include\';\n      fetchOptions.headers = this.requestHeader;\n      fetch(url, fetchOptions).then(function (res) {\n        return res.blob();\n      }).then(function (blob) {\n        return createImageBitmap(blob, Object.assign(scope.options, {\n          colorSpaceConversion: \'none\'\n        }));\n      }).then(function (imageBitmap) {\n        Cache.add(url, imageBitmap);\n        if (onLoad) onLoad(imageBitmap);\n        scope.manager.itemEnd(url);\n      }).catch(function (e) {\n        if (onError) onError(e);\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      });\n      scope.manager.itemStart(url);\n    }\n  }]);\n\n  return ImageBitmapLoader;\n}(Loader);\n\nvar _context;\n\nvar AudioContext = {\n  getContext: function getContext() {\n    if (_context === undefined) {\n      _context = new (window.AudioContext || window.webkitAudioContext)();\n    }\n\n    return _context;\n  },\n  setContext: function setContext(value) {\n    _context = value;\n  }\n};\n\nvar AudioLoader = /*#__PURE__*/function (_Loader12) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(AudioLoader, _Loader12);\n\n  var _super133 = _createSuper(AudioLoader);\n\n  function AudioLoader(manager) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AudioLoader);\n\n    return _super133.call(this, manager);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AudioLoader, [{\n    key: "load",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setResponseType(\'arraybuffer\');\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        try {\n          // Create a copy of the buffer. The `decodeAudioData` method\n          // detaches the buffer when complete, preventing reuse.\n          var bufferCopy = buffer.slice(0);\n          var context = AudioContext.getContext();\n          context.decodeAudioData(bufferCopy, function (audioBuffer) {\n            onLoad(audioBuffer);\n          });\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }]);\n\n  return AudioLoader;\n}(Loader);\n\nvar HemisphereLightProbe = /*#__PURE__*/function (_LightProbe) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(HemisphereLightProbe, _LightProbe);\n\n  var _super134 = _createSuper(HemisphereLightProbe);\n\n  function HemisphereLightProbe(skyColor, groundColor) {\n    var _this107;\n\n    var intensity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, HemisphereLightProbe);\n\n    _this107 = _super134.call(this, undefined, intensity);\n    _this107.isHemisphereLightProbe = true;\n    var color1 = new Color().set(skyColor);\n    var color2 = new Color().set(groundColor);\n    var sky = new Vector3(color1.r, color1.g, color1.b);\n    var ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\n    var c0 = Math.sqrt(Math.PI);\n    var c1 = c0 * Math.sqrt(0.75);\n\n    _this107.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);\n\n    _this107.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);\n\n    return _this107;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(HemisphereLightProbe);\n}(LightProbe);\n\nvar AmbientLightProbe = /*#__PURE__*/function (_LightProbe2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(AmbientLightProbe, _LightProbe2);\n\n  var _super135 = _createSuper(AmbientLightProbe);\n\n  function AmbientLightProbe(color) {\n    var _this108;\n\n    var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AmbientLightProbe);\n\n    _this108 = _super135.call(this, undefined, intensity);\n    _this108.isAmbientLightProbe = true;\n    var color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\n    _this108.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));\n\n    return _this108;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AmbientLightProbe);\n}(LightProbe);\n\nvar _eyeRight = /*@__PURE__*/new Matrix4();\n\nvar _eyeLeft = /*@__PURE__*/new Matrix4();\n\nvar _projectionMatrix = /*@__PURE__*/new Matrix4();\n\nvar StereoCamera = /*#__PURE__*/function () {\n  function StereoCamera() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, StereoCamera);\n\n    this.type = \'StereoCamera\';\n    this.aspect = 1;\n    this.eyeSep = 0.064;\n    this.cameraL = new PerspectiveCamera();\n    this.cameraL.layers.enable(1);\n    this.cameraL.matrixAutoUpdate = false;\n    this.cameraR = new PerspectiveCamera();\n    this.cameraR.layers.enable(2);\n    this.cameraR.matrixAutoUpdate = false;\n    this._cache = {\n      focus: null,\n      fov: null,\n      aspect: null,\n      near: null,\n      far: null,\n      zoom: null,\n      eyeSep: null\n    };\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(StereoCamera, [{\n    key: "update",\n    value: function update(camera) {\n      var cache = this._cache;\n      var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n      if (needsUpdate) {\n        cache.focus = camera.focus;\n        cache.fov = camera.fov;\n        cache.aspect = camera.aspect * this.aspect;\n        cache.near = camera.near;\n        cache.far = camera.far;\n        cache.zoom = camera.zoom;\n        cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on\n        // http://paulbourke.net/stereographics/stereorender/\n\n        _projectionMatrix.copy(camera.projectionMatrix);\n\n        var eyeSepHalf = cache.eyeSep / 2;\n        var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n        var ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;\n        var xmin, xmax; // translate xOffset\n\n        _eyeLeft.elements[12] = -eyeSepHalf;\n        _eyeRight.elements[12] = eyeSepHalf; // for left eye\n\n        xmin = -ymax * cache.aspect + eyeSepOnProjection;\n        xmax = ymax * cache.aspect + eyeSepOnProjection;\n        _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n        _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n        this.cameraL.projectionMatrix.copy(_projectionMatrix); // for right eye\n\n        xmin = -ymax * cache.aspect - eyeSepOnProjection;\n        xmax = ymax * cache.aspect - eyeSepOnProjection;\n        _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n        _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n        this.cameraR.projectionMatrix.copy(_projectionMatrix);\n      }\n\n      this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);\n      this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);\n    }\n  }]);\n\n  return StereoCamera;\n}();\n\nvar Clock = /*#__PURE__*/function () {\n  function Clock() {\n    var autoStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Clock);\n\n    this.autoStart = autoStart;\n    this.startTime = 0;\n    this.oldTime = 0;\n    this.elapsedTime = 0;\n    this.running = false;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Clock, [{\n    key: "start",\n    value: function start() {\n      this.startTime = now();\n      this.oldTime = this.startTime;\n      this.elapsedTime = 0;\n      this.running = true;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this.getElapsedTime();\n      this.running = false;\n      this.autoStart = false;\n    }\n  }, {\n    key: "getElapsedTime",\n    value: function getElapsedTime() {\n      this.getDelta();\n      return this.elapsedTime;\n    }\n  }, {\n    key: "getDelta",\n    value: function getDelta() {\n      var diff = 0;\n\n      if (this.autoStart && !this.running) {\n        this.start();\n        return 0;\n      }\n\n      if (this.running) {\n        var newTime = now();\n        diff = (newTime - this.oldTime) / 1000;\n        this.oldTime = newTime;\n        this.elapsedTime += diff;\n      }\n\n      return diff;\n    }\n  }]);\n\n  return Clock;\n}();\n\nfunction now() {\n  return (typeof performance === \'undefined\' ? Date : performance).now(); // see #10732\n}\n\nvar _position$1 = /*@__PURE__*/new Vector3();\n\nvar _quaternion$1 = /*@__PURE__*/new Quaternion();\n\nvar _scale$1 = /*@__PURE__*/new Vector3();\n\nvar _orientation$1 = /*@__PURE__*/new Vector3();\n\nvar AudioListener = /*#__PURE__*/function (_Object3D12) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(AudioListener, _Object3D12);\n\n  var _super136 = _createSuper(AudioListener);\n\n  function AudioListener() {\n    var _this109;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AudioListener);\n\n    _this109 = _super136.call(this);\n    _this109.type = \'AudioListener\';\n    _this109.context = AudioContext.getContext();\n    _this109.gain = _this109.context.createGain();\n\n    _this109.gain.connect(_this109.context.destination);\n\n    _this109.filter = null;\n    _this109.timeDelta = 0; // private\n\n    _this109._clock = new Clock();\n    return _this109;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AudioListener, [{\n    key: "getInput",\n    value: function getInput() {\n      return this.gain;\n    }\n  }, {\n    key: "removeFilter",\n    value: function removeFilter() {\n      if (this.filter !== null) {\n        this.gain.disconnect(this.filter);\n        this.filter.disconnect(this.context.destination);\n        this.gain.connect(this.context.destination);\n        this.filter = null;\n      }\n\n      return this;\n    }\n  }, {\n    key: "getFilter",\n    value: function getFilter() {\n      return this.filter;\n    }\n  }, {\n    key: "setFilter",\n    value: function setFilter(value) {\n      if (this.filter !== null) {\n        this.gain.disconnect(this.filter);\n        this.filter.disconnect(this.context.destination);\n      } else {\n        this.gain.disconnect(this.context.destination);\n      }\n\n      this.filter = value;\n      this.gain.connect(this.filter);\n      this.filter.connect(this.context.destination);\n      return this;\n    }\n  }, {\n    key: "getMasterVolume",\n    value: function getMasterVolume() {\n      return this.gain.gain.value;\n    }\n  }, {\n    key: "setMasterVolume",\n    value: function setMasterVolume(value) {\n      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n      return this;\n    }\n  }, {\n    key: "updateMatrixWorld",\n    value: function updateMatrixWorld(force) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(AudioListener.prototype), "updateMatrixWorld", this).call(this, force);\n\n      var listener = this.context.listener;\n      var up = this.up;\n      this.timeDelta = this._clock.getDelta();\n      this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);\n\n      _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);\n\n      if (listener.positionX) {\n        // code path for Chrome (see #14393)\n        var endTime = this.context.currentTime + this.timeDelta;\n        listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);\n        listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);\n        listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);\n        listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);\n        listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);\n        listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);\n        listener.upX.linearRampToValueAtTime(up.x, endTime);\n        listener.upY.linearRampToValueAtTime(up.y, endTime);\n        listener.upZ.linearRampToValueAtTime(up.z, endTime);\n      } else {\n        listener.setPosition(_position$1.x, _position$1.y, _position$1.z);\n        listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);\n      }\n    }\n  }]);\n\n  return AudioListener;\n}(Object3D);\n\nvar Audio = /*#__PURE__*/function (_Object3D13) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Audio, _Object3D13);\n\n  var _super137 = _createSuper(Audio);\n\n  function Audio(listener) {\n    var _this110;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Audio);\n\n    _this110 = _super137.call(this);\n    _this110.type = \'Audio\';\n    _this110.listener = listener;\n    _this110.context = listener.context;\n    _this110.gain = _this110.context.createGain();\n\n    _this110.gain.connect(listener.getInput());\n\n    _this110.autoplay = false;\n    _this110.buffer = null;\n    _this110.detune = 0;\n    _this110.loop = false;\n    _this110.loopStart = 0;\n    _this110.loopEnd = 0;\n    _this110.offset = 0;\n    _this110.duration = undefined;\n    _this110.playbackRate = 1;\n    _this110.isPlaying = false;\n    _this110.hasPlaybackControl = true;\n    _this110.source = null;\n    _this110.sourceType = \'empty\';\n    _this110._startedAt = 0;\n    _this110._progress = 0;\n    _this110._connected = false;\n    _this110.filters = [];\n    return _this110;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Audio, [{\n    key: "getOutput",\n    value: function getOutput() {\n      return this.gain;\n    }\n  }, {\n    key: "setNodeSource",\n    value: function setNodeSource(audioNode) {\n      this.hasPlaybackControl = false;\n      this.sourceType = \'audioNode\';\n      this.source = audioNode;\n      this.connect();\n      return this;\n    }\n  }, {\n    key: "setMediaElementSource",\n    value: function setMediaElementSource(mediaElement) {\n      this.hasPlaybackControl = false;\n      this.sourceType = \'mediaNode\';\n      this.source = this.context.createMediaElementSource(mediaElement);\n      this.connect();\n      return this;\n    }\n  }, {\n    key: "setMediaStreamSource",\n    value: function setMediaStreamSource(mediaStream) {\n      this.hasPlaybackControl = false;\n      this.sourceType = \'mediaStreamNode\';\n      this.source = this.context.createMediaStreamSource(mediaStream);\n      this.connect();\n      return this;\n    }\n  }, {\n    key: "setBuffer",\n    value: function setBuffer(audioBuffer) {\n      this.buffer = audioBuffer;\n      this.sourceType = \'buffer\';\n      if (this.autoplay) this.play();\n      return this;\n    }\n  }, {\n    key: "play",\n    value: function play() {\n      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (this.isPlaying === true) {\n        console.warn(\'THREE.Audio: Audio is already playing.\');\n        return;\n      }\n\n      if (this.hasPlaybackControl === false) {\n        console.warn(\'THREE.Audio: this Audio has no playback control.\');\n        return;\n      }\n\n      this._startedAt = this.context.currentTime + delay;\n      var source = this.context.createBufferSource();\n      source.buffer = this.buffer;\n      source.loop = this.loop;\n      source.loopStart = this.loopStart;\n      source.loopEnd = this.loopEnd;\n      source.onended = this.onEnded.bind(this);\n      source.start(this._startedAt, this._progress + this.offset, this.duration);\n      this.isPlaying = true;\n      this.source = source;\n      this.setDetune(this.detune);\n      this.setPlaybackRate(this.playbackRate);\n      return this.connect();\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      if (this.hasPlaybackControl === false) {\n        console.warn(\'THREE.Audio: this Audio has no playback control.\');\n        return;\n      }\n\n      if (this.isPlaying === true) {\n        // update current progress\n        this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;\n\n        if (this.loop === true) {\n          // ensure _progress does not exceed duration with looped audios\n          this._progress = this._progress % (this.duration || this.buffer.duration);\n        }\n\n        this.source.stop();\n        this.source.onended = null;\n        this.isPlaying = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this.hasPlaybackControl === false) {\n        console.warn(\'THREE.Audio: this Audio has no playback control.\');\n        return;\n      }\n\n      this._progress = 0;\n      this.source.stop();\n      this.source.onended = null;\n      this.isPlaying = false;\n      return this;\n    }\n  }, {\n    key: "connect",\n    value: function connect() {\n      if (this.filters.length > 0) {\n        this.source.connect(this.filters[0]);\n\n        for (var _i311 = 1, l = this.filters.length; _i311 < l; _i311++) {\n          this.filters[_i311 - 1].connect(this.filters[_i311]);\n        }\n\n        this.filters[this.filters.length - 1].connect(this.getOutput());\n      } else {\n        this.source.connect(this.getOutput());\n      }\n\n      this._connected = true;\n      return this;\n    }\n  }, {\n    key: "disconnect",\n    value: function disconnect() {\n      if (this.filters.length > 0) {\n        this.source.disconnect(this.filters[0]);\n\n        for (var _i312 = 1, l = this.filters.length; _i312 < l; _i312++) {\n          this.filters[_i312 - 1].disconnect(this.filters[_i312]);\n        }\n\n        this.filters[this.filters.length - 1].disconnect(this.getOutput());\n      } else {\n        this.source.disconnect(this.getOutput());\n      }\n\n      this._connected = false;\n      return this;\n    }\n  }, {\n    key: "getFilters",\n    value: function getFilters() {\n      return this.filters;\n    }\n  }, {\n    key: "setFilters",\n    value: function setFilters(value) {\n      if (!value) value = [];\n\n      if (this._connected === true) {\n        this.disconnect();\n        this.filters = value.slice();\n        this.connect();\n      } else {\n        this.filters = value.slice();\n      }\n\n      return this;\n    }\n  }, {\n    key: "setDetune",\n    value: function setDetune(value) {\n      this.detune = value;\n      if (this.source.detune === undefined) return; // only set detune when available\n\n      if (this.isPlaying === true) {\n        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);\n      }\n\n      return this;\n    }\n  }, {\n    key: "getDetune",\n    value: function getDetune() {\n      return this.detune;\n    }\n  }, {\n    key: "getFilter",\n    value: function getFilter() {\n      return this.getFilters()[0];\n    }\n  }, {\n    key: "setFilter",\n    value: function setFilter(filter) {\n      return this.setFilters(filter ? [filter] : []);\n    }\n  }, {\n    key: "setPlaybackRate",\n    value: function setPlaybackRate(value) {\n      if (this.hasPlaybackControl === false) {\n        console.warn(\'THREE.Audio: this Audio has no playback control.\');\n        return;\n      }\n\n      this.playbackRate = value;\n\n      if (this.isPlaying === true) {\n        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);\n      }\n\n      return this;\n    }\n  }, {\n    key: "getPlaybackRate",\n    value: function getPlaybackRate() {\n      return this.playbackRate;\n    }\n  }, {\n    key: "onEnded",\n    value: function onEnded() {\n      this.isPlaying = false;\n    }\n  }, {\n    key: "getLoop",\n    value: function getLoop() {\n      if (this.hasPlaybackControl === false) {\n        console.warn(\'THREE.Audio: this Audio has no playback control.\');\n        return false;\n      }\n\n      return this.loop;\n    }\n  }, {\n    key: "setLoop",\n    value: function setLoop(value) {\n      if (this.hasPlaybackControl === false) {\n        console.warn(\'THREE.Audio: this Audio has no playback control.\');\n        return;\n      }\n\n      this.loop = value;\n\n      if (this.isPlaying === true) {\n        this.source.loop = this.loop;\n      }\n\n      return this;\n    }\n  }, {\n    key: "setLoopStart",\n    value: function setLoopStart(value) {\n      this.loopStart = value;\n      return this;\n    }\n  }, {\n    key: "setLoopEnd",\n    value: function setLoopEnd(value) {\n      this.loopEnd = value;\n      return this;\n    }\n  }, {\n    key: "getVolume",\n    value: function getVolume() {\n      return this.gain.gain.value;\n    }\n  }, {\n    key: "setVolume",\n    value: function setVolume(value) {\n      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n      return this;\n    }\n  }]);\n\n  return Audio;\n}(Object3D);\n\nvar _position = /*@__PURE__*/new Vector3();\n\nvar _quaternion = /*@__PURE__*/new Quaternion();\n\nvar _scale = /*@__PURE__*/new Vector3();\n\nvar _orientation = /*@__PURE__*/new Vector3();\n\nvar PositionalAudio = /*#__PURE__*/function (_Audio) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PositionalAudio, _Audio);\n\n  var _super138 = _createSuper(PositionalAudio);\n\n  function PositionalAudio(listener) {\n    var _this111;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PositionalAudio);\n\n    _this111 = _super138.call(this, listener);\n    _this111.panner = _this111.context.createPanner();\n    _this111.panner.panningModel = \'HRTF\';\n\n    _this111.panner.connect(_this111.gain);\n\n    return _this111;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PositionalAudio, [{\n    key: "disconnect",\n    value: function disconnect() {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(PositionalAudio.prototype), "disconnect", this).call(this);\n\n      this.panner.disconnect(this.gain);\n    }\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      return this.panner;\n    }\n  }, {\n    key: "getRefDistance",\n    value: function getRefDistance() {\n      return this.panner.refDistance;\n    }\n  }, {\n    key: "setRefDistance",\n    value: function setRefDistance(value) {\n      this.panner.refDistance = value;\n      return this;\n    }\n  }, {\n    key: "getRolloffFactor",\n    value: function getRolloffFactor() {\n      return this.panner.rolloffFactor;\n    }\n  }, {\n    key: "setRolloffFactor",\n    value: function setRolloffFactor(value) {\n      this.panner.rolloffFactor = value;\n      return this;\n    }\n  }, {\n    key: "getDistanceModel",\n    value: function getDistanceModel() {\n      return this.panner.distanceModel;\n    }\n  }, {\n    key: "setDistanceModel",\n    value: function setDistanceModel(value) {\n      this.panner.distanceModel = value;\n      return this;\n    }\n  }, {\n    key: "getMaxDistance",\n    value: function getMaxDistance() {\n      return this.panner.maxDistance;\n    }\n  }, {\n    key: "setMaxDistance",\n    value: function setMaxDistance(value) {\n      this.panner.maxDistance = value;\n      return this;\n    }\n  }, {\n    key: "setDirectionalCone",\n    value: function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n      this.panner.coneInnerAngle = coneInnerAngle;\n      this.panner.coneOuterAngle = coneOuterAngle;\n      this.panner.coneOuterGain = coneOuterGain;\n      return this;\n    }\n  }, {\n    key: "updateMatrixWorld",\n    value: function updateMatrixWorld(force) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(PositionalAudio.prototype), "updateMatrixWorld", this).call(this, force);\n\n      if (this.hasPlaybackControl === true && this.isPlaying === false) return;\n      this.matrixWorld.decompose(_position, _quaternion, _scale);\n\n      _orientation.set(0, 0, 1).applyQuaternion(_quaternion);\n\n      var panner = this.panner;\n\n      if (panner.positionX) {\n        // code path for Chrome and Firefox (see #14393)\n        var endTime = this.context.currentTime + this.listener.timeDelta;\n        panner.positionX.linearRampToValueAtTime(_position.x, endTime);\n        panner.positionY.linearRampToValueAtTime(_position.y, endTime);\n        panner.positionZ.linearRampToValueAtTime(_position.z, endTime);\n        panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);\n        panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);\n        panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);\n      } else {\n        panner.setPosition(_position.x, _position.y, _position.z);\n        panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);\n      }\n    }\n  }]);\n\n  return PositionalAudio;\n}(Audio);\n\nvar AudioAnalyser = /*#__PURE__*/function () {\n  function AudioAnalyser(audio) {\n    var fftSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2048;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AudioAnalyser);\n\n    this.analyser = audio.context.createAnalyser();\n    this.analyser.fftSize = fftSize;\n    this.data = new Uint8Array(this.analyser.frequencyBinCount);\n    audio.getOutput().connect(this.analyser);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AudioAnalyser, [{\n    key: "getFrequencyData",\n    value: function getFrequencyData() {\n      this.analyser.getByteFrequencyData(this.data);\n      return this.data;\n    }\n  }, {\n    key: "getAverageFrequency",\n    value: function getAverageFrequency() {\n      var value = 0;\n      var data = this.getFrequencyData();\n\n      for (var _i313 = 0; _i313 < data.length; _i313++) {\n        value += data[_i313];\n      }\n\n      return value / data.length;\n    }\n  }]);\n\n  return AudioAnalyser;\n}();\n\nvar PropertyMixer = /*#__PURE__*/function () {\n  function PropertyMixer(binding, typeName, valueSize) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PropertyMixer);\n\n    this.binding = binding;\n    this.valueSize = valueSize;\n    var mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n    //\n    // interpolators can use .buffer as their .result\n    // the data then goes to \'incoming\'\n    //\n    // \'accu0\' and \'accu1\' are used frame-interleaved for\n    // the cumulative result and are compared to detect\n    // changes\n    //\n    // \'orig\' stores the original state of the property\n    //\n    // \'add\' is used for additive cumulative results\n    //\n    // \'work\' is optional and is only present for quaternion types. It is used\n    // to store intermediate quaternion multiplication results\n\n    switch (typeName) {\n      case \'quaternion\':\n        mixFunction = this._slerp;\n        mixFunctionAdditive = this._slerpAdditive;\n        setIdentity = this._setAdditiveIdentityQuaternion;\n        this.buffer = new Float64Array(valueSize * 6);\n        this._workIndex = 5;\n        break;\n\n      case \'string\':\n      case \'bool\':\n        mixFunction = this._select; // Use the regular mix function and for additive on these types,\n        // additive is not relevant for non-numeric types\n\n        mixFunctionAdditive = this._select;\n        setIdentity = this._setAdditiveIdentityOther;\n        this.buffer = new Array(valueSize * 5);\n        break;\n\n      default:\n        mixFunction = this._lerp;\n        mixFunctionAdditive = this._lerpAdditive;\n        setIdentity = this._setAdditiveIdentityNumeric;\n        this.buffer = new Float64Array(valueSize * 5);\n    }\n\n    this._mixBufferRegion = mixFunction;\n    this._mixBufferRegionAdditive = mixFunctionAdditive;\n    this._setIdentity = setIdentity;\n    this._origIndex = 3;\n    this._addIndex = 4;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    this.useCount = 0;\n    this.referenceCount = 0;\n  } // accumulate data in the \'incoming\' region into \'accu<i>\'\n\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PropertyMixer, [{\n    key: "accumulate",\n    value: function accumulate(accuIndex, weight) {\n      // note: happily accumulating nothing when weight = 0, the caller knows\n      // the weight and shouldn\'t have made the call in the first place\n      var buffer = this.buffer,\n          stride = this.valueSize,\n          offset = accuIndex * stride + stride;\n      var currentWeight = this.cumulativeWeight;\n\n      if (currentWeight === 0) {\n        // accuN := incoming * weight\n        for (var _i314 = 0; _i314 !== stride; ++_i314) {\n          buffer[offset + _i314] = buffer[_i314];\n        }\n\n        currentWeight = weight;\n      } else {\n        // accuN := accuN + incoming * weight\n        currentWeight += weight;\n        var mix = weight / currentWeight;\n\n        this._mixBufferRegion(buffer, offset, 0, mix, stride);\n      }\n\n      this.cumulativeWeight = currentWeight;\n    } // accumulate data in the \'incoming\' region into \'add\'\n\n  }, {\n    key: "accumulateAdditive",\n    value: function accumulateAdditive(weight) {\n      var buffer = this.buffer,\n          stride = this.valueSize,\n          offset = stride * this._addIndex;\n\n      if (this.cumulativeWeightAdditive === 0) {\n        // add = identity\n        this._setIdentity();\n      } // add := add + incoming * weight\n\n\n      this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n\n      this.cumulativeWeightAdditive += weight;\n    } // apply the state of \'accu<i>\' to the binding when accus differ\n\n  }, {\n    key: "apply",\n    value: function apply(accuIndex) {\n      var stride = this.valueSize,\n          buffer = this.buffer,\n          offset = accuIndex * stride + stride,\n          weight = this.cumulativeWeight,\n          weightAdditive = this.cumulativeWeightAdditive,\n          binding = this.binding;\n      this.cumulativeWeight = 0;\n      this.cumulativeWeightAdditive = 0;\n\n      if (weight < 1) {\n        // accuN := accuN + original * ( 1 - cumulativeWeight )\n        var originalValueOffset = stride * this._origIndex;\n\n        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n      }\n\n      if (weightAdditive > 0) {\n        // accuN := accuN + additive accuN\n        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n      }\n\n      for (var _i315 = stride, e = stride + stride; _i315 !== e; ++_i315) {\n        if (buffer[_i315] !== buffer[_i315 + stride]) {\n          // value has changed -> update scene graph\n          binding.setValue(buffer, offset);\n          break;\n        }\n      }\n    } // remember the state of the bound property and copy it to both accus\n\n  }, {\n    key: "saveOriginalState",\n    value: function saveOriginalState() {\n      var binding = this.binding;\n      var buffer = this.buffer,\n          stride = this.valueSize,\n          originalValueOffset = stride * this._origIndex;\n      binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original\n\n      for (var _i316 = stride, e = originalValueOffset; _i316 !== e; ++_i316) {\n        buffer[_i316] = buffer[originalValueOffset + _i316 % stride];\n      } // Add to identity for additive\n\n\n      this._setIdentity();\n\n      this.cumulativeWeight = 0;\n      this.cumulativeWeightAdditive = 0;\n    } // apply the state previously taken via \'saveOriginalState\' to the binding\n\n  }, {\n    key: "restoreOriginalState",\n    value: function restoreOriginalState() {\n      var originalValueOffset = this.valueSize * 3;\n      this.binding.setValue(this.buffer, originalValueOffset);\n    }\n  }, {\n    key: "_setAdditiveIdentityNumeric",\n    value: function _setAdditiveIdentityNumeric() {\n      var startIndex = this._addIndex * this.valueSize;\n      var endIndex = startIndex + this.valueSize;\n\n      for (var _i317 = startIndex; _i317 < endIndex; _i317++) {\n        this.buffer[_i317] = 0;\n      }\n    }\n  }, {\n    key: "_setAdditiveIdentityQuaternion",\n    value: function _setAdditiveIdentityQuaternion() {\n      this._setAdditiveIdentityNumeric();\n\n      this.buffer[this._addIndex * this.valueSize + 3] = 1;\n    }\n  }, {\n    key: "_setAdditiveIdentityOther",\n    value: function _setAdditiveIdentityOther() {\n      var startIndex = this._origIndex * this.valueSize;\n      var targetIndex = this._addIndex * this.valueSize;\n\n      for (var _i318 = 0; _i318 < this.valueSize; _i318++) {\n        this.buffer[targetIndex + _i318] = this.buffer[startIndex + _i318];\n      }\n    } // mix functions\n\n  }, {\n    key: "_select",\n    value: function _select(buffer, dstOffset, srcOffset, t, stride) {\n      if (t >= 0.5) {\n        for (var _i319 = 0; _i319 !== stride; ++_i319) {\n          buffer[dstOffset + _i319] = buffer[srcOffset + _i319];\n        }\n      }\n    }\n  }, {\n    key: "_slerp",\n    value: function _slerp(buffer, dstOffset, srcOffset, t) {\n      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n    }\n  }, {\n    key: "_slerpAdditive",\n    value: function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n      var workOffset = this._workIndex * stride; // Store result in intermediate buffer offset\n\n      Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result\n\n      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n    }\n  }, {\n    key: "_lerp",\n    value: function _lerp(buffer, dstOffset, srcOffset, t, stride) {\n      var s = 1 - t;\n\n      for (var _i320 = 0; _i320 !== stride; ++_i320) {\n        var j = dstOffset + _i320;\n        buffer[j] = buffer[j] * s + buffer[srcOffset + _i320] * t;\n      }\n    }\n  }, {\n    key: "_lerpAdditive",\n    value: function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n      for (var _i321 = 0; _i321 !== stride; ++_i321) {\n        var j = dstOffset + _i321;\n        buffer[j] = buffer[j] + buffer[srcOffset + _i321] * t;\n      }\n    }\n  }]);\n\n  return PropertyMixer;\n}(); // Characters [].:/ are reserved for track binding syntax.\n\n\nvar _RESERVED_CHARS_RE = \'\\\\[\\\\]\\\\.:\\\\/\';\n\nvar _reservedRe = new RegExp(\'[\' + _RESERVED_CHARS_RE + \']\', \'g\'); // Attempts to allow node names from any language. ES5\'s `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\n\n\nvar _wordChar = \'[^\' + _RESERVED_CHARS_RE + \']\';\n\nvar _wordCharOrDot = \'[^\' + _RESERVED_CHARS_RE.replace(\'\\\\.\', \'\') + \']\'; // Parent directories, delimited by \'/\' or \':\'. Currently unused, but must\n// be matched to parse the rest of the track name.\n\n\nvar _directoryRe = /((?:WC+[\\/:])*)/.source.replace(\'WC\', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and \'.\' or \'-\'.\n\n\nvar _nodeRe = /(WCOD+)?/.source.replace(\'WCOD\', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\n\n\nvar _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace(\'WC\', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\n\n\nvar _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace(\'WC\', _wordChar);\n\nvar _trackRe = new RegExp(\'\' + \'^\' + _directoryRe + _nodeRe + _objectRe + _propertyRe + \'$\');\n\nvar _supportedObjectNames = [\'material\', \'materials\', \'bones\'];\n\nvar Composite = /*#__PURE__*/function () {\n  function Composite(targetGroup, path, optionalParsedPath) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Composite);\n\n    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Composite, [{\n    key: "getValue",\n    value: function getValue(array, offset) {\n      this.bind(); // bind all binding\n\n      var firstValidIndex = this._targetGroup.nCachedObjects_,\n          binding = this._bindings[firstValidIndex]; // and only call .getValue on the first\n\n      if (binding !== undefined) binding.getValue(array, offset);\n    }\n  }, {\n    key: "setValue",\n    value: function setValue(array, offset) {\n      var bindings = this._bindings;\n\n      for (var _i322 = this._targetGroup.nCachedObjects_, n = bindings.length; _i322 !== n; ++_i322) {\n        bindings[_i322].setValue(array, offset);\n      }\n    }\n  }, {\n    key: "bind",\n    value: function bind() {\n      var bindings = this._bindings;\n\n      for (var _i323 = this._targetGroup.nCachedObjects_, n = bindings.length; _i323 !== n; ++_i323) {\n        bindings[_i323].bind();\n      }\n    }\n  }, {\n    key: "unbind",\n    value: function unbind() {\n      var bindings = this._bindings;\n\n      for (var _i324 = this._targetGroup.nCachedObjects_, n = bindings.length; _i324 !== n; ++_i324) {\n        bindings[_i324].unbind();\n      }\n    }\n  }]);\n\n  return Composite;\n}(); // Note: This class uses a State pattern on a per-method basis:\n// \'bind\' sets \'this.getValue\' / \'setValue\' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\n\n\nvar PropertyBinding = /*#__PURE__*/function () {\n  function PropertyBinding(rootNode, path, parsedPath) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PropertyBinding);\n\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n    this.rootNode = rootNode; // initial state of these methods that calls \'bind\'\n\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PropertyBinding, [{\n    key: "_getValue_unavailable",\n    value: // these are used to "bind" a nonexistent property\n    function _getValue_unavailable() {}\n  }, {\n    key: "_setValue_unavailable",\n    value: function _setValue_unavailable() {} // Getters\n\n  }, {\n    key: "_getValue_direct",\n    value: function _getValue_direct(buffer, offset) {\n      buffer[offset] = this.targetObject[this.propertyName];\n    }\n  }, {\n    key: "_getValue_array",\n    value: function _getValue_array(buffer, offset) {\n      var source = this.resolvedProperty;\n\n      for (var _i325 = 0, n = source.length; _i325 !== n; ++_i325) {\n        buffer[offset++] = source[_i325];\n      }\n    }\n  }, {\n    key: "_getValue_arrayElement",\n    value: function _getValue_arrayElement(buffer, offset) {\n      buffer[offset] = this.resolvedProperty[this.propertyIndex];\n    }\n  }, {\n    key: "_getValue_toArray",\n    value: function _getValue_toArray(buffer, offset) {\n      this.resolvedProperty.toArray(buffer, offset);\n    } // Direct\n\n  }, {\n    key: "_setValue_direct",\n    value: function _setValue_direct(buffer, offset) {\n      this.targetObject[this.propertyName] = buffer[offset];\n    }\n  }, {\n    key: "_setValue_direct_setNeedsUpdate",\n    value: function _setValue_direct_setNeedsUpdate(buffer, offset) {\n      this.targetObject[this.propertyName] = buffer[offset];\n      this.targetObject.needsUpdate = true;\n    }\n  }, {\n    key: "_setValue_direct_setMatrixWorldNeedsUpdate",\n    value: function _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n      this.targetObject[this.propertyName] = buffer[offset];\n      this.targetObject.matrixWorldNeedsUpdate = true;\n    } // EntireArray\n\n  }, {\n    key: "_setValue_array",\n    value: function _setValue_array(buffer, offset) {\n      var dest = this.resolvedProperty;\n\n      for (var _i326 = 0, n = dest.length; _i326 !== n; ++_i326) {\n        dest[_i326] = buffer[offset++];\n      }\n    }\n  }, {\n    key: "_setValue_array_setNeedsUpdate",\n    value: function _setValue_array_setNeedsUpdate(buffer, offset) {\n      var dest = this.resolvedProperty;\n\n      for (var _i327 = 0, n = dest.length; _i327 !== n; ++_i327) {\n        dest[_i327] = buffer[offset++];\n      }\n\n      this.targetObject.needsUpdate = true;\n    }\n  }, {\n    key: "_setValue_array_setMatrixWorldNeedsUpdate",\n    value: function _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n      var dest = this.resolvedProperty;\n\n      for (var _i328 = 0, n = dest.length; _i328 !== n; ++_i328) {\n        dest[_i328] = buffer[offset++];\n      }\n\n      this.targetObject.matrixWorldNeedsUpdate = true;\n    } // ArrayElement\n\n  }, {\n    key: "_setValue_arrayElement",\n    value: function _setValue_arrayElement(buffer, offset) {\n      this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    }\n  }, {\n    key: "_setValue_arrayElement_setNeedsUpdate",\n    value: function _setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n      this.resolvedProperty[this.propertyIndex] = buffer[offset];\n      this.targetObject.needsUpdate = true;\n    }\n  }, {\n    key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",\n    value: function _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n      this.resolvedProperty[this.propertyIndex] = buffer[offset];\n      this.targetObject.matrixWorldNeedsUpdate = true;\n    } // HasToFromArray\n\n  }, {\n    key: "_setValue_fromArray",\n    value: function _setValue_fromArray(buffer, offset) {\n      this.resolvedProperty.fromArray(buffer, offset);\n    }\n  }, {\n    key: "_setValue_fromArray_setNeedsUpdate",\n    value: function _setValue_fromArray_setNeedsUpdate(buffer, offset) {\n      this.resolvedProperty.fromArray(buffer, offset);\n      this.targetObject.needsUpdate = true;\n    }\n  }, {\n    key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",\n    value: function _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n      this.resolvedProperty.fromArray(buffer, offset);\n      this.targetObject.matrixWorldNeedsUpdate = true;\n    }\n  }, {\n    key: "_getValue_unbound",\n    value: function _getValue_unbound(targetArray, offset) {\n      this.bind();\n      this.getValue(targetArray, offset);\n    }\n  }, {\n    key: "_setValue_unbound",\n    value: function _setValue_unbound(sourceArray, offset) {\n      this.bind();\n      this.setValue(sourceArray, offset);\n    } // create getter / setter pair for a property in the scene graph\n\n  }, {\n    key: "bind",\n    value: function bind() {\n      var targetObject = this.node;\n      var parsedPath = this.parsedPath;\n      var objectName = parsedPath.objectName;\n      var propertyName = parsedPath.propertyName;\n      var propertyIndex = parsedPath.propertyIndex;\n\n      if (!targetObject) {\n        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n        this.node = targetObject;\n      } // set fail state so we can just \'return\' on error\n\n\n      this.getValue = this._getValue_unavailable;\n      this.setValue = this._setValue_unavailable; // ensure there is a value node\n\n      if (!targetObject) {\n        console.error(\'THREE.PropertyBinding: Trying to update node for track: \' + this.path + \' but it wasn\\\'t found.\');\n        return;\n      }\n\n      if (objectName) {\n        var objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....\n\n        switch (objectName) {\n          case \'materials\':\n            if (!targetObject.material) {\n              console.error(\'THREE.PropertyBinding: Can not bind to material as node does not have a material.\', this);\n              return;\n            }\n\n            if (!targetObject.material.materials) {\n              console.error(\'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.\', this);\n              return;\n            }\n\n            targetObject = targetObject.material.materials;\n            break;\n\n          case \'bones\':\n            if (!targetObject.skeleton) {\n              console.error(\'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.\', this);\n              return;\n            } // potential future optimization: skip this if propertyIndex is already an integer\n            // and convert the integer string to a true integer.\n\n\n            targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.\n\n            for (var _i329 = 0; _i329 < targetObject.length; _i329++) {\n              if (targetObject[_i329].name === objectIndex) {\n                objectIndex = _i329;\n                break;\n              }\n            }\n\n            break;\n\n          default:\n            if (targetObject[objectName] === undefined) {\n              console.error(\'THREE.PropertyBinding: Can not bind to objectName of node undefined.\', this);\n              return;\n            }\n\n            targetObject = targetObject[objectName];\n        }\n\n        if (objectIndex !== undefined) {\n          if (targetObject[objectIndex] === undefined) {\n            console.error(\'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.\', this, targetObject);\n            return;\n          }\n\n          targetObject = targetObject[objectIndex];\n        }\n      } // resolve property\n\n\n      var nodeProperty = targetObject[propertyName];\n\n      if (nodeProperty === undefined) {\n        var nodeName = parsedPath.nodeName;\n        console.error(\'THREE.PropertyBinding: Trying to update property for track: \' + nodeName + \'.\' + propertyName + \' but it wasn\\\'t found.\', targetObject);\n        return;\n      } // determine versioning scheme\n\n\n      var versioning = this.Versioning.None;\n      this.targetObject = targetObject;\n\n      if (targetObject.needsUpdate !== undefined) {\n        // material\n        versioning = this.Versioning.NeedsUpdate;\n      } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n        // node transform\n        versioning = this.Versioning.MatrixWorldNeedsUpdate;\n      } // determine how the property gets bound\n\n\n      var bindingType = this.BindingType.Direct;\n\n      if (propertyIndex !== undefined) {\n        // access a sub element of the property array (only primitives are supported right now)\n        if (propertyName === \'morphTargetInfluences\') {\n          // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n          // support resolving morphTarget names into indices.\n          if (!targetObject.geometry) {\n            console.error(\'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.\', this);\n            return;\n          }\n\n          if (!targetObject.geometry.morphAttributes) {\n            console.error(\'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.\', this);\n            return;\n          }\n\n          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n          }\n        }\n\n        bindingType = this.BindingType.ArrayElement;\n        this.resolvedProperty = nodeProperty;\n        this.propertyIndex = propertyIndex;\n      } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n        // must use copy for Object3D.Euler/Quaternion\n        bindingType = this.BindingType.HasFromToArray;\n        this.resolvedProperty = nodeProperty;\n      } else if (Array.isArray(nodeProperty)) {\n        bindingType = this.BindingType.EntireArray;\n        this.resolvedProperty = nodeProperty;\n      } else {\n        this.propertyName = propertyName;\n      } // select getter / setter\n\n\n      this.getValue = this.GetterByBindingType[bindingType];\n      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n    }\n  }, {\n    key: "unbind",\n    value: function unbind() {\n      this.node = null; // back to the prototype version of getValue / setValue\n      // note: avoiding to mutate the shape of \'this\' via \'delete\'\n\n      this.getValue = this._getValue_unbound;\n      this.setValue = this._setValue_unbound;\n    }\n  }], [{\n    key: "create",\n    value: function create(root, path, parsedPath) {\n      if (!(root && root.isAnimationObjectGroup)) {\n        return new PropertyBinding(root, path, parsedPath);\n      } else {\n        return new PropertyBinding.Composite(root, path, parsedPath);\n      }\n    }\n    /**\n     * Replaces spaces with underscores and removes unsupported characters from\n     * node names, to ensure compatibility with parseTrackName().\n     *\n     * @param {string} name Node name to be sanitized.\n     * @return {string}\n     */\n\n  }, {\n    key: "sanitizeNodeName",\n    value: function sanitizeNodeName(name) {\n      return name.replace(/\\s/g, \'_\').replace(_reservedRe, \'\');\n    }\n  }, {\n    key: "parseTrackName",\n    value: function parseTrackName(trackName) {\n      var matches = _trackRe.exec(trackName);\n\n      if (matches === null) {\n        throw new Error(\'PropertyBinding: Cannot parse trackName: \' + trackName);\n      }\n\n      var results = {\n        // directoryName: matches[ 1 ], // (tschw) currently unused\n        nodeName: matches[2],\n        objectName: matches[3],\n        objectIndex: matches[4],\n        propertyName: matches[5],\n        // required\n        propertyIndex: matches[6]\n      };\n      var lastDot = results.nodeName && results.nodeName.lastIndexOf(\'.\');\n\n      if (lastDot !== undefined && lastDot !== -1) {\n        var objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there\n        // is no way to parse \'foo.bar.baz\': \'baz\' must be a property, but\n        // \'bar\' could be the objectName, or part of a nodeName (which can\n        // include \'.\' characters).\n\n        if (_supportedObjectNames.indexOf(objectName) !== -1) {\n          results.nodeName = results.nodeName.substring(0, lastDot);\n          results.objectName = objectName;\n        }\n      }\n\n      if (results.propertyName === null || results.propertyName.length === 0) {\n        throw new Error(\'PropertyBinding: can not parse propertyName from trackName: \' + trackName);\n      }\n\n      return results;\n    }\n  }, {\n    key: "findNode",\n    value: function findNode(root, nodeName) {\n      if (nodeName === undefined || nodeName === \'\' || nodeName === \'.\' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n        return root;\n      } // search into skeleton bones.\n\n\n      if (root.skeleton) {\n        var bone = root.skeleton.getBoneByName(nodeName);\n\n        if (bone !== undefined) {\n          return bone;\n        }\n      } // search into node subtree.\n\n\n      if (root.children) {\n        var searchNodeSubtree = function searchNodeSubtree(children) {\n          for (var _i330 = 0; _i330 < children.length; _i330++) {\n            var childNode = children[_i330];\n\n            if (childNode.name === nodeName || childNode.uuid === nodeName) {\n              return childNode;\n            }\n\n            var result = searchNodeSubtree(childNode.children);\n            if (result) return result;\n          }\n\n          return null;\n        };\n\n        var subTreeNode = searchNodeSubtree(root.children);\n\n        if (subTreeNode) {\n          return subTreeNode;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return PropertyBinding;\n}();\n\nPropertyBinding.Composite = Composite;\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: 3\n};\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: 1,\n  MatrixWorldNeedsUpdate: 2\n};\nPropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct\nPropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray\nPropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement\nPropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray\nPropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as \'root\' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as \'root\'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nvar AnimationObjectGroup = /*#__PURE__*/function () {\n  function AnimationObjectGroup() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AnimationObjectGroup);\n\n    this.isAnimationObjectGroup = true;\n    this.uuid = generateUUID(); // cached objects followed by the active ones\n\n    this._objects = Array.prototype.slice.call(arguments);\n    this.nCachedObjects_ = 0; // threshold\n    // note: read by PropertyBinding.Composite\n\n    var indices = {};\n    this._indicesByUUID = indices; // for bookkeeping\n\n    for (var _i331 = 0, n = arguments.length; _i331 !== n; ++_i331) {\n      indices[arguments[_i331].uuid] = _i331;\n    }\n\n    this._paths = []; // inside: string\n\n    this._parsedPaths = []; // inside: { we don\'t care, here }\n\n    this._bindings = []; // inside: Array< PropertyBinding >\n\n    this._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n    var scope = this;\n    this.stats = {\n      objects: {\n        get total() {\n          return scope._objects.length;\n        },\n\n        get inUse() {\n          return this.total - scope.nCachedObjects_;\n        }\n\n      },\n\n      get bindingsPerObject() {\n        return scope._bindings.length;\n      }\n\n    };\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AnimationObjectGroup, [{\n    key: "add",\n    value: function add() {\n      var objects = this._objects,\n          indicesByUUID = this._indicesByUUID,\n          paths = this._paths,\n          parsedPaths = this._parsedPaths,\n          bindings = this._bindings,\n          nBindings = bindings.length;\n      var knownObject = undefined,\n          nObjects = objects.length,\n          nCachedObjects = this.nCachedObjects_;\n\n      for (var _i332 = 0, n = arguments.length; _i332 !== n; ++_i332) {\n        var object = arguments[_i332],\n            uuid = object.uuid;\n        var index = indicesByUUID[uuid];\n\n        if (index === undefined) {\n          // unknown object -> add it to the ACTIVE region\n          index = nObjects++;\n          indicesByUUID[uuid] = index;\n          objects.push(object); // accounting is done, now do the same for all bindings\n\n          for (var j = 0, m = nBindings; j !== m; ++j) {\n            bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n          }\n        } else if (index < nCachedObjects) {\n          knownObject = objects[index]; // move existing object to the ACTIVE region\n\n          var firstActiveIndex = --nCachedObjects,\n              lastCachedObject = objects[firstActiveIndex];\n          indicesByUUID[lastCachedObject.uuid] = index;\n          objects[index] = lastCachedObject;\n          indicesByUUID[uuid] = firstActiveIndex;\n          objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings\n\n          for (var _j16 = 0, _m2 = nBindings; _j16 !== _m2; ++_j16) {\n            var bindingsForPath = bindings[_j16],\n                lastCached = bindingsForPath[firstActiveIndex];\n            var binding = bindingsForPath[index];\n            bindingsForPath[index] = lastCached;\n\n            if (binding === undefined) {\n              // since we do not bother to create new bindings\n              // for objects that are cached, the binding may\n              // or may not exist\n              binding = new PropertyBinding(object, paths[_j16], parsedPaths[_j16]);\n            }\n\n            bindingsForPath[firstActiveIndex] = binding;\n          }\n        } else if (objects[index] !== knownObject) {\n          console.error(\'THREE.AnimationObjectGroup: Different objects with the same UUID \' + \'detected. Clean the caches or recreate your infrastructure when reloading scenes.\');\n        } // else the object is already where we want it to be\n\n      } // for arguments\n\n\n      this.nCachedObjects_ = nCachedObjects;\n    }\n  }, {\n    key: "remove",\n    value: function remove() {\n      var objects = this._objects,\n          indicesByUUID = this._indicesByUUID,\n          bindings = this._bindings,\n          nBindings = bindings.length;\n      var nCachedObjects = this.nCachedObjects_;\n\n      for (var _i333 = 0, n = arguments.length; _i333 !== n; ++_i333) {\n        var object = arguments[_i333],\n            uuid = object.uuid,\n            index = indicesByUUID[uuid];\n\n        if (index !== undefined && index >= nCachedObjects) {\n          // move existing object into the CACHED region\n          var lastCachedIndex = nCachedObjects++,\n              firstActiveObject = objects[lastCachedIndex];\n          indicesByUUID[firstActiveObject.uuid] = index;\n          objects[index] = firstActiveObject;\n          indicesByUUID[uuid] = lastCachedIndex;\n          objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings\n\n          for (var j = 0, m = nBindings; j !== m; ++j) {\n            var bindingsForPath = bindings[j],\n                firstActive = bindingsForPath[lastCachedIndex],\n                binding = bindingsForPath[index];\n            bindingsForPath[index] = firstActive;\n            bindingsForPath[lastCachedIndex] = binding;\n          }\n        }\n      } // for arguments\n\n\n      this.nCachedObjects_ = nCachedObjects;\n    } // remove & forget\n\n  }, {\n    key: "uncache",\n    value: function uncache() {\n      var objects = this._objects,\n          indicesByUUID = this._indicesByUUID,\n          bindings = this._bindings,\n          nBindings = bindings.length;\n      var nCachedObjects = this.nCachedObjects_,\n          nObjects = objects.length;\n\n      for (var _i334 = 0, n = arguments.length; _i334 !== n; ++_i334) {\n        var object = arguments[_i334],\n            uuid = object.uuid,\n            index = indicesByUUID[uuid];\n\n        if (index !== undefined) {\n          delete indicesByUUID[uuid];\n\n          if (index < nCachedObjects) {\n            // object is cached, shrink the CACHED region\n            var firstActiveIndex = --nCachedObjects,\n                lastCachedObject = objects[firstActiveIndex],\n                lastIndex = --nObjects,\n                lastObject = objects[lastIndex]; // last cached object takes this object\'s place\n\n            indicesByUUID[lastCachedObject.uuid] = index;\n            objects[index] = lastCachedObject; // last object goes to the activated slot and pop\n\n            indicesByUUID[lastObject.uuid] = firstActiveIndex;\n            objects[firstActiveIndex] = lastObject;\n            objects.pop(); // accounting is done, now do the same for all bindings\n\n            for (var j = 0, m = nBindings; j !== m; ++j) {\n              var bindingsForPath = bindings[j],\n                  lastCached = bindingsForPath[firstActiveIndex],\n                  last = bindingsForPath[lastIndex];\n              bindingsForPath[index] = lastCached;\n              bindingsForPath[firstActiveIndex] = last;\n              bindingsForPath.pop();\n            }\n          } else {\n            // object is active, just swap with the last and pop\n            var _lastIndex = --nObjects,\n                _lastObject = objects[_lastIndex];\n\n            if (_lastIndex > 0) {\n              indicesByUUID[_lastObject.uuid] = index;\n            }\n\n            objects[index] = _lastObject;\n            objects.pop(); // accounting is done, now do the same for all bindings\n\n            for (var _j17 = 0, _m3 = nBindings; _j17 !== _m3; ++_j17) {\n              var _bindingsForPath = bindings[_j17];\n              _bindingsForPath[index] = _bindingsForPath[_lastIndex];\n\n              _bindingsForPath.pop();\n            }\n          } // cached or active\n\n        } // if object is known\n\n      } // for arguments\n\n\n      this.nCachedObjects_ = nCachedObjects;\n    } // Internal interface used by befriended PropertyBinding.Composite:\n\n  }, {\n    key: "subscribe_",\n    value: function subscribe_(path, parsedPath) {\n      // returns an array of bindings for the given path that is changed\n      // according to the contained objects in the group\n      var indicesByPath = this._bindingsIndicesByPath;\n      var index = indicesByPath[path];\n      var bindings = this._bindings;\n      if (index !== undefined) return bindings[index];\n      var paths = this._paths,\n          parsedPaths = this._parsedPaths,\n          objects = this._objects,\n          nObjects = objects.length,\n          nCachedObjects = this.nCachedObjects_,\n          bindingsForPath = new Array(nObjects);\n      index = bindings.length;\n      indicesByPath[path] = index;\n      paths.push(path);\n      parsedPaths.push(parsedPath);\n      bindings.push(bindingsForPath);\n\n      for (var _i335 = nCachedObjects, n = objects.length; _i335 !== n; ++_i335) {\n        var object = objects[_i335];\n        bindingsForPath[_i335] = new PropertyBinding(object, path, parsedPath);\n      }\n\n      return bindingsForPath;\n    }\n  }, {\n    key: "unsubscribe_",\n    value: function unsubscribe_(path) {\n      // tells the group to forget about a property path and no longer\n      // update the array previously obtained with \'subscribe_\'\n      var indicesByPath = this._bindingsIndicesByPath,\n          index = indicesByPath[path];\n\n      if (index !== undefined) {\n        var paths = this._paths,\n            parsedPaths = this._parsedPaths,\n            bindings = this._bindings,\n            lastBindingsIndex = bindings.length - 1,\n            lastBindings = bindings[lastBindingsIndex],\n            lastBindingsPath = path[lastBindingsIndex];\n        indicesByPath[lastBindingsPath] = index;\n        bindings[index] = lastBindings;\n        bindings.pop();\n        parsedPaths[index] = parsedPaths[lastBindingsIndex];\n        parsedPaths.pop();\n        paths[index] = paths[lastBindingsIndex];\n        paths.pop();\n      }\n    }\n  }]);\n\n  return AnimationObjectGroup;\n}();\n\nvar AnimationAction = /*#__PURE__*/function () {\n  function AnimationAction(mixer, clip) {\n    var localRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : clip.blendMode;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AnimationAction);\n\n    this._mixer = mixer;\n    this._clip = clip;\n    this._localRoot = localRoot;\n    this.blendMode = blendMode;\n    var tracks = clip.tracks,\n        nTracks = tracks.length,\n        interpolants = new Array(nTracks);\n    var interpolantSettings = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n\n    for (var _i336 = 0; _i336 !== nTracks; ++_i336) {\n      var interpolant = tracks[_i336].createInterpolant(null);\n\n      interpolants[_i336] = interpolant;\n      interpolant.settings = interpolantSettings;\n    }\n\n    this._interpolantSettings = interpolantSettings;\n    this._interpolants = interpolants; // bound by the mixer\n    // inside: PropertyMixer (managed by the mixer)\n\n    this._propertyBindings = new Array(nTracks);\n    this._cacheIndex = null; // for the memory manager\n\n    this._byClipCacheIndex = null; // for the memory manager\n\n    this._timeScaleInterpolant = null;\n    this._weightInterpolant = null;\n    this.loop = LoopRepeat;\n    this._loopCount = -1; // global mixer time when the action is to be started\n    // it\'s set back to \'null\' upon start of the action\n\n    this._startTime = null; // scaled local time of the action\n    // gets clamped or wrapped to 0..clip.duration according to loop\n\n    this.time = 0;\n    this.timeScale = 1;\n    this._effectiveTimeScale = 1;\n    this.weight = 1;\n    this._effectiveWeight = 1;\n    this.repetitions = Infinity; // no. of repetitions when looping\n\n    this.paused = false; // true -> zero effective time scale\n\n    this.enabled = true; // false -> zero effective weight\n\n    this.clampWhenFinished = false; // keep feeding the last frame?\n\n    this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n\n    this.zeroSlopeAtEnd = true; // clips for start, loop and end\n  } // State & Scheduling\n\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AnimationAction, [{\n    key: "play",\n    value: function play() {\n      this._mixer._activateAction(this);\n\n      return this;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._mixer._deactivateAction(this);\n\n      return this.reset();\n    }\n  }, {\n    key: "reset",\n    value: function reset() {\n      this.paused = false;\n      this.enabled = true;\n      this.time = 0; // restart clip\n\n      this._loopCount = -1; // forget previous loops\n\n      this._startTime = null; // forget scheduling\n\n      return this.stopFading().stopWarping();\n    }\n  }, {\n    key: "isRunning",\n    value: function isRunning() {\n      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n    } // return true when play has been called\n\n  }, {\n    key: "isScheduled",\n    value: function isScheduled() {\n      return this._mixer._isActiveAction(this);\n    }\n  }, {\n    key: "startAt",\n    value: function startAt(time) {\n      this._startTime = time;\n      return this;\n    }\n  }, {\n    key: "setLoop",\n    value: function setLoop(mode, repetitions) {\n      this.loop = mode;\n      this.repetitions = repetitions;\n      return this;\n    } // Weight\n    // set the weight stopping any scheduled fading\n    // although .enabled = false yields an effective weight of zero, this\n    // method does *not* change .enabled, because it would be confusing\n\n  }, {\n    key: "setEffectiveWeight",\n    value: function setEffectiveWeight(weight) {\n      this.weight = weight; // note: same logic as when updated at runtime\n\n      this._effectiveWeight = this.enabled ? weight : 0;\n      return this.stopFading();\n    } // return the weight considering fading and .enabled\n\n  }, {\n    key: "getEffectiveWeight",\n    value: function getEffectiveWeight() {\n      return this._effectiveWeight;\n    }\n  }, {\n    key: "fadeIn",\n    value: function fadeIn(duration) {\n      return this._scheduleFading(duration, 0, 1);\n    }\n  }, {\n    key: "fadeOut",\n    value: function fadeOut(duration) {\n      return this._scheduleFading(duration, 1, 0);\n    }\n  }, {\n    key: "crossFadeFrom",\n    value: function crossFadeFrom(fadeOutAction, duration, warp) {\n      fadeOutAction.fadeOut(duration);\n      this.fadeIn(duration);\n\n      if (warp) {\n        var fadeInDuration = this._clip.duration,\n            fadeOutDuration = fadeOutAction._clip.duration,\n            startEndRatio = fadeOutDuration / fadeInDuration,\n            endStartRatio = fadeInDuration / fadeOutDuration;\n        fadeOutAction.warp(1.0, startEndRatio, duration);\n        this.warp(endStartRatio, 1.0, duration);\n      }\n\n      return this;\n    }\n  }, {\n    key: "crossFadeTo",\n    value: function crossFadeTo(fadeInAction, duration, warp) {\n      return fadeInAction.crossFadeFrom(this, duration, warp);\n    }\n  }, {\n    key: "stopFading",\n    value: function stopFading() {\n      var weightInterpolant = this._weightInterpolant;\n\n      if (weightInterpolant !== null) {\n        this._weightInterpolant = null;\n\n        this._mixer._takeBackControlInterpolant(weightInterpolant);\n      }\n\n      return this;\n    } // Time Scale Control\n    // set the time scale stopping any scheduled warping\n    // although .paused = true yields an effective time scale of zero, this\n    // method does *not* change .paused, because it would be confusing\n\n  }, {\n    key: "setEffectiveTimeScale",\n    value: function setEffectiveTimeScale(timeScale) {\n      this.timeScale = timeScale;\n      this._effectiveTimeScale = this.paused ? 0 : timeScale;\n      return this.stopWarping();\n    } // return the time scale considering warping and .paused\n\n  }, {\n    key: "getEffectiveTimeScale",\n    value: function getEffectiveTimeScale() {\n      return this._effectiveTimeScale;\n    }\n  }, {\n    key: "setDuration",\n    value: function setDuration(duration) {\n      this.timeScale = this._clip.duration / duration;\n      return this.stopWarping();\n    }\n  }, {\n    key: "syncWith",\n    value: function syncWith(action) {\n      this.time = action.time;\n      this.timeScale = action.timeScale;\n      return this.stopWarping();\n    }\n  }, {\n    key: "halt",\n    value: function halt(duration) {\n      return this.warp(this._effectiveTimeScale, 0, duration);\n    }\n  }, {\n    key: "warp",\n    value: function warp(startTimeScale, endTimeScale, duration) {\n      var mixer = this._mixer,\n          now = mixer.time,\n          timeScale = this.timeScale;\n      var interpolant = this._timeScaleInterpolant;\n\n      if (interpolant === null) {\n        interpolant = mixer._lendControlInterpolant();\n        this._timeScaleInterpolant = interpolant;\n      }\n\n      var times = interpolant.parameterPositions,\n          values = interpolant.sampleValues;\n      times[0] = now;\n      times[1] = now + duration;\n      values[0] = startTimeScale / timeScale;\n      values[1] = endTimeScale / timeScale;\n      return this;\n    }\n  }, {\n    key: "stopWarping",\n    value: function stopWarping() {\n      var timeScaleInterpolant = this._timeScaleInterpolant;\n\n      if (timeScaleInterpolant !== null) {\n        this._timeScaleInterpolant = null;\n\n        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n      }\n\n      return this;\n    } // Object Accessors\n\n  }, {\n    key: "getMixer",\n    value: function getMixer() {\n      return this._mixer;\n    }\n  }, {\n    key: "getClip",\n    value: function getClip() {\n      return this._clip;\n    }\n  }, {\n    key: "getRoot",\n    value: function getRoot() {\n      return this._localRoot || this._mixer._root;\n    } // Interna\n\n  }, {\n    key: "_update",\n    value: function _update(time, deltaTime, timeDirection, accuIndex) {\n      // called by the mixer\n      if (!this.enabled) {\n        // call ._updateWeight() to update ._effectiveWeight\n        this._updateWeight(time);\n\n        return;\n      }\n\n      var startTime = this._startTime;\n\n      if (startTime !== null) {\n        // check for scheduled start of action\n        var timeRunning = (time - startTime) * timeDirection;\n\n        if (timeRunning < 0 || timeDirection === 0) {\n          return; // yet to come / don\'t decide when delta = 0\n        } // start\n\n\n        this._startTime = null; // unschedule\n\n        deltaTime = timeDirection * timeRunning;\n      } // apply time scale and advance time\n\n\n      deltaTime *= this._updateTimeScale(time);\n\n      var clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in\n      // an effective weight of 0\n\n\n      var weight = this._updateWeight(time);\n\n      if (weight > 0) {\n        var interpolants = this._interpolants;\n        var propertyMixers = this._propertyBindings;\n\n        switch (this.blendMode) {\n          case AdditiveAnimationBlendMode:\n            for (var j = 0, m = interpolants.length; j !== m; ++j) {\n              interpolants[j].evaluate(clipTime);\n              propertyMixers[j].accumulateAdditive(weight);\n            }\n\n            break;\n\n          case NormalAnimationBlendMode:\n          default:\n            for (var _j18 = 0, _m4 = interpolants.length; _j18 !== _m4; ++_j18) {\n              interpolants[_j18].evaluate(clipTime);\n\n              propertyMixers[_j18].accumulate(accuIndex, weight);\n            }\n\n        }\n      }\n    }\n  }, {\n    key: "_updateWeight",\n    value: function _updateWeight(time) {\n      var weight = 0;\n\n      if (this.enabled) {\n        weight = this.weight;\n        var interpolant = this._weightInterpolant;\n\n        if (interpolant !== null) {\n          var interpolantValue = interpolant.evaluate(time)[0];\n          weight *= interpolantValue;\n\n          if (time > interpolant.parameterPositions[1]) {\n            this.stopFading();\n\n            if (interpolantValue === 0) {\n              // faded out, disable\n              this.enabled = false;\n            }\n          }\n        }\n      }\n\n      this._effectiveWeight = weight;\n      return weight;\n    }\n  }, {\n    key: "_updateTimeScale",\n    value: function _updateTimeScale(time) {\n      var timeScale = 0;\n\n      if (!this.paused) {\n        timeScale = this.timeScale;\n        var interpolant = this._timeScaleInterpolant;\n\n        if (interpolant !== null) {\n          var interpolantValue = interpolant.evaluate(time)[0];\n          timeScale *= interpolantValue;\n\n          if (time > interpolant.parameterPositions[1]) {\n            this.stopWarping();\n\n            if (timeScale === 0) {\n              // motion has halted, pause\n              this.paused = true;\n            } else {\n              // warp done - apply final time scale\n              this.timeScale = timeScale;\n            }\n          }\n        }\n      }\n\n      this._effectiveTimeScale = timeScale;\n      return timeScale;\n    }\n  }, {\n    key: "_updateTime",\n    value: function _updateTime(deltaTime) {\n      var duration = this._clip.duration;\n      var loop = this.loop;\n      var time = this.time + deltaTime;\n      var loopCount = this._loopCount;\n      var pingPong = loop === LoopPingPong;\n\n      if (deltaTime === 0) {\n        if (loopCount === -1) return time;\n        return pingPong && (loopCount & 1) === 1 ? duration - time : time;\n      }\n\n      if (loop === LoopOnce) {\n        if (loopCount === -1) {\n          // just started\n          this._loopCount = 0;\n\n          this._setEndings(true, true, false);\n        }\n\n        handle_stop: {\n          if (time >= duration) {\n            time = duration;\n          } else if (time < 0) {\n            time = 0;\n          } else {\n            this.time = time;\n            break handle_stop;\n          }\n\n          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n          this.time = time;\n\n          this._mixer.dispatchEvent({\n            type: \'finished\',\n            action: this,\n            direction: deltaTime < 0 ? -1 : 1\n          });\n        }\n      } else {\n        // repetitive Repeat or PingPong\n        if (loopCount === -1) {\n          // just started\n          if (deltaTime >= 0) {\n            loopCount = 0;\n\n            this._setEndings(true, this.repetitions === 0, pingPong);\n          } else {\n            // when looping in reverse direction, the initial\n            // transition through zero counts as a repetition,\n            // so leave loopCount at -1\n            this._setEndings(this.repetitions === 0, true, pingPong);\n          }\n        }\n\n        if (time >= duration || time < 0) {\n          // wrap around\n          var loopDelta = Math.floor(time / duration); // signed\n\n          time -= duration * loopDelta;\n          loopCount += Math.abs(loopDelta);\n          var pending = this.repetitions - loopCount;\n\n          if (pending <= 0) {\n            // have to stop (switch state, clamp time, fire event)\n            if (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n            time = deltaTime > 0 ? duration : 0;\n            this.time = time;\n\n            this._mixer.dispatchEvent({\n              type: \'finished\',\n              action: this,\n              direction: deltaTime > 0 ? 1 : -1\n            });\n          } else {\n            // keep running\n            if (pending === 1) {\n              // entering the last round\n              var atStart = deltaTime < 0;\n\n              this._setEndings(atStart, !atStart, pingPong);\n            } else {\n              this._setEndings(false, false, pingPong);\n            }\n\n            this._loopCount = loopCount;\n            this.time = time;\n\n            this._mixer.dispatchEvent({\n              type: \'loop\',\n              action: this,\n              loopDelta: loopDelta\n            });\n          }\n        } else {\n          this.time = time;\n        }\n\n        if (pingPong && (loopCount & 1) === 1) {\n          // invert time for the "pong round"\n          return duration - time;\n        }\n      }\n\n      return time;\n    }\n  }, {\n    key: "_setEndings",\n    value: function _setEndings(atStart, atEnd, pingPong) {\n      var settings = this._interpolantSettings;\n\n      if (pingPong) {\n        settings.endingStart = ZeroSlopeEnding;\n        settings.endingEnd = ZeroSlopeEnding;\n      } else {\n        // assuming for LoopOnce atStart == atEnd == true\n        if (atStart) {\n          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n        } else {\n          settings.endingStart = WrapAroundEnding;\n        }\n\n        if (atEnd) {\n          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n        } else {\n          settings.endingEnd = WrapAroundEnding;\n        }\n      }\n    }\n  }, {\n    key: "_scheduleFading",\n    value: function _scheduleFading(duration, weightNow, weightThen) {\n      var mixer = this._mixer,\n          now = mixer.time;\n      var interpolant = this._weightInterpolant;\n\n      if (interpolant === null) {\n        interpolant = mixer._lendControlInterpolant();\n        this._weightInterpolant = interpolant;\n      }\n\n      var times = interpolant.parameterPositions,\n          values = interpolant.sampleValues;\n      times[0] = now;\n      values[0] = weightNow;\n      times[1] = now + duration;\n      values[1] = weightThen;\n      return this;\n    }\n  }]);\n\n  return AnimationAction;\n}();\n\nvar _controlInterpolantsResultBuffer = /*@__PURE__*/new Float32Array(1);\n\nvar AnimationMixer = /*#__PURE__*/function (_EventDispatcher7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(AnimationMixer, _EventDispatcher7);\n\n  var _super139 = _createSuper(AnimationMixer);\n\n  function AnimationMixer(root) {\n    var _this112;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AnimationMixer);\n\n    _this112 = _super139.call(this);\n    _this112._root = root;\n\n    _this112._initMemoryManager();\n\n    _this112._accuIndex = 0;\n    _this112.time = 0;\n    _this112.timeScale = 1.0;\n    return _this112;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AnimationMixer, [{\n    key: "_bindAction",\n    value: function _bindAction(action, prototypeAction) {\n      var root = action._localRoot || this._root,\n          tracks = action._clip.tracks,\n          nTracks = tracks.length,\n          bindings = action._propertyBindings,\n          interpolants = action._interpolants,\n          rootUuid = root.uuid,\n          bindingsByRoot = this._bindingsByRootAndName;\n      var bindingsByName = bindingsByRoot[rootUuid];\n\n      if (bindingsByName === undefined) {\n        bindingsByName = {};\n        bindingsByRoot[rootUuid] = bindingsByName;\n      }\n\n      for (var _i337 = 0; _i337 !== nTracks; ++_i337) {\n        var track = tracks[_i337],\n            trackName = track.name;\n        var binding = bindingsByName[trackName];\n\n        if (binding !== undefined) {\n          ++binding.referenceCount;\n          bindings[_i337] = binding;\n        } else {\n          binding = bindings[_i337];\n\n          if (binding !== undefined) {\n            // existing binding, make sure the cache knows\n            if (binding._cacheIndex === null) {\n              ++binding.referenceCount;\n\n              this._addInactiveBinding(binding, rootUuid, trackName);\n            }\n\n            continue;\n          }\n\n          var path = prototypeAction && prototypeAction._propertyBindings[_i337].binding.parsedPath;\n          binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n          ++binding.referenceCount;\n\n          this._addInactiveBinding(binding, rootUuid, trackName);\n\n          bindings[_i337] = binding;\n        }\n\n        interpolants[_i337].resultBuffer = binding.buffer;\n      }\n    }\n  }, {\n    key: "_activateAction",\n    value: function _activateAction(action) {\n      if (!this._isActiveAction(action)) {\n        if (action._cacheIndex === null) {\n          // this action has been forgotten by the cache, but the user\n          // appears to be still using it -> rebind\n          var rootUuid = (action._localRoot || this._root).uuid,\n              clipUuid = action._clip.uuid,\n              actionsForClip = this._actionsByClip[clipUuid];\n\n          this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n          this._addInactiveAction(action, clipUuid, rootUuid);\n        }\n\n        var bindings = action._propertyBindings; // increment reference counts / sort out state\n\n        for (var _i338 = 0, n = bindings.length; _i338 !== n; ++_i338) {\n          var binding = bindings[_i338];\n\n          if (binding.useCount++ === 0) {\n            this._lendBinding(binding);\n\n            binding.saveOriginalState();\n          }\n        }\n\n        this._lendAction(action);\n      }\n    }\n  }, {\n    key: "_deactivateAction",\n    value: function _deactivateAction(action) {\n      if (this._isActiveAction(action)) {\n        var bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n        for (var _i339 = 0, n = bindings.length; _i339 !== n; ++_i339) {\n          var binding = bindings[_i339];\n\n          if (--binding.useCount === 0) {\n            binding.restoreOriginalState();\n\n            this._takeBackBinding(binding);\n          }\n        }\n\n        this._takeBackAction(action);\n      }\n    } // Memory manager\n\n  }, {\n    key: "_initMemoryManager",\n    value: function _initMemoryManager() {\n      this._actions = []; // \'nActiveActions\' followed by inactive ones\n\n      this._nActiveActions = 0;\n      this._actionsByClip = {}; // inside:\n      // {\n      // \tknownActions: Array< AnimationAction > - used as prototypes\n      // \tactionByRoot: AnimationAction - lookup\n      // }\n\n      this._bindings = []; // \'nActiveBindings\' followed by inactive ones\n\n      this._nActiveBindings = 0;\n      this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n      this._controlInterpolants = []; // same game as above\n\n      this._nActiveControlInterpolants = 0;\n      var scope = this;\n      this.stats = {\n        actions: {\n          get total() {\n            return scope._actions.length;\n          },\n\n          get inUse() {\n            return scope._nActiveActions;\n          }\n\n        },\n        bindings: {\n          get total() {\n            return scope._bindings.length;\n          },\n\n          get inUse() {\n            return scope._nActiveBindings;\n          }\n\n        },\n        controlInterpolants: {\n          get total() {\n            return scope._controlInterpolants.length;\n          },\n\n          get inUse() {\n            return scope._nActiveControlInterpolants;\n          }\n\n        }\n      };\n    } // Memory management for AnimationAction objects\n\n  }, {\n    key: "_isActiveAction",\n    value: function _isActiveAction(action) {\n      var index = action._cacheIndex;\n      return index !== null && index < this._nActiveActions;\n    }\n  }, {\n    key: "_addInactiveAction",\n    value: function _addInactiveAction(action, clipUuid, rootUuid) {\n      var actions = this._actions,\n          actionsByClip = this._actionsByClip;\n      var actionsForClip = actionsByClip[clipUuid];\n\n      if (actionsForClip === undefined) {\n        actionsForClip = {\n          knownActions: [action],\n          actionByRoot: {}\n        };\n        action._byClipCacheIndex = 0;\n        actionsByClip[clipUuid] = actionsForClip;\n      } else {\n        var knownActions = actionsForClip.knownActions;\n        action._byClipCacheIndex = knownActions.length;\n        knownActions.push(action);\n      }\n\n      action._cacheIndex = actions.length;\n      actions.push(action);\n      actionsForClip.actionByRoot[rootUuid] = action;\n    }\n  }, {\n    key: "_removeInactiveAction",\n    value: function _removeInactiveAction(action) {\n      var actions = this._actions,\n          lastInactiveAction = actions[actions.length - 1],\n          cacheIndex = action._cacheIndex;\n      lastInactiveAction._cacheIndex = cacheIndex;\n      actions[cacheIndex] = lastInactiveAction;\n      actions.pop();\n      action._cacheIndex = null;\n      var clipUuid = action._clip.uuid,\n          actionsByClip = this._actionsByClip,\n          actionsForClip = actionsByClip[clipUuid],\n          knownActionsForClip = actionsForClip.knownActions,\n          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n          byClipCacheIndex = action._byClipCacheIndex;\n      lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n      knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n      knownActionsForClip.pop();\n      action._byClipCacheIndex = null;\n      var actionByRoot = actionsForClip.actionByRoot,\n          rootUuid = (action._localRoot || this._root).uuid;\n      delete actionByRoot[rootUuid];\n\n      if (knownActionsForClip.length === 0) {\n        delete actionsByClip[clipUuid];\n      }\n\n      this._removeInactiveBindingsForAction(action);\n    }\n  }, {\n    key: "_removeInactiveBindingsForAction",\n    value: function _removeInactiveBindingsForAction(action) {\n      var bindings = action._propertyBindings;\n\n      for (var _i340 = 0, n = bindings.length; _i340 !== n; ++_i340) {\n        var binding = bindings[_i340];\n\n        if (--binding.referenceCount === 0) {\n          this._removeInactiveBinding(binding);\n        }\n      }\n    }\n  }, {\n    key: "_lendAction",\n    value: function _lendAction(action) {\n      // [ active actions |  inactive actions  ]\n      // [  active actions >| inactive actions ]\n      //                 s        a\n      //                  <-swap->\n      //                 a        s\n      var actions = this._actions,\n          prevIndex = action._cacheIndex,\n          lastActiveIndex = this._nActiveActions++,\n          firstInactiveAction = actions[lastActiveIndex];\n      action._cacheIndex = lastActiveIndex;\n      actions[lastActiveIndex] = action;\n      firstInactiveAction._cacheIndex = prevIndex;\n      actions[prevIndex] = firstInactiveAction;\n    }\n  }, {\n    key: "_takeBackAction",\n    value: function _takeBackAction(action) {\n      // [  active actions  | inactive actions ]\n      // [ active actions |< inactive actions  ]\n      //        a        s\n      //         <-swap->\n      //        s        a\n      var actions = this._actions,\n          prevIndex = action._cacheIndex,\n          firstInactiveIndex = --this._nActiveActions,\n          lastActiveAction = actions[firstInactiveIndex];\n      action._cacheIndex = firstInactiveIndex;\n      actions[firstInactiveIndex] = action;\n      lastActiveAction._cacheIndex = prevIndex;\n      actions[prevIndex] = lastActiveAction;\n    } // Memory management for PropertyMixer objects\n\n  }, {\n    key: "_addInactiveBinding",\n    value: function _addInactiveBinding(binding, rootUuid, trackName) {\n      var bindingsByRoot = this._bindingsByRootAndName,\n          bindings = this._bindings;\n      var bindingByName = bindingsByRoot[rootUuid];\n\n      if (bindingByName === undefined) {\n        bindingByName = {};\n        bindingsByRoot[rootUuid] = bindingByName;\n      }\n\n      bindingByName[trackName] = binding;\n      binding._cacheIndex = bindings.length;\n      bindings.push(binding);\n    }\n  }, {\n    key: "_removeInactiveBinding",\n    value: function _removeInactiveBinding(binding) {\n      var bindings = this._bindings,\n          propBinding = binding.binding,\n          rootUuid = propBinding.rootNode.uuid,\n          trackName = propBinding.path,\n          bindingsByRoot = this._bindingsByRootAndName,\n          bindingByName = bindingsByRoot[rootUuid],\n          lastInactiveBinding = bindings[bindings.length - 1],\n          cacheIndex = binding._cacheIndex;\n      lastInactiveBinding._cacheIndex = cacheIndex;\n      bindings[cacheIndex] = lastInactiveBinding;\n      bindings.pop();\n      delete bindingByName[trackName];\n\n      if (Object.keys(bindingByName).length === 0) {\n        delete bindingsByRoot[rootUuid];\n      }\n    }\n  }, {\n    key: "_lendBinding",\n    value: function _lendBinding(binding) {\n      var bindings = this._bindings,\n          prevIndex = binding._cacheIndex,\n          lastActiveIndex = this._nActiveBindings++,\n          firstInactiveBinding = bindings[lastActiveIndex];\n      binding._cacheIndex = lastActiveIndex;\n      bindings[lastActiveIndex] = binding;\n      firstInactiveBinding._cacheIndex = prevIndex;\n      bindings[prevIndex] = firstInactiveBinding;\n    }\n  }, {\n    key: "_takeBackBinding",\n    value: function _takeBackBinding(binding) {\n      var bindings = this._bindings,\n          prevIndex = binding._cacheIndex,\n          firstInactiveIndex = --this._nActiveBindings,\n          lastActiveBinding = bindings[firstInactiveIndex];\n      binding._cacheIndex = firstInactiveIndex;\n      bindings[firstInactiveIndex] = binding;\n      lastActiveBinding._cacheIndex = prevIndex;\n      bindings[prevIndex] = lastActiveBinding;\n    } // Memory management of Interpolants for weight and time scale\n\n  }, {\n    key: "_lendControlInterpolant",\n    value: function _lendControlInterpolant() {\n      var interpolants = this._controlInterpolants,\n          lastActiveIndex = this._nActiveControlInterpolants++;\n      var interpolant = interpolants[lastActiveIndex];\n\n      if (interpolant === undefined) {\n        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer);\n        interpolant.__cacheIndex = lastActiveIndex;\n        interpolants[lastActiveIndex] = interpolant;\n      }\n\n      return interpolant;\n    }\n  }, {\n    key: "_takeBackControlInterpolant",\n    value: function _takeBackControlInterpolant(interpolant) {\n      var interpolants = this._controlInterpolants,\n          prevIndex = interpolant.__cacheIndex,\n          firstInactiveIndex = --this._nActiveControlInterpolants,\n          lastActiveInterpolant = interpolants[firstInactiveIndex];\n      interpolant.__cacheIndex = firstInactiveIndex;\n      interpolants[firstInactiveIndex] = interpolant;\n      lastActiveInterpolant.__cacheIndex = prevIndex;\n      interpolants[prevIndex] = lastActiveInterpolant;\n    } // return an action for a clip optionally using a custom root target\n    // object (this method allocates a lot of dynamic memory in case a\n    // previously unknown clip/root combination is specified)\n\n  }, {\n    key: "clipAction",\n    value: function clipAction(clip, optionalRoot, blendMode) {\n      var root = optionalRoot || this._root,\n          rootUuid = root.uuid;\n      var clipObject = typeof clip === \'string\' ? AnimationClip.findByName(root, clip) : clip;\n      var clipUuid = clipObject !== null ? clipObject.uuid : clip;\n      var actionsForClip = this._actionsByClip[clipUuid];\n      var prototypeAction = null;\n\n      if (blendMode === undefined) {\n        if (clipObject !== null) {\n          blendMode = clipObject.blendMode;\n        } else {\n          blendMode = NormalAnimationBlendMode;\n        }\n      }\n\n      if (actionsForClip !== undefined) {\n        var existingAction = actionsForClip.actionByRoot[rootUuid];\n\n        if (existingAction !== undefined && existingAction.blendMode === blendMode) {\n          return existingAction;\n        } // we know the clip, so we don\'t have to parse all\n        // the bindings again but can just copy\n\n\n        prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n        if (clipObject === null) clipObject = prototypeAction._clip;\n      } // clip must be known when specified via string\n\n\n      if (clipObject === null) return null; // allocate all resources required to run it\n\n      var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n\n      this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n      this._addInactiveAction(newAction, clipUuid, rootUuid);\n\n      return newAction;\n    } // get an existing action\n\n  }, {\n    key: "existingAction",\n    value: function existingAction(clip, optionalRoot) {\n      var root = optionalRoot || this._root,\n          rootUuid = root.uuid,\n          clipObject = typeof clip === \'string\' ? AnimationClip.findByName(root, clip) : clip,\n          clipUuid = clipObject ? clipObject.uuid : clip,\n          actionsForClip = this._actionsByClip[clipUuid];\n\n      if (actionsForClip !== undefined) {\n        return actionsForClip.actionByRoot[rootUuid] || null;\n      }\n\n      return null;\n    } // deactivates all previously scheduled actions\n\n  }, {\n    key: "stopAllAction",\n    value: function stopAllAction() {\n      var actions = this._actions,\n          nActions = this._nActiveActions;\n\n      for (var _i341 = nActions - 1; _i341 >= 0; --_i341) {\n        actions[_i341].stop();\n      }\n\n      return this;\n    } // advance the time and update apply the animation\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      deltaTime *= this.timeScale;\n      var actions = this._actions,\n          nActions = this._nActiveActions,\n          time = this.time += deltaTime,\n          timeDirection = Math.sign(deltaTime),\n          accuIndex = this._accuIndex ^= 1; // run active actions\n\n      for (var _i342 = 0; _i342 !== nActions; ++_i342) {\n        var action = actions[_i342];\n\n        action._update(time, deltaTime, timeDirection, accuIndex);\n      } // update scene graph\n\n\n      var bindings = this._bindings,\n          nBindings = this._nActiveBindings;\n\n      for (var _i343 = 0; _i343 !== nBindings; ++_i343) {\n        bindings[_i343].apply(accuIndex);\n      }\n\n      return this;\n    } // Allows you to seek to a specific time in an animation.\n\n  }, {\n    key: "setTime",\n    value: function setTime(timeInSeconds) {\n      this.time = 0; // Zero out time attribute for AnimationMixer object;\n\n      for (var _i344 = 0; _i344 < this._actions.length; _i344++) {\n        this._actions[_i344].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n      }\n\n      return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.\n    } // return this mixer\'s root target object\n\n  }, {\n    key: "getRoot",\n    value: function getRoot() {\n      return this._root;\n    } // free all resources specific to a particular clip\n\n  }, {\n    key: "uncacheClip",\n    value: function uncacheClip(clip) {\n      var actions = this._actions,\n          clipUuid = clip.uuid,\n          actionsByClip = this._actionsByClip,\n          actionsForClip = actionsByClip[clipUuid];\n\n      if (actionsForClip !== undefined) {\n        // note: just calling _removeInactiveAction would mess up the\n        // iteration state and also require updating the state we can\n        // just throw away\n        var actionsToRemove = actionsForClip.knownActions;\n\n        for (var _i345 = 0, n = actionsToRemove.length; _i345 !== n; ++_i345) {\n          var action = actionsToRemove[_i345];\n\n          this._deactivateAction(action);\n\n          var cacheIndex = action._cacheIndex,\n              lastInactiveAction = actions[actions.length - 1];\n          action._cacheIndex = null;\n          action._byClipCacheIndex = null;\n          lastInactiveAction._cacheIndex = cacheIndex;\n          actions[cacheIndex] = lastInactiveAction;\n          actions.pop();\n\n          this._removeInactiveBindingsForAction(action);\n        }\n\n        delete actionsByClip[clipUuid];\n      }\n    } // free all resources specific to a particular root target object\n\n  }, {\n    key: "uncacheRoot",\n    value: function uncacheRoot(root) {\n      var rootUuid = root.uuid,\n          actionsByClip = this._actionsByClip;\n\n      for (var clipUuid in actionsByClip) {\n        var actionByRoot = actionsByClip[clipUuid].actionByRoot,\n            action = actionByRoot[rootUuid];\n\n        if (action !== undefined) {\n          this._deactivateAction(action);\n\n          this._removeInactiveAction(action);\n        }\n      }\n\n      var bindingsByRoot = this._bindingsByRootAndName,\n          bindingByName = bindingsByRoot[rootUuid];\n\n      if (bindingByName !== undefined) {\n        for (var trackName in bindingByName) {\n          var binding = bindingByName[trackName];\n          binding.restoreOriginalState();\n\n          this._removeInactiveBinding(binding);\n        }\n      }\n    } // remove a targeted clip from the cache\n\n  }, {\n    key: "uncacheAction",\n    value: function uncacheAction(clip, optionalRoot) {\n      var action = this.existingAction(clip, optionalRoot);\n\n      if (action !== null) {\n        this._deactivateAction(action);\n\n        this._removeInactiveAction(action);\n      }\n    }\n  }]);\n\n  return AnimationMixer;\n}(EventDispatcher);\n\nvar Uniform = /*#__PURE__*/function () {\n  function Uniform(value) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Uniform);\n\n    if (typeof value === \'string\') {\n      console.warn(\'THREE.Uniform: Type parameter is no longer needed.\');\n      value = arguments[1];\n    }\n\n    this.value = value;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Uniform, [{\n    key: "clone",\n    value: function clone() {\n      return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());\n    }\n  }]);\n\n  return Uniform;\n}();\n\nvar InstancedInterleavedBuffer = /*#__PURE__*/function (_InterleavedBuffer) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(InstancedInterleavedBuffer, _InterleavedBuffer);\n\n  var _super140 = _createSuper(InstancedInterleavedBuffer);\n\n  function InstancedInterleavedBuffer(array, stride) {\n    var _this113;\n\n    var meshPerAttribute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, InstancedInterleavedBuffer);\n\n    _this113 = _super140.call(this, array, stride);\n    _this113.isInstancedInterleavedBuffer = true;\n    _this113.meshPerAttribute = meshPerAttribute;\n    return _this113;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(InstancedInterleavedBuffer, [{\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(InstancedInterleavedBuffer.prototype), "copy", this).call(this, source);\n\n      this.meshPerAttribute = source.meshPerAttribute;\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone(data) {\n      var ib = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(InstancedInterleavedBuffer.prototype), "clone", this).call(this, data);\n\n      ib.meshPerAttribute = this.meshPerAttribute;\n      return ib;\n    }\n  }, {\n    key: "toJSON",\n    value: function toJSON(data) {\n      var json = (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(InstancedInterleavedBuffer.prototype), "toJSON", this).call(this, data);\n\n      json.isInstancedInterleavedBuffer = true;\n      json.meshPerAttribute = this.meshPerAttribute;\n      return json;\n    }\n  }]);\n\n  return InstancedInterleavedBuffer;\n}(InterleavedBuffer);\n\nvar GLBufferAttribute = /*#__PURE__*/function () {\n  function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, GLBufferAttribute);\n\n    this.isGLBufferAttribute = true;\n    this.buffer = buffer;\n    this.type = type;\n    this.itemSize = itemSize;\n    this.elementSize = elementSize;\n    this.count = count;\n    this.version = 0;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(GLBufferAttribute, [{\n    key: "needsUpdate",\n    set: function set(value) {\n      if (value === true) this.version++;\n    }\n  }, {\n    key: "setBuffer",\n    value: function setBuffer(buffer) {\n      this.buffer = buffer;\n      return this;\n    }\n  }, {\n    key: "setType",\n    value: function setType(type, elementSize) {\n      this.type = type;\n      this.elementSize = elementSize;\n      return this;\n    }\n  }, {\n    key: "setItemSize",\n    value: function setItemSize(itemSize) {\n      this.itemSize = itemSize;\n      return this;\n    }\n  }, {\n    key: "setCount",\n    value: function setCount(count) {\n      this.count = count;\n      return this;\n    }\n  }]);\n\n  return GLBufferAttribute;\n}();\n\nvar Raycaster = /*#__PURE__*/function () {\n  function Raycaster(origin, direction) {\n    var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Raycaster);\n\n    this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.near = near;\n    this.far = far;\n    this.camera = null;\n    this.layers = new Layers();\n    this.params = {\n      Mesh: {},\n      Line: {\n        threshold: 1\n      },\n      LOD: {},\n      Points: {\n        threshold: 1\n      },\n      Sprite: {}\n    };\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Raycaster, [{\n    key: "set",\n    value: function set(origin, direction) {\n      // direction is assumed to be normalized (for accurate distance calculations)\n      this.ray.set(origin, direction);\n    }\n  }, {\n    key: "setFromCamera",\n    value: function setFromCamera(coords, camera) {\n      if (camera.isPerspectiveCamera) {\n        this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n        this.camera = camera;\n      } else if (camera.isOrthographicCamera) {\n        this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n\n        this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n        this.camera = camera;\n      } else {\n        console.error(\'THREE.Raycaster: Unsupported camera type: \' + camera.type);\n      }\n    }\n  }, {\n    key: "intersectObject",\n    value: function intersectObject(object) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var intersects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      _intersectObject(object, this, intersects, recursive);\n\n      intersects.sort(ascSort);\n      return intersects;\n    }\n  }, {\n    key: "intersectObjects",\n    value: function intersectObjects(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var intersects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      for (var _i346 = 0, l = objects.length; _i346 < l; _i346++) {\n        _intersectObject(objects[_i346], this, intersects, recursive);\n      }\n\n      intersects.sort(ascSort);\n      return intersects;\n    }\n  }]);\n\n  return Raycaster;\n}();\n\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\n\nfunction _intersectObject(object, raycaster, intersects, recursive) {\n  if (object.layers.test(raycaster.layers)) {\n    object.raycast(raycaster, intersects);\n  }\n\n  if (recursive === true) {\n    var children = object.children;\n\n    for (var _i347 = 0, l = children.length; _i347 < l; _i347++) {\n      _intersectObject(children[_i347], raycaster, intersects, true);\n    }\n  }\n}\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axis.\n */\n\n\nvar Spherical = /*#__PURE__*/function () {\n  function Spherical() {\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var phi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var theta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Spherical);\n\n    this.radius = radius;\n    this.phi = phi; // polar angle\n\n    this.theta = theta; // azimuthal angle\n\n    return this;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Spherical, [{\n    key: "set",\n    value: function set(radius, phi, theta) {\n      this.radius = radius;\n      this.phi = phi;\n      this.theta = theta;\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(other) {\n      this.radius = other.radius;\n      this.phi = other.phi;\n      this.theta = other.theta;\n      return this;\n    } // restrict phi to be between EPS and PI-EPS\n\n  }, {\n    key: "makeSafe",\n    value: function makeSafe() {\n      var EPS = 0.000001;\n      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n      return this;\n    }\n  }, {\n    key: "setFromVector3",\n    value: function setFromVector3(v) {\n      return this.setFromCartesianCoords(v.x, v.y, v.z);\n    }\n  }, {\n    key: "setFromCartesianCoords",\n    value: function setFromCartesianCoords(x, y, z) {\n      this.radius = Math.sqrt(x * x + y * y + z * z);\n\n      if (this.radius === 0) {\n        this.theta = 0;\n        this.phi = 0;\n      } else {\n        this.theta = Math.atan2(x, z);\n        this.phi = Math.acos(clamp(y / this.radius, -1, 1));\n      }\n\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }]);\n\n  return Spherical;\n}();\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\n\nvar Cylindrical = /*#__PURE__*/function () {\n  function Cylindrical() {\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var theta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Cylindrical);\n\n    this.radius = radius; // distance from the origin to a point in the x-z plane\n\n    this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\n    this.y = y; // height above the x-z plane\n\n    return this;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Cylindrical, [{\n    key: "set",\n    value: function set(radius, theta, y) {\n      this.radius = radius;\n      this.theta = theta;\n      this.y = y;\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(other) {\n      this.radius = other.radius;\n      this.theta = other.theta;\n      this.y = other.y;\n      return this;\n    }\n  }, {\n    key: "setFromVector3",\n    value: function setFromVector3(v) {\n      return this.setFromCartesianCoords(v.x, v.y, v.z);\n    }\n  }, {\n    key: "setFromCartesianCoords",\n    value: function setFromCartesianCoords(x, y, z) {\n      this.radius = Math.sqrt(x * x + z * z);\n      this.theta = Math.atan2(x, z);\n      this.y = y;\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }]);\n\n  return Cylindrical;\n}();\n\nvar _vector$4 = /*@__PURE__*/new Vector2();\n\nvar Box2 = /*#__PURE__*/function () {\n  function Box2() {\n    var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2(+Infinity, +Infinity);\n    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2(-Infinity, -Infinity);\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Box2);\n\n    this.isBox2 = true;\n    this.min = min;\n    this.max = max;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Box2, [{\n    key: "set",\n    value: function set(min, max) {\n      this.min.copy(min);\n      this.max.copy(max);\n      return this;\n    }\n  }, {\n    key: "setFromPoints",\n    value: function setFromPoints(points) {\n      this.makeEmpty();\n\n      for (var _i348 = 0, il = points.length; _i348 < il; _i348++) {\n        this.expandByPoint(points[_i348]);\n      }\n\n      return this;\n    }\n  }, {\n    key: "setFromCenterAndSize",\n    value: function setFromCenterAndSize(center, size) {\n      var halfSize = _vector$4.copy(size).multiplyScalar(0.5);\n\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: "copy",\n    value: function copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n  }, {\n    key: "makeEmpty",\n    value: function makeEmpty() {\n      this.min.x = this.min.y = +Infinity;\n      this.max.x = this.max.y = -Infinity;\n      return this;\n    }\n  }, {\n    key: "isEmpty",\n    value: function isEmpty() {\n      // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n      return this.max.x < this.min.x || this.max.y < this.min.y;\n    }\n  }, {\n    key: "getCenter",\n    value: function getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n  }, {\n    key: "getSize",\n    value: function getSize(target) {\n      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);\n    }\n  }, {\n    key: "expandByPoint",\n    value: function expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n  }, {\n    key: "expandByVector",\n    value: function expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n  }, {\n    key: "expandByScalar",\n    value: function expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n  }, {\n    key: "containsPoint",\n    value: function containsPoint(point) {\n      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;\n    }\n  }, {\n    key: "containsBox",\n    value: function containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;\n    }\n  }, {\n    key: "getParameter",\n    value: function getParameter(point, target) {\n      // This can potentially have a divide by zero if the box\n      // has a size dimension of 0.\n      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\n    }\n  }, {\n    key: "intersectsBox",\n    value: function intersectsBox(box) {\n      // using 4 splitting planes to rule out intersections\n      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n    }\n  }, {\n    key: "clampPoint",\n    value: function clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n  }, {\n    key: "distanceToPoint",\n    value: function distanceToPoint(point) {\n      var clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);\n\n      return clampedPoint.sub(point).length();\n    }\n  }, {\n    key: "intersect",\n    value: function intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      return this;\n    }\n  }, {\n    key: "union",\n    value: function union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n  }, {\n    key: "translate",\n    value: function translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n  }]);\n\n  return Box2;\n}();\n\nvar _startP = /*@__PURE__*/new Vector3();\n\nvar _startEnd = /*@__PURE__*/new Vector3();\n\nvar Line3 = /*#__PURE__*/function () {\n  function Line3() {\n    var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();\n    var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Line3);\n\n    this.start = start;\n    this.end = end;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Line3, [{\n    key: "set",\n    value: function set(start, end) {\n      this.start.copy(start);\n      this.end.copy(end);\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(line) {\n      this.start.copy(line.start);\n      this.end.copy(line.end);\n      return this;\n    }\n  }, {\n    key: "getCenter",\n    value: function getCenter(target) {\n      return target.addVectors(this.start, this.end).multiplyScalar(0.5);\n    }\n  }, {\n    key: "delta",\n    value: function delta(target) {\n      return target.subVectors(this.end, this.start);\n    }\n  }, {\n    key: "distanceSq",\n    value: function distanceSq() {\n      return this.start.distanceToSquared(this.end);\n    }\n  }, {\n    key: "distance",\n    value: function distance() {\n      return this.start.distanceTo(this.end);\n    }\n  }, {\n    key: "at",\n    value: function at(t, target) {\n      return this.delta(target).multiplyScalar(t).add(this.start);\n    }\n  }, {\n    key: "closestPointToPointParameter",\n    value: function closestPointToPointParameter(point, clampToLine) {\n      _startP.subVectors(point, this.start);\n\n      _startEnd.subVectors(this.end, this.start);\n\n      var startEnd2 = _startEnd.dot(_startEnd);\n\n      var startEnd_startP = _startEnd.dot(_startP);\n\n      var t = startEnd_startP / startEnd2;\n\n      if (clampToLine) {\n        t = clamp(t, 0, 1);\n      }\n\n      return t;\n    }\n  }, {\n    key: "closestPointToPoint",\n    value: function closestPointToPoint(point, clampToLine, target) {\n      var t = this.closestPointToPointParameter(point, clampToLine);\n      return this.delta(target).multiplyScalar(t).add(this.start);\n    }\n  }, {\n    key: "applyMatrix4",\n    value: function applyMatrix4(matrix) {\n      this.start.applyMatrix4(matrix);\n      this.end.applyMatrix4(matrix);\n      return this;\n    }\n  }, {\n    key: "equals",\n    value: function equals(line) {\n      return line.start.equals(this.start) && line.end.equals(this.end);\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }]);\n\n  return Line3;\n}();\n\nvar _vector$3 = /*@__PURE__*/new Vector3();\n\nvar SpotLightHelper = /*#__PURE__*/function (_Object3D14) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(SpotLightHelper, _Object3D14);\n\n  var _super141 = _createSuper(SpotLightHelper);\n\n  function SpotLightHelper(light, color) {\n    var _this114;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SpotLightHelper);\n\n    _this114 = _super141.call(this);\n    _this114.light = light;\n\n    _this114.light.updateMatrixWorld();\n\n    _this114.matrix = light.matrixWorld;\n    _this114.matrixAutoUpdate = false;\n    _this114.color = color;\n    var geometry = new BufferGeometry();\n    var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];\n\n    for (var _i349 = 0, j = 1, l = 32; _i349 < l; _i349++, j++) {\n      var p1 = _i349 / l * Math.PI * 2;\n      var p2 = j / l * Math.PI * 2;\n      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);\n    }\n\n    geometry.setAttribute(\'position\', new Float32BufferAttribute(positions, 3));\n    var material = new LineBasicMaterial({\n      fog: false,\n      toneMapped: false\n    });\n    _this114.cone = new LineSegments(geometry, material);\n\n    _this114.add(_this114.cone);\n\n    _this114.update();\n\n    return _this114;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SpotLightHelper, [{\n    key: "dispose",\n    value: function dispose() {\n      this.cone.geometry.dispose();\n      this.cone.material.dispose();\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      this.light.updateMatrixWorld();\n      var coneLength = this.light.distance ? this.light.distance : 1000;\n      var coneWidth = coneLength * Math.tan(this.light.angle);\n      this.cone.scale.set(coneWidth, coneWidth, coneLength);\n\n      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);\n\n      this.cone.lookAt(_vector$3);\n\n      if (this.color !== undefined) {\n        this.cone.material.color.set(this.color);\n      } else {\n        this.cone.material.color.copy(this.light.color);\n      }\n    }\n  }]);\n\n  return SpotLightHelper;\n}(Object3D);\n\nvar _vector$2 = /*@__PURE__*/new Vector3();\n\nvar _boneMatrix = /*@__PURE__*/new Matrix4();\n\nvar _matrixWorldInv = /*@__PURE__*/new Matrix4();\n\nvar SkeletonHelper = /*#__PURE__*/function (_LineSegments) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(SkeletonHelper, _LineSegments);\n\n  var _super142 = _createSuper(SkeletonHelper);\n\n  function SkeletonHelper(object) {\n    var _this115;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, SkeletonHelper);\n\n    var bones = getBoneList(object);\n    var geometry = new BufferGeometry();\n    var vertices = [];\n    var colors = [];\n    var color1 = new Color(0, 0, 1);\n    var color2 = new Color(0, 1, 0);\n\n    for (var _i350 = 0; _i350 < bones.length; _i350++) {\n      var bone = bones[_i350];\n\n      if (bone.parent && bone.parent.isBone) {\n        vertices.push(0, 0, 0);\n        vertices.push(0, 0, 0);\n        colors.push(color1.r, color1.g, color1.b);\n        colors.push(color2.r, color2.g, color2.b);\n      }\n    }\n\n    geometry.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\'color\', new Float32BufferAttribute(colors, 3));\n    var material = new LineBasicMaterial({\n      vertexColors: true,\n      depthTest: false,\n      depthWrite: false,\n      toneMapped: false,\n      transparent: true\n    });\n    _this115 = _super142.call(this, geometry, material);\n    _this115.isSkeletonHelper = true;\n    _this115.type = \'SkeletonHelper\';\n    _this115.root = object;\n    _this115.bones = bones;\n    _this115.matrix = object.matrixWorld;\n    _this115.matrixAutoUpdate = false;\n    return _this115;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(SkeletonHelper, [{\n    key: "updateMatrixWorld",\n    value: function updateMatrixWorld(force) {\n      var bones = this.bones;\n      var geometry = this.geometry;\n      var position = geometry.getAttribute(\'position\');\n\n      _matrixWorldInv.copy(this.root.matrixWorld).invert();\n\n      for (var _i351 = 0, j = 0; _i351 < bones.length; _i351++) {\n        var bone = bones[_i351];\n\n        if (bone.parent && bone.parent.isBone) {\n          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);\n\n          _vector$2.setFromMatrixPosition(_boneMatrix);\n\n          position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);\n\n          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);\n\n          _vector$2.setFromMatrixPosition(_boneMatrix);\n\n          position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);\n          j += 2;\n        }\n      }\n\n      geometry.getAttribute(\'position\').needsUpdate = true;\n\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(SkeletonHelper.prototype), "updateMatrixWorld", this).call(this, force);\n    }\n  }]);\n\n  return SkeletonHelper;\n}(LineSegments);\n\nfunction getBoneList(object) {\n  var boneList = [];\n\n  if (object.isBone === true) {\n    boneList.push(object);\n  }\n\n  for (var _i352 = 0; _i352 < object.children.length; _i352++) {\n    boneList.push.apply(boneList, getBoneList(object.children[_i352]));\n  }\n\n  return boneList;\n}\n\nvar PointLightHelper = /*#__PURE__*/function (_Mesh3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PointLightHelper, _Mesh3);\n\n  var _super143 = _createSuper(PointLightHelper);\n\n  function PointLightHelper(light, sphereSize, color) {\n    var _this116;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PointLightHelper);\n\n    var geometry = new SphereGeometry(sphereSize, 4, 2);\n    var material = new MeshBasicMaterial({\n      wireframe: true,\n      fog: false,\n      toneMapped: false\n    });\n    _this116 = _super143.call(this, geometry, material);\n    _this116.light = light;\n\n    _this116.light.updateMatrixWorld();\n\n    _this116.color = color;\n    _this116.type = \'PointLightHelper\';\n    _this116.matrix = _this116.light.matrixWorld;\n    _this116.matrixAutoUpdate = false;\n\n    _this116.update();\n    /*\n    // TODO: delete this comment?\n    const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n    const d = light.distance;\n    if ( d === 0.0 ) {\n    \tthis.lightDistance.visible = false;\n    } else {\n    \tthis.lightDistance.scale.set( d, d, d );\n    }\n    this.add( this.lightDistance );\n    */\n\n\n    return _this116;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PointLightHelper, [{\n    key: "dispose",\n    value: function dispose() {\n      this.geometry.dispose();\n      this.material.dispose();\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      if (this.color !== undefined) {\n        this.material.color.set(this.color);\n      } else {\n        this.material.color.copy(this.light.color);\n      }\n      /*\n      const d = this.light.distance;\n      \tif ( d === 0.0 ) {\n      \t\tthis.lightDistance.visible = false;\n      \t} else {\n      \t\tthis.lightDistance.visible = true;\n      \tthis.lightDistance.scale.set( d, d, d );\n      \t}\n      */\n\n    }\n  }]);\n\n  return PointLightHelper;\n}(Mesh);\n\nvar _vector$1 = /*@__PURE__*/new Vector3();\n\nvar _color1 = /*@__PURE__*/new Color();\n\nvar _color2 = /*@__PURE__*/new Color();\n\nvar HemisphereLightHelper = /*#__PURE__*/function (_Object3D15) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(HemisphereLightHelper, _Object3D15);\n\n  var _super144 = _createSuper(HemisphereLightHelper);\n\n  function HemisphereLightHelper(light, size, color) {\n    var _this117;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, HemisphereLightHelper);\n\n    _this117 = _super144.call(this);\n    _this117.light = light;\n\n    _this117.light.updateMatrixWorld();\n\n    _this117.matrix = light.matrixWorld;\n    _this117.matrixAutoUpdate = false;\n    _this117.color = color;\n    var geometry = new OctahedronGeometry(size);\n    geometry.rotateY(Math.PI * 0.5);\n    _this117.material = new MeshBasicMaterial({\n      wireframe: true,\n      fog: false,\n      toneMapped: false\n    });\n    if (_this117.color === undefined) _this117.material.vertexColors = true;\n    var position = geometry.getAttribute(\'position\');\n    var colors = new Float32Array(position.count * 3);\n    geometry.setAttribute(\'color\', new BufferAttribute(colors, 3));\n\n    _this117.add(new Mesh(geometry, _this117.material));\n\n    _this117.update();\n\n    return _this117;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(HemisphereLightHelper, [{\n    key: "dispose",\n    value: function dispose() {\n      this.children[0].geometry.dispose();\n      this.children[0].material.dispose();\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      var mesh = this.children[0];\n\n      if (this.color !== undefined) {\n        this.material.color.set(this.color);\n      } else {\n        var colors = mesh.geometry.getAttribute(\'color\');\n\n        _color1.copy(this.light.color);\n\n        _color2.copy(this.light.groundColor);\n\n        for (var _i353 = 0, l = colors.count; _i353 < l; _i353++) {\n          var color = _i353 < l / 2 ? _color1 : _color2;\n          colors.setXYZ(_i353, color.r, color.g, color.b);\n        }\n\n        colors.needsUpdate = true;\n      }\n\n      mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());\n    }\n  }]);\n\n  return HemisphereLightHelper;\n}(Object3D);\n\nvar GridHelper = /*#__PURE__*/function (_LineSegments2) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(GridHelper, _LineSegments2);\n\n  var _super145 = _createSuper(GridHelper);\n\n  function GridHelper() {\n    var _this118;\n\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    var divisions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    var color1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0x444444;\n    var color2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0x888888;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, GridHelper);\n\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n    var center = divisions / 2;\n    var step = size / divisions;\n    var halfSize = size / 2;\n    var vertices = [],\n        colors = [];\n\n    for (var _i354 = 0, j = 0, k = -halfSize; _i354 <= divisions; _i354++, k += step) {\n      vertices.push(-halfSize, 0, k, halfSize, 0, k);\n      vertices.push(k, 0, -halfSize, k, 0, halfSize);\n      var color = _i354 === center ? color1 : color2;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n    }\n\n    var geometry = new BufferGeometry();\n    geometry.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\'color\', new Float32BufferAttribute(colors, 3));\n    var material = new LineBasicMaterial({\n      vertexColors: true,\n      toneMapped: false\n    });\n    _this118 = _super145.call(this, geometry, material);\n    _this118.type = \'GridHelper\';\n    return _this118;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(GridHelper);\n}(LineSegments);\n\nvar PolarGridHelper = /*#__PURE__*/function (_LineSegments3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PolarGridHelper, _LineSegments3);\n\n  var _super146 = _createSuper(PolarGridHelper);\n\n  function PolarGridHelper() {\n    var _this119;\n\n    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    var radials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    var circles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    var divisions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 64;\n    var color1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0x444444;\n    var color2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0x888888;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PolarGridHelper);\n\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n    var vertices = [];\n    var colors = []; // create the radials\n\n    for (var _i355 = 0; _i355 <= radials; _i355++) {\n      var v = _i355 / radials * (Math.PI * 2);\n      var x = Math.sin(v) * radius;\n      var z = Math.cos(v) * radius;\n      vertices.push(0, 0, 0);\n      vertices.push(x, 0, z);\n      var color = _i355 & 1 ? color1 : color2;\n      colors.push(color.r, color.g, color.b);\n      colors.push(color.r, color.g, color.b);\n    } // create the circles\n\n\n    for (var _i356 = 0; _i356 <= circles; _i356++) {\n      var _color = _i356 & 1 ? color1 : color2;\n\n      var r = radius - radius / circles * _i356;\n\n      for (var j = 0; j < divisions; j++) {\n        // first vertex\n        var _v = j / divisions * (Math.PI * 2);\n\n        var _x12 = Math.sin(_v) * r;\n\n        var _z3 = Math.cos(_v) * r;\n\n        vertices.push(_x12, 0, _z3);\n        colors.push(_color.r, _color.g, _color.b); // second vertex\n\n        _v = (j + 1) / divisions * (Math.PI * 2);\n        _x12 = Math.sin(_v) * r;\n        _z3 = Math.cos(_v) * r;\n        vertices.push(_x12, 0, _z3);\n        colors.push(_color.r, _color.g, _color.b);\n      }\n    }\n\n    var geometry = new BufferGeometry();\n    geometry.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\'color\', new Float32BufferAttribute(colors, 3));\n    var material = new LineBasicMaterial({\n      vertexColors: true,\n      toneMapped: false\n    });\n    _this119 = _super146.call(this, geometry, material);\n    _this119.type = \'PolarGridHelper\';\n    return _this119;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PolarGridHelper);\n}(LineSegments);\n\nvar _v1 = /*@__PURE__*/new Vector3();\n\nvar _v2 = /*@__PURE__*/new Vector3();\n\nvar _v3 = /*@__PURE__*/new Vector3();\n\nvar DirectionalLightHelper = /*#__PURE__*/function (_Object3D16) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DirectionalLightHelper, _Object3D16);\n\n  var _super147 = _createSuper(DirectionalLightHelper);\n\n  function DirectionalLightHelper(light, size, color) {\n    var _this120;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DirectionalLightHelper);\n\n    _this120 = _super147.call(this);\n    _this120.light = light;\n\n    _this120.light.updateMatrixWorld();\n\n    _this120.matrix = light.matrixWorld;\n    _this120.matrixAutoUpdate = false;\n    _this120.color = color;\n    if (size === undefined) size = 1;\n    var geometry = new BufferGeometry();\n    geometry.setAttribute(\'position\', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));\n    var material = new LineBasicMaterial({\n      fog: false,\n      toneMapped: false\n    });\n    _this120.lightPlane = new Line(geometry, material);\n\n    _this120.add(_this120.lightPlane);\n\n    geometry = new BufferGeometry();\n    geometry.setAttribute(\'position\', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n    _this120.targetLine = new Line(geometry, material);\n\n    _this120.add(_this120.targetLine);\n\n    _this120.update();\n\n    return _this120;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DirectionalLightHelper, [{\n    key: "dispose",\n    value: function dispose() {\n      this.lightPlane.geometry.dispose();\n      this.lightPlane.material.dispose();\n      this.targetLine.geometry.dispose();\n      this.targetLine.material.dispose();\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      _v1.setFromMatrixPosition(this.light.matrixWorld);\n\n      _v2.setFromMatrixPosition(this.light.target.matrixWorld);\n\n      _v3.subVectors(_v2, _v1);\n\n      this.lightPlane.lookAt(_v2);\n\n      if (this.color !== undefined) {\n        this.lightPlane.material.color.set(this.color);\n        this.targetLine.material.color.set(this.color);\n      } else {\n        this.lightPlane.material.color.copy(this.light.color);\n        this.targetLine.material.color.copy(this.light.color);\n      }\n\n      this.targetLine.lookAt(_v2);\n      this.targetLine.scale.z = _v3.length();\n    }\n  }]);\n\n  return DirectionalLightHelper;\n}(Object3D);\n\nvar _vector = /*@__PURE__*/new Vector3();\n\nvar _camera = /*@__PURE__*/new Camera();\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttps://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html\n */\n\n\nvar CameraHelper = /*#__PURE__*/function (_LineSegments4) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(CameraHelper, _LineSegments4);\n\n  var _super148 = _createSuper(CameraHelper);\n\n  function CameraHelper(camera) {\n    var _this121;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, CameraHelper);\n\n    var geometry = new BufferGeometry();\n    var material = new LineBasicMaterial({\n      color: 0xffffff,\n      vertexColors: true,\n      toneMapped: false\n    });\n    var vertices = [];\n    var colors = [];\n    var pointMap = {}; // colors\n\n    var colorFrustum = new Color(0xffaa00);\n    var colorCone = new Color(0xff0000);\n    var colorUp = new Color(0x00aaff);\n    var colorTarget = new Color(0xffffff);\n    var colorCross = new Color(0x333333); // near\n\n    addLine(\'n1\', \'n2\', colorFrustum);\n    addLine(\'n2\', \'n4\', colorFrustum);\n    addLine(\'n4\', \'n3\', colorFrustum);\n    addLine(\'n3\', \'n1\', colorFrustum); // far\n\n    addLine(\'f1\', \'f2\', colorFrustum);\n    addLine(\'f2\', \'f4\', colorFrustum);\n    addLine(\'f4\', \'f3\', colorFrustum);\n    addLine(\'f3\', \'f1\', colorFrustum); // sides\n\n    addLine(\'n1\', \'f1\', colorFrustum);\n    addLine(\'n2\', \'f2\', colorFrustum);\n    addLine(\'n3\', \'f3\', colorFrustum);\n    addLine(\'n4\', \'f4\', colorFrustum); // cone\n\n    addLine(\'p\', \'n1\', colorCone);\n    addLine(\'p\', \'n2\', colorCone);\n    addLine(\'p\', \'n3\', colorCone);\n    addLine(\'p\', \'n4\', colorCone); // up\n\n    addLine(\'u1\', \'u2\', colorUp);\n    addLine(\'u2\', \'u3\', colorUp);\n    addLine(\'u3\', \'u1\', colorUp); // target\n\n    addLine(\'c\', \'t\', colorTarget);\n    addLine(\'p\', \'c\', colorCross); // cross\n\n    addLine(\'cn1\', \'cn2\', colorCross);\n    addLine(\'cn3\', \'cn4\', colorCross);\n    addLine(\'cf1\', \'cf2\', colorCross);\n    addLine(\'cf3\', \'cf4\', colorCross);\n\n    function addLine(a, b, color) {\n      addPoint(a, color);\n      addPoint(b, color);\n    }\n\n    function addPoint(id, color) {\n      vertices.push(0, 0, 0);\n      colors.push(color.r, color.g, color.b);\n\n      if (pointMap[id] === undefined) {\n        pointMap[id] = [];\n      }\n\n      pointMap[id].push(vertices.length / 3 - 1);\n    }\n\n    geometry.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\'color\', new Float32BufferAttribute(colors, 3));\n    _this121 = _super148.call(this, geometry, material);\n    _this121.type = \'CameraHelper\';\n    _this121.camera = camera;\n    if (_this121.camera.updateProjectionMatrix) _this121.camera.updateProjectionMatrix();\n    _this121.matrix = camera.matrixWorld;\n    _this121.matrixAutoUpdate = false;\n    _this121.pointMap = pointMap;\n\n    _this121.update();\n\n    return _this121;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(CameraHelper, [{\n    key: "update",\n    value: function update() {\n      var geometry = this.geometry;\n      var pointMap = this.pointMap;\n      var w = 1,\n          h = 1; // we need just camera projection matrix inverse\n      // world matrix must be identity\n\n      _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target\n\n\n      setPoint(\'c\', pointMap, geometry, _camera, 0, 0, -1);\n      setPoint(\'t\', pointMap, geometry, _camera, 0, 0, 1); // near\n\n      setPoint(\'n1\', pointMap, geometry, _camera, -w, -h, -1);\n      setPoint(\'n2\', pointMap, geometry, _camera, w, -h, -1);\n      setPoint(\'n3\', pointMap, geometry, _camera, -w, h, -1);\n      setPoint(\'n4\', pointMap, geometry, _camera, w, h, -1); // far\n\n      setPoint(\'f1\', pointMap, geometry, _camera, -w, -h, 1);\n      setPoint(\'f2\', pointMap, geometry, _camera, w, -h, 1);\n      setPoint(\'f3\', pointMap, geometry, _camera, -w, h, 1);\n      setPoint(\'f4\', pointMap, geometry, _camera, w, h, 1); // up\n\n      setPoint(\'u1\', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);\n      setPoint(\'u2\', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);\n      setPoint(\'u3\', pointMap, geometry, _camera, 0, h * 2, -1); // cross\n\n      setPoint(\'cf1\', pointMap, geometry, _camera, -w, 0, 1);\n      setPoint(\'cf2\', pointMap, geometry, _camera, w, 0, 1);\n      setPoint(\'cf3\', pointMap, geometry, _camera, 0, -h, 1);\n      setPoint(\'cf4\', pointMap, geometry, _camera, 0, h, 1);\n      setPoint(\'cn1\', pointMap, geometry, _camera, -w, 0, -1);\n      setPoint(\'cn2\', pointMap, geometry, _camera, w, 0, -1);\n      setPoint(\'cn3\', pointMap, geometry, _camera, 0, -h, -1);\n      setPoint(\'cn4\', pointMap, geometry, _camera, 0, h, -1);\n      geometry.getAttribute(\'position\').needsUpdate = true;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.geometry.dispose();\n      this.material.dispose();\n    }\n  }]);\n\n  return CameraHelper;\n}(LineSegments);\n\nfunction setPoint(point, pointMap, geometry, camera, x, y, z) {\n  _vector.set(x, y, z).unproject(camera);\n\n  var points = pointMap[point];\n\n  if (points !== undefined) {\n    var position = geometry.getAttribute(\'position\');\n\n    for (var _i357 = 0, l = points.length; _i357 < l; _i357++) {\n      position.setXYZ(points[_i357], _vector.x, _vector.y, _vector.z);\n    }\n  }\n}\n\nvar _box = /*@__PURE__*/new Box3();\n\nvar BoxHelper = /*#__PURE__*/function (_LineSegments5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(BoxHelper, _LineSegments5);\n\n  var _super149 = _createSuper(BoxHelper);\n\n  function BoxHelper(object) {\n    var _this122;\n\n    var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xffff00;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, BoxHelper);\n\n    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n    var positions = new Float32Array(8 * 3);\n    var geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(indices, 1));\n    geometry.setAttribute(\'position\', new BufferAttribute(positions, 3));\n    _this122 = _super149.call(this, geometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    _this122.object = object;\n    _this122.type = \'BoxHelper\';\n    _this122.matrixAutoUpdate = false;\n\n    _this122.update();\n\n    return _this122;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(BoxHelper, [{\n    key: "update",\n    value: function update(object) {\n      if (object !== undefined) {\n        console.warn(\'THREE.BoxHelper: .update() has no longer arguments.\');\n      }\n\n      if (this.object !== undefined) {\n        _box.setFromObject(this.object);\n      }\n\n      if (_box.isEmpty()) return;\n      var min = _box.min;\n      var max = _box.max;\n      /*\n      \t5____4\n      1/___0/|\n      | 6__|_7\n      2/___3/\n      \t0: max.x, max.y, max.z\n      1: min.x, max.y, max.z\n      2: min.x, min.y, max.z\n      3: max.x, min.y, max.z\n      4: max.x, max.y, min.z\n      5: min.x, max.y, min.z\n      6: min.x, min.y, min.z\n      7: max.x, min.y, min.z\n      */\n\n      var position = this.geometry.attributes.position;\n      var array = position.array;\n      array[0] = max.x;\n      array[1] = max.y;\n      array[2] = max.z;\n      array[3] = min.x;\n      array[4] = max.y;\n      array[5] = max.z;\n      array[6] = min.x;\n      array[7] = min.y;\n      array[8] = max.z;\n      array[9] = max.x;\n      array[10] = min.y;\n      array[11] = max.z;\n      array[12] = max.x;\n      array[13] = max.y;\n      array[14] = min.z;\n      array[15] = min.x;\n      array[16] = max.y;\n      array[17] = min.z;\n      array[18] = min.x;\n      array[19] = min.y;\n      array[20] = min.z;\n      array[21] = max.x;\n      array[22] = min.y;\n      array[23] = min.z;\n      position.needsUpdate = true;\n      this.geometry.computeBoundingSphere();\n    }\n  }, {\n    key: "setFromObject",\n    value: function setFromObject(object) {\n      this.object = object;\n      this.update();\n      return this;\n    }\n  }, {\n    key: "copy",\n    value: function copy(source, recursive) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(BoxHelper.prototype), "copy", this).call(this, source, recursive);\n\n      this.object = source.object;\n      return this;\n    }\n  }]);\n\n  return BoxHelper;\n}(LineSegments);\n\nvar Box3Helper = /*#__PURE__*/function (_LineSegments6) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(Box3Helper, _LineSegments6);\n\n  var _super150 = _createSuper(Box3Helper);\n\n  function Box3Helper(box) {\n    var _this123;\n\n    var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xffff00;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, Box3Helper);\n\n    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n    var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];\n    var geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(indices, 1));\n    geometry.setAttribute(\'position\', new Float32BufferAttribute(positions, 3));\n    _this123 = _super150.call(this, geometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    _this123.box = box;\n    _this123.type = \'Box3Helper\';\n\n    _this123.geometry.computeBoundingSphere();\n\n    return _this123;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(Box3Helper, [{\n    key: "updateMatrixWorld",\n    value: function updateMatrixWorld(force) {\n      var box = this.box;\n      if (box.isEmpty()) return;\n      box.getCenter(this.position);\n      box.getSize(this.scale);\n      this.scale.multiplyScalar(0.5);\n\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(Box3Helper.prototype), "updateMatrixWorld", this).call(this, force);\n    }\n  }]);\n\n  return Box3Helper;\n}(LineSegments);\n\nvar PlaneHelper = /*#__PURE__*/function (_Line3) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(PlaneHelper, _Line3);\n\n  var _super151 = _createSuper(PlaneHelper);\n\n  function PlaneHelper(plane) {\n    var _this124;\n\n    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var hex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0xffff00;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, PlaneHelper);\n\n    var color = hex;\n    var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];\n    var geometry = new BufferGeometry();\n    geometry.setAttribute(\'position\', new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    _this124 = _super151.call(this, geometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    _this124.type = \'PlaneHelper\';\n    _this124.plane = plane;\n    _this124.size = size;\n    var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];\n    var geometry2 = new BufferGeometry();\n    geometry2.setAttribute(\'position\', new Float32BufferAttribute(positions2, 3));\n    geometry2.computeBoundingSphere();\n\n    _this124.add(new Mesh(geometry2, new MeshBasicMaterial({\n      color: color,\n      opacity: 0.2,\n      transparent: true,\n      depthWrite: false,\n      toneMapped: false\n    })));\n\n    return _this124;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(PlaneHelper, [{\n    key: "updateMatrixWorld",\n    value: function updateMatrixWorld(force) {\n      var scale = -this.plane.constant;\n      if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter\n\n      this.scale.set(0.5 * this.size, 0.5 * this.size, scale);\n      this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\n\n      this.lookAt(this.plane.normal);\n\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(PlaneHelper.prototype), "updateMatrixWorld", this).call(this, force);\n    }\n  }]);\n\n  return PlaneHelper;\n}(Line);\n\nvar _axis = /*@__PURE__*/new Vector3();\n\nvar _lineGeometry, _coneGeometry;\n\nvar ArrowHelper = /*#__PURE__*/function (_Object3D17) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ArrowHelper, _Object3D17);\n\n  var _super152 = _createSuper(ArrowHelper);\n\n  // dir is assumed to be normalized\n  function ArrowHelper() {\n    var _this125;\n\n    var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 1);\n    var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, 0);\n    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0xffff00;\n    var headLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : length * 0.2;\n    var headWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : headLength * 0.2;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ArrowHelper);\n\n    _this125 = _super152.call(this);\n    _this125.type = \'ArrowHelper\';\n\n    if (_lineGeometry === undefined) {\n      _lineGeometry = new BufferGeometry();\n\n      _lineGeometry.setAttribute(\'position\', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n\n      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);\n\n      _coneGeometry.translate(0, -0.5, 0);\n    }\n\n    _this125.position.copy(origin);\n\n    _this125.line = new Line(_lineGeometry, new LineBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    _this125.line.matrixAutoUpdate = false;\n\n    _this125.add(_this125.line);\n\n    _this125.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({\n      color: color,\n      toneMapped: false\n    }));\n    _this125.cone.matrixAutoUpdate = false;\n\n    _this125.add(_this125.cone);\n\n    _this125.setDirection(dir);\n\n    _this125.setLength(length, headLength, headWidth);\n\n    return _this125;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ArrowHelper, [{\n    key: "setDirection",\n    value: function setDirection(dir) {\n      // dir is assumed to be normalized\n      if (dir.y > 0.99999) {\n        this.quaternion.set(0, 0, 0, 1);\n      } else if (dir.y < -0.99999) {\n        this.quaternion.set(1, 0, 0, 0);\n      } else {\n        _axis.set(dir.z, 0, -dir.x).normalize();\n\n        var radians = Math.acos(dir.y);\n        this.quaternion.setFromAxisAngle(_axis, radians);\n      }\n    }\n  }, {\n    key: "setLength",\n    value: function setLength(length) {\n      var headLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : length * 0.2;\n      var headWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : headLength * 0.2;\n      this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458\n\n      this.line.updateMatrix();\n      this.cone.scale.set(headWidth, headLength, headWidth);\n      this.cone.position.y = length;\n      this.cone.updateMatrix();\n    }\n  }, {\n    key: "setColor",\n    value: function setColor(color) {\n      this.line.material.color.set(color);\n      this.cone.material.color.set(color);\n    }\n  }, {\n    key: "copy",\n    value: function copy(source) {\n      (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_9__/* ["default"] */ .Z)((0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z)(ArrowHelper.prototype), "copy", this).call(this, source, false);\n\n      this.line.copy(source.line);\n      this.cone.copy(source.cone);\n      return this;\n    }\n  }]);\n\n  return ArrowHelper;\n}(Object3D);\n\nvar AxesHelper = /*#__PURE__*/function (_LineSegments7) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(AxesHelper, _LineSegments7);\n\n  var _super153 = _createSuper(AxesHelper);\n\n  function AxesHelper() {\n    var _this126;\n\n    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, AxesHelper);\n\n    var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];\n    var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];\n    var geometry = new BufferGeometry();\n    geometry.setAttribute(\'position\', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\'color\', new Float32BufferAttribute(colors, 3));\n    var material = new LineBasicMaterial({\n      vertexColors: true,\n      toneMapped: false\n    });\n    _this126 = _super153.call(this, geometry, material);\n    _this126.type = \'AxesHelper\';\n    return _this126;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(AxesHelper, [{\n    key: "setColors",\n    value: function setColors(xAxisColor, yAxisColor, zAxisColor) {\n      var color = new Color();\n      var array = this.geometry.attributes.color.array;\n      color.set(xAxisColor);\n      color.toArray(array, 0);\n      color.toArray(array, 3);\n      color.set(yAxisColor);\n      color.toArray(array, 6);\n      color.toArray(array, 9);\n      color.set(zAxisColor);\n      color.toArray(array, 12);\n      color.toArray(array, 15);\n      this.geometry.attributes.color.needsUpdate = true;\n      return this;\n    }\n  }, {\n    key: "dispose",\n    value: function dispose() {\n      this.geometry.dispose();\n      this.material.dispose();\n    }\n  }]);\n\n  return AxesHelper;\n}(LineSegments);\n\nvar ShapePath = /*#__PURE__*/function () {\n  function ShapePath() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ShapePath);\n\n    this.type = \'ShapePath\';\n    this.color = new Color();\n    this.subPaths = [];\n    this.currentPath = null;\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ShapePath, [{\n    key: "moveTo",\n    value: function moveTo(x, y) {\n      this.currentPath = new Path();\n      this.subPaths.push(this.currentPath);\n      this.currentPath.moveTo(x, y);\n      return this;\n    }\n  }, {\n    key: "lineTo",\n    value: function lineTo(x, y) {\n      this.currentPath.lineTo(x, y);\n      return this;\n    }\n  }, {\n    key: "quadraticCurveTo",\n    value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {\n      this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n      return this;\n    }\n  }, {\n    key: "bezierCurveTo",\n    value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n      this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n      return this;\n    }\n  }, {\n    key: "splineThru",\n    value: function splineThru(pts) {\n      this.currentPath.splineThru(pts);\n      return this;\n    }\n  }, {\n    key: "toShapes",\n    value: function toShapes(isCCW, noHoles) {\n      function toShapesNoHoles(inSubpaths) {\n        var shapes = [];\n\n        for (var _i358 = 0, l = inSubpaths.length; _i358 < l; _i358++) {\n          var _tmpPath = inSubpaths[_i358];\n\n          var _tmpShape = new Shape();\n\n          _tmpShape.curves = _tmpPath.curves;\n          shapes.push(_tmpShape);\n        }\n\n        return shapes;\n      }\n\n      function isPointInsidePolygon(inPt, inPolygon) {\n        var polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or\n        // toggling of inside/outside at every single! intersection point of an edge\n        //  with the horizontal line through inPt, left of inPt\n        //  not counting lowerY endpoints of edges and whole edges on that line\n\n        var inside = false;\n\n        for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n          var edgeLowPt = inPolygon[p];\n          var edgeHighPt = inPolygon[q];\n          var edgeDx = edgeHighPt.x - edgeLowPt.x;\n          var edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n          if (Math.abs(edgeDy) > Number.EPSILON) {\n            // not parallel\n            if (edgeDy < 0) {\n              edgeLowPt = inPolygon[q];\n              edgeDx = -edgeDx;\n              edgeHighPt = inPolygon[p];\n              edgeDy = -edgeDy;\n            }\n\n            if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n\n            if (inPt.y === edgeLowPt.y) {\n              if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n              // continue;\t\t\t\t// no intersection or edgeLowPt => doesn\'t count !!!\n            } else {\n              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n              if (perpEdge === 0) return true; // inPt is on contour ?\n\n              if (perpEdge < 0) continue;\n              inside = !inside; // true intersection left of inPt\n            }\n          } else {\n            // parallel or collinear\n            if (inPt.y !== edgeLowPt.y) continue; // parallel\n            // edge lies on the same horizontal line as inPt\n\n            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n            // continue;\n          }\n        }\n\n        return inside;\n      }\n\n      var isClockWise = ShapeUtils.isClockWise;\n      var subPaths = this.subPaths;\n      if (subPaths.length === 0) return [];\n      if (noHoles === true) return toShapesNoHoles(subPaths);\n      var solid, tmpPath, tmpShape;\n      var shapes = [];\n\n      if (subPaths.length === 1) {\n        tmpPath = subPaths[0];\n        tmpShape = new Shape();\n        tmpShape.curves = tmpPath.curves;\n        shapes.push(tmpShape);\n        return shapes;\n      }\n\n      var holesFirst = !isClockWise(subPaths[0].getPoints());\n      holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);\n\n      var betterShapeHoles = [];\n      var newShapes = [];\n      var newShapeHoles = [];\n      var mainIdx = 0;\n      var tmpPoints;\n      newShapes[mainIdx] = undefined;\n      newShapeHoles[mainIdx] = [];\n\n      for (var _i359 = 0, l = subPaths.length; _i359 < l; _i359++) {\n        tmpPath = subPaths[_i359];\n        tmpPoints = tmpPath.getPoints();\n        solid = isClockWise(tmpPoints);\n        solid = isCCW ? !solid : solid;\n\n        if (solid) {\n          if (!holesFirst && newShapes[mainIdx]) mainIdx++;\n          newShapes[mainIdx] = {\n            s: new Shape(),\n            p: tmpPoints\n          };\n          newShapes[mainIdx].s.curves = tmpPath.curves;\n          if (holesFirst) mainIdx++;\n          newShapeHoles[mainIdx] = []; //console.log(\'cw\', i);\n        } else {\n          newShapeHoles[mainIdx].push({\n            h: tmpPath,\n            p: tmpPoints[0]\n          }); //console.log(\'ccw\', i);\n        }\n      } // only Holes? -> probably all Shapes with wrong orientation\n\n\n      if (!newShapes[0]) return toShapesNoHoles(subPaths);\n\n      if (newShapes.length > 1) {\n        var ambiguous = false;\n        var toChange = 0;\n\n        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n          betterShapeHoles[sIdx] = [];\n        }\n\n        for (var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++) {\n          var sho = newShapeHoles[_sIdx];\n\n          for (var hIdx = 0; hIdx < sho.length; hIdx++) {\n            var ho = sho[hIdx];\n            var hole_unassigned = true;\n\n            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n                if (_sIdx !== s2Idx) toChange++;\n\n                if (hole_unassigned) {\n                  hole_unassigned = false;\n                  betterShapeHoles[s2Idx].push(ho);\n                } else {\n                  ambiguous = true;\n                }\n              }\n            }\n\n            if (hole_unassigned) {\n              betterShapeHoles[_sIdx].push(ho);\n            }\n          }\n        }\n\n        if (toChange > 0 && ambiguous === false) {\n          newShapeHoles = betterShapeHoles;\n        }\n      }\n\n      var tmpHoles;\n\n      for (var _i360 = 0, il = newShapes.length; _i360 < il; _i360++) {\n        tmpShape = newShapes[_i360].s;\n        shapes.push(tmpShape);\n        tmpHoles = newShapeHoles[_i360];\n\n        for (var j = 0, jl = tmpHoles.length; j < jl; j++) {\n          tmpShape.holes.push(tmpHoles[j].h);\n        }\n      } //console.log("shape", shapes);\n\n\n      return shapes;\n    }\n  }]);\n\n  return ShapePath;\n}(); // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\n\nvar DataUtils = /*#__PURE__*/function () {\n  function DataUtils() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DataUtils);\n  }\n\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DataUtils, null, [{\n    key: "toHalfFloat",\n    value: // float32 to float16\n    function toHalfFloat(val) {\n      if (Math.abs(val) > 65504) console.warn(\'THREE.DataUtils.toHalfFloat(): Value out of range.\');\n      val = clamp(val, -65504, 65504);\n      _floatView[0] = val;\n      var f = _uint32View[0];\n      var e = f >> 23 & 0x1ff;\n      return _baseTable[e] + ((f & 0x007fffff) >> _shiftTable[e]);\n    } // float16 to float32\n\n  }, {\n    key: "fromHalfFloat",\n    value: function fromHalfFloat(val) {\n      var m = val >> 10;\n      _uint32View[0] = _mantissaTable[_offsetTable[m] + (val & 0x3ff)] + _exponentTable[m];\n      return _floatView[0];\n    }\n  }]);\n\n  return DataUtils;\n}(); // float32 to float16 helpers\n\n\nvar _buffer = new ArrayBuffer(4);\n\nvar _floatView = new Float32Array(_buffer);\n\nvar _uint32View = new Uint32Array(_buffer);\n\nvar _baseTable = new Uint32Array(512);\n\nvar _shiftTable = new Uint32Array(512);\n\nfor (var _i361 = 0; _i361 < 256; ++_i361) {\n  var e = _i361 - 127; // very small number (0, -0)\n\n  if (e < -27) {\n    _baseTable[_i361] = 0x0000;\n    _baseTable[_i361 | 0x100] = 0x8000;\n    _shiftTable[_i361] = 24;\n    _shiftTable[_i361 | 0x100] = 24; // small number (denorm)\n  } else if (e < -14) {\n    _baseTable[_i361] = 0x0400 >> -e - 14;\n    _baseTable[_i361 | 0x100] = 0x0400 >> -e - 14 | 0x8000;\n    _shiftTable[_i361] = -e - 1;\n    _shiftTable[_i361 | 0x100] = -e - 1; // normal number\n  } else if (e <= 15) {\n    _baseTable[_i361] = e + 15 << 10;\n    _baseTable[_i361 | 0x100] = e + 15 << 10 | 0x8000;\n    _shiftTable[_i361] = 13;\n    _shiftTable[_i361 | 0x100] = 13; // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    _baseTable[_i361] = 0x7c00;\n    _baseTable[_i361 | 0x100] = 0xfc00;\n    _shiftTable[_i361] = 24;\n    _shiftTable[_i361 | 0x100] = 24; // stay (NaN, Infinity, -Infinity)\n  } else {\n    _baseTable[_i361] = 0x7c00;\n    _baseTable[_i361 | 0x100] = 0xfc00;\n    _shiftTable[_i361] = 13;\n    _shiftTable[_i361 | 0x100] = 13;\n  }\n} // float16 to float32 helpers\n\n\nvar _mantissaTable = new Uint32Array(2048);\n\nvar _exponentTable = new Uint32Array(64);\n\nvar _offsetTable = new Uint32Array(64);\n\nfor (var _i362 = 1; _i362 < 1024; ++_i362) {\n  var m = _i362 << 13; // zero pad mantissa bits\n\n  var _e = 0; // zero exponent\n  // normalized\n\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    _e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n\n  _e += 0x38800000; // adjust bias\n\n  _mantissaTable[_i362] = m | _e;\n}\n\nfor (var _i363 = 1024; _i363 < 2048; ++_i363) {\n  _mantissaTable[_i363] = 0x38000000 + (_i363 - 1024 << 13);\n}\n\nfor (var _i364 = 1; _i364 < 31; ++_i364) {\n  _exponentTable[_i364] = _i364 << 23;\n}\n\n_exponentTable[31] = 0x47800000;\n_exponentTable[32] = 0x80000000;\n\nfor (var _i365 = 33; _i365 < 63; ++_i365) {\n  _exponentTable[_i365] = 0x80000000 + (_i365 - 32 << 23);\n}\n\n_exponentTable[63] = 0xc7800000;\n\nfor (var _i366 = 1; _i366 < 64; ++_i366) {\n  if (_i366 !== 32) {\n    _offsetTable[_i366] = 1024;\n  }\n} // r133, c5bb5434555a3c3ddd784944a0a124f996fc721b\n\n\nvar ParametricGeometry = /*#__PURE__*/function (_BufferGeometry17) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(ParametricGeometry, _BufferGeometry17);\n\n  var _super154 = _createSuper(ParametricGeometry);\n\n  function ParametricGeometry() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, ParametricGeometry);\n\n    console.error(\'THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js\');\n    return _super154.call(this);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(ParametricGeometry);\n}(BufferGeometry); // r133, eb58ff153119090d3bbb24474ea0ffc40c70dc92\n\n\nvar TextGeometry = /*#__PURE__*/function (_BufferGeometry18) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(TextGeometry, _BufferGeometry18);\n\n  var _super155 = _createSuper(TextGeometry);\n\n  function TextGeometry() {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, TextGeometry);\n\n    console.error(\'THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js\');\n    return _super155.call(this);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(TextGeometry);\n}(BufferGeometry); // r133, eb58ff153119090d3bbb24474ea0ffc40c70dc92\n\n\nfunction FontLoader() {\n  console.error(\'THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js\');\n} // r133, eb58ff153119090d3bbb24474ea0ffc40c70dc92\n\n\nfunction Font() {\n  console.error(\'THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js\');\n} // r134, d65e0af06644fe5a84a6fc0e372f4318f95a04c0\n\n\nfunction ImmediateRenderObject() {\n  console.error(\'THREE.ImmediateRenderObject has been removed.\');\n} // r138, 48b05d3500acc084df50be9b4c90781ad9b8cb17\n\n\nvar WebGLMultisampleRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget5) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(WebGLMultisampleRenderTarget, _WebGLRenderTarget5);\n\n  var _super156 = _createSuper(WebGLMultisampleRenderTarget);\n\n  function WebGLMultisampleRenderTarget(width, height, options) {\n    var _this127;\n\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, WebGLMultisampleRenderTarget);\n\n    console.error(\'THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.\');\n    _this127 = _super156.call(this, width, height, options);\n    _this127.samples = 4;\n    return _this127;\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(WebGLMultisampleRenderTarget);\n}(WebGLRenderTarget); // r138, f9cd9cab03b7b64244e304900a3a2eeaa3a588ce\n\n\nvar DataTexture2DArray = /*#__PURE__*/function (_DataArrayTexture) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DataTexture2DArray, _DataArrayTexture);\n\n  var _super157 = _createSuper(DataTexture2DArray);\n\n  function DataTexture2DArray(data, width, height, depth) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DataTexture2DArray);\n\n    console.warn(\'THREE.DataTexture2DArray has been renamed to DataArrayTexture.\');\n    return _super157.call(this, data, width, height, depth);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DataTexture2DArray);\n}(DataArrayTexture); // r138, f9cd9cab03b7b64244e304900a3a2eeaa3a588ce\n\n\nvar DataTexture3D = /*#__PURE__*/function (_Data3DTexture) {\n  (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .Z)(DataTexture3D, _Data3DTexture);\n\n  var _super158 = _createSuper(DataTexture3D);\n\n  function DataTexture3D(data, width, height, depth) {\n    (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .Z)(this, DataTexture3D);\n\n    console.warn(\'THREE.DataTexture3D has been renamed to Data3DTexture.\');\n    return _super158.call(this, data, width, height, depth);\n  }\n\n  return (0,_Users_sepehrfazeli_Desktop_CodeCademy_site_sepehrfazeli_github_io_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .Z)(DataTexture3D);\n}(Data3DTexture);\n\nif (typeof __THREE_DEVTOOLS__ !== \'undefined\') {\n  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\'register\', {\n    detail: {\n      revision: REVISION\n    }\n  }));\n}\n\nif (typeof window !== \'undefined\') {\n  if (window.__THREE__) {\n    console.warn(\'WARNING: Multiple instances of Three.js being imported.\');\n  } else {\n    window.__THREE__ = REVISION;\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUs7QUFDRjtBQUNOO0FBQ3BCO0FBQ29DO0FBQzFCO0FBQ2tDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNOOztBQUVySjs7QUFFK0M7O0FBRS9DLHlEQUF5RCxpRkFBaUYsV0FBVyx3SEFBd0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsK0JBQStCLHVCQUF1QixZQUFZLFlBQVksZ0tBQWdLLGtEQUFrRCxTQUFTLGtCQUFrQixrQkFBa0Isb0JBQW9CLHNCQUFzQiw4QkFBOEIsY0FBYyx1QkFBdUIsZUFBZSxZQUFZLG9CQUFvQixNQUFNLDJEQUEyRCxVQUFVOztBQUV6OEIsa0RBQWtELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Q7O0FBRTdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLGlDQUFpQyw2REFBNkQseUNBQXlDLFlBQVksZ0xBQWUsbUJBQW1CLGlDQUFpQyxn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QUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLDhKQUF3QjtBQUNoRCxhQUFhLDhKQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLGtCQUFrQixFQUFFLGdMQUFlLHNCQUFzQixnTEFBZSxHQUFHLHdDQUF3QyxnTEFBZSw0QkFBNEIsZ0xBQWUsR0FBRztBQUNoTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsOEpBQXdCO0FBQ2hELGFBQWEsOEpBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxnTEFBZTtBQUNuQjs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBLDBCQUEwQix1TEFBc0I7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCLFFBQVE7OztBQUdSLDRHQUE0Rzs7QUFFNUcsc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FB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O0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLDhKQUF3QjtBQUNoRCxhQUFhLDhKQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsOEpBQXdCO0FBQ2hELGFBQWEsOEpBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsVUFBVTtBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjs7QUFFQSw4Q0FBOEM7OztBQUc5Qzs7QUFFQTs7QUFFQSw2Q0FBNkM7OztBQUc3Qzs7QUFFQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkMsK0VBQStFOzs7QUFHL0UsK0VBQStFOzs7QUFHL0UsK0VBQStFOzs7QUFHL0UsK0VBQStFOzs7QUFHL0UsK0VBQStFOzs7QUFHL0UsK0VBQStFOzs7QUFHL0UsK0VBQStFOzs7QUFHL0UsK0VBQStFOzs7QUFHL0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBLHNDQUFzQzs7O0FBR3RDOztBQUVBOztBQUVBLHdDQUF3Qzs7O0FBR3hDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQscUNBQXFDOzs7QUFHckMsdUhBQXVIOztBQUV2SDtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0RkFBNEY7OztBQUc1RjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QywwQkFBMEI7O0FBRTFCLDBCQUEwQjs7QUFFMUIseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUEsOENBQThDOztBQUU5QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUEsK0VBQStFOztBQUUvRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUEsa0ZBQWtGOztBQUVsRjtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FOztBQUVuRTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSLDhDQUE4Qzs7O0FBRzlDO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEseURBQXlEOzs7QUFHekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQ0FBa0M7O0FBRWpGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0EsTUFBTSxxS0FBSSxDQUFDLGdMQUFlOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsVUFBVTtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxVQUFVO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxVQUFVO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDLFVBQVU7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkNBQTZDLFlBQVk7QUFDekQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDLElBQUk7OztBQUdMO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsNktBQVk7QUFDckIsQ0FBQzs7QUFFRDtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBOztBQUVBLFNBQVMsNktBQVk7QUFDckIsQ0FBQzs7QUFFRDtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBOztBQUVBLFNBQVMsNktBQVk7QUFDckIsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0EsMEJBQTBCLHVMQUFzQjtBQUNoRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FB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QUFFQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFF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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFROztBQUVSLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFdBQVc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0FBMkMsa0JBQWtCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0EsTUFBTSxxS0FBSSxDQUFDLGdMQUFlOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQixxS0FBSSxDQUFDLGdMQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7QUFDakU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLCtCQUErQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixVQUFVO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtB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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHNEQUFzRCxZQUFZO0FBQ2xFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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OztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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SUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELG9DQUFvQyw2S0FBWTtBQUNoRCxFQUFFLGdMQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakIsMENBQTBDLFFBQVE7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQSwyQ0FBMkMsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDJDQUEyQztBQUMzQztBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFdBQVc7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUEsc0RBQXNEOzs7QUFHdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0EsTUFBTSxxS0FBSSxDQUFDLGdMQUFlOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBLE1BQU0scUtBQUksQ0FBQyxnTEFBZTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCwyQkFBMkIsd0NBQXdDLEdBQUc7QUFDdEUsOENBQThDLDBCQUEwQix1QkFBdUIsbUNBQW1DLCtDQUErQyxxQkFBcUIsNkJBQTZCLG9FQUFvRSxpREFBaUQseUJBQXlCLGFBQWEsUUFBUSw4Q0FBOEMseUtBQXlLLCtCQUErQiwwRkFBMEYsa0pBQWtKLHNCQUFzQixzQ0FBc0MsaUJBQWlCLDBCQUEwQiwwQ0FBMEMsdURBQXVELDREQUE0RCxHQUFHOztBQUUvbUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0M7OztBQUdsQyw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QixvQkFBb0I7QUFDM0M7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsd0dBQXdHOzs7QUFHeEc7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxFQUFFLGdMQUFlLHFDQUFxQyxnTEFBZSwwQ0FBMEMsZ0xBQWU7O0FBRXRLO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxFQUFFLGdMQUFlLDhCQUE4QixnTEFBZSw2QkFBNkIsZ0xBQWUsb0NBQW9DLGdMQUFlLG9DQUFvQyxnTEFBZSw0Q0FBNEMsZ0xBQWUsb0NBQW9DLGdMQUFlLG9DQUFvQyxnTEFBZSw0Q0FBNEMsZ0xBQWUsNENBQTRDLGdMQUFlLDRDQUE0QyxnTEFBZTs7QUFFdGtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksYUFBYTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFD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QXlCO0FBQ3JEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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QUFDQSxRQUFROzs7QUFHUjs7QUFFQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9B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QVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQyw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTs7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QUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FB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M0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSxxS0FBSSxDQUFDLGdMQUFlOztBQUUxQjs7QUFFQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLHFLQUFJLENBQUMsZ0xBQWU7O0FBRXJDOztBQUVBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLHFLQUFJLENBQUMsZ0xBQWU7O0FBRTFCOztBQUVBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLHFLQUFJLENBQUMsZ0xBQWU7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaUJBQWlCLHFLQUFJLENBQUMsZ0xBQWU7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTSxxS0FBSSxDQUFDLGdMQUFlOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0scUtBQUksQ0FBQyxnTEFBZTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIscUtBQUksQ0FBQyxnTEFBZTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLHFLQUFJLENBQUMsZ0xBQWU7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLHFLQUFJLENBQUMsZ0xBQWU7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIscUtBQUksQ0FBQyxnTEFBZTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0scUtBQUksQ0FBQyxnTEFBZTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLHFLQUFJLENBQUMsZ0xBQWU7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIscUtBQUksQ0FBQyxnTEFBZTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0scUtBQUksQ0FBQyxnTEFBZTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FB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QUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0scUtBQUksQ0FBQyxnTEFBZTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvTEFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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R0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0EsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEw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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxxS0FBSSxDQUFDLGdMQUFlO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLHFLQUFJLENBQUMsZ0xBQWU7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLHFLQUFJLENBQUMsZ0xBQWU7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBLEVBQUUsNktBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUixpRkFBaUY7QUFDakY7O0FBRUE7QUFDQSwrRkFBK0Y7O0FBRS9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxXQUFXO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0scUtBQUksQ0FBQyxnTEFBZTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDZLQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELFdBQVc7QUFDaEU7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNB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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBLDBEQUEwRDs7QUFFMUQ7QUFDQSxRQUFROzs7QUFHUiw0Q0FBNEM7O0FBRTVDOztBQUVBLG9EQUFvRDs7O0FBR3BEOztBQUVBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFF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QTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw2S0FBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdB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QUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7QUFDakM7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDLGtCQUFrQjs7O0FBR25CO0FBQ0EsRUFBRSwwS0FBUzs7QUFFWDs7QUFFQTtBQUNBLElBQUksZ0xBQWU7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDZLQUFZO0FBQ3JCLENBQUMsa0JBQWtCOzs7QUFHbkI7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDZLQUFZO0FBQ3JCLENBQUMscUJBQXFCOzs7QUFHdEI7QUFDQSxFQUFFLDBLQUFTOztBQUVYOztBQUVBO0FBQ0EsSUFBSSxnTEFBZTs7QUFFbkI7QUFDQTtBQUNBOztBQUVBLFNBQVMsNktBQVk7QUFDckIsQ0FBQyxvQkFBb0I7OztBQUdyQjtBQUNBLEVBQUUsMEtBQVM7O0FBRVg7O0FBRUE7QUFDQSxJQUFJLGdMQUFlOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw2S0FBWTtBQUNyQixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3d3dy8uL25vZGVfbW9kdWxlcy90aHJlZS9idWlsZC90aHJlZS5tb2R1bGUuanM/NjNkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCIvVXNlcnMvc2VwZWhyZmF6ZWxpL0Rlc2t0b3AvQ29kZUNhZGVteS9zaXRlL3NlcGVocmZhemVsaS5naXRodWIuaW8vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzXCI7XG5pbXBvcnQgX2FzeW5jVG9HZW5lcmF0b3IgZnJvbSBcIi9Vc2Vycy9zZXBlaHJmYXplbGkvRGVza3RvcC9Db2RlQ2FkZW15L3NpdGUvc2VwZWhyZmF6ZWxpLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qc1wiO1xuaW1wb3J0IF9zbGljZWRUb0FycmF5IGZyb20gXCIvVXNlcnMvc2VwZWhyZmF6ZWxpL0Rlc2t0b3AvQ29kZUNhZGVteS9zaXRlL3NlcGVocmZhemVsaS5naXRodWIuaW8vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanNcIjtcbmltcG9ydCBfZ2V0IGZyb20gXCIvVXNlcnMvc2VwZWhyZmF6ZWxpL0Rlc2t0b3AvQ29kZUNhZGVteS9zaXRlL3NlcGVocmZhemVsaS5naXRodWIuaW8vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldC5qc1wiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIi9Vc2Vycy9zZXBlaHJmYXplbGkvRGVza3RvcC9Db2RlQ2FkZW15L3NpdGUvc2VwZWhyZmF6ZWxpLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCIvVXNlcnMvc2VwZWhyZmF6ZWxpL0Rlc2t0b3AvQ29kZUNhZGVteS9zaXRlL3NlcGVocmZhemVsaS5naXRodWIuaW8vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIi9Vc2Vycy9zZXBlaHJmYXplbGkvRGVza3RvcC9Db2RlQ2FkZW15L3NpdGUvc2VwZWhyZmF6ZWxpLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1wiO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tIFwiL1VzZXJzL3NlcGVocmZhemVsaS9EZXNrdG9wL0NvZGVDYWRlbXkvc2l0ZS9zZXBlaHJmYXplbGkuZ2l0aHViLmlvL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZi5qc1wiO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tIFwiL1VzZXJzL3NlcGVocmZhemVsaS9EZXNrdG9wL0NvZGVDYWRlbXkvc2l0ZS9zZXBlaHJmYXplbGkuZ2l0aHViLmlvL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qc1wiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiL1VzZXJzL3NlcGVocmZhemVsaS9EZXNrdG9wL0NvZGVDYWRlbXkvc2l0ZS9zZXBlaHJmYXplbGkuZ2l0aHViLmlvL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVjay5qc1wiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiL1VzZXJzL3NlcGVocmZhemVsaS9EZXNrdG9wL0NvZGVDYWRlbXkvc2l0ZS9zZXBlaHJmYXplbGkuZ2l0aHViLmlvL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzcy5qc1wiO1xuXG52YXIgX0ZOO1xuXG5pbXBvcnQgXCJjb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5maW5hbGx5LmpzXCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IHRocm93IF9lMjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMykgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTM7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuaW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSBcIi9Vc2Vycy9zZXBlaHJmYXplbGkvRGVza3RvcC9Db2RlQ2FkZW15L3NpdGUvc2VwZWhyZmF6ZWxpLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTAtMjAyMiBUaHJlZS5qcyBBdXRob3JzXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4gKi9cbnZhciBSRVZJU0lPTiA9ICcxNDEnO1xudmFyIE1PVVNFID0ge1xuICBMRUZUOiAwLFxuICBNSURETEU6IDEsXG4gIFJJR0hUOiAyLFxuICBST1RBVEU6IDAsXG4gIERPTExZOiAxLFxuICBQQU46IDJcbn07XG52YXIgVE9VQ0ggPSB7XG4gIFJPVEFURTogMCxcbiAgUEFOOiAxLFxuICBET0xMWV9QQU46IDIsXG4gIERPTExZX1JPVEFURTogM1xufTtcbnZhciBDdWxsRmFjZU5vbmUgPSAwO1xudmFyIEN1bGxGYWNlQmFjayA9IDE7XG52YXIgQ3VsbEZhY2VGcm9udCA9IDI7XG52YXIgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xudmFyIEJhc2ljU2hhZG93TWFwID0gMDtcbnZhciBQQ0ZTaGFkb3dNYXAgPSAxO1xudmFyIFBDRlNvZnRTaGFkb3dNYXAgPSAyO1xudmFyIFZTTVNoYWRvd01hcCA9IDM7XG52YXIgRnJvbnRTaWRlID0gMDtcbnZhciBCYWNrU2lkZSA9IDE7XG52YXIgRG91YmxlU2lkZSA9IDI7XG52YXIgRmxhdFNoYWRpbmcgPSAxO1xudmFyIFNtb290aFNoYWRpbmcgPSAyO1xudmFyIE5vQmxlbmRpbmcgPSAwO1xudmFyIE5vcm1hbEJsZW5kaW5nID0gMTtcbnZhciBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcbnZhciBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcbnZhciBNdWx0aXBseUJsZW5kaW5nID0gNDtcbnZhciBDdXN0b21CbGVuZGluZyA9IDU7XG52YXIgQWRkRXF1YXRpb24gPSAxMDA7XG52YXIgU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcbnZhciBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcbnZhciBNaW5FcXVhdGlvbiA9IDEwMztcbnZhciBNYXhFcXVhdGlvbiA9IDEwNDtcbnZhciBaZXJvRmFjdG9yID0gMjAwO1xudmFyIE9uZUZhY3RvciA9IDIwMTtcbnZhciBTcmNDb2xvckZhY3RvciA9IDIwMjtcbnZhciBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xudmFyIFNyY0FscGhhRmFjdG9yID0gMjA0O1xudmFyIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XG52YXIgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG52YXIgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcbnZhciBEc3RDb2xvckZhY3RvciA9IDIwODtcbnZhciBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xudmFyIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG52YXIgTmV2ZXJEZXB0aCA9IDA7XG52YXIgQWx3YXlzRGVwdGggPSAxO1xudmFyIExlc3NEZXB0aCA9IDI7XG52YXIgTGVzc0VxdWFsRGVwdGggPSAzO1xudmFyIEVxdWFsRGVwdGggPSA0O1xudmFyIEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcbnZhciBHcmVhdGVyRGVwdGggPSA2O1xudmFyIE5vdEVxdWFsRGVwdGggPSA3O1xudmFyIE11bHRpcGx5T3BlcmF0aW9uID0gMDtcbnZhciBNaXhPcGVyYXRpb24gPSAxO1xudmFyIEFkZE9wZXJhdGlvbiA9IDI7XG52YXIgTm9Ub25lTWFwcGluZyA9IDA7XG52YXIgTGluZWFyVG9uZU1hcHBpbmcgPSAxO1xudmFyIFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xudmFyIENpbmVvblRvbmVNYXBwaW5nID0gMztcbnZhciBBQ0VTRmlsbWljVG9uZU1hcHBpbmcgPSA0O1xudmFyIEN1c3RvbVRvbmVNYXBwaW5nID0gNTtcbnZhciBVVk1hcHBpbmcgPSAzMDA7XG52YXIgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xudmFyIEN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcbnZhciBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcbnZhciBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcbnZhciBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IDMwNjtcbnZhciBSZXBlYXRXcmFwcGluZyA9IDEwMDA7XG52YXIgQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG52YXIgTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG52YXIgTmVhcmVzdEZpbHRlciA9IDEwMDM7XG52YXIgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA0O1xudmFyIE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcbnZhciBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyID0gMTAwNTtcbnZhciBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcbnZhciBMaW5lYXJGaWx0ZXIgPSAxMDA2O1xudmFyIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xudmFyIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xudmFyIExpbmVhck1pcG1hcExpbmVhckZpbHRlciA9IDEwMDg7XG52YXIgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcbnZhciBVbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcbnZhciBCeXRlVHlwZSA9IDEwMTA7XG52YXIgU2hvcnRUeXBlID0gMTAxMTtcbnZhciBVbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XG52YXIgSW50VHlwZSA9IDEwMTM7XG52YXIgVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcbnZhciBGbG9hdFR5cGUgPSAxMDE1O1xudmFyIEhhbGZGbG9hdFR5cGUgPSAxMDE2O1xudmFyIFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTc7XG52YXIgVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxODtcbnZhciBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xudmFyIEFscGhhRm9ybWF0ID0gMTAyMTtcbnZhciBSR0JGb3JtYXQgPSAxMDIyO1xudmFyIFJHQkFGb3JtYXQgPSAxMDIzO1xudmFyIEx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XG52YXIgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xudmFyIERlcHRoRm9ybWF0ID0gMTAyNjtcbnZhciBEZXB0aFN0ZW5jaWxGb3JtYXQgPSAxMDI3O1xudmFyIFJlZEZvcm1hdCA9IDEwMjg7XG52YXIgUmVkSW50ZWdlckZvcm1hdCA9IDEwMjk7XG52YXIgUkdGb3JtYXQgPSAxMDMwO1xudmFyIFJHSW50ZWdlckZvcm1hdCA9IDEwMzE7XG52YXIgUkdCQUludGVnZXJGb3JtYXQgPSAxMDMzO1xudmFyIFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3NzY7XG52YXIgUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMzM3Nzc7XG52YXIgUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMzM3Nzg7XG52YXIgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMzM3Nzk7XG52YXIgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAzNTg0MDtcbnZhciBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDM1ODQxO1xudmFyIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDM1ODQyO1xudmFyIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDM1ODQzO1xudmFyIFJHQl9FVEMxX0Zvcm1hdCA9IDM2MTk2O1xudmFyIFJHQl9FVEMyX0Zvcm1hdCA9IDM3NDkyO1xudmFyIFJHQkFfRVRDMl9FQUNfRm9ybWF0ID0gMzc0OTY7XG52YXIgUkdCQV9BU1RDXzR4NF9Gb3JtYXQgPSAzNzgwODtcbnZhciBSR0JBX0FTVENfNXg0X0Zvcm1hdCA9IDM3ODA5O1xudmFyIFJHQkFfQVNUQ181eDVfRm9ybWF0ID0gMzc4MTA7XG52YXIgUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgPSAzNzgxMTtcbnZhciBSR0JBX0FTVENfNng2X0Zvcm1hdCA9IDM3ODEyO1xudmFyIFJHQkFfQVNUQ184eDVfRm9ybWF0ID0gMzc4MTM7XG52YXIgUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgPSAzNzgxNDtcbnZhciBSR0JBX0FTVENfOHg4X0Zvcm1hdCA9IDM3ODE1O1xudmFyIFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCA9IDM3ODE2O1xudmFyIFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCA9IDM3ODE3O1xudmFyIFJHQkFfQVNUQ18xMHg4X0Zvcm1hdCA9IDM3ODE4O1xudmFyIFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQgPSAzNzgxOTtcbnZhciBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0ID0gMzc4MjA7XG52YXIgUkdCQV9BU1RDXzEyeDEyX0Zvcm1hdCA9IDM3ODIxO1xudmFyIFJHQkFfQlBUQ19Gb3JtYXQgPSAzNjQ5MjtcbnZhciBMb29wT25jZSA9IDIyMDA7XG52YXIgTG9vcFJlcGVhdCA9IDIyMDE7XG52YXIgTG9vcFBpbmdQb25nID0gMjIwMjtcbnZhciBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcbnZhciBJbnRlcnBvbGF0ZUxpbmVhciA9IDIzMDE7XG52YXIgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xudmFyIFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xudmFyIFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XG52YXIgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG52YXIgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlID0gMjUwMDtcbnZhciBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSA9IDI1MDE7XG52YXIgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xudmFyIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XG52YXIgVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XG52YXIgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xudmFyIHNSR0JFbmNvZGluZyA9IDMwMDE7XG52YXIgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xudmFyIFJHQkFEZXB0aFBhY2tpbmcgPSAzMjAxO1xudmFyIFRhbmdlbnRTcGFjZU5vcm1hbE1hcCA9IDA7XG52YXIgT2JqZWN0U3BhY2VOb3JtYWxNYXAgPSAxOyAvLyBDb2xvciBzcGFjZSBzdHJpbmcgaWRlbnRpZmllcnMsIG1hdGNoaW5nIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCBhbmQgV2ViR1BVIG5hbWVzIHdoZXJlIGF2YWlsYWJsZS5cblxudmFyIE5vQ29sb3JTcGFjZSA9ICcnO1xudmFyIFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xudmFyIExpbmVhclNSR0JDb2xvclNwYWNlID0gJ3NyZ2ItbGluZWFyJztcbnZhciBaZXJvU3RlbmNpbE9wID0gMDtcbnZhciBLZWVwU3RlbmNpbE9wID0gNzY4MDtcbnZhciBSZXBsYWNlU3RlbmNpbE9wID0gNzY4MTtcbnZhciBJbmNyZW1lbnRTdGVuY2lsT3AgPSA3NjgyO1xudmFyIERlY3JlbWVudFN0ZW5jaWxPcCA9IDc2ODM7XG52YXIgSW5jcmVtZW50V3JhcFN0ZW5jaWxPcCA9IDM0MDU1O1xudmFyIERlY3JlbWVudFdyYXBTdGVuY2lsT3AgPSAzNDA1NjtcbnZhciBJbnZlcnRTdGVuY2lsT3AgPSA1Mzg2O1xudmFyIE5ldmVyU3RlbmNpbEZ1bmMgPSA1MTI7XG52YXIgTGVzc1N0ZW5jaWxGdW5jID0gNTEzO1xudmFyIEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTQ7XG52YXIgTGVzc0VxdWFsU3RlbmNpbEZ1bmMgPSA1MTU7XG52YXIgR3JlYXRlclN0ZW5jaWxGdW5jID0gNTE2O1xudmFyIE5vdEVxdWFsU3RlbmNpbEZ1bmMgPSA1MTc7XG52YXIgR3JlYXRlckVxdWFsU3RlbmNpbEZ1bmMgPSA1MTg7XG52YXIgQWx3YXlzU3RlbmNpbEZ1bmMgPSA1MTk7XG52YXIgU3RhdGljRHJhd1VzYWdlID0gMzUwNDQ7XG52YXIgRHluYW1pY0RyYXdVc2FnZSA9IDM1MDQ4O1xudmFyIFN0cmVhbURyYXdVc2FnZSA9IDM1MDQwO1xudmFyIFN0YXRpY1JlYWRVc2FnZSA9IDM1MDQ1O1xudmFyIER5bmFtaWNSZWFkVXNhZ2UgPSAzNTA0OTtcbnZhciBTdHJlYW1SZWFkVXNhZ2UgPSAzNTA0MTtcbnZhciBTdGF0aWNDb3B5VXNhZ2UgPSAzNTA0NjtcbnZhciBEeW5hbWljQ29weVVzYWdlID0gMzUwNTA7XG52YXIgU3RyZWFtQ29weVVzYWdlID0gMzUwNDI7XG52YXIgR0xTTDEgPSAnMTAwJztcbnZhciBHTFNMMyA9ICczMDAgZXMnO1xudmFyIF9TUkdCQUZvcm1hdCA9IDEwMzU7IC8vIGZhbGxiYWNrIGZvciBXZWJHTCAxXG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG4gKi9cblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnREaXNwYXRjaGVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudERpc3BhdGNoZXIsIFt7XG4gICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0V2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIHJldHVybiBsaXN0ZW5lcnNbdHlwZV0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcikgIT09IC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzW3R5cGVdO1xuXG4gICAgICBpZiAobGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGxpc3RlbmVyQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwYXRjaEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzW2V2ZW50LnR5cGVdO1xuXG4gICAgICBpZiAobGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7IC8vIE1ha2UgYSBjb3B5LCBpbiBjYXNlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCB3aGlsZSBpdGVyYXRpbmcuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gbGlzdGVuZXJBcnJheS5zbGljZSgwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFycmF5W2ldLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnREaXNwYXRjaGVyO1xufSgpO1xuXG52YXIgX2x1dCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIF9sdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgaS50b1N0cmluZygxNik7XG59XG5cbnZhciBfc2VlZCA9IDEyMzQ1Njc7XG52YXIgREVHMlJBRCA9IE1hdGguUEkgLyAxODA7XG52YXIgUkFEMkRFRyA9IDE4MCAvIE1hdGguUEk7IC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG4gIHZhciBkMCA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgdmFyIGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICB2YXIgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIHZhciBkMyA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgdmFyIHV1aWQgPSBfbHV0W2QwICYgMHhmZl0gKyBfbHV0W2QwID4+IDggJiAweGZmXSArIF9sdXRbZDAgPj4gMTYgJiAweGZmXSArIF9sdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArIF9sdXRbZDEgJiAweGZmXSArIF9sdXRbZDEgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIF9sdXRbZDEgPj4gMjQgJiAweGZmXSArICctJyArIF9sdXRbZDIgJiAweDNmIHwgMHg4MF0gKyBfbHV0W2QyID4+IDggJiAweGZmXSArICctJyArIF9sdXRbZDIgPj4gMTYgJiAweGZmXSArIF9sdXRbZDIgPj4gMjQgJiAweGZmXSArIF9sdXRbZDMgJiAweGZmXSArIF9sdXRbZDMgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMyA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMyA+PiAyNCAmIDB4ZmZdOyAvLyAudG9Mb3dlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG5cbiAgcmV0dXJuIHV1aWQudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn0gLy8gY29tcHV0ZSBldWNsaWRlYW4gbW9kdWxvIG9mIG0gJSBuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXG5cblxuZnVuY3Rpb24gZXVjbGlkZWFuTW9kdWxvKG4sIG0pIHtcbiAgcmV0dXJuIChuICUgbSArIG0pICUgbTtcbn0gLy8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxuXG5cbmZ1bmN0aW9uIG1hcExpbmVhcih4LCBhMSwgYTIsIGIxLCBiMikge1xuICByZXR1cm4gYjEgKyAoeCAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcbn0gLy8gaHR0cHM6Ly93d3cuZ2FtZWRldi5uZXQvdHV0b3JpYWxzL3Byb2dyYW1taW5nL2dlbmVyYWwtYW5kLWdhbWVwbGF5LXByb2dyYW1taW5nL2ludmVyc2UtbGVycC1hLXN1cGVyLXVzZWZ1bC15ZXQtb2Z0ZW4tb3Zlcmxvb2tlZC1mdW5jdGlvbi1yNTIzMC9cblxuXG5mdW5jdGlvbiBpbnZlcnNlTGVycCh4LCB5LCB2YWx1ZSkge1xuICBpZiAoeCAhPT0geSkge1xuICAgIHJldHVybiAodmFsdWUgLSB4KSAvICh5IC0geCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn0gLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cblxuXG5mdW5jdGlvbiBsZXJwKHgsIHksIHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiB4ICsgdCAqIHk7XG59IC8vIGh0dHA6Ly93d3cucm9yeWRyaXNjb2xsLmNvbS8yMDE2LzAzLzA3L2ZyYW1lLXJhdGUtaW5kZXBlbmRlbnQtZGFtcGluZy11c2luZy1sZXJwL1xuXG5cbmZ1bmN0aW9uIGRhbXAoeCwgeSwgbGFtYmRhLCBkdCkge1xuICByZXR1cm4gbGVycCh4LCB5LCAxIC0gTWF0aC5leHAoLWxhbWJkYSAqIGR0KSk7XG59IC8vIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci92Y3Nqbnl6N3g0XG5cblxuZnVuY3Rpb24gcGluZ3BvbmcoeCkge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICByZXR1cm4gbGVuZ3RoIC0gTWF0aC5hYnMoZXVjbGlkZWFuTW9kdWxvKHgsIGxlbmd0aCAqIDIpIC0gbGVuZ3RoKTtcbn0gLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXG5cblxuZnVuY3Rpb24gc21vb3Roc3RlcCh4LCBtaW4sIG1heCkge1xuICBpZiAoeCA8PSBtaW4pIHJldHVybiAwO1xuICBpZiAoeCA+PSBtYXgpIHJldHVybiAxO1xuICB4ID0gKHggLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gIHJldHVybiB4ICogeCAqICgzIC0gMiAqIHgpO1xufVxuXG5mdW5jdGlvbiBzbW9vdGhlcnN0ZXAoeCwgbWluLCBtYXgpIHtcbiAgaWYgKHggPD0gbWluKSByZXR1cm4gMDtcbiAgaWYgKHggPj0gbWF4KSByZXR1cm4gMTtcbiAgeCA9ICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xuICByZXR1cm4geCAqIHggKiB4ICogKHggKiAoeCAqIDYgLSAxNSkgKyAxMCk7XG59IC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXG5mdW5jdGlvbiByYW5kSW50KGxvdywgaGlnaCkge1xuICByZXR1cm4gbG93ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cgKyAxKSk7XG59IC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXG5cblxuZnVuY3Rpb24gcmFuZEZsb2F0KGxvdywgaGlnaCkge1xuICByZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KTtcbn0gLy8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuXG5cbmZ1bmN0aW9uIHJhbmRGbG9hdFNwcmVhZChyYW5nZSkge1xuICByZXR1cm4gcmFuZ2UgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7XG59IC8vIERldGVybWluaXN0aWMgcHNldWRvLXJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgWyAwLCAxIF1cblxuXG5mdW5jdGlvbiBzZWVkZWRSYW5kb20ocykge1xuICBpZiAocyAhPT0gdW5kZWZpbmVkKSBfc2VlZCA9IHM7IC8vIE11bGJlcnJ5MzIgZ2VuZXJhdG9yXG5cbiAgdmFyIHQgPSBfc2VlZCArPSAweDZEMkI3OUY1O1xuICB0ID0gTWF0aC5pbXVsKHQgXiB0ID4+PiAxNSwgdCB8IDEpO1xuICB0IF49IHQgKyBNYXRoLmltdWwodCBeIHQgPj4+IDcsIHQgfCA2MSk7XG4gIHJldHVybiAoKHQgXiB0ID4+PiAxNCkgPj4+IDApIC8gNDI5NDk2NzI5Njtcbn1cblxuZnVuY3Rpb24gZGVnVG9SYWQoZGVncmVlcykge1xuICByZXR1cm4gZGVncmVlcyAqIERFRzJSQUQ7XG59XG5cbmZ1bmN0aW9uIHJhZFRvRGVnKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiBSQUQyREVHO1xufVxuXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28odmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAmIHZhbHVlIC0gMSkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG59XG5cbmZ1bmN0aW9uIGNlaWxQb3dlck9mVHdvKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpKTtcbn1cblxuZnVuY3Rpb24gZmxvb3JQb3dlck9mVHdvKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKSk7XG59XG5cbmZ1bmN0aW9uIHNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIocSwgYSwgYiwgYywgb3JkZXIpIHtcbiAgLy8gSW50cmluc2ljIFByb3BlciBFdWxlciBBbmdsZXMgLSBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzXG4gIC8vIHJvdGF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgYXhlcyBpbiB0aGUgb3JkZXIgc3BlY2lmaWVkIGJ5ICdvcmRlcidcbiAgLy8gcm90YXRpb24gYnkgYW5nbGUgJ2EnIGlzIGFwcGxpZWQgZmlyc3QsIHRoZW4gYnkgYW5nbGUgJ2InLCB0aGVuIGJ5IGFuZ2xlICdjJ1xuICAvLyBhbmdsZXMgYXJlIGluIHJhZGlhbnNcbiAgdmFyIGNvcyA9IE1hdGguY29zO1xuICB2YXIgc2luID0gTWF0aC5zaW47XG4gIHZhciBjMiA9IGNvcyhiIC8gMik7XG4gIHZhciBzMiA9IHNpbihiIC8gMik7XG4gIHZhciBjMTMgPSBjb3MoKGEgKyBjKSAvIDIpO1xuICB2YXIgczEzID0gc2luKChhICsgYykgLyAyKTtcbiAgdmFyIGMxXzMgPSBjb3MoKGEgLSBjKSAvIDIpO1xuICB2YXIgczFfMyA9IHNpbigoYSAtIGMpIC8gMik7XG4gIHZhciBjM18xID0gY29zKChjIC0gYSkgLyAyKTtcbiAgdmFyIHMzXzEgPSBzaW4oKGMgLSBhKSAvIDIpO1xuXG4gIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlICdYWVgnOlxuICAgICAgcS5zZXQoYzIgKiBzMTMsIHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIGMxMyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1laWSc6XG4gICAgICBxLnNldChzMiAqIHMxXzMsIGMyICogczEzLCBzMiAqIGMxXzMsIGMyICogYzEzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnWlhaJzpcbiAgICAgIHEuc2V0KHMyICogYzFfMywgczIgKiBzMV8zLCBjMiAqIHMxMywgYzIgKiBjMTMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdYWlgnOlxuICAgICAgcS5zZXQoYzIgKiBzMTMsIHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIGMxMyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1lYWSc6XG4gICAgICBxLnNldChzMiAqIGMzXzEsIGMyICogczEzLCBzMiAqIHMzXzEsIGMyICogYzEzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnWllaJzpcbiAgICAgIHEuc2V0KHMyICogczNfMSwgczIgKiBjM18xLCBjMiAqIHMxMywgYzIgKiBjMTMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5NYXRoVXRpbHM6IC5zZXRRdWF0ZXJuaW9uRnJvbVByb3BlckV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogJyArIG9yZGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZW5vcm1hbGl6ZSQxKHZhbHVlLCBhcnJheSkge1xuICBzd2l0Y2ggKGFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIHZhbHVlIC8gNjU1MzUuMDtcblxuICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIHJldHVybiB2YWx1ZSAvIDI1NS4wO1xuXG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlIC8gMzI3NjcuMCwgLTEuMCk7XG5cbiAgICBjYXNlIEludDhBcnJheTpcbiAgICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSAvIDEyNy4wLCAtMS4wKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcG9uZW50IHR5cGUuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHZhbHVlLCBhcnJheSkge1xuICBzd2l0Y2ggKGFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiA2NTUzNS4wKTtcblxuICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMjU1LjApO1xuXG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAzMjc2Ny4wKTtcblxuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMjcuMCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXBvbmVudCB0eXBlLicpO1xuICB9XG59XG5cbnZhciBNYXRoVXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgREVHMlJBRDogREVHMlJBRCxcbiAgUkFEMkRFRzogUkFEMkRFRyxcbiAgZ2VuZXJhdGVVVUlEOiBnZW5lcmF0ZVVVSUQsXG4gIGNsYW1wOiBjbGFtcCxcbiAgZXVjbGlkZWFuTW9kdWxvOiBldWNsaWRlYW5Nb2R1bG8sXG4gIG1hcExpbmVhcjogbWFwTGluZWFyLFxuICBpbnZlcnNlTGVycDogaW52ZXJzZUxlcnAsXG4gIGxlcnA6IGxlcnAsXG4gIGRhbXA6IGRhbXAsXG4gIHBpbmdwb25nOiBwaW5ncG9uZyxcbiAgc21vb3Roc3RlcDogc21vb3Roc3RlcCxcbiAgc21vb3RoZXJzdGVwOiBzbW9vdGhlcnN0ZXAsXG4gIHJhbmRJbnQ6IHJhbmRJbnQsXG4gIHJhbmRGbG9hdDogcmFuZEZsb2F0LFxuICByYW5kRmxvYXRTcHJlYWQ6IHJhbmRGbG9hdFNwcmVhZCxcbiAgc2VlZGVkUmFuZG9tOiBzZWVkZWRSYW5kb20sXG4gIGRlZ1RvUmFkOiBkZWdUb1JhZCxcbiAgcmFkVG9EZWc6IHJhZFRvRGVnLFxuICBpc1Bvd2VyT2ZUd286IGlzUG93ZXJPZlR3byxcbiAgY2VpbFBvd2VyT2ZUd286IGNlaWxQb3dlck9mVHdvLFxuICBmbG9vclBvd2VyT2ZUd286IGZsb29yUG93ZXJPZlR3byxcbiAgc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcjogc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcixcbiAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gIGRlbm9ybWFsaXplOiBkZW5vcm1hbGl6ZSQxXG59KTtcblxudmFyIFZlY3RvcjIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TeW1ib2wkaXRlcmF0b3IpIHtcbiAgZnVuY3Rpb24gVmVjdG9yMigpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZWN0b3IyKTtcblxuICAgIHRoaXMuaXNWZWN0b3IyID0gdHJ1ZTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVmVjdG9yMiwgW3tcbiAgICBrZXk6IFwid2lkdGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLng7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhlaWdodFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldCh4LCB5KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTY2FsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2NhbGFyKHNjYWxhcikge1xuICAgICAgdGhpcy54ID0gc2NhbGFyO1xuICAgICAgdGhpcy55ID0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WCh4KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WSh5KSB7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENvbXBvbmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb21wb25lbnQoaW5kZXgsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy55ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbXBvbmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21wb25lbnQoaW5kZXgpIHtcbiAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB0aGlzLng7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiB0aGlzLnk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkodikge1xuICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodiwgdykge1xuICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyh2LCB3KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy54ICs9IHYueDtcbiAgICAgIHRoaXMueSArPSB2Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNjYWxhcihzKSB7XG4gICAgICB0aGlzLnggKz0gcztcbiAgICAgIHRoaXMueSArPSBzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFZlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVmVjdG9ycyhhLCBiKSB7XG4gICAgICB0aGlzLnggPSBhLnggKyBiLng7XG4gICAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU2NhbGVkVmVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNjYWxlZFZlY3Rvcih2LCBzKSB7XG4gICAgICB0aGlzLnggKz0gdi54ICogcztcbiAgICAgIHRoaXMueSArPSB2LnkgKiBzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1YlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWIodiwgdykge1xuICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyh2LCB3KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy54IC09IHYueDtcbiAgICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ViU2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YlNjYWxhcihzKSB7XG4gICAgICB0aGlzLnggLT0gcztcbiAgICAgIHRoaXMueSAtPSBzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1YlZlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3ViVmVjdG9ycyhhLCBiKSB7XG4gICAgICB0aGlzLnggPSBhLnggLSBiLng7XG4gICAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVsdGlwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHkodikge1xuICAgICAgdGhpcy54ICo9IHYueDtcbiAgICAgIHRoaXMueSAqPSB2Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVsdGlwbHlTY2FsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXZpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGl2aWRlKHYpIHtcbiAgICAgIHRoaXMueCAvPSB2Lng7XG4gICAgICB0aGlzLnkgLz0gdi55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpdmlkZVNjYWxhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXZpZGVTY2FsYXIoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gc2NhbGFyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlNYXRyaXgzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5TWF0cml4MyhtKSB7XG4gICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICB5ID0gdGhpcy55O1xuICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuICAgICAgdGhpcy54ID0gZVswXSAqIHggKyBlWzNdICogeSArIGVbNl07XG4gICAgICB0aGlzLnkgPSBlWzFdICogeCArIGVbNF0gKiB5ICsgZVs3XTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluKHYpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgdi54KTtcbiAgICAgIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdi55KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KHYpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgdi54KTtcbiAgICAgIHRoaXMueSA9IE1hdGgubWF4KHRoaXMueSwgdi55KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGFtcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCkge1xuICAgICAgLy8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcbiAgICAgIHRoaXMueCA9IE1hdGgubWF4KG1pbi54LCBNYXRoLm1pbihtYXgueCwgdGhpcy54KSk7XG4gICAgICB0aGlzLnkgPSBNYXRoLm1heChtaW4ueSwgTWF0aC5taW4obWF4LnksIHRoaXMueSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsYW1wU2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy54KSk7XG4gICAgICB0aGlzLnkgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy55KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhbXBMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xhbXBMZW5ndGgobWluLCBtYXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKGxlbmd0aCB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgbGVuZ3RoKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbG9vclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbG9vcigpIHtcbiAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjZWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlaWwoKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kKCkge1xuICAgICAgdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xuICAgICAgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdW5kVG9aZXJvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kVG9aZXJvKCkge1xuICAgICAgdGhpcy54ID0gdGhpcy54IDwgMCA/IE1hdGguY2VpbCh0aGlzLngpIDogTWF0aC5mbG9vcih0aGlzLngpO1xuICAgICAgdGhpcy55ID0gdGhpcy55IDwgMCA/IE1hdGguY2VpbCh0aGlzLnkpIDogTWF0aC5mbG9vcih0aGlzLnkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5lZ2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWdhdGUoKSB7XG4gICAgICB0aGlzLnggPSAtdGhpcy54O1xuICAgICAgdGhpcy55ID0gLXRoaXMueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG90KHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyb3NzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyb3NzKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFNxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aFNxKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFuaGF0dGFuTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmhhdHRhbkxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpIHx8IDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmdsZSgpIHtcbiAgICAgIC8vIGNvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmUgeC1heGlzXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKC10aGlzLnksIC10aGlzLngpICsgTWF0aC5QSTtcbiAgICAgIHJldHVybiBhbmdsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvKHYpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9TcXVhcmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9TcXVhcmVkKHYpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMueCAtIHYueCxcbiAgICAgICAgICBkeSA9IHRoaXMueSAtIHYueTtcbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFuaGF0dGFuRGlzdGFuY2VUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYW5oYXR0YW5EaXN0YW5jZVRvKHYpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSB2LngpICsgTWF0aC5hYnModGhpcy55IC0gdi55KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExlbmd0aChsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlcnBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVycCh2LCBhbHBoYSkge1xuICAgICAgdGhpcy54ICs9ICh2LnggLSB0aGlzLngpICogYWxwaGE7XG4gICAgICB0aGlzLnkgKz0gKHYueSAtIHRoaXMueSkgKiBhbHBoYTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXJwVmVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXJwVmVjdG9ycyh2MSwgdjIsIGFscGhhKSB7XG4gICAgICB0aGlzLnggPSB2MS54ICsgKHYyLnggLSB2MS54KSAqIGFscGhhO1xuICAgICAgdGhpcy55ID0gdjEueSArICh2Mi55IC0gdjEueSkgKiBhbHBoYTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHYpIHtcbiAgICAgIHJldHVybiB2LnggPT09IHRoaXMueCAmJiB2LnkgPT09IHRoaXMueTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHRoaXMueCA9IGFycmF5W29mZnNldF07XG4gICAgICB0aGlzLnkgPSBhcnJheVtvZmZzZXQgKyAxXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGFycmF5W29mZnNldF0gPSB0aGlzLng7XG4gICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMueTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUJ1ZmZlckF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMjogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG4gICAgICB0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WShpbmRleCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlQXJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZUFyb3VuZChjZW50ZXIsIGFuZ2xlKSB7XG4gICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdmFyIHggPSB0aGlzLnggLSBjZW50ZXIueDtcbiAgICAgIHZhciB5ID0gdGhpcy55IC0gY2VudGVyLnk7XG4gICAgICB0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XG4gICAgICB0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZG9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJGl0ZXJhdG9yLFxuICAgIHZhbHVlOiAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiB2YWx1ZSQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB2YWx1ZSwgdGhpcyk7XG4gICAgfSlcbiAgfV0pO1xuXG4gIHJldHVybiBWZWN0b3IyO1xufShTeW1ib2wuaXRlcmF0b3IpO1xuXG52YXIgTWF0cml4MyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdHJpeDMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hdHJpeDMpO1xuXG4gICAgdGhpcy5pc01hdHJpeDMgPSB0cnVlO1xuICAgIHRoaXMuZWxlbWVudHMgPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV07XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hdHJpeDMsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQobjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMykge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHRlWzBdID0gbjExO1xuICAgICAgdGVbMV0gPSBuMjE7XG4gICAgICB0ZVsyXSA9IG4zMTtcbiAgICAgIHRlWzNdID0gbjEyO1xuICAgICAgdGVbNF0gPSBuMjI7XG4gICAgICB0ZVs1XSA9IG4zMjtcbiAgICAgIHRlWzZdID0gbjEzO1xuICAgICAgdGVbN10gPSBuMjM7XG4gICAgICB0ZVs4XSA9IG4zMztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpZGVudGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgICAgIHRoaXMuc2V0KDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShtKSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcbiAgICAgIHRlWzBdID0gbWVbMF07XG4gICAgICB0ZVsxXSA9IG1lWzFdO1xuICAgICAgdGVbMl0gPSBtZVsyXTtcbiAgICAgIHRlWzNdID0gbWVbM107XG4gICAgICB0ZVs0XSA9IG1lWzRdO1xuICAgICAgdGVbNV0gPSBtZVs1XTtcbiAgICAgIHRlWzZdID0gbWVbNl07XG4gICAgICB0ZVs3XSA9IG1lWzddO1xuICAgICAgdGVbOF0gPSBtZVs4XTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0QmFzaXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdEJhc2lzKHhBeGlzLCB5QXhpcywgekF4aXMpIHtcbiAgICAgIHhBeGlzLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDApO1xuICAgICAgeUF4aXMuc2V0RnJvbU1hdHJpeDNDb2x1bW4odGhpcywgMSk7XG4gICAgICB6QXhpcy5zZXRGcm9tTWF0cml4M0NvbHVtbih0aGlzLCAyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tTWF0cml4NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tTWF0cml4NChtKSB7XG4gICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuICAgICAgdGhpcy5zZXQobWVbMF0sIG1lWzRdLCBtZVs4XSwgbWVbMV0sIG1lWzVdLCBtZVs5XSwgbWVbMl0sIG1lWzZdLCBtZVsxMF0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5KG0pIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModGhpcywgbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZW11bHRpcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZW11bHRpcGx5KG0pIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMobSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5TWF0cmljZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHlNYXRyaWNlcyhhLCBiKSB7XG4gICAgICB2YXIgYWUgPSBhLmVsZW1lbnRzO1xuICAgICAgdmFyIGJlID0gYi5lbGVtZW50cztcbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB2YXIgYTExID0gYWVbMF0sXG4gICAgICAgICAgYTEyID0gYWVbM10sXG4gICAgICAgICAgYTEzID0gYWVbNl07XG4gICAgICB2YXIgYTIxID0gYWVbMV0sXG4gICAgICAgICAgYTIyID0gYWVbNF0sXG4gICAgICAgICAgYTIzID0gYWVbN107XG4gICAgICB2YXIgYTMxID0gYWVbMl0sXG4gICAgICAgICAgYTMyID0gYWVbNV0sXG4gICAgICAgICAgYTMzID0gYWVbOF07XG4gICAgICB2YXIgYjExID0gYmVbMF0sXG4gICAgICAgICAgYjEyID0gYmVbM10sXG4gICAgICAgICAgYjEzID0gYmVbNl07XG4gICAgICB2YXIgYjIxID0gYmVbMV0sXG4gICAgICAgICAgYjIyID0gYmVbNF0sXG4gICAgICAgICAgYjIzID0gYmVbN107XG4gICAgICB2YXIgYjMxID0gYmVbMl0sXG4gICAgICAgICAgYjMyID0gYmVbNV0sXG4gICAgICAgICAgYjMzID0gYmVbOF07XG4gICAgICB0ZVswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMTtcbiAgICAgIHRlWzNdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyO1xuICAgICAgdGVbNl0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzM7XG4gICAgICB0ZVsxXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMTtcbiAgICAgIHRlWzRdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyO1xuICAgICAgdGVbN10gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzM7XG4gICAgICB0ZVsyXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMTtcbiAgICAgIHRlWzVdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyO1xuICAgICAgdGVbOF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVsdGlwbHlTY2FsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIocykge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHRlWzBdICo9IHM7XG4gICAgICB0ZVszXSAqPSBzO1xuICAgICAgdGVbNl0gKj0gcztcbiAgICAgIHRlWzFdICo9IHM7XG4gICAgICB0ZVs0XSAqPSBzO1xuICAgICAgdGVbN10gKj0gcztcbiAgICAgIHRlWzJdICo9IHM7XG4gICAgICB0ZVs1XSAqPSBzO1xuICAgICAgdGVbOF0gKj0gcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXRlcm1pbmFudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmFudCgpIHtcbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB2YXIgYSA9IHRlWzBdLFxuICAgICAgICAgIGIgPSB0ZVsxXSxcbiAgICAgICAgICBjID0gdGVbMl0sXG4gICAgICAgICAgZCA9IHRlWzNdLFxuICAgICAgICAgIGUgPSB0ZVs0XSxcbiAgICAgICAgICBmID0gdGVbNV0sXG4gICAgICAgICAgZyA9IHRlWzZdLFxuICAgICAgICAgIGggPSB0ZVs3XSxcbiAgICAgICAgICBpID0gdGVbOF07XG4gICAgICByZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cyxcbiAgICAgICAgICBuMTEgPSB0ZVswXSxcbiAgICAgICAgICBuMjEgPSB0ZVsxXSxcbiAgICAgICAgICBuMzEgPSB0ZVsyXSxcbiAgICAgICAgICBuMTIgPSB0ZVszXSxcbiAgICAgICAgICBuMjIgPSB0ZVs0XSxcbiAgICAgICAgICBuMzIgPSB0ZVs1XSxcbiAgICAgICAgICBuMTMgPSB0ZVs2XSxcbiAgICAgICAgICBuMjMgPSB0ZVs3XSxcbiAgICAgICAgICBuMzMgPSB0ZVs4XSxcbiAgICAgICAgICB0MTEgPSBuMzMgKiBuMjIgLSBuMzIgKiBuMjMsXG4gICAgICAgICAgdDEyID0gbjMyICogbjEzIC0gbjMzICogbjEyLFxuICAgICAgICAgIHQxMyA9IG4yMyAqIG4xMiAtIG4yMiAqIG4xMyxcbiAgICAgICAgICBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG4gICAgICBpZiAoZGV0ID09PSAwKSByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICB2YXIgZGV0SW52ID0gMSAvIGRldDtcbiAgICAgIHRlWzBdID0gdDExICogZGV0SW52O1xuICAgICAgdGVbMV0gPSAobjMxICogbjIzIC0gbjMzICogbjIxKSAqIGRldEludjtcbiAgICAgIHRlWzJdID0gKG4zMiAqIG4yMSAtIG4zMSAqIG4yMikgKiBkZXRJbnY7XG4gICAgICB0ZVszXSA9IHQxMiAqIGRldEludjtcbiAgICAgIHRlWzRdID0gKG4zMyAqIG4xMSAtIG4zMSAqIG4xMykgKiBkZXRJbnY7XG4gICAgICB0ZVs1XSA9IChuMzEgKiBuMTIgLSBuMzIgKiBuMTEpICogZGV0SW52O1xuICAgICAgdGVbNl0gPSB0MTMgKiBkZXRJbnY7XG4gICAgICB0ZVs3XSA9IChuMjEgKiBuMTMgLSBuMjMgKiBuMTEpICogZGV0SW52O1xuICAgICAgdGVbOF0gPSAobjIyICogbjExIC0gbjIxICogbjEyKSAqIGRldEludjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNwb3NlKCkge1xuICAgICAgdmFyIHRtcDtcbiAgICAgIHZhciBtID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHRtcCA9IG1bMV07XG4gICAgICBtWzFdID0gbVszXTtcbiAgICAgIG1bM10gPSB0bXA7XG4gICAgICB0bXAgPSBtWzJdO1xuICAgICAgbVsyXSA9IG1bNl07XG4gICAgICBtWzZdID0gdG1wO1xuICAgICAgdG1wID0gbVs1XTtcbiAgICAgIG1bNV0gPSBtWzddO1xuICAgICAgbVs3XSA9IHRtcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXROb3JtYWxNYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeDQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KG1hdHJpeDQpLmludmVydCgpLnRyYW5zcG9zZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc3Bvc2VJbnRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNwb3NlSW50b0FycmF5KHIpIHtcbiAgICAgIHZhciBtID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHJbMF0gPSBtWzBdO1xuICAgICAgclsxXSA9IG1bM107XG4gICAgICByWzJdID0gbVs2XTtcbiAgICAgIHJbM10gPSBtWzFdO1xuICAgICAgcls0XSA9IG1bNF07XG4gICAgICByWzVdID0gbVs3XTtcbiAgICAgIHJbNl0gPSBtWzJdO1xuICAgICAgcls3XSA9IG1bNV07XG4gICAgICByWzhdID0gbVs4XTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRVdlRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVdlRyYW5zZm9ybSh0eCwgdHksIHN4LCBzeSwgcm90YXRpb24sIGN4LCBjeSkge1xuICAgICAgdmFyIGMgPSBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKHJvdGF0aW9uKTtcbiAgICAgIHRoaXMuc2V0KHN4ICogYywgc3ggKiBzLCAtc3ggKiAoYyAqIGN4ICsgcyAqIGN5KSArIGN4ICsgdHgsIC1zeSAqIHMsIHN5ICogYywgLXN5ICogKC1zICogY3ggKyBjICogY3kpICsgY3kgKyB0eSwgMCwgMCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGUoc3gsIHN5KSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdGVbMF0gKj0gc3g7XG4gICAgICB0ZVszXSAqPSBzeDtcbiAgICAgIHRlWzZdICo9IHN4O1xuICAgICAgdGVbMV0gKj0gc3k7XG4gICAgICB0ZVs0XSAqPSBzeTtcbiAgICAgIHRlWzddICo9IHN5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGUodGhldGEpIHtcbiAgICAgIHZhciBjID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHMgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIGExMSA9IHRlWzBdLFxuICAgICAgICAgIGExMiA9IHRlWzNdLFxuICAgICAgICAgIGExMyA9IHRlWzZdO1xuICAgICAgdmFyIGEyMSA9IHRlWzFdLFxuICAgICAgICAgIGEyMiA9IHRlWzRdLFxuICAgICAgICAgIGEyMyA9IHRlWzddO1xuICAgICAgdGVbMF0gPSBjICogYTExICsgcyAqIGEyMTtcbiAgICAgIHRlWzNdID0gYyAqIGExMiArIHMgKiBhMjI7XG4gICAgICB0ZVs2XSA9IGMgKiBhMTMgKyBzICogYTIzO1xuICAgICAgdGVbMV0gPSAtcyAqIGExMSArIGMgKiBhMjE7XG4gICAgICB0ZVs0XSA9IC1zICogYTEyICsgYyAqIGEyMjtcbiAgICAgIHRlWzddID0gLXMgKiBhMTMgKyBjICogYTIzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGUodHgsIHR5KSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdGVbMF0gKz0gdHggKiB0ZVsyXTtcbiAgICAgIHRlWzNdICs9IHR4ICogdGVbNV07XG4gICAgICB0ZVs2XSArPSB0eCAqIHRlWzhdO1xuICAgICAgdGVbMV0gKz0gdHkgKiB0ZVsyXTtcbiAgICAgIHRlWzRdICs9IHR5ICogdGVbNV07XG4gICAgICB0ZVs3XSArPSB0eSAqIHRlWzhdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMobWF0cml4KSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgOTsgX2krKykge1xuICAgICAgICBpZiAodGVbX2ldICE9PSBtZVtfaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IDk7IF9pMisrKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbX2kyXSA9IGFycmF5W19pMiArIG9mZnNldF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICBhcnJheVtvZmZzZXRdID0gdGVbMF07XG4gICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IHRlWzFdO1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSB0ZVsyXTtcbiAgICAgIGFycmF5W29mZnNldCArIDNdID0gdGVbM107XG4gICAgICBhcnJheVtvZmZzZXQgKyA0XSA9IHRlWzRdO1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgNV0gPSB0ZVs1XTtcbiAgICAgIGFycmF5W29mZnNldCArIDZdID0gdGVbNl07XG4gICAgICBhcnJheVtvZmZzZXQgKyA3XSA9IHRlWzddO1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgOF0gPSB0ZVs4XTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hdHJpeDM7XG59KCk7XG5cbmZ1bmN0aW9uIGFycmF5TmVlZHNVaW50MzIoYXJyYXkpIHtcbiAgLy8gYXNzdW1lcyBsYXJnZXIgdmFsdWVzIHVzdWFsbHkgb24gbGFzdFxuICBmb3IgKHZhciBfaTMgPSBhcnJheS5sZW5ndGggLSAxOyBfaTMgPj0gMDsgLS1faTMpIHtcbiAgICBpZiAoYXJyYXlbX2kzXSA+IDY1NTM1KSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFRZUEVEX0FSUkFZUyA9IHtcbiAgSW50OEFycmF5OiBJbnQ4QXJyYXksXG4gIFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXG4gIFVpbnQ4Q2xhbXBlZEFycmF5OiBVaW50OENsYW1wZWRBcnJheSxcbiAgSW50MTZBcnJheTogSW50MTZBcnJheSxcbiAgVWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxuICBJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuICBVaW50MzJBcnJheTogVWludDMyQXJyYXksXG4gIEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuICBGbG9hdDY0QXJyYXk6IEZsb2F0NjRBcnJheVxufTtcblxuZnVuY3Rpb24gZ2V0VHlwZWRBcnJheSh0eXBlLCBidWZmZXIpIHtcbiAgcmV0dXJuIG5ldyBUWVBFRF9BUlJBWVNbdHlwZV0oYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBTUkdCVG9MaW5lYXIoYykge1xuICByZXR1cm4gYyA8IDAuMDQwNDUgPyBjICogMC4wNzczOTkzODA4IDogTWF0aC5wb3coYyAqIDAuOTQ3ODY3Mjk4NiArIDAuMDUyMTMyNzAxNCwgMi40KTtcbn1cblxuZnVuY3Rpb24gTGluZWFyVG9TUkdCKGMpIHtcbiAgcmV0dXJuIGMgPCAwLjAwMzEzMDggPyBjICogMTIuOTIgOiAxLjA1NSAqIE1hdGgucG93KGMsIDAuNDE2NjYpIC0gMC4wNTU7XG59IC8vIEphdmFTY3JpcHQgUkdCLXRvLVJHQiB0cmFuc2Zvcm1zLCBkZWZpbmVkIGFzXG4vLyBGTltJbnB1dENvbG9yU3BhY2VdW091dHB1dENvbG9yU3BhY2VdIGNhbGxiYWNrIGZ1bmN0aW9ucy5cblxuXG52YXIgRk4gPSAoX0ZOID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfRk4sIFNSR0JDb2xvclNwYWNlLCBfZGVmaW5lUHJvcGVydHkoe30sIExpbmVhclNSR0JDb2xvclNwYWNlLCBTUkdCVG9MaW5lYXIpKSwgX2RlZmluZVByb3BlcnR5KF9GTiwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgU1JHQkNvbG9yU3BhY2UsIExpbmVhclRvU1JHQikpLCBfRk4pO1xudmFyIENvbG9yTWFuYWdlbWVudCA9IHtcbiAgbGVnYWN5TW9kZTogdHJ1ZSxcblxuICBnZXQgd29ya2luZ0NvbG9yU3BhY2UoKSB7XG4gICAgcmV0dXJuIExpbmVhclNSR0JDb2xvclNwYWNlO1xuICB9LFxuXG4gIHNldCB3b3JraW5nQ29sb3JTcGFjZShjb2xvclNwYWNlKSB7XG4gICAgY29uc29sZS53YXJuKCdUSFJFRS5Db2xvck1hbmFnZW1lbnQ6IC53b3JraW5nQ29sb3JTcGFjZSBpcyByZWFkb25seS4nKTtcbiAgfSxcblxuICBjb252ZXJ0OiBmdW5jdGlvbiBjb252ZXJ0KGNvbG9yLCBzb3VyY2VDb2xvclNwYWNlLCB0YXJnZXRDb2xvclNwYWNlKSB7XG4gICAgaWYgKHRoaXMubGVnYWN5TW9kZSB8fCBzb3VyY2VDb2xvclNwYWNlID09PSB0YXJnZXRDb2xvclNwYWNlIHx8ICFzb3VyY2VDb2xvclNwYWNlIHx8ICF0YXJnZXRDb2xvclNwYWNlKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuXG4gICAgaWYgKEZOW3NvdXJjZUNvbG9yU3BhY2VdICYmIEZOW3NvdXJjZUNvbG9yU3BhY2VdW3RhcmdldENvbG9yU3BhY2VdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmbiA9IEZOW3NvdXJjZUNvbG9yU3BhY2VdW3RhcmdldENvbG9yU3BhY2VdO1xuICAgICAgY29sb3IuciA9IGZuKGNvbG9yLnIpO1xuICAgICAgY29sb3IuZyA9IGZuKGNvbG9yLmcpO1xuICAgICAgY29sb3IuYiA9IGZuKGNvbG9yLmIpO1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgY29sb3Igc3BhY2UgY29udmVyc2lvbi4nKTtcbiAgfSxcbiAgZnJvbVdvcmtpbmdDb2xvclNwYWNlOiBmdW5jdGlvbiBmcm9tV29ya2luZ0NvbG9yU3BhY2UoY29sb3IsIHRhcmdldENvbG9yU3BhY2UpIHtcbiAgICByZXR1cm4gdGhpcy5jb252ZXJ0KGNvbG9yLCB0aGlzLndvcmtpbmdDb2xvclNwYWNlLCB0YXJnZXRDb2xvclNwYWNlKTtcbiAgfSxcbiAgdG9Xb3JraW5nQ29sb3JTcGFjZTogZnVuY3Rpb24gdG9Xb3JraW5nQ29sb3JTcGFjZShjb2xvciwgc291cmNlQ29sb3JTcGFjZSkge1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnQoY29sb3IsIHNvdXJjZUNvbG9yU3BhY2UsIHRoaXMud29ya2luZ0NvbG9yU3BhY2UpO1xuICB9XG59O1xudmFyIF9jb2xvcktleXdvcmRzID0ge1xuICAnYWxpY2VibHVlJzogMHhGMEY4RkYsXG4gICdhbnRpcXVld2hpdGUnOiAweEZBRUJENyxcbiAgJ2FxdWEnOiAweDAwRkZGRixcbiAgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCxcbiAgJ2F6dXJlJzogMHhGMEZGRkYsXG4gICdiZWlnZSc6IDB4RjVGNURDLFxuICAnYmlzcXVlJzogMHhGRkU0QzQsXG4gICdibGFjayc6IDB4MDAwMDAwLFxuICAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCxcbiAgJ2JsdWUnOiAweDAwMDBGRixcbiAgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcbiAgJ2Jyb3duJzogMHhBNTJBMkEsXG4gICdidXJseXdvb2QnOiAweERFQjg4NyxcbiAgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLFxuICAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLFxuICAnY2hvY29sYXRlJzogMHhEMjY5MUUsXG4gICdjb3JhbCc6IDB4RkY3RjUwLFxuICAnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCxcbiAgJ2Nvcm5zaWxrJzogMHhGRkY4REMsXG4gICdjcmltc29uJzogMHhEQzE0M0MsXG4gICdjeWFuJzogMHgwMEZGRkYsXG4gICdkYXJrYmx1ZSc6IDB4MDAwMDhCLFxuICAnZGFya2N5YW4nOiAweDAwOEI4QixcbiAgJ2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQixcbiAgJ2RhcmtncmF5JzogMHhBOUE5QTksXG4gICdkYXJrZ3JlZW4nOiAweDAwNjQwMCxcbiAgJ2RhcmtncmV5JzogMHhBOUE5QTksXG4gICdkYXJra2hha2knOiAweEJEQjc2QixcbiAgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG4gICdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLFxuICAnZGFya29yYW5nZSc6IDB4RkY4QzAwLFxuICAnZGFya29yY2hpZCc6IDB4OTkzMkNDLFxuICAnZGFya3JlZCc6IDB4OEIwMDAwLFxuICAnZGFya3NhbG1vbic6IDB4RTk5NjdBLFxuICAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXG4gICdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsXG4gICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsXG4gICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsXG4gICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsXG4gICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG4gICdkZWVwcGluayc6IDB4RkYxNDkzLFxuICAnZGVlcHNreWJsdWUnOiAweDAwQkZGRixcbiAgJ2RpbWdyYXknOiAweDY5Njk2OSxcbiAgJ2RpbWdyZXknOiAweDY5Njk2OSxcbiAgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRixcbiAgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxuICAnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCxcbiAgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsXG4gICdmdWNoc2lhJzogMHhGRjAwRkYsXG4gICdnYWluc2Jvcm8nOiAweERDRENEQyxcbiAgJ2dob3N0d2hpdGUnOiAweEY4RjhGRixcbiAgJ2dvbGQnOiAweEZGRDcwMCxcbiAgJ2dvbGRlbnJvZCc6IDB4REFBNTIwLFxuICAnZ3JheSc6IDB4ODA4MDgwLFxuICAnZ3JlZW4nOiAweDAwODAwMCxcbiAgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsXG4gICdncmV5JzogMHg4MDgwODAsXG4gICdob25leWRldyc6IDB4RjBGRkYwLFxuICAnaG90cGluayc6IDB4RkY2OUI0LFxuICAnaW5kaWFucmVkJzogMHhDRDVDNUMsXG4gICdpbmRpZ28nOiAweDRCMDA4MixcbiAgJ2l2b3J5JzogMHhGRkZGRjAsXG4gICdraGFraSc6IDB4RjBFNjhDLFxuICAnbGF2ZW5kZXInOiAweEU2RTZGQSxcbiAgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSxcbiAgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxuICAnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsXG4gICdsaWdodGJsdWUnOiAweEFERDhFNixcbiAgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCxcbiAgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLFxuICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMixcbiAgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxuICAnbGlnaHRncmVlbic6IDB4OTBFRTkwLFxuICAnbGlnaHRncmV5JzogMHhEM0QzRDMsXG4gICdsaWdodHBpbmsnOiAweEZGQjZDMSxcbiAgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsXG4gICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsXG4gICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcbiAgJ2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksXG4gICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LFxuICAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSxcbiAgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsXG4gICdsaW1lJzogMHgwMEZGMDAsXG4gICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcbiAgJ2xpbmVuJzogMHhGQUYwRTYsXG4gICdtYWdlbnRhJzogMHhGRjAwRkYsXG4gICdtYXJvb24nOiAweDgwMDAwMCxcbiAgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSxcbiAgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCxcbiAgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxuICAnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsXG4gICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLFxuICAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsXG4gICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLFxuICAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG4gICdtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSxcbiAgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLFxuICAnbWludGNyZWFtJzogMHhGNUZGRkEsXG4gICdtaXN0eXJvc2UnOiAweEZGRTRFMSxcbiAgJ21vY2Nhc2luJzogMHhGRkU0QjUsXG4gICduYXZham93aGl0ZSc6IDB4RkZERUFELFxuICAnbmF2eSc6IDB4MDAwMDgwLFxuICAnb2xkbGFjZSc6IDB4RkRGNUU2LFxuICAnb2xpdmUnOiAweDgwODAwMCxcbiAgJ29saXZlZHJhYic6IDB4NkI4RTIzLFxuICAnb3JhbmdlJzogMHhGRkE1MDAsXG4gICdvcmFuZ2VyZWQnOiAweEZGNDUwMCxcbiAgJ29yY2hpZCc6IDB4REE3MEQ2LFxuICAncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLFxuICAncGFsZWdyZWVuJzogMHg5OEZCOTgsXG4gICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsXG4gICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsXG4gICdwYXBheWF3aGlwJzogMHhGRkVGRDUsXG4gICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcbiAgJ3BlcnUnOiAweENEODUzRixcbiAgJ3BpbmsnOiAweEZGQzBDQixcbiAgJ3BsdW0nOiAweEREQTBERCxcbiAgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNixcbiAgJ3B1cnBsZSc6IDB4ODAwMDgwLFxuICAncmViZWNjYXB1cnBsZSc6IDB4NjYzMzk5LFxuICAncmVkJzogMHhGRjAwMDAsXG4gICdyb3N5YnJvd24nOiAweEJDOEY4RixcbiAgJ3JveWFsYmx1ZSc6IDB4NDE2OUUxLFxuICAnc2FkZGxlYnJvd24nOiAweDhCNDUxMyxcbiAgJ3NhbG1vbic6IDB4RkE4MDcyLFxuICAnc2FuZHlicm93bic6IDB4RjRBNDYwLFxuICAnc2VhZ3JlZW4nOiAweDJFOEI1NyxcbiAgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXG4gICdzaWVubmEnOiAweEEwNTIyRCxcbiAgJ3NpbHZlcic6IDB4QzBDMEMwLFxuICAnc2t5Ymx1ZSc6IDB4ODdDRUVCLFxuICAnc2xhdGVibHVlJzogMHg2QTVBQ0QsXG4gICdzbGF0ZWdyYXknOiAweDcwODA5MCxcbiAgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLFxuICAnc25vdyc6IDB4RkZGQUZBLFxuICAnc3ByaW5nZ3JlZW4nOiAweDAwRkY3RixcbiAgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LFxuICAndGFuJzogMHhEMkI0OEMsXG4gICd0ZWFsJzogMHgwMDgwODAsXG4gICd0aGlzdGxlJzogMHhEOEJGRDgsXG4gICd0b21hdG8nOiAweEZGNjM0NyxcbiAgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuICAndmlvbGV0JzogMHhFRTgyRUUsXG4gICd3aGVhdCc6IDB4RjVERUIzLFxuICAnd2hpdGUnOiAweEZGRkZGRixcbiAgJ3doaXRlc21va2UnOiAweEY1RjVGNSxcbiAgJ3llbGxvdyc6IDB4RkZGRjAwLFxuICAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMlxufTtcbnZhciBfcmdiID0ge1xuICByOiAwLFxuICBnOiAwLFxuICBiOiAwXG59O1xudmFyIF9oc2xBID0ge1xuICBoOiAwLFxuICBzOiAwLFxuICBsOiAwXG59O1xudmFyIF9oc2xCID0ge1xuICBoOiAwLFxuICBzOiAwLFxuICBsOiAwXG59O1xuXG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gIGlmICh0ID4gMSkgdCAtPSAxO1xuICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiAoMiAvIDMgLSB0KTtcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHRvQ29tcG9uZW50cyhzb3VyY2UsIHRhcmdldCkge1xuICB0YXJnZXQuciA9IHNvdXJjZS5yO1xuICB0YXJnZXQuZyA9IHNvdXJjZS5nO1xuICB0YXJnZXQuYiA9IHNvdXJjZS5iO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgQ29sb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TeW1ib2wkaXRlcmF0b3IyKSB7XG4gIGZ1bmN0aW9uIENvbG9yKHIsIGcsIGIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3IpO1xuXG4gICAgdGhpcy5pc0NvbG9yID0gdHJ1ZTtcbiAgICB0aGlzLnIgPSAxO1xuICAgIHRoaXMuZyA9IDE7XG4gICAgdGhpcy5iID0gMTtcblxuICAgIGlmIChnID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByIGlzIFRIUkVFLkNvbG9yLCBoZXggb3Igc3RyaW5nXG4gICAgICByZXR1cm4gdGhpcy5zZXQocik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0UkdCKHIsIGcsIGIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbG9yLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUuaXNDb2xvcikge1xuICAgICAgICB0aGlzLmNvcHkodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuc2V0SGV4KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnNldFN0eWxlKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNjYWxhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTY2FsYXIoc2NhbGFyKSB7XG4gICAgICB0aGlzLnIgPSBzY2FsYXI7XG4gICAgICB0aGlzLmcgPSBzY2FsYXI7XG4gICAgICB0aGlzLmIgPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhleChoZXgpIHtcbiAgICAgIHZhciBjb2xvclNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBTUkdCQ29sb3JTcGFjZTtcbiAgICAgIGhleCA9IE1hdGguZmxvb3IoaGV4KTtcbiAgICAgIHRoaXMuciA9IChoZXggPj4gMTYgJiAyNTUpIC8gMjU1O1xuICAgICAgdGhpcy5nID0gKGhleCA+PiA4ICYgMjU1KSAvIDI1NTtcbiAgICAgIHRoaXMuYiA9IChoZXggJiAyNTUpIC8gMjU1O1xuICAgICAgQ29sb3JNYW5hZ2VtZW50LnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcywgY29sb3JTcGFjZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UkdCXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJHQihyLCBnLCBiKSB7XG4gICAgICB2YXIgY29sb3JTcGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICB0aGlzLnIgPSByO1xuICAgICAgdGhpcy5nID0gZztcbiAgICAgIHRoaXMuYiA9IGI7XG4gICAgICBDb2xvck1hbmFnZW1lbnQudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLCBjb2xvclNwYWNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRIU0xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SFNMKGgsIHMsIGwpIHtcbiAgICAgIHZhciBjb2xvclNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG4gICAgICBoID0gZXVjbGlkZWFuTW9kdWxvKGgsIDEpO1xuICAgICAgcyA9IGNsYW1wKHMsIDAsIDEpO1xuICAgICAgbCA9IGNsYW1wKGwsIDAsIDEpO1xuXG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICB0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHEgPSAyICogbCAtIHA7XG4gICAgICAgIHRoaXMuciA9IGh1ZTJyZ2IocSwgcCwgaCArIDEgLyAzKTtcbiAgICAgICAgdGhpcy5nID0gaHVlMnJnYihxLCBwLCBoKTtcbiAgICAgICAgdGhpcy5iID0gaHVlMnJnYihxLCBwLCBoIC0gMSAvIDMpO1xuICAgICAgfVxuXG4gICAgICBDb2xvck1hbmFnZW1lbnQudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLCBjb2xvclNwYWNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdHlsZShzdHlsZSkge1xuICAgICAgdmFyIGNvbG9yU3BhY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFNSR0JDb2xvclNwYWNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVBbHBoYShzdHJpbmcpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHBhcnNlRmxvYXQoc3RyaW5nKSA8IDEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG07XG5cbiAgICAgIGlmIChtID0gL14oKD86cmdifGhzbClhPylcXCgoW15cXCldKilcXCkvLmV4ZWMoc3R5bGUpKSB7XG4gICAgICAgIC8vIHJnYiAvIGhzbFxuICAgICAgICB2YXIgY29sb3I7XG4gICAgICAgIHZhciBuYW1lID0gbVsxXTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBtWzJdO1xuXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgICBpZiAoY29sb3IgPSAvXlxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoY29tcG9uZW50cykpIHtcbiAgICAgICAgICAgICAgLy8gcmdiKDI1NSwwLDApIHJnYmEoMjU1LDAsMCwwLjUpXG4gICAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbMV0sIDEwKSkgLyAyNTU7XG4gICAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbMl0sIDEwKSkgLyAyNTU7XG4gICAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKDI1NSwgcGFyc2VJbnQoY29sb3JbM10sIDEwKSkgLyAyNTU7XG4gICAgICAgICAgICAgIENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGNvbG9yU3BhY2UpO1xuICAgICAgICAgICAgICBoYW5kbGVBbHBoYShjb2xvcls0XSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sb3IgPSAvXlxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKD86LFxccyooXFxkKlxcLj9cXGQrKVxccyopPyQvLmV4ZWMoY29tcG9uZW50cykpIHtcbiAgICAgICAgICAgICAgLy8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG4gICAgICAgICAgICAgIHRoaXMuciA9IE1hdGgubWluKDEwMCwgcGFyc2VJbnQoY29sb3JbMV0sIDEwKSkgLyAxMDA7XG4gICAgICAgICAgICAgIHRoaXMuZyA9IE1hdGgubWluKDEwMCwgcGFyc2VJbnQoY29sb3JbMl0sIDEwKSkgLyAxMDA7XG4gICAgICAgICAgICAgIHRoaXMuYiA9IE1hdGgubWluKDEwMCwgcGFyc2VJbnQoY29sb3JbM10sIDEwKSkgLyAxMDA7XG4gICAgICAgICAgICAgIENvbG9yTWFuYWdlbWVudC50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGNvbG9yU3BhY2UpO1xuICAgICAgICAgICAgICBoYW5kbGVBbHBoYShjb2xvcls0XSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgICAgICBpZiAoY29sb3IgPSAvXlxccyooXFxkKlxcLj9cXGQrKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooPzosXFxzKihcXGQqXFwuP1xcZCspXFxzKik/JC8uZXhlYyhjb21wb25lbnRzKSkge1xuICAgICAgICAgICAgICAvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxuICAgICAgICAgICAgICB2YXIgaCA9IHBhcnNlRmxvYXQoY29sb3JbMV0pIC8gMzYwO1xuICAgICAgICAgICAgICB2YXIgcyA9IHBhcnNlSW50KGNvbG9yWzJdLCAxMCkgLyAxMDA7XG4gICAgICAgICAgICAgIHZhciBsID0gcGFyc2VJbnQoY29sb3JbM10sIDEwKSAvIDEwMDtcbiAgICAgICAgICAgICAgaGFuZGxlQWxwaGEoY29sb3JbNF0pO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRIU0woaCwgcywgbCwgY29sb3JTcGFjZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG0gPSAvXlxcIyhbQS1GYS1mXFxkXSspJC8uZXhlYyhzdHlsZSkpIHtcbiAgICAgICAgLy8gaGV4IGNvbG9yXG4gICAgICAgIHZhciBoZXggPSBtWzFdO1xuICAgICAgICB2YXIgc2l6ZSA9IGhleC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHNpemUgPT09IDMpIHtcbiAgICAgICAgICAvLyAjZmYwXG4gICAgICAgICAgdGhpcy5yID0gcGFyc2VJbnQoaGV4LmNoYXJBdCgwKSArIGhleC5jaGFyQXQoMCksIDE2KSAvIDI1NTtcbiAgICAgICAgICB0aGlzLmcgPSBwYXJzZUludChoZXguY2hhckF0KDEpICsgaGV4LmNoYXJBdCgxKSwgMTYpIC8gMjU1O1xuICAgICAgICAgIHRoaXMuYiA9IHBhcnNlSW50KGhleC5jaGFyQXQoMikgKyBoZXguY2hhckF0KDIpLCAxNikgLyAyNTU7XG4gICAgICAgICAgQ29sb3JNYW5hZ2VtZW50LnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcywgY29sb3JTcGFjZSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gNikge1xuICAgICAgICAgIC8vICNmZjAwMDBcbiAgICAgICAgICB0aGlzLnIgPSBwYXJzZUludChoZXguY2hhckF0KDApICsgaGV4LmNoYXJBdCgxKSwgMTYpIC8gMjU1O1xuICAgICAgICAgIHRoaXMuZyA9IHBhcnNlSW50KGhleC5jaGFyQXQoMikgKyBoZXguY2hhckF0KDMpLCAxNikgLyAyNTU7XG4gICAgICAgICAgdGhpcy5iID0gcGFyc2VJbnQoaGV4LmNoYXJBdCg0KSArIGhleC5jaGFyQXQoNSksIDE2KSAvIDI1NTtcbiAgICAgICAgICBDb2xvck1hbmFnZW1lbnQudG9Xb3JraW5nQ29sb3JTcGFjZSh0aGlzLCBjb2xvclNwYWNlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUgJiYgc3R5bGUubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRDb2xvck5hbWUoc3R5bGUsIGNvbG9yU3BhY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29sb3JOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbG9yTmFtZShzdHlsZSkge1xuICAgICAgdmFyIGNvbG9yU3BhY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFNSR0JDb2xvclNwYWNlO1xuXG4gICAgICAvLyBjb2xvciBrZXl3b3Jkc1xuICAgICAgdmFyIGhleCA9IF9jb2xvcktleXdvcmRzW3N0eWxlLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICBpZiAoaGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmVkXG4gICAgICAgIHRoaXMuc2V0SGV4KGhleCwgY29sb3JTcGFjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1bmtub3duIGNvbG9yXG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoY29sb3IpIHtcbiAgICAgIHRoaXMuciA9IGNvbG9yLnI7XG4gICAgICB0aGlzLmcgPSBjb2xvci5nO1xuICAgICAgdGhpcy5iID0gY29sb3IuYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5U1JHQlRvTGluZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlTUkdCVG9MaW5lYXIoY29sb3IpIHtcbiAgICAgIHRoaXMuciA9IFNSR0JUb0xpbmVhcihjb2xvci5yKTtcbiAgICAgIHRoaXMuZyA9IFNSR0JUb0xpbmVhcihjb2xvci5nKTtcbiAgICAgIHRoaXMuYiA9IFNSR0JUb0xpbmVhcihjb2xvci5iKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5TGluZWFyVG9TUkdCXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlMaW5lYXJUb1NSR0IoY29sb3IpIHtcbiAgICAgIHRoaXMuciA9IExpbmVhclRvU1JHQihjb2xvci5yKTtcbiAgICAgIHRoaXMuZyA9IExpbmVhclRvU1JHQihjb2xvci5nKTtcbiAgICAgIHRoaXMuYiA9IExpbmVhclRvU1JHQihjb2xvci5iKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb252ZXJ0U1JHQlRvTGluZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRTUkdCVG9MaW5lYXIoKSB7XG4gICAgICB0aGlzLmNvcHlTUkdCVG9MaW5lYXIodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydExpbmVhclRvU1JHQlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb252ZXJ0TGluZWFyVG9TUkdCKCkge1xuICAgICAgdGhpcy5jb3B5TGluZWFyVG9TUkdCKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZXgoKSB7XG4gICAgICB2YXIgY29sb3JTcGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogU1JHQkNvbG9yU3BhY2U7XG4gICAgICBDb2xvck1hbmFnZW1lbnQuZnJvbVdvcmtpbmdDb2xvclNwYWNlKHRvQ29tcG9uZW50cyh0aGlzLCBfcmdiKSwgY29sb3JTcGFjZSk7XG4gICAgICByZXR1cm4gY2xhbXAoX3JnYi5yICogMjU1LCAwLCAyNTUpIDw8IDE2IF4gY2xhbXAoX3JnYi5nICogMjU1LCAwLCAyNTUpIDw8IDggXiBjbGFtcChfcmdiLmIgKiAyNTUsIDAsIDI1NSkgPDwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGV4U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhleFN0cmluZygpIHtcbiAgICAgIHZhciBjb2xvclNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBTUkdCQ29sb3JTcGFjZTtcbiAgICAgIHJldHVybiAoJzAwMDAwMCcgKyB0aGlzLmdldEhleChjb2xvclNwYWNlKS50b1N0cmluZygxNikpLnNsaWNlKC02KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SFNMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhTTCh0YXJnZXQpIHtcbiAgICAgIHZhciBjb2xvclNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG4gICAgICBDb2xvck1hbmFnZW1lbnQuZnJvbVdvcmtpbmdDb2xvclNwYWNlKHRvQ29tcG9uZW50cyh0aGlzLCBfcmdiKSwgY29sb3JTcGFjZSk7XG4gICAgICB2YXIgciA9IF9yZ2IucixcbiAgICAgICAgICBnID0gX3JnYi5nLFxuICAgICAgICAgIGIgPSBfcmdiLmI7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICB2YXIgaHVlLCBzYXR1cmF0aW9uO1xuICAgICAgdmFyIGxpZ2h0bmVzcyA9IChtaW4gKyBtYXgpIC8gMi4wO1xuXG4gICAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgICAgaHVlID0gMDtcbiAgICAgICAgc2F0dXJhdGlvbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgICAgIHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAobWF4ICsgbWluKSA6IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXG4gICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgaHVlID0gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICBodWUgPSAoYiAtIHIpIC8gZGVsdGEgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgICBodWUgPSAociAtIGcpIC8gZGVsdGEgKyA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBodWUgLz0gNjtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LmggPSBodWU7XG4gICAgICB0YXJnZXQucyA9IHNhdHVyYXRpb247XG4gICAgICB0YXJnZXQubCA9IGxpZ2h0bmVzcztcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJHQlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSR0IodGFyZ2V0KSB7XG4gICAgICB2YXIgY29sb3JTcGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICBDb2xvck1hbmFnZW1lbnQuZnJvbVdvcmtpbmdDb2xvclNwYWNlKHRvQ29tcG9uZW50cyh0aGlzLCBfcmdiKSwgY29sb3JTcGFjZSk7XG4gICAgICB0YXJnZXQuciA9IF9yZ2IucjtcbiAgICAgIHRhcmdldC5nID0gX3JnYi5nO1xuICAgICAgdGFyZ2V0LmIgPSBfcmdiLmI7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHlsZSgpIHtcbiAgICAgIHZhciBjb2xvclNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBTUkdCQ29sb3JTcGFjZTtcbiAgICAgIENvbG9yTWFuYWdlbWVudC5mcm9tV29ya2luZ0NvbG9yU3BhY2UodG9Db21wb25lbnRzKHRoaXMsIF9yZ2IpLCBjb2xvclNwYWNlKTtcblxuICAgICAgaWYgKGNvbG9yU3BhY2UgIT09IFNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIC8vIFJlcXVpcmVzIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgNCAoaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1jb2xvci00LykuXG4gICAgICAgIHJldHVybiBcImNvbG9yKFwiLmNvbmNhdChjb2xvclNwYWNlLCBcIiBcIikuY29uY2F0KF9yZ2IuciwgXCIgXCIpLmNvbmNhdChfcmdiLmcsIFwiIFwiKS5jb25jYXQoX3JnYi5iLCBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcInJnYihcIi5jb25jYXQoX3JnYi5yICogMjU1IHwgMCwgXCIsXCIpLmNvbmNhdChfcmdiLmcgKiAyNTUgfCAwLCBcIixcIikuY29uY2F0KF9yZ2IuYiAqIDI1NSB8IDAsIFwiKVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib2Zmc2V0SFNMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZnNldEhTTChoLCBzLCBsKSB7XG4gICAgICB0aGlzLmdldEhTTChfaHNsQSk7XG4gICAgICBfaHNsQS5oICs9IGg7XG4gICAgICBfaHNsQS5zICs9IHM7XG4gICAgICBfaHNsQS5sICs9IGw7XG4gICAgICB0aGlzLnNldEhTTChfaHNsQS5oLCBfaHNsQS5zLCBfaHNsQS5sKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGNvbG9yKSB7XG4gICAgICB0aGlzLnIgKz0gY29sb3IucjtcbiAgICAgIHRoaXMuZyArPSBjb2xvci5nO1xuICAgICAgdGhpcy5iICs9IGNvbG9yLmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ29sb3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbG9ycyhjb2xvcjEsIGNvbG9yMikge1xuICAgICAgdGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcbiAgICAgIHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XG4gICAgICB0aGlzLmIgPSBjb2xvcjEuYiArIGNvbG9yMi5iO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFNjYWxhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTY2FsYXIocykge1xuICAgICAgdGhpcy5yICs9IHM7XG4gICAgICB0aGlzLmcgKz0gcztcbiAgICAgIHRoaXMuYiArPSBzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1YlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWIoY29sb3IpIHtcbiAgICAgIHRoaXMuciA9IE1hdGgubWF4KDAsIHRoaXMuciAtIGNvbG9yLnIpO1xuICAgICAgdGhpcy5nID0gTWF0aC5tYXgoMCwgdGhpcy5nIC0gY29sb3IuZyk7XG4gICAgICB0aGlzLmIgPSBNYXRoLm1heCgwLCB0aGlzLmIgLSBjb2xvci5iKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtdWx0aXBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseShjb2xvcikge1xuICAgICAgdGhpcy5yICo9IGNvbG9yLnI7XG4gICAgICB0aGlzLmcgKj0gY29sb3IuZztcbiAgICAgIHRoaXMuYiAqPSBjb2xvci5iO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5U2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKHMpIHtcbiAgICAgIHRoaXMuciAqPSBzO1xuICAgICAgdGhpcy5nICo9IHM7XG4gICAgICB0aGlzLmIgKj0gcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXJwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlcnAoY29sb3IsIGFscGhhKSB7XG4gICAgICB0aGlzLnIgKz0gKGNvbG9yLnIgLSB0aGlzLnIpICogYWxwaGE7XG4gICAgICB0aGlzLmcgKz0gKGNvbG9yLmcgLSB0aGlzLmcpICogYWxwaGE7XG4gICAgICB0aGlzLmIgKz0gKGNvbG9yLmIgLSB0aGlzLmIpICogYWxwaGE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVycENvbG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXJwQ29sb3JzKGNvbG9yMSwgY29sb3IyLCBhbHBoYSkge1xuICAgICAgdGhpcy5yID0gY29sb3IxLnIgKyAoY29sb3IyLnIgLSBjb2xvcjEucikgKiBhbHBoYTtcbiAgICAgIHRoaXMuZyA9IGNvbG9yMS5nICsgKGNvbG9yMi5nIC0gY29sb3IxLmcpICogYWxwaGE7XG4gICAgICB0aGlzLmIgPSBjb2xvcjEuYiArIChjb2xvcjIuYiAtIGNvbG9yMS5iKSAqIGFscGhhO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlcnBIU0xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVycEhTTChjb2xvciwgYWxwaGEpIHtcbiAgICAgIHRoaXMuZ2V0SFNMKF9oc2xBKTtcbiAgICAgIGNvbG9yLmdldEhTTChfaHNsQik7XG4gICAgICB2YXIgaCA9IGxlcnAoX2hzbEEuaCwgX2hzbEIuaCwgYWxwaGEpO1xuICAgICAgdmFyIHMgPSBsZXJwKF9oc2xBLnMsIF9oc2xCLnMsIGFscGhhKTtcbiAgICAgIHZhciBsID0gbGVycChfaHNsQS5sLCBfaHNsQi5sLCBhbHBoYSk7XG4gICAgICB0aGlzLnNldEhTTChoLCBzLCBsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKGMpIHtcbiAgICAgIHJldHVybiBjLnIgPT09IHRoaXMuciAmJiBjLmcgPT09IHRoaXMuZyAmJiBjLmIgPT09IHRoaXMuYjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHRoaXMuciA9IGFycmF5W29mZnNldF07XG4gICAgICB0aGlzLmcgPSBhcnJheVtvZmZzZXQgKyAxXTtcbiAgICAgIHRoaXMuYiA9IGFycmF5W29mZnNldCArIDJdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IHRoaXMucjtcbiAgICAgIGFycmF5W29mZnNldCArIDFdID0gdGhpcy5nO1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLmI7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21CdWZmZXJBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGV4KSB7XG4gICAgICB0aGlzLnIgPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG4gICAgICB0aGlzLmcgPSBhdHRyaWJ1dGUuZ2V0WShpbmRleCk7XG4gICAgICB0aGlzLmIgPSBhdHRyaWJ1dGUuZ2V0WihpbmRleCk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGUubm9ybWFsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBhc3N1bWluZyBVaW50OEFycmF5XG4gICAgICAgIHRoaXMuciAvPSAyNTU7XG4gICAgICAgIHRoaXMuZyAvPSAyNTU7XG4gICAgICAgIHRoaXMuYiAvPSAyNTU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SGV4KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJGl0ZXJhdG9yMixcbiAgICB2YWx1ZTogLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0Mykge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnI7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYjtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHZhbHVlLCB0aGlzKTtcbiAgICB9KVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbG9yO1xufShTeW1ib2wuaXRlcmF0b3IpO1xuXG5Db2xvci5OQU1FUyA9IF9jb2xvcktleXdvcmRzO1xuXG52YXIgX2NhbnZhcztcblxudmFyIEltYWdlVXRpbHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbWFnZVV0aWxzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZVV0aWxzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZVV0aWxzLCBudWxsLCBbe1xuICAgIGtleTogXCJnZXREYXRhVVJMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGFVUkwoaW1hZ2UpIHtcbiAgICAgIGlmICgvXmRhdGE6L2kudGVzdChpbWFnZS5zcmMpKSB7XG4gICAgICAgIHJldHVybiBpbWFnZS5zcmM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGltYWdlLnNyYztcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbnZhcztcblxuICAgICAgaWYgKGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgY2FudmFzID0gaW1hZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX2NhbnZhcyA9PT0gdW5kZWZpbmVkKSBfY2FudmFzID0gY3JlYXRlRWxlbWVudE5TKCdjYW52YXMnKTtcbiAgICAgICAgX2NhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICBfY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICB2YXIgY29udGV4dCA9IF9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICAgICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzID0gX2NhbnZhcztcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5JbWFnZVV0aWxzLmdldERhdGFVUkw6IEltYWdlIGNvbnZlcnRlZCB0byBqcGcgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMnLCBpbWFnZSk7XG4gICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMC42KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic1JHQlRvTGluZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNSR0JUb0xpbmVhcihpbWFnZSkge1xuICAgICAgaWYgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuICAgICAgICB2YXIgY2FudmFzID0gY3JlYXRlRWxlbWVudE5TKCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGRhdGEubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgIGRhdGFbX2k0XSA9IFNSR0JUb0xpbmVhcihkYXRhW19pNF0gLyAyNTUpICogMjU1O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgIH0gZWxzZSBpZiAoaW1hZ2UuZGF0YSkge1xuICAgICAgICB2YXIgX2RhdGEgPSBpbWFnZS5kYXRhLnNsaWNlKDApO1xuXG4gICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IF9kYXRhLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgICBpZiAoX2RhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IF9kYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICAgICAgICAgIF9kYXRhW19pNV0gPSBNYXRoLmZsb29yKFNSR0JUb0xpbmVhcihfZGF0YVtfaTVdIC8gMjU1KSAqIDI1NSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFzc3VtaW5nIGZsb2F0XG4gICAgICAgICAgICBfZGF0YVtfaTVdID0gU1JHQlRvTGluZWFyKF9kYXRhW19pNV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogX2RhdGEsXG4gICAgICAgICAgd2lkdGg6IGltYWdlLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaW1hZ2UuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkltYWdlVXRpbHMuc1JHQlRvTGluZWFyKCk6IFVuc3VwcG9ydGVkIGltYWdlIHR5cGUuIE5vIGNvbG9yIHNwYWNlIGNvbnZlcnNpb24gYXBwbGllZC4nKTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZVV0aWxzO1xufSgpO1xuXG52YXIgU291cmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU291cmNlKCkge1xuICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvdXJjZSk7XG5cbiAgICB0aGlzLmlzU291cmNlID0gdHJ1ZTtcbiAgICB0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU291cmNlLCBbe1xuICAgIGtleTogXCJuZWVkc1VwZGF0ZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHRydWUpIHRoaXMudmVyc2lvbisrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKG1ldGEpIHtcbiAgICAgIHZhciBpc1Jvb3RPYmplY3QgPSBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnO1xuXG4gICAgICBpZiAoIWlzUm9vdE9iamVjdCAmJiBtZXRhLmltYWdlc1t0aGlzLnV1aWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG1ldGEuaW1hZ2VzW3RoaXMudXVpZF07XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICAgIHV1aWQ6IHRoaXMudXVpZCxcbiAgICAgICAgdXJsOiAnJ1xuICAgICAgfTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdXJsO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgLy8gY3ViZSB0ZXh0dXJlXG4gICAgICAgICAgdXJsID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTYgPSAwLCBsID0gZGF0YS5sZW5ndGg7IF9pNiA8IGw7IF9pNisrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVtfaTZdLmlzRGF0YVRleHR1cmUpIHtcbiAgICAgICAgICAgICAgdXJsLnB1c2goc2VyaWFsaXplSW1hZ2UoZGF0YVtfaTZdLmltYWdlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cmwucHVzaChzZXJpYWxpemVJbWFnZShkYXRhW19pNl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGV4dHVyZVxuICAgICAgICAgIHVybCA9IHNlcmlhbGl6ZUltYWdlKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnVybCA9IHVybDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1Jvb3RPYmplY3QpIHtcbiAgICAgICAgbWV0YS5pbWFnZXNbdGhpcy51dWlkXSA9IG91dHB1dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU291cmNlO1xufSgpO1xuXG5mdW5jdGlvbiBzZXJpYWxpemVJbWFnZShpbWFnZSkge1xuICBpZiAodHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHwgdHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XG4gICAgLy8gZGVmYXVsdCBpbWFnZXNcbiAgICByZXR1cm4gSW1hZ2VVdGlscy5nZXREYXRhVVJMKGltYWdlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaW1hZ2UuZGF0YSkge1xuICAgICAgLy8gaW1hZ2VzIG9mIERhdGFUZXh0dXJlXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbWFnZS5kYXRhKSxcbiAgICAgICAgd2lkdGg6IGltYWdlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltYWdlLmhlaWdodCxcbiAgICAgICAgdHlwZTogaW1hZ2UuZGF0YS5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4nKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHRleHR1cmVJZCA9IDA7XG5cbnZhciBUZXh0dXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnREaXNwYXRjaGVyKSB7XG4gIF9pbmhlcml0cyhUZXh0dXJlLCBfRXZlbnREaXNwYXRjaGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFRleHR1cmUpO1xuXG4gIGZ1bmN0aW9uIFRleHR1cmUoKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIHZhciBpbWFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogVGV4dHVyZS5ERUZBVUxUX0lNQUdFO1xuICAgIHZhciBtYXBwaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBUZXh0dXJlLkRFRkFVTFRfTUFQUElORztcbiAgICB2YXIgd3JhcFMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgdmFyIHdyYXBUID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgIHZhciBtYWdGaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IExpbmVhckZpbHRlcjtcbiAgICB2YXIgbWluRmlsdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXI7XG4gICAgdmFyIGZvcm1hdCA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogUkdCQUZvcm1hdDtcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogVW5zaWduZWRCeXRlVHlwZTtcbiAgICB2YXIgYW5pc290cm9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiA4ICYmIGFyZ3VtZW50c1s4XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzhdIDogMTtcbiAgICB2YXIgZW5jb2RpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gOSAmJiBhcmd1bWVudHNbOV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s5XSA6IExpbmVhckVuY29kaW5nO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHR1cmUpO1xuXG4gICAgX3RoaXMyID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMyLmlzVGV4dHVyZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyKSwgJ2lkJywge1xuICAgICAgdmFsdWU6IHRleHR1cmVJZCsrXG4gICAgfSk7XG4gICAgX3RoaXMyLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICBfdGhpczIubmFtZSA9ICcnO1xuICAgIF90aGlzMi5zb3VyY2UgPSBuZXcgU291cmNlKGltYWdlKTtcbiAgICBfdGhpczIubWlwbWFwcyA9IFtdO1xuICAgIF90aGlzMi5tYXBwaW5nID0gbWFwcGluZztcbiAgICBfdGhpczIud3JhcFMgPSB3cmFwUztcbiAgICBfdGhpczIud3JhcFQgPSB3cmFwVDtcbiAgICBfdGhpczIubWFnRmlsdGVyID0gbWFnRmlsdGVyO1xuICAgIF90aGlzMi5taW5GaWx0ZXIgPSBtaW5GaWx0ZXI7XG4gICAgX3RoaXMyLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xuICAgIF90aGlzMi5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgX3RoaXMyLmludGVybmFsRm9ybWF0ID0gbnVsbDtcbiAgICBfdGhpczIudHlwZSA9IHR5cGU7XG4gICAgX3RoaXMyLm9mZnNldCA9IG5ldyBWZWN0b3IyKDAsIDApO1xuICAgIF90aGlzMi5yZXBlYXQgPSBuZXcgVmVjdG9yMigxLCAxKTtcbiAgICBfdGhpczIuY2VudGVyID0gbmV3IFZlY3RvcjIoMCwgMCk7XG4gICAgX3RoaXMyLnJvdGF0aW9uID0gMDtcbiAgICBfdGhpczIubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgX3RoaXMyLm1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XG4gICAgX3RoaXMyLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG4gICAgX3RoaXMyLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcbiAgICBfdGhpczIuZmxpcFkgPSB0cnVlO1xuICAgIF90aGlzMi51bnBhY2tBbGlnbm1lbnQgPSA0OyAvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcbiAgICAvLyBWYWx1ZXMgb2YgZW5jb2RpbmcgIT09IFRIUkVFLkxpbmVhckVuY29kaW5nIG9ubHkgc3VwcG9ydGVkIG9uIG1hcCwgZW52TWFwIGFuZCBlbWlzc2l2ZU1hcC5cbiAgICAvL1xuICAgIC8vIEFsc28gY2hhbmdpbmcgdGhlIGVuY29kaW5nIGFmdGVyIGFscmVhZHkgdXNlZCBieSBhIE1hdGVyaWFsIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgbWFrZSB0aGUgTWF0ZXJpYWxcbiAgICAvLyB1cGRhdGUuIFlvdSBuZWVkIHRvIGV4cGxpY2l0bHkgY2FsbCBNYXRlcmlhbC5uZWVkc1VwZGF0ZSB0byB0cmlnZ2VyIGl0IHRvIHJlY29tcGlsZS5cblxuICAgIF90aGlzMi5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIF90aGlzMi51c2VyRGF0YSA9IHt9O1xuICAgIF90aGlzMi52ZXJzaW9uID0gMDtcbiAgICBfdGhpczIub25VcGRhdGUgPSBudWxsO1xuICAgIF90aGlzMi5pc1JlbmRlclRhcmdldFRleHR1cmUgPSBmYWxzZTsgLy8gaW5kaWNhdGVzIHdoZXRoZXIgYSB0ZXh0dXJlIGJlbG9uZ3MgdG8gYSByZW5kZXIgdGFyZ2V0IG9yIG5vdFxuXG4gICAgX3RoaXMyLm5lZWRzUE1SRU1VcGRhdGUgPSBmYWxzZTsgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyB0ZXh0dXJlIHNob3VsZCBiZSBwcm9jZXNzZWQgYnkgUE1SRU1HZW5lcmF0b3Igb3Igbm90IChvbmx5IHJlbGV2YW50IGZvciByZW5kZXIgdGFyZ2V0IHRleHR1cmVzKVxuXG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXh0dXJlLCBbe1xuICAgIGtleTogXCJpbWFnZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmRhdGE7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5zb3VyY2UuZGF0YSA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVNYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTWF0cml4KCkge1xuICAgICAgdGhpcy5tYXRyaXguc2V0VXZUcmFuc2Zvcm0odGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSwgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSwgdGhpcy5yb3RhdGlvbiwgdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZS5zb3VyY2U7XG4gICAgICB0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSgwKTtcbiAgICAgIHRoaXMubWFwcGluZyA9IHNvdXJjZS5tYXBwaW5nO1xuICAgICAgdGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcbiAgICAgIHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG4gICAgICB0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XG4gICAgICB0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XG4gICAgICB0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcbiAgICAgIHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcbiAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBzb3VyY2UuaW50ZXJuYWxGb3JtYXQ7XG4gICAgICB0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgICAgIHRoaXMub2Zmc2V0LmNvcHkoc291cmNlLm9mZnNldCk7XG4gICAgICB0aGlzLnJlcGVhdC5jb3B5KHNvdXJjZS5yZXBlYXQpO1xuICAgICAgdGhpcy5jZW50ZXIuY29weShzb3VyY2UuY2VudGVyKTtcbiAgICAgIHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG4gICAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcbiAgICAgIHRoaXMubWF0cml4LmNvcHkoc291cmNlLm1hdHJpeCk7XG4gICAgICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG4gICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgIHRoaXMuZmxpcFkgPSBzb3VyY2UuZmxpcFk7XG4gICAgICB0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XG4gICAgICB0aGlzLmVuY29kaW5nID0gc291cmNlLmVuY29kaW5nO1xuICAgICAgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc291cmNlLnVzZXJEYXRhKSk7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKG1ldGEpIHtcbiAgICAgIHZhciBpc1Jvb3RPYmplY3QgPSBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnO1xuXG4gICAgICBpZiAoIWlzUm9vdE9iamVjdCAmJiBtZXRhLnRleHR1cmVzW3RoaXMudXVpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbWV0YS50ZXh0dXJlc1t0aGlzLnV1aWRdO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHZlcnNpb246IDQuNSxcbiAgICAgICAgICB0eXBlOiAnVGV4dHVyZScsXG4gICAgICAgICAgZ2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG4gICAgICAgIH0sXG4gICAgICAgIHV1aWQ6IHRoaXMudXVpZCxcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBpbWFnZTogdGhpcy5zb3VyY2UudG9KU09OKG1ldGEpLnV1aWQsXG4gICAgICAgIG1hcHBpbmc6IHRoaXMubWFwcGluZyxcbiAgICAgICAgcmVwZWF0OiBbdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueV0sXG4gICAgICAgIG9mZnNldDogW3RoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnldLFxuICAgICAgICBjZW50ZXI6IFt0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55XSxcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICAgIHdyYXA6IFt0aGlzLndyYXBTLCB0aGlzLndyYXBUXSxcbiAgICAgICAgZm9ybWF0OiB0aGlzLmZvcm1hdCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBlbmNvZGluZzogdGhpcy5lbmNvZGluZyxcbiAgICAgICAgbWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcbiAgICAgICAgbWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcbiAgICAgICAgYW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5LFxuICAgICAgICBmbGlwWTogdGhpcy5mbGlwWSxcbiAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogdGhpcy5wcmVtdWx0aXBseUFscGhhLFxuICAgICAgICB1bnBhY2tBbGlnbm1lbnQ6IHRoaXMudW5wYWNrQWxpZ25tZW50XG4gICAgICB9O1xuICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHRoaXMudXNlckRhdGEpICE9PSAne30nKSBvdXRwdXQudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXG4gICAgICBpZiAoIWlzUm9vdE9iamVjdCkge1xuICAgICAgICBtZXRhLnRleHR1cmVzW3RoaXMudXVpZF0gPSBvdXRwdXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6ICdkaXNwb3NlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybVV2XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zZm9ybVV2KHV2KSB7XG4gICAgICBpZiAodGhpcy5tYXBwaW5nICE9PSBVVk1hcHBpbmcpIHJldHVybiB1djtcbiAgICAgIHV2LmFwcGx5TWF0cml4Myh0aGlzLm1hdHJpeCk7XG5cbiAgICAgIGlmICh1di54IDwgMCB8fCB1di54ID4gMSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMud3JhcFMpIHtcbiAgICAgICAgICBjYXNlIFJlcGVhdFdyYXBwaW5nOlxuICAgICAgICAgICAgdXYueCA9IHV2LnggLSBNYXRoLmZsb29yKHV2LngpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XG4gICAgICAgICAgICB1di54ID0gdXYueCA8IDAgPyAwIDogMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKE1hdGguZmxvb3IodXYueCkgJSAyKSA9PT0gMSkge1xuICAgICAgICAgICAgICB1di54ID0gTWF0aC5jZWlsKHV2LngpIC0gdXYueDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHV2LnggPSB1di54IC0gTWF0aC5mbG9vcih1di54KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHV2LnkgPCAwIHx8IHV2LnkgPiAxKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy53cmFwVCkge1xuICAgICAgICAgIGNhc2UgUmVwZWF0V3JhcHBpbmc6XG4gICAgICAgICAgICB1di55ID0gdXYueSAtIE1hdGguZmxvb3IodXYueSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcbiAgICAgICAgICAgIHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoTWF0aC5mbG9vcih1di55KSAlIDIpID09PSAxKSB7XG4gICAgICAgICAgICAgIHV2LnkgPSBNYXRoLmNlaWwodXYueSkgLSB1di55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKHV2LnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mbGlwWSkge1xuICAgICAgICB1di55ID0gMSAtIHV2Lnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1djtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmVlZHNVcGRhdGVcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgICB0aGlzLnNvdXJjZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHR1cmU7XG59KEV2ZW50RGlzcGF0Y2hlcik7XG5cblRleHR1cmUuREVGQVVMVF9JTUFHRSA9IG51bGw7XG5UZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFVWTWFwcGluZztcblxudmFyIFZlY3RvcjQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TeW1ib2wkaXRlcmF0b3IzKSB7XG4gIGZ1bmN0aW9uIFZlY3RvcjQoKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIHcgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVjdG9yNCk7XG5cbiAgICB0aGlzLmlzVmVjdG9yNCA9IHRydWU7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy53ID0gdztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWZWN0b3I0LCBbe1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuejtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnogPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy53O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMudyA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHgsIHksIHosIHcpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy56ID0gejtcbiAgICAgIHRoaXMudyA9IHc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNjYWxhcihzY2FsYXIpIHtcbiAgICAgIHRoaXMueCA9IHNjYWxhcjtcbiAgICAgIHRoaXMueSA9IHNjYWxhcjtcbiAgICAgIHRoaXMueiA9IHNjYWxhcjtcbiAgICAgIHRoaXMudyA9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFgoeCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFkoeSkge1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRaXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFooeikge1xuICAgICAgdGhpcy56ID0gejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRXXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFcodykge1xuICAgICAgdGhpcy53ID0gdztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDb21wb25lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29tcG9uZW50KGluZGV4LCB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMueSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aGlzLnogPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhpcy53ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbXBvbmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21wb25lbnQoaW5kZXgpIHtcbiAgICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB0aGlzLng7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiB0aGlzLnk7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiB0aGlzLno7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiB0aGlzLnc7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHYpIHtcbiAgICAgIHRoaXMueCA9IHYueDtcbiAgICAgIHRoaXMueSA9IHYueTtcbiAgICAgIHRoaXMueiA9IHYuejtcbiAgICAgIHRoaXMudyA9IHYudyAhPT0gdW5kZWZpbmVkID8gdi53IDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKHYsIHcpIHtcbiAgICAgIGlmICh3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFZlY3RvcnModiwgdyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueCArPSB2Lng7XG4gICAgICB0aGlzLnkgKz0gdi55O1xuICAgICAgdGhpcy56ICs9IHYuejtcbiAgICAgIHRoaXMudyArPSB2Lnc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNjYWxhcihzKSB7XG4gICAgICB0aGlzLnggKz0gcztcbiAgICAgIHRoaXMueSArPSBzO1xuICAgICAgdGhpcy56ICs9IHM7XG4gICAgICB0aGlzLncgKz0gcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRWZWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFZlY3RvcnMoYSwgYikge1xuICAgICAgdGhpcy54ID0gYS54ICsgYi54O1xuICAgICAgdGhpcy55ID0gYS55ICsgYi55O1xuICAgICAgdGhpcy56ID0gYS56ICsgYi56O1xuICAgICAgdGhpcy53ID0gYS53ICsgYi53O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFNjYWxlZFZlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTY2FsZWRWZWN0b3Iodiwgcykge1xuICAgICAgdGhpcy54ICs9IHYueCAqIHM7XG4gICAgICB0aGlzLnkgKz0gdi55ICogcztcbiAgICAgIHRoaXMueiArPSB2LnogKiBzO1xuICAgICAgdGhpcy53ICs9IHYudyAqIHM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ViXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1Yih2LCB3KSB7XG4gICAgICBpZiAodyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKHYsIHcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgdGhpcy55IC09IHYueTtcbiAgICAgIHRoaXMueiAtPSB2Lno7XG4gICAgICB0aGlzLncgLT0gdi53O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN1YlNjYWxhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJTY2FsYXIocykge1xuICAgICAgdGhpcy54IC09IHM7XG4gICAgICB0aGlzLnkgLT0gcztcbiAgICAgIHRoaXMueiAtPSBzO1xuICAgICAgdGhpcy53IC09IHM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ViVmVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJWZWN0b3JzKGEsIGIpIHtcbiAgICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICAgIHRoaXMueSA9IGEueSAtIGIueTtcbiAgICAgIHRoaXMueiA9IGEueiAtIGIuejtcbiAgICAgIHRoaXMudyA9IGEudyAtIGIudztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtdWx0aXBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseSh2KSB7XG4gICAgICB0aGlzLnggKj0gdi54O1xuICAgICAgdGhpcy55ICo9IHYueTtcbiAgICAgIHRoaXMueiAqPSB2Lno7XG4gICAgICB0aGlzLncgKj0gdi53O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5U2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xuICAgICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgICB0aGlzLnogKj0gc2NhbGFyO1xuICAgICAgdGhpcy53ICo9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseU1hdHJpeDRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlNYXRyaXg0KG0pIHtcbiAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgICAgeiA9IHRoaXMueixcbiAgICAgICAgICB3ID0gdGhpcy53O1xuICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuICAgICAgdGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6ICsgZVsxMl0gKiB3O1xuICAgICAgdGhpcy55ID0gZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gKiB6ICsgZVsxM10gKiB3O1xuICAgICAgdGhpcy56ID0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdICogdztcbiAgICAgIHRoaXMudyA9IGVbM10gKiB4ICsgZVs3XSAqIHkgKyBlWzExXSAqIHogKyBlWzE1XSAqIHc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGl2aWRlU2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpdmlkZVNjYWxhcihzY2FsYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzY2FsYXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbihxKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG4gICAgICAvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuICAgICAgdGhpcy53ID0gMiAqIE1hdGguYWNvcyhxLncpO1xuICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMSAtIHEudyAqIHEudyk7XG5cbiAgICAgIGlmIChzIDwgMC4wMDAxKSB7XG4gICAgICAgIHRoaXMueCA9IDE7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMueiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggPSBxLnggLyBzO1xuICAgICAgICB0aGlzLnkgPSBxLnkgLyBzO1xuICAgICAgICB0aGlzLnogPSBxLnogLyBzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeChtKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cbiAgICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG4gICAgICB2YXIgYW5nbGUsIHgsIHksIHo7IC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XG5cbiAgICAgIHZhciBlcHNpbG9uID0gMC4wMSxcbiAgICAgICAgICAvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xuICAgICAgZXBzaWxvbjIgPSAwLjEsXG4gICAgICAgICAgLy8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcbiAgICAgIHRlID0gbS5lbGVtZW50cyxcbiAgICAgICAgICBtMTEgPSB0ZVswXSxcbiAgICAgICAgICBtMTIgPSB0ZVs0XSxcbiAgICAgICAgICBtMTMgPSB0ZVs4XSxcbiAgICAgICAgICBtMjEgPSB0ZVsxXSxcbiAgICAgICAgICBtMjIgPSB0ZVs1XSxcbiAgICAgICAgICBtMjMgPSB0ZVs5XSxcbiAgICAgICAgICBtMzEgPSB0ZVsyXSxcbiAgICAgICAgICBtMzIgPSB0ZVs2XSxcbiAgICAgICAgICBtMzMgPSB0ZVsxMF07XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMTIgLSBtMjEpIDwgZXBzaWxvbiAmJiBNYXRoLmFicyhtMTMgLSBtMzEpIDwgZXBzaWxvbiAmJiBNYXRoLmFicyhtMjMgLSBtMzIpIDwgZXBzaWxvbikge1xuICAgICAgICAvLyBzaW5ndWxhcml0eSBmb3VuZFxuICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXG4gICAgICAgIC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcbiAgICAgICAgaWYgKE1hdGguYWJzKG0xMiArIG0yMSkgPCBlcHNpbG9uMiAmJiBNYXRoLmFicyhtMTMgKyBtMzEpIDwgZXBzaWxvbjIgJiYgTWF0aC5hYnMobTIzICsgbTMyKSA8IGVwc2lsb24yICYmIE1hdGguYWJzKG0xMSArIG0yMiArIG0zMyAtIDMpIDwgZXBzaWxvbjIpIHtcbiAgICAgICAgICAvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcbiAgICAgICAgICB0aGlzLnNldCgxLCAwLCAwLCAwKTtcbiAgICAgICAgICByZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcbiAgICAgICAgfSAvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxuXG5cbiAgICAgICAgYW5nbGUgPSBNYXRoLlBJO1xuICAgICAgICB2YXIgeHggPSAobTExICsgMSkgLyAyO1xuICAgICAgICB2YXIgeXkgPSAobTIyICsgMSkgLyAyO1xuICAgICAgICB2YXIgenogPSAobTMzICsgMSkgLyAyO1xuICAgICAgICB2YXIgeHkgPSAobTEyICsgbTIxKSAvIDQ7XG4gICAgICAgIHZhciB4eiA9IChtMTMgKyBtMzEpIC8gNDtcbiAgICAgICAgdmFyIHl6ID0gKG0yMyArIG0zMikgLyA0O1xuXG4gICAgICAgIGlmICh4eCA+IHl5ICYmIHh4ID4genopIHtcbiAgICAgICAgICAvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxuICAgICAgICAgIGlmICh4eCA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgeSA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgICAgeiA9IDAuNzA3MTA2NzgxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gTWF0aC5zcXJ0KHh4KTtcbiAgICAgICAgICAgIHkgPSB4eSAvIHg7XG4gICAgICAgICAgICB6ID0geHogLyB4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh5eSA+IHp6KSB7XG4gICAgICAgICAgLy8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cbiAgICAgICAgICBpZiAoeXkgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICB4ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgICAgIHogPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IE1hdGguc3FydCh5eSk7XG4gICAgICAgICAgICB4ID0geHkgLyB5O1xuICAgICAgICAgICAgeiA9IHl6IC8geTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbTMzIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm0gc28gYmFzZSByZXN1bHQgb24gdGhpc1xuICAgICAgICAgIGlmICh6eiA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHggPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICAgIHkgPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICAgIHogPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB6ID0gTWF0aC5zcXJ0KHp6KTtcbiAgICAgICAgICAgIHggPSB4eiAvIHo7XG4gICAgICAgICAgICB5ID0geXogLyB6O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0KHgsIHksIHosIGFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG4gICAgICB9IC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcblxuXG4gICAgICB2YXIgcyA9IE1hdGguc3FydCgobTMyIC0gbTIzKSAqIChtMzIgLSBtMjMpICsgKG0xMyAtIG0zMSkgKiAobTEzIC0gbTMxKSArIChtMjEgLSBtMTIpICogKG0yMSAtIG0xMikpOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG4gICAgICBpZiAoTWF0aC5hYnMocykgPCAwLjAwMSkgcyA9IDE7IC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcbiAgICAgIC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxuXG4gICAgICB0aGlzLnggPSAobTMyIC0gbTIzKSAvIHM7XG4gICAgICB0aGlzLnkgPSAobTEzIC0gbTMxKSAvIHM7XG4gICAgICB0aGlzLnogPSAobTIxIC0gbTEyKSAvIHM7XG4gICAgICB0aGlzLncgPSBNYXRoLmFjb3MoKG0xMSArIG0yMiArIG0zMyAtIDEpIC8gMik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1pbih2KSB7XG4gICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIHYueCk7XG4gICAgICB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIHYueSk7XG4gICAgICB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIHYueik7XG4gICAgICB0aGlzLncgPSBNYXRoLm1pbih0aGlzLncsIHYudyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heCh2KSB7XG4gICAgICB0aGlzLnggPSBNYXRoLm1heCh0aGlzLngsIHYueCk7XG4gICAgICB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIHYueSk7XG4gICAgICB0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIHYueik7XG4gICAgICB0aGlzLncgPSBNYXRoLm1heCh0aGlzLncsIHYudyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhbXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xhbXAobWluLCBtYXgpIHtcbiAgICAgIC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXG4gICAgICB0aGlzLnggPSBNYXRoLm1heChtaW4ueCwgTWF0aC5taW4obWF4LngsIHRoaXMueCkpO1xuICAgICAgdGhpcy55ID0gTWF0aC5tYXgobWluLnksIE1hdGgubWluKG1heC55LCB0aGlzLnkpKTtcbiAgICAgIHRoaXMueiA9IE1hdGgubWF4KG1pbi56LCBNYXRoLm1pbihtYXgueiwgdGhpcy56KSk7XG4gICAgICB0aGlzLncgPSBNYXRoLm1heChtaW4udywgTWF0aC5taW4obWF4LncsIHRoaXMudykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsYW1wU2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy54KSk7XG4gICAgICB0aGlzLnkgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy55KSk7XG4gICAgICB0aGlzLnogPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy56KSk7XG4gICAgICB0aGlzLncgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy53KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhbXBMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xhbXBMZW5ndGgobWluLCBtYXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKGxlbmd0aCB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgbGVuZ3RoKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbG9vclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbG9vcigpIHtcbiAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIHRoaXMueiA9IE1hdGguZmxvb3IodGhpcy56KTtcbiAgICAgIHRoaXMudyA9IE1hdGguZmxvb3IodGhpcy53KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjZWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlaWwoKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuICAgICAgdGhpcy56ID0gTWF0aC5jZWlsKHRoaXMueik7XG4gICAgICB0aGlzLncgPSBNYXRoLmNlaWwodGhpcy53KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZCgpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KTtcbiAgICAgIHRoaXMueiA9IE1hdGgucm91bmQodGhpcy56KTtcbiAgICAgIHRoaXMudyA9IE1hdGgucm91bmQodGhpcy53KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3VuZFRvWmVyb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZFRvWmVybygpIHtcbiAgICAgIHRoaXMueCA9IHRoaXMueCA8IDAgPyBNYXRoLmNlaWwodGhpcy54KSA6IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IHRoaXMueSA8IDAgPyBNYXRoLmNlaWwodGhpcy55KSA6IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIHRoaXMueiA9IHRoaXMueiA8IDAgPyBNYXRoLmNlaWwodGhpcy56KSA6IE1hdGguZmxvb3IodGhpcy56KTtcbiAgICAgIHRoaXMudyA9IHRoaXMudyA8IDAgPyBNYXRoLmNlaWwodGhpcy53KSA6IE1hdGguZmxvb3IodGhpcy53KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJuZWdhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVnYXRlKCkge1xuICAgICAgdGhpcy54ID0gLXRoaXMueDtcbiAgICAgIHRoaXMueSA9IC10aGlzLnk7XG4gICAgICB0aGlzLnogPSAtdGhpcy56O1xuICAgICAgdGhpcy53ID0gLXRoaXMudztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG90KHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFNxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aFNxKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFuaGF0dGFuTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmhhdHRhbkxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KSArIE1hdGguYWJzKHRoaXMueikgKyBNYXRoLmFicyh0aGlzLncpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXJwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlcnAodiwgYWxwaGEpIHtcbiAgICAgIHRoaXMueCArPSAodi54IC0gdGhpcy54KSAqIGFscGhhO1xuICAgICAgdGhpcy55ICs9ICh2LnkgLSB0aGlzLnkpICogYWxwaGE7XG4gICAgICB0aGlzLnogKz0gKHYueiAtIHRoaXMueikgKiBhbHBoYTtcbiAgICAgIHRoaXMudyArPSAodi53IC0gdGhpcy53KSAqIGFscGhhO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlcnBWZWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcbiAgICAgIHRoaXMueCA9IHYxLnggKyAodjIueCAtIHYxLngpICogYWxwaGE7XG4gICAgICB0aGlzLnkgPSB2MS55ICsgKHYyLnkgLSB2MS55KSAqIGFscGhhO1xuICAgICAgdGhpcy56ID0gdjEueiArICh2Mi56IC0gdjEueikgKiBhbHBoYTtcbiAgICAgIHRoaXMudyA9IHYxLncgKyAodjIudyAtIHYxLncpICogYWxwaGE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh2KSB7XG4gICAgICByZXR1cm4gdi54ID09PSB0aGlzLnggJiYgdi55ID09PSB0aGlzLnkgJiYgdi56ID09PSB0aGlzLnogJiYgdi53ID09PSB0aGlzLnc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB0aGlzLnggPSBhcnJheVtvZmZzZXRdO1xuICAgICAgdGhpcy55ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG4gICAgICB0aGlzLnogPSBhcnJheVtvZmZzZXQgKyAyXTtcbiAgICAgIHRoaXMudyA9IGFycmF5W29mZnNldCArIDNdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IHRoaXMueDtcbiAgICAgIGFycmF5W29mZnNldCArIDFdID0gdGhpcy55O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLno7XG4gICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IHRoaXMudztcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUJ1ZmZlckF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yNDogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WChpbmRleCk7XG4gICAgICB0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WShpbmRleCk7XG4gICAgICB0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WihpbmRleCk7XG4gICAgICB0aGlzLncgPSBhdHRyaWJ1dGUuZ2V0VyhpbmRleCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZG9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmRvbSgpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICB0aGlzLnkgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgdGhpcy56ID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIHRoaXMudyA9IE1hdGgucmFuZG9tKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IF9TeW1ib2wkaXRlcmF0b3IzLFxuICAgIHZhbHVlOiAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiB2YWx1ZSQoX2NvbnRleHQ0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueDtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy56O1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudztcblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHZhbHVlLCB0aGlzKTtcbiAgICB9KVxuICB9XSk7XG5cbiAgcmV0dXJuIFZlY3RvcjQ7XG59KFN5bWJvbC5pdGVyYXRvcik7XG4vKlxuIEluIG9wdGlvbnMsIHdlIGNhbiBzcGVjaWZ5OlxuICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxuICogZGVwdGhCdWZmZXIvc3RlbmNpbEJ1ZmZlcjogQm9vbGVhbnMgdG8gaW5kaWNhdGUgaWYgd2Ugc2hvdWxkIGdlbmVyYXRlIHRoZXNlIGJ1ZmZlcnNcbiovXG5cblxudmFyIFdlYkdMUmVuZGVyVGFyZ2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnREaXNwYXRjaGVyMikge1xuICBfaW5oZXJpdHMoV2ViR0xSZW5kZXJUYXJnZXQsIF9FdmVudERpc3BhdGNoZXIyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihXZWJHTFJlbmRlclRhcmdldCk7XG5cbiAgZnVuY3Rpb24gV2ViR0xSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xSZW5kZXJUYXJnZXQpO1xuXG4gICAgX3RoaXMzID0gX3N1cGVyMi5jYWxsKHRoaXMpO1xuICAgIF90aGlzMy5pc1dlYkdMUmVuZGVyVGFyZ2V0ID0gdHJ1ZTtcbiAgICBfdGhpczMud2lkdGggPSB3aWR0aDtcbiAgICBfdGhpczMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIF90aGlzMy5kZXB0aCA9IDE7XG4gICAgX3RoaXMzLnNjaXNzb3IgPSBuZXcgVmVjdG9yNCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBfdGhpczMuc2Npc3NvclRlc3QgPSBmYWxzZTtcbiAgICBfdGhpczMudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgaW1hZ2UgPSB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGRlcHRoOiAxXG4gICAgfTtcbiAgICBfdGhpczMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKGltYWdlLCBvcHRpb25zLm1hcHBpbmcsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5LCBvcHRpb25zLmVuY29kaW5nKTtcbiAgICBfdGhpczMudGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuICAgIF90aGlzMy50ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgX3RoaXMzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG4gICAgX3RoaXMzLnRleHR1cmUuaW50ZXJuYWxGb3JtYXQgPSBvcHRpb25zLmludGVybmFsRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmludGVybmFsRm9ybWF0IDogbnVsbDtcbiAgICBfdGhpczMudGV4dHVyZS5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG4gICAgX3RoaXMzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XG4gICAgX3RoaXMzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IGZhbHNlO1xuICAgIF90aGlzMy5kZXB0aFRleHR1cmUgPSBvcHRpb25zLmRlcHRoVGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aFRleHR1cmUgOiBudWxsO1xuICAgIF90aGlzMy5zYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnNhbXBsZXMgOiAwO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViR0xSZW5kZXJUYXJnZXQsIFt7XG4gICAga2V5OiBcInNldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG5cbiAgICAgIGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0IHx8IHRoaXMuZGVwdGggIT09IGRlcHRoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy50ZXh0dXJlLmltYWdlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudGV4dHVyZS5pbWFnZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMudGV4dHVyZS5pbWFnZS5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3cG9ydC5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLnNjaXNzb3Iuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG4gICAgICB0aGlzLmRlcHRoID0gc291cmNlLmRlcHRoO1xuICAgICAgdGhpcy52aWV3cG9ydC5jb3B5KHNvdXJjZS52aWV3cG9ydCk7XG4gICAgICB0aGlzLnRleHR1cmUgPSBzb3VyY2UudGV4dHVyZS5jbG9uZSgpO1xuICAgICAgdGhpcy50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7IC8vIGVuc3VyZSBpbWFnZSBvYmplY3QgaXMgbm90IHNoYXJlZCwgc2VlICMyMDMyOFxuXG4gICAgICB2YXIgaW1hZ2UgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UudGV4dHVyZS5pbWFnZSk7XG4gICAgICB0aGlzLnRleHR1cmUuc291cmNlID0gbmV3IFNvdXJjZShpbWFnZSk7XG4gICAgICB0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuICAgICAgdGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XG4gICAgICBpZiAoc291cmNlLmRlcHRoVGV4dHVyZSAhPT0gbnVsbCkgdGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlLmNsb25lKCk7XG4gICAgICB0aGlzLnNhbXBsZXMgPSBzb3VyY2Uuc2FtcGxlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnZGlzcG9zZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJHTFJlbmRlclRhcmdldDtcbn0oRXZlbnREaXNwYXRjaGVyKTtcblxudmFyIERhdGFBcnJheVRleHR1cmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UZXh0dXJlKSB7XG4gIF9pbmhlcml0cyhEYXRhQXJyYXlUZXh0dXJlLCBfVGV4dHVyZSk7XG5cbiAgdmFyIF9zdXBlcjMgPSBfY3JlYXRlU3VwZXIoRGF0YUFycmF5VGV4dHVyZSk7XG5cbiAgZnVuY3Rpb24gRGF0YUFycmF5VGV4dHVyZSgpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgdmFyIHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgdmFyIGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFBcnJheVRleHR1cmUpO1xuXG4gICAgX3RoaXM0ID0gX3N1cGVyMy5jYWxsKHRoaXMsIG51bGwpO1xuICAgIF90aGlzNC5pc0RhdGFBcnJheVRleHR1cmUgPSB0cnVlO1xuICAgIF90aGlzNC5pbWFnZSA9IHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGRlcHRoOiBkZXB0aFxuICAgIH07XG4gICAgX3RoaXM0Lm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG4gICAgX3RoaXM0Lm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG4gICAgX3RoaXM0LndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICBfdGhpczQuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgX3RoaXM0LmZsaXBZID0gZmFsc2U7XG4gICAgX3RoaXM0LnVucGFja0FsaWdubWVudCA9IDE7XG4gICAgcmV0dXJuIF90aGlzNDtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGF0YUFycmF5VGV4dHVyZSk7XG59KFRleHR1cmUpO1xuXG52YXIgV2ViR0xBcnJheVJlbmRlclRhcmdldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1dlYkdMUmVuZGVyVGFyZ2V0KSB7XG4gIF9pbmhlcml0cyhXZWJHTEFycmF5UmVuZGVyVGFyZ2V0LCBfV2ViR0xSZW5kZXJUYXJnZXQpO1xuXG4gIHZhciBfc3VwZXI0ID0gX2NyZWF0ZVN1cGVyKFdlYkdMQXJyYXlSZW5kZXJUYXJnZXQpO1xuXG4gIGZ1bmN0aW9uIFdlYkdMQXJyYXlSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgZGVwdGgpIHtcbiAgICB2YXIgX3RoaXM1O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMQXJyYXlSZW5kZXJUYXJnZXQpO1xuXG4gICAgX3RoaXM1ID0gX3N1cGVyNC5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgIF90aGlzNS5pc1dlYkdMQXJyYXlSZW5kZXJUYXJnZXQgPSB0cnVlO1xuICAgIF90aGlzNS5kZXB0aCA9IGRlcHRoO1xuICAgIF90aGlzNS50ZXh0dXJlID0gbmV3IERhdGFBcnJheVRleHR1cmUobnVsbCwgd2lkdGgsIGhlaWdodCwgZGVwdGgpO1xuICAgIF90aGlzNS50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoV2ViR0xBcnJheVJlbmRlclRhcmdldCk7XG59KFdlYkdMUmVuZGVyVGFyZ2V0KTtcblxudmFyIERhdGEzRFRleHR1cmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UZXh0dXJlMikge1xuICBfaW5oZXJpdHMoRGF0YTNEVGV4dHVyZSwgX1RleHR1cmUyKTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihEYXRhM0RUZXh0dXJlKTtcblxuICBmdW5jdGlvbiBEYXRhM0RUZXh0dXJlKCkge1xuICAgIHZhciBfdGhpczY7XG5cbiAgICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YTNEVGV4dHVyZSk7XG5cbiAgICAvLyBXZSdyZSBnb2luZyB0byBhZGQgLnNldFhYWCgpIG1ldGhvZHMgZm9yIHNldHRpbmcgcHJvcGVydGllcyBsYXRlci5cbiAgICAvLyBVc2VycyBjYW4gc3RpbGwgc2V0IGluIERhdGFUZXh0dXJlM0QgZGlyZWN0bHkuXG4gICAgLy9cbiAgICAvL1x0Y29uc3QgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZTNEKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCApO1xuICAgIC8vIFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gMTY7XG4gICAgLy9cbiAgICAvLyBTZWUgIzE0ODM5XG4gICAgX3RoaXM2ID0gX3N1cGVyNS5jYWxsKHRoaXMsIG51bGwpO1xuICAgIF90aGlzNi5pc0RhdGEzRFRleHR1cmUgPSB0cnVlO1xuICAgIF90aGlzNi5pbWFnZSA9IHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGRlcHRoOiBkZXB0aFxuICAgIH07XG4gICAgX3RoaXM2Lm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG4gICAgX3RoaXM2Lm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG4gICAgX3RoaXM2LndyYXBSID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICBfdGhpczYuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgX3RoaXM2LmZsaXBZID0gZmFsc2U7XG4gICAgX3RoaXM2LnVucGFja0FsaWdubWVudCA9IDE7XG4gICAgcmV0dXJuIF90aGlzNjtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGF0YTNEVGV4dHVyZSk7XG59KFRleHR1cmUpO1xuXG52YXIgV2ViR0wzRFJlbmRlclRhcmdldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1dlYkdMUmVuZGVyVGFyZ2V0Mikge1xuICBfaW5oZXJpdHMoV2ViR0wzRFJlbmRlclRhcmdldCwgX1dlYkdMUmVuZGVyVGFyZ2V0Mik7XG5cbiAgdmFyIF9zdXBlcjYgPSBfY3JlYXRlU3VwZXIoV2ViR0wzRFJlbmRlclRhcmdldCk7XG5cbiAgZnVuY3Rpb24gV2ViR0wzRFJlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCBkZXB0aCkge1xuICAgIHZhciBfdGhpczc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0wzRFJlbmRlclRhcmdldCk7XG5cbiAgICBfdGhpczcgPSBfc3VwZXI2LmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCk7XG4gICAgX3RoaXM3LmlzV2ViR0wzRFJlbmRlclRhcmdldCA9IHRydWU7XG4gICAgX3RoaXM3LmRlcHRoID0gZGVwdGg7XG4gICAgX3RoaXM3LnRleHR1cmUgPSBuZXcgRGF0YTNEVGV4dHVyZShudWxsLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCk7XG4gICAgX3RoaXM3LnRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhXZWJHTDNEUmVuZGVyVGFyZ2V0KTtcbn0oV2ViR0xSZW5kZXJUYXJnZXQpO1xuXG52YXIgV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9XZWJHTFJlbmRlclRhcmdldDMpIHtcbiAgX2luaGVyaXRzKFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzLCBfV2ViR0xSZW5kZXJUYXJnZXQzKTtcblxuICB2YXIgX3N1cGVyNyA9IF9jcmVhdGVTdXBlcihXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyk7XG5cbiAgZnVuY3Rpb24gV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMod2lkdGgsIGhlaWdodCwgY291bnQpIHtcbiAgICB2YXIgX3RoaXM4O1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzKTtcblxuICAgIF90aGlzOCA9IF9zdXBlcjcuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICBfdGhpczguaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9IHRydWU7XG4gICAgdmFyIHRleHR1cmUgPSBfdGhpczgudGV4dHVyZTtcbiAgICBfdGhpczgudGV4dHVyZSA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgY291bnQ7IF9pNysrKSB7XG4gICAgICBfdGhpczgudGV4dHVyZVtfaTddID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgICAgX3RoaXM4LnRleHR1cmVbX2k3XS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpczg7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMsIFt7XG4gICAga2V5OiBcInNldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG5cbiAgICAgIGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0IHx8IHRoaXMuZGVwdGggIT09IGRlcHRoKSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcblxuICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBpbCA9IHRoaXMudGV4dHVyZS5sZW5ndGg7IF9pOCA8IGlsOyBfaTgrKykge1xuICAgICAgICAgIHRoaXMudGV4dHVyZVtfaThdLmltYWdlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgdGhpcy50ZXh0dXJlW19pOF0uaW1hZ2UuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIHRoaXMudGV4dHVyZVtfaThdLmltYWdlLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3cG9ydC5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLnNjaXNzb3Iuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcbiAgICAgIHRoaXMuZGVwdGggPSBzb3VyY2UuZGVwdGg7XG4gICAgICB0aGlzLnZpZXdwb3J0LnNldCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLnNjaXNzb3Iuc2V0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuZGVwdGhCdWZmZXIgPSBzb3VyY2UuZGVwdGhCdWZmZXI7XG4gICAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcbiAgICAgIGlmIChzb3VyY2UuZGVwdGhUZXh0dXJlICE9PSBudWxsKSB0aGlzLmRlcHRoVGV4dHVyZSA9IHNvdXJjZS5kZXB0aFRleHR1cmUuY2xvbmUoKTtcbiAgICAgIHRoaXMudGV4dHVyZS5sZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTkgPSAwLCBpbCA9IHNvdXJjZS50ZXh0dXJlLmxlbmd0aDsgX2k5IDwgaWw7IF9pOSsrKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZVtfaTldID0gc291cmNlLnRleHR1cmVbX2k5XS5jbG9uZSgpO1xuICAgICAgICB0aGlzLnRleHR1cmVbX2k5XS5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHM7XG59KFdlYkdMUmVuZGVyVGFyZ2V0KTtcblxudmFyIFF1YXRlcm5pb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TeW1ib2wkaXRlcmF0b3I0KSB7XG4gIGZ1bmN0aW9uIFF1YXRlcm5pb24oKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIHcgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVhdGVybmlvbik7XG5cbiAgICB0aGlzLmlzUXVhdGVybmlvbiA9IHRydWU7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5feiA9IHo7XG4gICAgdGhpcy5fdyA9IHc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUXVhdGVybmlvbiwgW3tcbiAgICBrZXk6IFwieFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5feCA9IHZhbHVlO1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcblxuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ6XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fejtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl96ID0gdmFsdWU7XG5cbiAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fdyA9IHZhbHVlO1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoeCwgeSwgeiwgdykge1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIHRoaXMuX3ogPSB6O1xuICAgICAgdGhpcy5fdyA9IHc7XG5cbiAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkocXVhdGVybmlvbikge1xuICAgICAgdGhpcy5feCA9IHF1YXRlcm5pb24ueDtcbiAgICAgIHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XG4gICAgICB0aGlzLl96ID0gcXVhdGVybmlvbi56O1xuICAgICAgdGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbUV1bGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21FdWxlcihldWxlciwgdXBkYXRlKSB7XG4gICAgICBpZiAoIShldWxlciAmJiBldWxlci5pc0V1bGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IGV1bGVyLl94LFxuICAgICAgICAgIHkgPSBldWxlci5feSxcbiAgICAgICAgICB6ID0gZXVsZXIuX3osXG4gICAgICAgICAgb3JkZXIgPSBldWxlci5fb3JkZXI7IC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cbiAgICAgIC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXG4gICAgICAvL1x0Y29udGVudC9TcGluQ2FsYy5tXG5cbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgICAgIHZhciBjMSA9IGNvcyh4IC8gMik7XG4gICAgICB2YXIgYzIgPSBjb3MoeSAvIDIpO1xuICAgICAgdmFyIGMzID0gY29zKHogLyAyKTtcbiAgICAgIHZhciBzMSA9IHNpbih4IC8gMik7XG4gICAgICB2YXIgczIgPSBzaW4oeSAvIDIpO1xuICAgICAgdmFyIHMzID0gc2luKHogLyAyKTtcblxuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgICBjYXNlICdYWVonOlxuICAgICAgICAgIHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgIHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnWVhaJzpcbiAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1pYWSc6XG4gICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdaWVgnOlxuICAgICAgICAgIHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgdGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgICAgIHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnWVpYJzpcbiAgICAgICAgICB0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgICAgdGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgICB0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1haWSc6XG4gICAgICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICB0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICAgIHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cGRhdGUgIT09IGZhbHNlKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbUF4aXNBbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKSB7XG4gICAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gICAgICAvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuICAgICAgdmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMixcbiAgICAgICAgICBzID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcbiAgICAgIHRoaXMuX3ggPSBheGlzLnggKiBzO1xuICAgICAgdGhpcy5feSA9IGF4aXMueSAqIHM7XG4gICAgICB0aGlzLl96ID0gYXhpcy56ICogcztcbiAgICAgIHRoaXMuX3cgPSBNYXRoLmNvcyhoYWxmQW5nbGUpO1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tUm90YXRpb25NYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVJvdGF0aW9uTWF0cml4KG0pIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuICAgICAgdmFyIHRlID0gbS5lbGVtZW50cyxcbiAgICAgICAgICBtMTEgPSB0ZVswXSxcbiAgICAgICAgICBtMTIgPSB0ZVs0XSxcbiAgICAgICAgICBtMTMgPSB0ZVs4XSxcbiAgICAgICAgICBtMjEgPSB0ZVsxXSxcbiAgICAgICAgICBtMjIgPSB0ZVs1XSxcbiAgICAgICAgICBtMjMgPSB0ZVs5XSxcbiAgICAgICAgICBtMzEgPSB0ZVsyXSxcbiAgICAgICAgICBtMzIgPSB0ZVs2XSxcbiAgICAgICAgICBtMzMgPSB0ZVsxMF0sXG4gICAgICAgICAgdHJhY2UgPSBtMTEgKyBtMjIgKyBtMzM7XG5cbiAgICAgIGlmICh0cmFjZSA+IDApIHtcbiAgICAgICAgdmFyIHMgPSAwLjUgLyBNYXRoLnNxcnQodHJhY2UgKyAxLjApO1xuICAgICAgICB0aGlzLl93ID0gMC4yNSAvIHM7XG4gICAgICAgIHRoaXMuX3ggPSAobTMyIC0gbTIzKSAqIHM7XG4gICAgICAgIHRoaXMuX3kgPSAobTEzIC0gbTMxKSAqIHM7XG4gICAgICAgIHRoaXMuX3ogPSAobTIxIC0gbTEyKSAqIHM7XG4gICAgICB9IGVsc2UgaWYgKG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMpIHtcbiAgICAgICAgdmFyIF9zID0gMi4wICogTWF0aC5zcXJ0KDEuMCArIG0xMSAtIG0yMiAtIG0zMyk7XG5cbiAgICAgICAgdGhpcy5fdyA9IChtMzIgLSBtMjMpIC8gX3M7XG4gICAgICAgIHRoaXMuX3ggPSAwLjI1ICogX3M7XG4gICAgICAgIHRoaXMuX3kgPSAobTEyICsgbTIxKSAvIF9zO1xuICAgICAgICB0aGlzLl96ID0gKG0xMyArIG0zMSkgLyBfcztcbiAgICAgIH0gZWxzZSBpZiAobTIyID4gbTMzKSB7XG4gICAgICAgIHZhciBfczIgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcblxuICAgICAgICB0aGlzLl93ID0gKG0xMyAtIG0zMSkgLyBfczI7XG4gICAgICAgIHRoaXMuX3ggPSAobTEyICsgbTIxKSAvIF9zMjtcbiAgICAgICAgdGhpcy5feSA9IDAuMjUgKiBfczI7XG4gICAgICAgIHRoaXMuX3ogPSAobTIzICsgbTMyKSAvIF9zMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfczMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTMzIC0gbTExIC0gbTIyKTtcblxuICAgICAgICB0aGlzLl93ID0gKG0yMSAtIG0xMikgLyBfczM7XG4gICAgICAgIHRoaXMuX3ggPSAobTEzICsgbTMxKSAvIF9zMztcbiAgICAgICAgdGhpcy5feSA9IChtMjMgKyBtMzIpIC8gX3MzO1xuICAgICAgICB0aGlzLl96ID0gMC4yNSAqIF9zMztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbVVuaXRWZWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21Vbml0VmVjdG9ycyh2RnJvbSwgdlRvKSB7XG4gICAgICAvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcbiAgICAgIHZhciByID0gdkZyb20uZG90KHZUbykgKyAxO1xuXG4gICAgICBpZiAociA8IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgIC8vIHZGcm9tIGFuZCB2VG8gcG9pbnQgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uc1xuICAgICAgICByID0gMDtcblxuICAgICAgICBpZiAoTWF0aC5hYnModkZyb20ueCkgPiBNYXRoLmFicyh2RnJvbS56KSkge1xuICAgICAgICAgIHRoaXMuX3ggPSAtdkZyb20ueTtcbiAgICAgICAgICB0aGlzLl95ID0gdkZyb20ueDtcbiAgICAgICAgICB0aGlzLl96ID0gMDtcbiAgICAgICAgICB0aGlzLl93ID0gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgICB0aGlzLl95ID0gLXZGcm9tLno7XG4gICAgICAgICAgdGhpcy5feiA9IHZGcm9tLnk7XG4gICAgICAgICAgdGhpcy5fdyA9IHI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApOyAvLyBpbmxpbmVkIHRvIGF2b2lkIGN5Y2xpYyBkZXBlbmRlbmN5IG9uIFZlY3RvcjNcbiAgICAgICAgdGhpcy5feCA9IHZGcm9tLnkgKiB2VG8ueiAtIHZGcm9tLnogKiB2VG8ueTtcbiAgICAgICAgdGhpcy5feSA9IHZGcm9tLnogKiB2VG8ueCAtIHZGcm9tLnggKiB2VG8uejtcbiAgICAgICAgdGhpcy5feiA9IHZGcm9tLnggKiB2VG8ueSAtIHZGcm9tLnkgKiB2VG8ueDtcbiAgICAgICAgdGhpcy5fdyA9IHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmdsZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuZ2xlVG8ocSkge1xuICAgICAgcmV0dXJuIDIgKiBNYXRoLmFjb3MoTWF0aC5hYnMoY2xhbXAodGhpcy5kb3QocSksIC0xLCAxKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVUb3dhcmRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZVRvd2FyZHMocSwgc3RlcCkge1xuICAgICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZVRvKHEpO1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciB0ID0gTWF0aC5taW4oMSwgc3RlcCAvIGFuZ2xlKTtcbiAgICAgIHRoaXMuc2xlcnAocSwgdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWRlbnRpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWRlbnRpdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludmVydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgICAvLyBxdWF0ZXJuaW9uIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuICAgICAgcmV0dXJuIHRoaXMuY29uanVnYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmp1Z2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25qdWdhdGUoKSB7XG4gICAgICB0aGlzLl94ICo9IC0xO1xuICAgICAgdGhpcy5feSAqPSAtMTtcbiAgICAgIHRoaXMuX3ogKj0gLTE7XG5cbiAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRvdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3Qodikge1xuICAgICAgcmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZW5ndGhTcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGhTcSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgICAgdmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgIHRoaXMuX3ogPSAwO1xuICAgICAgICB0aGlzLl93ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSAxIC8gbDtcbiAgICAgICAgdGhpcy5feCA9IHRoaXMuX3ggKiBsO1xuICAgICAgICB0aGlzLl95ID0gdGhpcy5feSAqIGw7XG4gICAgICAgIHRoaXMuX3ogPSB0aGlzLl96ICogbDtcbiAgICAgICAgdGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtdWx0aXBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseShxLCBwKSB7XG4gICAgICBpZiAocCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMocSwgcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnModGhpcywgcSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZW11bHRpcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZW11bHRpcGx5KHEpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMocSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5UXVhdGVybmlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHlRdWF0ZXJuaW9ucyhhLCBiKSB7XG4gICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cbiAgICAgIHZhciBxYXggPSBhLl94LFxuICAgICAgICAgIHFheSA9IGEuX3ksXG4gICAgICAgICAgcWF6ID0gYS5feixcbiAgICAgICAgICBxYXcgPSBhLl93O1xuICAgICAgdmFyIHFieCA9IGIuX3gsXG4gICAgICAgICAgcWJ5ID0gYi5feSxcbiAgICAgICAgICBxYnogPSBiLl96LFxuICAgICAgICAgIHFidyA9IGIuX3c7XG4gICAgICB0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuICAgICAgdGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcbiAgICAgIHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XG4gICAgICB0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzbGVycFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGVycChxYiwgdCkge1xuICAgICAgaWYgKHQgPT09IDApIHJldHVybiB0aGlzO1xuICAgICAgaWYgKHQgPT09IDEpIHJldHVybiB0aGlzLmNvcHkocWIpO1xuICAgICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICAgIHogPSB0aGlzLl96LFxuICAgICAgICAgIHcgPSB0aGlzLl93OyAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuXG4gICAgICB2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG4gICAgICBpZiAoY29zSGFsZlRoZXRhIDwgMCkge1xuICAgICAgICB0aGlzLl93ID0gLXFiLl93O1xuICAgICAgICB0aGlzLl94ID0gLXFiLl94O1xuICAgICAgICB0aGlzLl95ID0gLXFiLl95O1xuICAgICAgICB0aGlzLl96ID0gLXFiLl96O1xuICAgICAgICBjb3NIYWxmVGhldGEgPSAtY29zSGFsZlRoZXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3B5KHFiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvc0hhbGZUaGV0YSA+PSAxLjApIHtcbiAgICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgdGhpcy5feiA9IHo7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3FyU2luSGFsZlRoZXRhID0gMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhO1xuXG4gICAgICBpZiAoc3FyU2luSGFsZlRoZXRhIDw9IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgIHZhciBzID0gMSAtIHQ7XG4gICAgICAgIHRoaXMuX3cgPSBzICogdyArIHQgKiB0aGlzLl93O1xuICAgICAgICB0aGlzLl94ID0gcyAqIHggKyB0ICogdGhpcy5feDtcbiAgICAgICAgdGhpcy5feSA9IHMgKiB5ICsgdCAqIHRoaXMuX3k7XG4gICAgICAgIHRoaXMuX3ogPSBzICogeiArIHQgKiB0aGlzLl96O1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydChzcXJTaW5IYWxmVGhldGEpO1xuICAgICAgdmFyIGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEpO1xuICAgICAgdmFyIHJhdGlvQSA9IE1hdGguc2luKCgxIC0gdCkgKiBoYWxmVGhldGEpIC8gc2luSGFsZlRoZXRhLFxuICAgICAgICAgIHJhdGlvQiA9IE1hdGguc2luKHQgKiBoYWxmVGhldGEpIC8gc2luSGFsZlRoZXRhO1xuICAgICAgdGhpcy5fdyA9IHcgKiByYXRpb0EgKyB0aGlzLl93ICogcmF0aW9CO1xuICAgICAgdGhpcy5feCA9IHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CO1xuICAgICAgdGhpcy5feSA9IHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CO1xuICAgICAgdGhpcy5feiA9IHogKiByYXRpb0EgKyB0aGlzLl96ICogcmF0aW9CO1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzbGVycFF1YXRlcm5pb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsZXJwUXVhdGVybmlvbnMocWEsIHFiLCB0KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KHFhKS5zbGVycChxYiwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhbmRvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5kb20oKSB7XG4gICAgICAvLyBEZXJpdmVkIGZyb20gaHR0cDovL3BsYW5uaW5nLmNzLnVpdWMuZWR1L25vZGUxOTguaHRtbFxuICAgICAgLy8gTm90ZSwgdGhpcyBzb3VyY2UgdXNlcyB3LCB4LCB5LCB6IG9yZGVyaW5nLFxuICAgICAgLy8gc28gd2Ugc3dhcCB0aGUgb3JkZXIgYmVsb3cuXG4gICAgICB2YXIgdTEgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgdmFyIHNxcnQxdTEgPSBNYXRoLnNxcnQoMSAtIHUxKTtcbiAgICAgIHZhciBzcXJ0dTEgPSBNYXRoLnNxcnQodTEpO1xuICAgICAgdmFyIHUyID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgdmFyIHUzID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KHNxcnQxdTEgKiBNYXRoLmNvcyh1MiksIHNxcnR1MSAqIE1hdGguc2luKHUzKSwgc3FydHUxICogTWF0aC5jb3ModTMpLCBzcXJ0MXUxICogTWF0aC5zaW4odTIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhxdWF0ZXJuaW9uKSB7XG4gICAgICByZXR1cm4gcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCAmJiBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICYmIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogJiYgcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHRoaXMuX3ggPSBhcnJheVtvZmZzZXRdO1xuICAgICAgdGhpcy5feSA9IGFycmF5W29mZnNldCArIDFdO1xuICAgICAgdGhpcy5feiA9IGFycmF5W29mZnNldCArIDJdO1xuICAgICAgdGhpcy5fdyA9IGFycmF5W29mZnNldCArIDNdO1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGFycmF5W29mZnNldF0gPSB0aGlzLl94O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLl95O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLl96O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSB0aGlzLl93O1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tQnVmZmVyQXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRleCkge1xuICAgICAgdGhpcy5feCA9IGF0dHJpYnV0ZS5nZXRYKGluZGV4KTtcbiAgICAgIHRoaXMuX3kgPSBhdHRyaWJ1dGUuZ2V0WShpbmRleCk7XG4gICAgICB0aGlzLl96ID0gYXR0cmlidXRlLmdldFooaW5kZXgpO1xuICAgICAgdGhpcy5fdyA9IGF0dHJpYnV0ZS5nZXRXKGluZGV4KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25DaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uQ2hhbmdlQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2hhbmdlQ2FsbGJhY2soKSB7fVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJGl0ZXJhdG9yNCxcbiAgICB2YWx1ZTogLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gdmFsdWUkKF9jb250ZXh0NSkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl94O1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fejtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl93O1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdmFsdWUsIHRoaXMpO1xuICAgIH0pXG4gIH1dLCBbe1xuICAgIGtleTogXCJzbGVycFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGVycChxYSwgcWIsIHFtLCB0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlF1YXRlcm5pb246IFN0YXRpYyAuc2xlcnAoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgcW0uc2xlcnBRdWF0ZXJuaW9ucyggcWEsIHFiLCB0ICkgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBxbS5zbGVycFF1YXRlcm5pb25zKHFhLCBxYiwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNsZXJwRmxhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGVycEZsYXQoZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEsIHQpIHtcbiAgICAgIC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cbiAgICAgIHZhciB4MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDBdLFxuICAgICAgICAgIHkwID0gc3JjMFtzcmNPZmZzZXQwICsgMV0sXG4gICAgICAgICAgejAgPSBzcmMwW3NyY09mZnNldDAgKyAyXSxcbiAgICAgICAgICB3MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDNdO1xuICAgICAgdmFyIHgxID0gc3JjMVtzcmNPZmZzZXQxICsgMF0sXG4gICAgICAgICAgeTEgPSBzcmMxW3NyY09mZnNldDEgKyAxXSxcbiAgICAgICAgICB6MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDJdLFxuICAgICAgICAgIHcxID0gc3JjMVtzcmNPZmZzZXQxICsgM107XG5cbiAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgIGRzdFtkc3RPZmZzZXQgKyAwXSA9IHgwO1xuICAgICAgICBkc3RbZHN0T2Zmc2V0ICsgMV0gPSB5MDtcbiAgICAgICAgZHN0W2RzdE9mZnNldCArIDJdID0gejA7XG4gICAgICAgIGRzdFtkc3RPZmZzZXQgKyAzXSA9IHcwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0ID09PSAxKSB7XG4gICAgICAgIGRzdFtkc3RPZmZzZXQgKyAwXSA9IHgxO1xuICAgICAgICBkc3RbZHN0T2Zmc2V0ICsgMV0gPSB5MTtcbiAgICAgICAgZHN0W2RzdE9mZnNldCArIDJdID0gejE7XG4gICAgICAgIGRzdFtkc3RPZmZzZXQgKyAzXSA9IHcxO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEpIHtcbiAgICAgICAgdmFyIHMgPSAxIC0gdDtcbiAgICAgICAgdmFyIGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXG4gICAgICAgICAgICBkaXIgPSBjb3MgPj0gMCA/IDEgOiAtMSxcbiAgICAgICAgICAgIHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7IC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XG5cbiAgICAgICAgaWYgKHNxclNpbiA+IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgICAgdmFyIHNpbiA9IE1hdGguc3FydChzcXJTaW4pLFxuICAgICAgICAgICAgICBsZW4gPSBNYXRoLmF0YW4yKHNpbiwgY29zICogZGlyKTtcbiAgICAgICAgICBzID0gTWF0aC5zaW4ocyAqIGxlbikgLyBzaW47XG4gICAgICAgICAgdCA9IE1hdGguc2luKHQgKiBsZW4pIC8gc2luO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHREaXIgPSB0ICogZGlyO1xuICAgICAgICB4MCA9IHgwICogcyArIHgxICogdERpcjtcbiAgICAgICAgeTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG4gICAgICAgIHowID0gejAgKiBzICsgejEgKiB0RGlyO1xuICAgICAgICB3MCA9IHcwICogcyArIHcxICogdERpcjsgLy8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxuXG4gICAgICAgIGlmIChzID09PSAxIC0gdCkge1xuICAgICAgICAgIHZhciBmID0gMSAvIE1hdGguc3FydCh4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwKTtcbiAgICAgICAgICB4MCAqPSBmO1xuICAgICAgICAgIHkwICo9IGY7XG4gICAgICAgICAgejAgKj0gZjtcbiAgICAgICAgICB3MCAqPSBmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRzdFtkc3RPZmZzZXRdID0geDA7XG4gICAgICBkc3RbZHN0T2Zmc2V0ICsgMV0gPSB5MDtcbiAgICAgIGRzdFtkc3RPZmZzZXQgKyAyXSA9IHowO1xuICAgICAgZHN0W2RzdE9mZnNldCArIDNdID0gdzA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5UXVhdGVybmlvbnNGbGF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxKSB7XG4gICAgICB2YXIgeDAgPSBzcmMwW3NyY09mZnNldDBdO1xuICAgICAgdmFyIHkwID0gc3JjMFtzcmNPZmZzZXQwICsgMV07XG4gICAgICB2YXIgejAgPSBzcmMwW3NyY09mZnNldDAgKyAyXTtcbiAgICAgIHZhciB3MCA9IHNyYzBbc3JjT2Zmc2V0MCArIDNdO1xuICAgICAgdmFyIHgxID0gc3JjMVtzcmNPZmZzZXQxXTtcbiAgICAgIHZhciB5MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDFdO1xuICAgICAgdmFyIHoxID0gc3JjMVtzcmNPZmZzZXQxICsgMl07XG4gICAgICB2YXIgdzEgPSBzcmMxW3NyY09mZnNldDEgKyAzXTtcbiAgICAgIGRzdFtkc3RPZmZzZXRdID0geDAgKiB3MSArIHcwICogeDEgKyB5MCAqIHoxIC0gejAgKiB5MTtcbiAgICAgIGRzdFtkc3RPZmZzZXQgKyAxXSA9IHkwICogdzEgKyB3MCAqIHkxICsgejAgKiB4MSAtIHgwICogejE7XG4gICAgICBkc3RbZHN0T2Zmc2V0ICsgMl0gPSB6MCAqIHcxICsgdzAgKiB6MSArIHgwICogeTEgLSB5MCAqIHgxO1xuICAgICAgZHN0W2RzdE9mZnNldCArIDNdID0gdzAgKiB3MSAtIHgwICogeDEgLSB5MCAqIHkxIC0gejAgKiB6MTtcbiAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFF1YXRlcm5pb247XG59KFN5bWJvbC5pdGVyYXRvcik7XG5cbnZhciBWZWN0b3IzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ltYm9sJGl0ZXJhdG9yNSkge1xuICBmdW5jdGlvbiBWZWN0b3IzKCkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHZhciB5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZlY3RvcjMpO1xuXG4gICAgdGhpcy5pc1ZlY3RvcjMgPSB0cnVlO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZlY3RvcjMsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoeCwgeSwgeikge1xuICAgICAgaWYgKHogPT09IHVuZGVmaW5lZCkgeiA9IHRoaXMuejsgLy8gc3ByaXRlLnNjYWxlLnNldCh4LHkpXG5cbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy56ID0gejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTY2FsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2NhbGFyKHNjYWxhcikge1xuICAgICAgdGhpcy54ID0gc2NhbGFyO1xuICAgICAgdGhpcy55ID0gc2NhbGFyO1xuICAgICAgdGhpcy56ID0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WCh4KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WSh5KSB7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Wih6KSB7XG4gICAgICB0aGlzLnogPSB6O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENvbXBvbmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb21wb25lbnQoaW5kZXgsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0aGlzLnggPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy55ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMueiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb21wb25lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29tcG9uZW50KGluZGV4KSB7XG4gICAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gdGhpcy54O1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gdGhpcy55O1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gdGhpcy56O1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkodikge1xuICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgdGhpcy56ID0gdi56O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodiwgdykge1xuICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkVmVjdG9ycyh2LCB3KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy54ICs9IHYueDtcbiAgICAgIHRoaXMueSArPSB2Lnk7XG4gICAgICB0aGlzLnogKz0gdi56O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFNjYWxhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRTY2FsYXIocykge1xuICAgICAgdGhpcy54ICs9IHM7XG4gICAgICB0aGlzLnkgKz0gcztcbiAgICAgIHRoaXMueiArPSBzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFZlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVmVjdG9ycyhhLCBiKSB7XG4gICAgICB0aGlzLnggPSBhLnggKyBiLng7XG4gICAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG4gICAgICB0aGlzLnogPSBhLnogKyBiLno7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU2NhbGVkVmVjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNjYWxlZFZlY3Rvcih2LCBzKSB7XG4gICAgICB0aGlzLnggKz0gdi54ICogcztcbiAgICAgIHRoaXMueSArPSB2LnkgKiBzO1xuICAgICAgdGhpcy56ICs9IHYueiAqIHM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ViXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1Yih2LCB3KSB7XG4gICAgICBpZiAodyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKHYsIHcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggLT0gdi54O1xuICAgICAgdGhpcy55IC09IHYueTtcbiAgICAgIHRoaXMueiAtPSB2Lno7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ViU2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YlNjYWxhcihzKSB7XG4gICAgICB0aGlzLnggLT0gcztcbiAgICAgIHRoaXMueSAtPSBzO1xuICAgICAgdGhpcy56IC09IHM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3ViVmVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJWZWN0b3JzKGEsIGIpIHtcbiAgICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICAgIHRoaXMueSA9IGEueSAtIGIueTtcbiAgICAgIHRoaXMueiA9IGEueiAtIGIuejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtdWx0aXBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseSh2LCB3KSB7XG4gICAgICBpZiAodyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKHYsIHcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnggKj0gdi54O1xuICAgICAgdGhpcy55ICo9IHYueTtcbiAgICAgIHRoaXMueiAqPSB2Lno7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVsdGlwbHlTY2FsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgIHRoaXMueiAqPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVsdGlwbHlWZWN0b3JzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5VmVjdG9ycyhhLCBiKSB7XG4gICAgICB0aGlzLnggPSBhLnggKiBiLng7XG4gICAgICB0aGlzLnkgPSBhLnkgKiBiLnk7XG4gICAgICB0aGlzLnogPSBhLnogKiBiLno7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlFdWxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUV1bGVyKGV1bGVyKSB7XG4gICAgICBpZiAoIShldWxlciAmJiBldWxlci5pc0V1bGVyKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihfcXVhdGVybmlvbiQ0LnNldEZyb21FdWxlcihldWxlcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseUF4aXNBbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZShheGlzLCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uJDQuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseU1hdHJpeDNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlNYXRyaXgzKG0pIHtcbiAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgICAgeiA9IHRoaXMuejtcbiAgICAgIHZhciBlID0gbS5lbGVtZW50cztcbiAgICAgIHRoaXMueCA9IGVbMF0gKiB4ICsgZVszXSAqIHkgKyBlWzZdICogejtcbiAgICAgIHRoaXMueSA9IGVbMV0gKiB4ICsgZVs0XSAqIHkgKyBlWzddICogejtcbiAgICAgIHRoaXMueiA9IGVbMl0gKiB4ICsgZVs1XSAqIHkgKyBlWzhdICogejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseU5vcm1hbE1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseU5vcm1hbE1hdHJpeChtKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDMobSkubm9ybWFsaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5TWF0cml4NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseU1hdHJpeDQobSkge1xuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueSxcbiAgICAgICAgICB6ID0gdGhpcy56O1xuICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuICAgICAgdmFyIHcgPSAxIC8gKGVbM10gKiB4ICsgZVs3XSAqIHkgKyBlWzExXSAqIHogKyBlWzE1XSk7XG4gICAgICB0aGlzLnggPSAoZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6ICsgZVsxMl0pICogdztcbiAgICAgIHRoaXMueSA9IChlWzFdICogeCArIGVbNV0gKiB5ICsgZVs5XSAqIHogKyBlWzEzXSkgKiB3O1xuICAgICAgdGhpcy56ID0gKGVbMl0gKiB4ICsgZVs2XSAqIHkgKyBlWzEwXSAqIHogKyBlWzE0XSkgKiB3O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5UXVhdGVybmlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVF1YXRlcm5pb24ocSkge1xuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueSxcbiAgICAgICAgICB6ID0gdGhpcy56O1xuICAgICAgdmFyIHF4ID0gcS54LFxuICAgICAgICAgIHF5ID0gcS55LFxuICAgICAgICAgIHF6ID0gcS56LFxuICAgICAgICAgIHF3ID0gcS53OyAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuXG4gICAgICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gICAgICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgICB2YXIgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XG4gICAgICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6OyAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgICAgIHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgICB0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgICAgdGhpcy56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9qZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2plY3QoY2FtZXJhKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSkuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5wcm9qZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucHJvamVjdChjYW1lcmEpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChjYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLmFwcGx5TWF0cml4NChjYW1lcmEubWF0cml4V29ybGQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1EaXJlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKG0pIHtcbiAgICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcbiAgICAgIC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueSxcbiAgICAgICAgICB6ID0gdGhpcy56O1xuICAgICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuICAgICAgdGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gKiB6O1xuICAgICAgdGhpcy55ID0gZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gKiB6O1xuICAgICAgdGhpcy56ID0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogejtcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXZpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGl2aWRlKHYpIHtcbiAgICAgIHRoaXMueCAvPSB2Lng7XG4gICAgICB0aGlzLnkgLz0gdi55O1xuICAgICAgdGhpcy56IC89IHYuejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXZpZGVTY2FsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGl2aWRlU2NhbGFyKHNjYWxhcikge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHNjYWxhcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4odikge1xuICAgICAgdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCB2LngpO1xuICAgICAgdGhpcy55ID0gTWF0aC5taW4odGhpcy55LCB2LnkpO1xuICAgICAgdGhpcy56ID0gTWF0aC5taW4odGhpcy56LCB2LnopO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXgodikge1xuICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCB2LngpO1xuICAgICAgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCB2LnkpO1xuICAgICAgdGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCB2LnopO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsYW1wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4KSB7XG4gICAgICAvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxuICAgICAgdGhpcy54ID0gTWF0aC5tYXgobWluLngsIE1hdGgubWluKG1heC54LCB0aGlzLngpKTtcbiAgICAgIHRoaXMueSA9IE1hdGgubWF4KG1pbi55LCBNYXRoLm1pbihtYXgueSwgdGhpcy55KSk7XG4gICAgICB0aGlzLnogPSBNYXRoLm1heChtaW4ueiwgTWF0aC5taW4obWF4LnosIHRoaXMueikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsYW1wU2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy54KSk7XG4gICAgICB0aGlzLnkgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy55KSk7XG4gICAgICB0aGlzLnogPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy56KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhbXBMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xhbXBMZW5ndGgobWluLCBtYXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKGxlbmd0aCB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgbGVuZ3RoKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbG9vclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbG9vcigpIHtcbiAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIHRoaXMueiA9IE1hdGguZmxvb3IodGhpcy56KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjZWlsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlaWwoKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuICAgICAgdGhpcy56ID0gTWF0aC5jZWlsKHRoaXMueik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmQoKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgICB0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm91bmRUb1plcm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmRUb1plcm8oKSB7XG4gICAgICB0aGlzLnggPSB0aGlzLnggPCAwID8gTWF0aC5jZWlsKHRoaXMueCkgOiBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgICB0aGlzLnkgPSB0aGlzLnkgPCAwID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSk7XG4gICAgICB0aGlzLnogPSB0aGlzLnogPCAwID8gTWF0aC5jZWlsKHRoaXMueikgOiBNYXRoLmZsb29yKHRoaXMueik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmVnYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgICAgIHRoaXMueCA9IC10aGlzLng7XG4gICAgICB0aGlzLnkgPSAtdGhpcy55O1xuICAgICAgdGhpcy56ID0gLXRoaXMuejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG90KHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG4gICAgfSAvLyBUT0RPIGxlbmd0aFNxdWFyZWQ/XG5cbiAgfSwge1xuICAgIGtleTogXCJsZW5ndGhTcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGhTcSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hbmhhdHRhbkxlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYW5oYXR0YW5MZW5ndGgoKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSkgKyBNYXRoLmFicyh0aGlzLnopO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXJwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlcnAodiwgYWxwaGEpIHtcbiAgICAgIHRoaXMueCArPSAodi54IC0gdGhpcy54KSAqIGFscGhhO1xuICAgICAgdGhpcy55ICs9ICh2LnkgLSB0aGlzLnkpICogYWxwaGE7XG4gICAgICB0aGlzLnogKz0gKHYueiAtIHRoaXMueikgKiBhbHBoYTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsZXJwVmVjdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXJwVmVjdG9ycyh2MSwgdjIsIGFscGhhKSB7XG4gICAgICB0aGlzLnggPSB2MS54ICsgKHYyLnggLSB2MS54KSAqIGFscGhhO1xuICAgICAgdGhpcy55ID0gdjEueSArICh2Mi55IC0gdjEueSkgKiBhbHBoYTtcbiAgICAgIHRoaXMueiA9IHYxLnogKyAodjIueiAtIHYxLnopICogYWxwaGE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3Jvc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3Jvc3Modiwgdykge1xuICAgICAgaWYgKHcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyh2LCB3KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKHRoaXMsIHYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcm9zc1ZlY3RvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3Jvc3NWZWN0b3JzKGEsIGIpIHtcbiAgICAgIHZhciBheCA9IGEueCxcbiAgICAgICAgICBheSA9IGEueSxcbiAgICAgICAgICBheiA9IGEuejtcbiAgICAgIHZhciBieCA9IGIueCxcbiAgICAgICAgICBieSA9IGIueSxcbiAgICAgICAgICBieiA9IGIuejtcbiAgICAgIHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgICB0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9qZWN0T25WZWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdE9uVmVjdG9yKHYpIHtcbiAgICAgIHZhciBkZW5vbWluYXRvciA9IHYubGVuZ3RoU3EoKTtcbiAgICAgIGlmIChkZW5vbWluYXRvciA9PT0gMCkgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDApO1xuICAgICAgdmFyIHNjYWxhciA9IHYuZG90KHRoaXMpIC8gZGVub21pbmF0b3I7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KHYpLm11bHRpcGx5U2NhbGFyKHNjYWxhcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2plY3RPblBsYW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2plY3RPblBsYW5lKHBsYW5lTm9ybWFsKSB7XG4gICAgICBfdmVjdG9yJGMuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IocGxhbmVOb3JtYWwpO1xuXG4gICAgICByZXR1cm4gdGhpcy5zdWIoX3ZlY3RvciRjKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVmbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZsZWN0KG5vcm1hbCkge1xuICAgICAgLy8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG4gICAgICAvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXG4gICAgICByZXR1cm4gdGhpcy5zdWIoX3ZlY3RvciRjLmNvcHkobm9ybWFsKS5tdWx0aXBseVNjYWxhcigyICogdGhpcy5kb3Qobm9ybWFsKSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbmdsZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuZ2xlVG8odikge1xuICAgICAgdmFyIGRlbm9taW5hdG9yID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSk7XG4gICAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHJldHVybiBNYXRoLlBJIC8gMjtcbiAgICAgIHZhciB0aGV0YSA9IHRoaXMuZG90KHYpIC8gZGVub21pbmF0b3I7IC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cbiAgICAgIHJldHVybiBNYXRoLmFjb3MoY2xhbXAodGhldGEsIC0xLCAxKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUbyh2KSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvU3F1YXJlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvU3F1YXJlZCh2KSB7XG4gICAgICB2YXIgZHggPSB0aGlzLnggLSB2LngsXG4gICAgICAgICAgZHkgPSB0aGlzLnkgLSB2LnksXG4gICAgICAgICAgZHogPSB0aGlzLnogLSB2Lno7XG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYW5oYXR0YW5EaXN0YW5jZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmhhdHRhbkRpc3RhbmNlVG8odikge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIHYueCkgKyBNYXRoLmFicyh0aGlzLnkgLSB2LnkpICsgTWF0aC5hYnModGhpcy56IC0gdi56KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbVNwaGVyaWNhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tU3BoZXJpY2FsKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHMocy5yYWRpdXMsIHMucGhpLCBzLnRoZXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbVNwaGVyaWNhbENvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tU3BoZXJpY2FsQ29vcmRzKHJhZGl1cywgcGhpLCB0aGV0YSkge1xuICAgICAgdmFyIHNpblBoaVJhZGl1cyA9IE1hdGguc2luKHBoaSkgKiByYWRpdXM7XG4gICAgICB0aGlzLnggPSBzaW5QaGlSYWRpdXMgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICB0aGlzLnkgPSBNYXRoLmNvcyhwaGkpICogcmFkaXVzO1xuICAgICAgdGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZyb21DeWxpbmRyaWNhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tQ3lsaW5kcmljYWwoYykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKGMucmFkaXVzLCBjLnRoZXRhLCBjLnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tQ3lsaW5kcmljYWxDb29yZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKHJhZGl1cywgdGhldGEsIHkpIHtcbiAgICAgIHRoaXMueCA9IHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLnogPSByYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbU1hdHJpeFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21NYXRyaXhQb3NpdGlvbihtKSB7XG4gICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG4gICAgICB0aGlzLnggPSBlWzEyXTtcbiAgICAgIHRoaXMueSA9IGVbMTNdO1xuICAgICAgdGhpcy56ID0gZVsxNF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbU1hdHJpeFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21NYXRyaXhTY2FsZShtKSB7XG4gICAgICB2YXIgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4obSwgMCkubGVuZ3RoKCk7XG4gICAgICB2YXIgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4obSwgMSkubGVuZ3RoKCk7XG4gICAgICB2YXIgc3ogPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4obSwgMikubGVuZ3RoKCk7XG4gICAgICB0aGlzLnggPSBzeDtcbiAgICAgIHRoaXMueSA9IHN5O1xuICAgICAgdGhpcy56ID0gc3o7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbU1hdHJpeENvbHVtblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tTWF0cml4Q29sdW1uKG0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkobS5lbGVtZW50cywgaW5kZXggKiA0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbU1hdHJpeDNDb2x1bW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbU1hdHJpeDNDb2x1bW4obSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21BcnJheShtLmVsZW1lbnRzLCBpbmRleCAqIDMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tRXVsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbUV1bGVyKGUpIHtcbiAgICAgIHRoaXMueCA9IGUuX3g7XG4gICAgICB0aGlzLnkgPSBlLl95O1xuICAgICAgdGhpcy56ID0gZS5fejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHYpIHtcbiAgICAgIHJldHVybiB2LnggPT09IHRoaXMueCAmJiB2LnkgPT09IHRoaXMueSAmJiB2LnogPT09IHRoaXMuejtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHRoaXMueCA9IGFycmF5W29mZnNldF07XG4gICAgICB0aGlzLnkgPSBhcnJheVtvZmZzZXQgKyAxXTtcbiAgICAgIHRoaXMueiA9IGFycmF5W29mZnNldCArIDJdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IHRoaXMueDtcbiAgICAgIGFycmF5W29mZnNldCArIDFdID0gdGhpcy55O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLno7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21CdWZmZXJBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlZlY3RvcjM6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy54ID0gYXR0cmlidXRlLmdldFgoaW5kZXgpO1xuICAgICAgdGhpcy55ID0gYXR0cmlidXRlLmdldFkoaW5kZXgpO1xuICAgICAgdGhpcy56ID0gYXR0cmlidXRlLmdldFooaW5kZXgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJhbmRvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYW5kb20oKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgdGhpcy55ID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIHRoaXMueiA9IE1hdGgucmFuZG9tKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZG9tRGlyZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmRvbURpcmVjdGlvbigpIHtcbiAgICAgIC8vIERlcml2ZWQgZnJvbSBodHRwczovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TcGhlcmVQb2ludFBpY2tpbmcuaHRtbFxuICAgICAgdmFyIHUgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyO1xuICAgICAgdmFyIHQgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICB2YXIgZiA9IE1hdGguc3FydCgxIC0gTWF0aC5wb3codSwgMikpO1xuICAgICAgdGhpcy54ID0gZiAqIE1hdGguY29zKHQpO1xuICAgICAgdGhpcy55ID0gZiAqIE1hdGguc2luKHQpO1xuICAgICAgdGhpcy56ID0gdTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCRpdGVyYXRvcjUsXG4gICAgdmFsdWU6IC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIHZhbHVlJChfY29udGV4dDYpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy54O1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLno7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB2YWx1ZSwgdGhpcyk7XG4gICAgfSlcbiAgfV0pO1xuXG4gIHJldHVybiBWZWN0b3IzO1xufShTeW1ib2wuaXRlcmF0b3IpO1xuXG52YXIgX3ZlY3RvciRjID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfcXVhdGVybmlvbiQ0ID0gLypAX19QVVJFX18qL25ldyBRdWF0ZXJuaW9uKCk7XG5cbnZhciBCb3gzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQm94MygpIHtcbiAgICB2YXIgbWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgVmVjdG9yMygrSW5maW5pdHksICtJbmZpbml0eSwgK0luZmluaXR5KTtcbiAgICB2YXIgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBuZXcgVmVjdG9yMygtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5KTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb3gzKTtcblxuICAgIHRoaXMuaXNCb3gzID0gdHJ1ZTtcbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCb3gzLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG1pbiwgbWF4KSB7XG4gICAgICB0aGlzLm1pbi5jb3B5KG1pbik7XG4gICAgICB0aGlzLm1heC5jb3B5KG1heCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21BcnJheShhcnJheSkge1xuICAgICAgdmFyIG1pblggPSArSW5maW5pdHk7XG4gICAgICB2YXIgbWluWSA9ICtJbmZpbml0eTtcbiAgICAgIHZhciBtaW5aID0gK0luZmluaXR5O1xuICAgICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtYXhaID0gLUluZmluaXR5O1xuXG4gICAgICBmb3IgKHZhciBfaTEwID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgX2kxMCA8IGw7IF9pMTAgKz0gMykge1xuICAgICAgICB2YXIgeCA9IGFycmF5W19pMTBdO1xuICAgICAgICB2YXIgeSA9IGFycmF5W19pMTAgKyAxXTtcbiAgICAgICAgdmFyIHogPSBhcnJheVtfaTEwICsgMl07XG4gICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgIGlmICh6IDwgbWluWikgbWluWiA9IHo7XG4gICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIGlmICh6ID4gbWF4WikgbWF4WiA9IHo7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWluLnNldChtaW5YLCBtaW5ZLCBtaW5aKTtcbiAgICAgIHRoaXMubWF4LnNldChtYXhYLCBtYXhZLCBtYXhaKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tQnVmZmVyQXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgbWluWCA9ICtJbmZpbml0eTtcbiAgICAgIHZhciBtaW5ZID0gK0luZmluaXR5O1xuICAgICAgdmFyIG1pblogPSArSW5maW5pdHk7XG4gICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xuICAgICAgdmFyIG1heFogPSAtSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIF9pMTEgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBfaTExIDwgbDsgX2kxMSsrKSB7XG4gICAgICAgIHZhciB4ID0gYXR0cmlidXRlLmdldFgoX2kxMSk7XG4gICAgICAgIHZhciB5ID0gYXR0cmlidXRlLmdldFkoX2kxMSk7XG4gICAgICAgIHZhciB6ID0gYXR0cmlidXRlLmdldFooX2kxMSk7XG4gICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgIGlmICh6IDwgbWluWikgbWluWiA9IHo7XG4gICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIGlmICh6ID4gbWF4WikgbWF4WiA9IHo7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWluLnNldChtaW5YLCBtaW5ZLCBtaW5aKTtcbiAgICAgIHRoaXMubWF4LnNldChtYXhYLCBtYXhZLCBtYXhaKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21Qb2ludHMocG9pbnRzKSB7XG4gICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuXG4gICAgICBmb3IgKHZhciBfaTEyID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBfaTEyIDwgaWw7IF9pMTIrKykge1xuICAgICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQocG9pbnRzW19pMTJdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZyb21DZW50ZXJBbmRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgc2l6ZSkge1xuICAgICAgdmFyIGhhbGZTaXplID0gX3ZlY3RvciRiLmNvcHkoc2l6ZSkubXVsdGlwbHlTY2FsYXIoMC41KTtcblxuICAgICAgdGhpcy5taW4uY29weShjZW50ZXIpLnN1YihoYWxmU2l6ZSk7XG4gICAgICB0aGlzLm1heC5jb3B5KGNlbnRlcikuYWRkKGhhbGZTaXplKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICB2YXIgcHJlY2lzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3Qob2JqZWN0LCBwcmVjaXNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoYm94KSB7XG4gICAgICB0aGlzLm1pbi5jb3B5KGJveC5taW4pO1xuICAgICAgdGhpcy5tYXguY29weShib3gubWF4KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYWtlRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZUVtcHR5KCkge1xuICAgICAgdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gK0luZmluaXR5O1xuICAgICAgdGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLUluZmluaXR5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG4gICAgICByZXR1cm4gdGhpcy5tYXgueCA8IHRoaXMubWluLnggfHwgdGhpcy5tYXgueSA8IHRoaXMubWluLnkgfHwgdGhpcy5tYXgueiA8IHRoaXMubWluLno7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZW50ZXIodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KDAsIDAsIDApIDogdGFyZ2V0LmFkZFZlY3RvcnModGhpcy5taW4sIHRoaXMubWF4KS5tdWx0aXBseVNjYWxhcigwLjUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpemUodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KDAsIDAsIDApIDogdGFyZ2V0LnN1YlZlY3RvcnModGhpcy5tYXgsIHRoaXMubWluKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwYW5kQnlQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRCeVBvaW50KHBvaW50KSB7XG4gICAgICB0aGlzLm1pbi5taW4ocG9pbnQpO1xuICAgICAgdGhpcy5tYXgubWF4KHBvaW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHBhbmRCeVZlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRCeVZlY3Rvcih2ZWN0b3IpIHtcbiAgICAgIHRoaXMubWluLnN1Yih2ZWN0b3IpO1xuICAgICAgdGhpcy5tYXguYWRkKHZlY3Rvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwYW5kQnlTY2FsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwYW5kQnlTY2FsYXIoc2NhbGFyKSB7XG4gICAgICB0aGlzLm1pbi5hZGRTY2FsYXIoLXNjYWxhcik7XG4gICAgICB0aGlzLm1heC5hZGRTY2FsYXIoc2NhbGFyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHBhbmRCeU9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRCeU9iamVjdChvYmplY3QpIHtcbiAgICAgIHZhciBwcmVjaXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXG4gICAgICAvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVuJ3MsIHdvcmxkIHRyYW5zZm9ybXNcbiAgICAgIG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeChmYWxzZSwgZmFsc2UpO1xuICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgICBpZiAoZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocHJlY2lzZSAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzICE9IHVuZGVmaW5lZCAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kxMyA9IDAsIGwgPSBwb3NpdGlvbi5jb3VudDsgX2kxMyA8IGw7IF9pMTMrKykge1xuICAgICAgICAgICAgX3ZlY3RvciRiLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIF9pMTMpLmFwcGx5TWF0cml4NChvYmplY3QubWF0cml4V29ybGQpO1xuXG4gICAgICAgICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoX3ZlY3RvciRiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsKSB7XG4gICAgICAgICAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfYm94JDMuY29weShnZW9tZXRyeS5ib3VuZGluZ0JveCk7XG5cbiAgICAgICAgICBfYm94JDMuYXBwbHlNYXRyaXg0KG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cbiAgICAgICAgICB0aGlzLnVuaW9uKF9ib3gkMyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBfaTE0ID0gMCwgX2wgPSBjaGlsZHJlbi5sZW5ndGg7IF9pMTQgPCBfbDsgX2kxNCsrKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kQnlPYmplY3QoY2hpbGRyZW5bX2kxNF0sIHByZWNpc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGFpbnNQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgICByZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHwgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgfHwgcG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRhaW5zQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zQm94KGJveCkge1xuICAgICAgcmV0dXJuIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICYmIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICYmIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICYmIHRoaXMubWluLnogPD0gYm94Lm1pbi56ICYmIGJveC5tYXgueiA8PSB0aGlzLm1heC56O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJhbWV0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFyYW1ldGVyKHBvaW50LCB0YXJnZXQpIHtcbiAgICAgIC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG4gICAgICAvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuICAgICAgcmV0dXJuIHRhcmdldC5zZXQoKHBvaW50LnggLSB0aGlzLm1pbi54KSAvICh0aGlzLm1heC54IC0gdGhpcy5taW4ueCksIChwb2ludC55IC0gdGhpcy5taW4ueSkgLyAodGhpcy5tYXgueSAtIHRoaXMubWluLnkpLCAocG9pbnQueiAtIHRoaXMubWluLnopIC8gKHRoaXMubWF4LnogLSB0aGlzLm1pbi56KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVyc2VjdHNCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c0JveChib3gpIHtcbiAgICAgIC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuICAgICAgcmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHwgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RzU3BoZXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG4gICAgICAvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxuICAgICAgdGhpcy5jbGFtcFBvaW50KHNwaGVyZS5jZW50ZXIsIF92ZWN0b3IkYik7IC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuXG4gICAgICByZXR1cm4gX3ZlY3RvciRiLmRpc3RhbmNlVG9TcXVhcmVkKHNwaGVyZS5jZW50ZXIpIDw9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RzUGxhbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c1BsYW5lKHBsYW5lKSB7XG4gICAgICAvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXG4gICAgICAvLyBhcmUgb24gdGhlIHNhbWUgc2lkZSAoYmFjayBvciBmcm9udCkgb2YgdGhlIHBsYW5lLCB0aGVuIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cbiAgICAgIHZhciBtaW4sIG1heDtcblxuICAgICAgaWYgKHBsYW5lLm5vcm1hbC54ID4gMCkge1xuICAgICAgICBtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XG4gICAgICAgIG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcbiAgICAgICAgbWF4ID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xuICAgICAgfVxuXG4gICAgICBpZiAocGxhbmUubm9ybWFsLnkgPiAwKSB7XG4gICAgICAgIG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XG4gICAgICAgIG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xuICAgICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuICAgICAgfVxuXG4gICAgICBpZiAocGxhbmUubm9ybWFsLnogPiAwKSB7XG4gICAgICAgIG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG4gICAgICAgIG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuICAgICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluIDw9IC1wbGFuZS5jb25zdGFudCAmJiBtYXggPj0gLXBsYW5lLmNvbnN0YW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RzVHJpYW5nbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c1RyaWFuZ2xlKHRyaWFuZ2xlKSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBjb21wdXRlIGJveCBjZW50ZXIgYW5kIGV4dGVudHNcblxuXG4gICAgICB0aGlzLmdldENlbnRlcihfY2VudGVyKTtcblxuICAgICAgX2V4dGVudHMuc3ViVmVjdG9ycyh0aGlzLm1heCwgX2NlbnRlcik7IC8vIHRyYW5zbGF0ZSB0cmlhbmdsZSB0byBhYWJiIG9yaWdpblxuXG5cbiAgICAgIF92MCQyLnN1YlZlY3RvcnModHJpYW5nbGUuYSwgX2NlbnRlcik7XG5cbiAgICAgIF92MSQ3LnN1YlZlY3RvcnModHJpYW5nbGUuYiwgX2NlbnRlcik7XG5cbiAgICAgIF92MiQzLnN1YlZlY3RvcnModHJpYW5nbGUuYywgX2NlbnRlcik7IC8vIGNvbXB1dGUgZWRnZSB2ZWN0b3JzIGZvciB0cmlhbmdsZVxuXG5cbiAgICAgIF9mMC5zdWJWZWN0b3JzKF92MSQ3LCBfdjAkMik7XG5cbiAgICAgIF9mMS5zdWJWZWN0b3JzKF92MiQzLCBfdjEkNyk7XG5cbiAgICAgIF9mMi5zdWJWZWN0b3JzKF92MCQyLCBfdjIkMyk7IC8vIHRlc3QgYWdhaW5zdCBheGVzIHRoYXQgYXJlIGdpdmVuIGJ5IGNyb3NzIHByb2R1Y3QgY29tYmluYXRpb25zIG9mIHRoZSBlZGdlcyBvZiB0aGUgdHJpYW5nbGUgYW5kIHRoZSBlZGdlcyBvZiB0aGUgYWFiYlxuICAgICAgLy8gbWFrZSBhbiBheGlzIHRlc3Rpbmcgb2YgZWFjaCBvZiB0aGUgMyBzaWRlcyBvZiB0aGUgYWFiYiBhZ2FpbnN0IGVhY2ggb2YgdGhlIDMgc2lkZXMgb2YgdGhlIHRyaWFuZ2xlID0gOSBheGlzIG9mIHNlcGFyYXRpb25cbiAgICAgIC8vIGF4aXNfaWogPSB1X2kgeCBmX2ogKHUwLCB1MSwgdTIgPSBmYWNlIG5vcm1hbHMgb2YgYWFiYiA9IHgseSx6IGF4ZXMgdmVjdG9ycyBzaW5jZSBhYWJiIGlzIGF4aXMgYWxpZ25lZClcblxuXG4gICAgICB2YXIgYXhlcyA9IFswLCAtX2YwLnosIF9mMC55LCAwLCAtX2YxLnosIF9mMS55LCAwLCAtX2YyLnosIF9mMi55LCBfZjAueiwgMCwgLV9mMC54LCBfZjEueiwgMCwgLV9mMS54LCBfZjIueiwgMCwgLV9mMi54LCAtX2YwLnksIF9mMC54LCAwLCAtX2YxLnksIF9mMS54LCAwLCAtX2YyLnksIF9mMi54LCAwXTtcblxuICAgICAgaWYgKCFzYXRGb3JBeGVzKGF4ZXMsIF92MCQyLCBfdjEkNywgX3YyJDMsIF9leHRlbnRzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIHRlc3QgMyBmYWNlIG5vcm1hbHMgZnJvbSB0aGUgYWFiYlxuXG5cbiAgICAgIGF4ZXMgPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV07XG5cbiAgICAgIGlmICghc2F0Rm9yQXhlcyhheGVzLCBfdjAkMiwgX3YxJDcsIF92MiQzLCBfZXh0ZW50cykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBmaW5hbGx5IHRlc3RpbmcgdGhlIGZhY2Ugbm9ybWFsIG9mIHRoZSB0cmlhbmdsZVxuICAgICAgLy8gdXNlIGFscmVhZHkgZXhpc3RpbmcgdHJpYW5nbGUgZWRnZSB2ZWN0b3JzIGhlcmVcblxuXG4gICAgICBfdHJpYW5nbGVOb3JtYWwuY3Jvc3NWZWN0b3JzKF9mMCwgX2YxKTtcblxuICAgICAgYXhlcyA9IFtfdHJpYW5nbGVOb3JtYWwueCwgX3RyaWFuZ2xlTm9ybWFsLnksIF90cmlhbmdsZU5vcm1hbC56XTtcbiAgICAgIHJldHVybiBzYXRGb3JBeGVzKGF4ZXMsIF92MCQyLCBfdjEkNywgX3YyJDMsIF9leHRlbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhbXBQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGFtcFBvaW50KHBvaW50LCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0YXJnZXQuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb1BvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludChwb2ludCkge1xuICAgICAgdmFyIGNsYW1wZWRQb2ludCA9IF92ZWN0b3IkYi5jb3B5KHBvaW50KS5jbGFtcCh0aGlzLm1pbiwgdGhpcy5tYXgpO1xuXG4gICAgICByZXR1cm4gY2xhbXBlZFBvaW50LnN1Yihwb2ludCkubGVuZ3RoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nU3BoZXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nU3BoZXJlKHRhcmdldCkge1xuICAgICAgdGhpcy5nZXRDZW50ZXIodGFyZ2V0LmNlbnRlcik7XG4gICAgICB0YXJnZXQucmFkaXVzID0gdGhpcy5nZXRTaXplKF92ZWN0b3IkYikubGVuZ3RoKCkgKiAwLjU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0KGJveCkge1xuICAgICAgdGhpcy5taW4ubWF4KGJveC5taW4pO1xuICAgICAgdGhpcy5tYXgubWluKGJveC5tYXgpOyAvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXG5cbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkgdGhpcy5tYWtlRW1wdHkoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmlvbihib3gpIHtcbiAgICAgIHRoaXMubWluLm1pbihib3gubWluKTtcbiAgICAgIHRoaXMubWF4Lm1heChib3gubWF4KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseU1hdHJpeDRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuICAgICAgLy8gdHJhbnNmb3JtIG9mIGVtcHR5IGJveCBpcyBhbiBlbXB0eSBib3guXG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHJldHVybiB0aGlzOyAvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuXG4gICAgICBfcG9pbnRzWzBdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMDAwXG5cblxuICAgICAgX3BvaW50c1sxXS5zZXQodGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDAwMVxuXG5cbiAgICAgIF9wb2ludHNbMl0uc2V0KHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAwMTBcblxuXG4gICAgICBfcG9pbnRzWzNdLnNldCh0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMDExXG5cblxuICAgICAgX3BvaW50c1s0XS5zZXQodGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDEwMFxuXG5cbiAgICAgIF9wb2ludHNbNV0uc2V0KHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChtYXRyaXgpOyAvLyAxMDFcblxuXG4gICAgICBfcG9pbnRzWzZdLnNldCh0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQobWF0cml4KTsgLy8gMTEwXG5cblxuICAgICAgX3BvaW50c1s3XS5zZXQodGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KG1hdHJpeCk7IC8vIDExMVxuXG5cbiAgICAgIHRoaXMuc2V0RnJvbVBvaW50cyhfcG9pbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2xhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNsYXRlKG9mZnNldCkge1xuICAgICAgdGhpcy5taW4uYWRkKG9mZnNldCk7XG4gICAgICB0aGlzLm1heC5hZGQob2Zmc2V0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKGJveCkge1xuICAgICAgcmV0dXJuIGJveC5taW4uZXF1YWxzKHRoaXMubWluKSAmJiBib3gubWF4LmVxdWFscyh0aGlzLm1heCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJveDM7XG59KCk7XG5cbnZhciBfcG9pbnRzID0gWy8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKV07XG5cbnZhciBfdmVjdG9yJGIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9ib3gkMyA9IC8qQF9fUFVSRV9fKi9uZXcgQm94MygpOyAvLyB0cmlhbmdsZSBjZW50ZXJlZCB2ZXJ0aWNlc1xuXG5cbnZhciBfdjAkMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3YxJDcgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF92MiQzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7IC8vIHRyaWFuZ2xlIGVkZ2UgdmVjdG9yc1xuXG5cbnZhciBfZjAgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9mMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX2YyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfY2VudGVyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfZXh0ZW50cyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3RyaWFuZ2xlTm9ybWFsID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdGVzdEF4aXMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxuZnVuY3Rpb24gc2F0Rm9yQXhlcyhheGVzLCB2MCwgdjEsIHYyLCBleHRlbnRzKSB7XG4gIGZvciAodmFyIF9pMTUgPSAwLCBqID0gYXhlcy5sZW5ndGggLSAzOyBfaTE1IDw9IGo7IF9pMTUgKz0gMykge1xuICAgIF90ZXN0QXhpcy5mcm9tQXJyYXkoYXhlcywgX2kxNSk7IC8vIHByb2plY3QgdGhlIGFhYmIgb250byB0aGUgc2VwYXJhdGluZyBheGlzXG5cblxuICAgIHZhciByID0gZXh0ZW50cy54ICogTWF0aC5hYnMoX3Rlc3RBeGlzLngpICsgZXh0ZW50cy55ICogTWF0aC5hYnMoX3Rlc3RBeGlzLnkpICsgZXh0ZW50cy56ICogTWF0aC5hYnMoX3Rlc3RBeGlzLnopOyAvLyBwcm9qZWN0IGFsbCAzIHZlcnRpY2VzIG9mIHRoZSB0cmlhbmdsZSBvbnRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcblxuICAgIHZhciBwMCA9IHYwLmRvdChfdGVzdEF4aXMpO1xuICAgIHZhciBwMSA9IHYxLmRvdChfdGVzdEF4aXMpO1xuICAgIHZhciBwMiA9IHYyLmRvdChfdGVzdEF4aXMpOyAvLyBhY3R1YWwgdGVzdCwgYmFzaWNhbGx5IHNlZSBpZiBlaXRoZXIgb2YgdGhlIG1vc3QgZXh0cmVtZSBvZiB0aGUgdHJpYW5nbGUgcG9pbnRzIGludGVyc2VjdHMgclxuXG4gICAgaWYgKE1hdGgubWF4KC1NYXRoLm1heChwMCwgcDEsIHAyKSwgTWF0aC5taW4ocDAsIHAxLCBwMikpID4gcikge1xuICAgICAgLy8gcG9pbnRzIG9mIHRoZSBwcm9qZWN0ZWQgdHJpYW5nbGUgYXJlIG91dHNpZGUgdGhlIHByb2plY3RlZCBoYWxmLWxlbmd0aCBvZiB0aGUgYWFiYlxuICAgICAgLy8gdGhlIGF4aXMgaXMgc2VwYXJhdGluZyBhbmQgd2UgY2FuIGV4aXRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIF9ib3gkMiA9IC8qQF9fUFVSRV9fKi9uZXcgQm94MygpO1xuXG52YXIgX3YxJDYgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF90b0ZhcnRoZXN0UG9pbnQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF90b1BvaW50ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBTcGhlcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTcGhlcmUoKSB7XG4gICAgdmFyIGNlbnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAtMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGhlcmUpO1xuXG4gICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3BoZXJlLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGNlbnRlciwgcmFkaXVzKSB7XG4gICAgICB0aGlzLmNlbnRlci5jb3B5KGNlbnRlcik7XG4gICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21Qb2ludHMocG9pbnRzLCBvcHRpb25hbENlbnRlcikge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG4gICAgICBpZiAob3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjZW50ZXIuY29weShvcHRpb25hbENlbnRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYm94JDIuc2V0RnJvbVBvaW50cyhwb2ludHMpLmdldENlbnRlcihjZW50ZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTE2ID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBfaTE2IDwgaWw7IF9pMTYrKykge1xuICAgICAgICBtYXhSYWRpdXNTcSA9IE1hdGgubWF4KG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQocG9pbnRzW19pMTZdKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KG1heFJhZGl1c1NxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc3BoZXJlKSB7XG4gICAgICB0aGlzLmNlbnRlci5jb3B5KHNwaGVyZS5jZW50ZXIpO1xuICAgICAgdGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhZGl1cyA8IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VFbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlRW1wdHkoKSB7XG4gICAgICB0aGlzLmNlbnRlci5zZXQoMCwgMCwgMCk7XG4gICAgICB0aGlzLnJhZGl1cyA9IC0xO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRhaW5zUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgcmV0dXJuIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKSA8PSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KHBvaW50KSB7XG4gICAgICByZXR1cm4gcG9pbnQuZGlzdGFuY2VUbyh0aGlzLmNlbnRlcikgLSB0aGlzLnJhZGl1cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0c1NwaGVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkge1xuICAgICAgdmFyIHJhZGl1c1N1bSA9IHRoaXMucmFkaXVzICsgc3BoZXJlLnJhZGl1cztcbiAgICAgIHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKSA8PSByYWRpdXNTdW0gKiByYWRpdXNTdW07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVyc2VjdHNCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c0JveChib3gpIHtcbiAgICAgIHJldHVybiBib3guaW50ZXJzZWN0c1NwaGVyZSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0c1BsYW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdHNQbGFuZShwbGFuZSkge1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHBsYW5lLmRpc3RhbmNlVG9Qb2ludCh0aGlzLmNlbnRlcikpIDw9IHRoaXMucmFkaXVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGFtcFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsYW1wUG9pbnQocG9pbnQsIHRhcmdldCkge1xuICAgICAgdmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChwb2ludCk7XG4gICAgICB0YXJnZXQuY29weShwb2ludCk7XG5cbiAgICAgIGlmIChkZWx0YUxlbmd0aFNxID4gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykge1xuICAgICAgICB0YXJnZXQuc3ViKHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdGFyZ2V0Lm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKS5hZGQodGhpcy5jZW50ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveCh0YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAvLyBFbXB0eSBzcGhlcmUgcHJvZHVjZXMgZW1wdHkgYm91bmRpbmcgYm94XG4gICAgICAgIHRhcmdldC5tYWtlRW1wdHkoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LnNldCh0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIpO1xuICAgICAgdGFyZ2V0LmV4cGFuZEJ5U2NhbGFyKHRoaXMucmFkaXVzKTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5TWF0cml4NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseU1hdHJpeDQobWF0cml4KSB7XG4gICAgICB0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgIHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2xhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNsYXRlKG9mZnNldCkge1xuICAgICAgdGhpcy5jZW50ZXIuYWRkKG9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwYW5kQnlQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRCeVBvaW50KHBvaW50KSB7XG4gICAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWovTWF0aEdlb0xpYi9ibG9iLzI5NDBiOTliOTljZmU1NzVkZDQ1MTAzZWYyMGY0MDE5ZGVlMTViNTQvc3JjL0dlb21ldHJ5L1NwaGVyZS5jcHAjTDY0OS1MNjcxXG4gICAgICBfdG9Qb2ludC5zdWJWZWN0b3JzKHBvaW50LCB0aGlzLmNlbnRlcik7XG5cbiAgICAgIHZhciBsZW5ndGhTcSA9IF90b1BvaW50Lmxlbmd0aFNxKCk7XG5cbiAgICAgIGlmIChsZW5ndGhTcSA+IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChsZW5ndGhTcSk7XG4gICAgICAgIHZhciBtaXNzaW5nUmFkaXVzSGFsZiA9IChsZW5ndGggLSB0aGlzLnJhZGl1cykgKiAwLjU7IC8vIE51ZGdlIHRoaXMgc3BoZXJlIHRvd2FyZHMgdGhlIHRhcmdldCBwb2ludC4gQWRkIGhhbGYgdGhlIG1pc3NpbmcgZGlzdGFuY2UgdG8gcmFkaXVzLFxuICAgICAgICAvLyBhbmQgdGhlIG90aGVyIGhhbGYgdG8gcG9zaXRpb24uIFRoaXMgZ2l2ZXMgYSB0aWdodGVyIGVuY2xvc3VyZSwgaW5zdGVhZCBvZiBpZlxuICAgICAgICAvLyB0aGUgd2hvbGUgbWlzc2luZyBkaXN0YW5jZSB3ZXJlIGp1c3QgYWRkZWQgdG8gcmFkaXVzLlxuXG4gICAgICAgIHRoaXMuY2VudGVyLmFkZChfdG9Qb2ludC5tdWx0aXBseVNjYWxhcihtaXNzaW5nUmFkaXVzSGFsZiAvIGxlbmd0aCkpO1xuICAgICAgICB0aGlzLnJhZGl1cyArPSBtaXNzaW5nUmFkaXVzSGFsZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuaW9uKHNwaGVyZSkge1xuICAgICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi8yOTQwYjk5Yjk5Y2ZlNTc1ZGQ0NTEwM2VmMjBmNDAxOWRlZTE1YjU0L3NyYy9HZW9tZXRyeS9TcGhlcmUuY3BwI0w3NTktTDc2OVxuICAgICAgLy8gVG8gZW5jbG9zZSBhbm90aGVyIHNwaGVyZSBpbnRvIHRoaXMgc3BoZXJlLCB3ZSBvbmx5IG5lZWQgdG8gZW5jbG9zZSB0d28gcG9pbnRzOlxuICAgICAgLy8gMSkgRW5jbG9zZSB0aGUgZmFydGhlc3QgcG9pbnQgb24gdGhlIG90aGVyIHNwaGVyZSBpbnRvIHRoaXMgc3BoZXJlLlxuICAgICAgLy8gMikgRW5jbG9zZSB0aGUgb3Bwb3NpdGUgcG9pbnQgb2YgdGhlIGZhcnRoZXN0IHBvaW50IGludG8gdGhpcyBzcGhlcmUuXG4gICAgICBpZiAodGhpcy5jZW50ZXIuZXF1YWxzKHNwaGVyZS5jZW50ZXIpID09PSB0cnVlKSB7XG4gICAgICAgIF90b0ZhcnRoZXN0UG9pbnQuc2V0KDAsIDAsIDEpLm11bHRpcGx5U2NhbGFyKHNwaGVyZS5yYWRpdXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RvRmFydGhlc3RQb2ludC5zdWJWZWN0b3JzKHNwaGVyZS5jZW50ZXIsIHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihzcGhlcmUucmFkaXVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5leHBhbmRCeVBvaW50KF92MSQ2LmNvcHkoc3BoZXJlLmNlbnRlcikuYWRkKF90b0ZhcnRoZXN0UG9pbnQpKTtcbiAgICAgIHRoaXMuZXhwYW5kQnlQb2ludChfdjEkNi5jb3B5KHNwaGVyZS5jZW50ZXIpLnN1YihfdG9GYXJ0aGVzdFBvaW50KSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhzcGhlcmUpIHtcbiAgICAgIHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyh0aGlzLmNlbnRlcikgJiYgc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BoZXJlO1xufSgpO1xuXG52YXIgX3ZlY3RvciRhID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfc2VnQ2VudGVyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfc2VnRGlyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfZGlmZiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX2VkZ2UxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfZWRnZTIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9ub3JtYWwkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgUmF5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmF5KCkge1xuICAgIHZhciBvcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjMoMCwgMCwgLTEpO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJheSk7XG5cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYXksIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ2luLCBkaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMub3JpZ2luLmNvcHkob3JpZ2luKTtcbiAgICAgIHRoaXMuZGlyZWN0aW9uLmNvcHkoZGlyZWN0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkocmF5KSB7XG4gICAgICB0aGlzLm9yaWdpbi5jb3B5KHJheS5vcmlnaW4pO1xuICAgICAgdGhpcy5kaXJlY3Rpb24uY29weShyYXkuZGlyZWN0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdCh0LCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0YXJnZXQuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIodCkuYWRkKHRoaXMub3JpZ2luKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9va0F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvb2tBdCh2KSB7XG4gICAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KHYpLnN1Yih0aGlzLm9yaWdpbikubm9ybWFsaXplKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjYXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2FzdCh0KSB7XG4gICAgICB0aGlzLm9yaWdpbi5jb3B5KHRoaXMuYXQodCwgX3ZlY3RvciRhKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VzdFBvaW50VG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KHBvaW50LCB0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5zdWJWZWN0b3JzKHBvaW50LCB0aGlzLm9yaWdpbik7XG4gICAgICB2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB0YXJnZXQuZG90KHRoaXMuZGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbkRpc3RhbmNlIDwgMCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvcHkodGhpcy5vcmlnaW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0LmNvcHkodGhpcy5kaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKGRpcmVjdGlvbkRpc3RhbmNlKS5hZGQodGhpcy5vcmlnaW4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KHBvaW50KSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQocG9pbnQpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VTcVRvUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VTcVRvUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IF92ZWN0b3IkYS5zdWJWZWN0b3JzKHBvaW50LCB0aGlzLm9yaWdpbikuZG90KHRoaXMuZGlyZWN0aW9uKTsgLy8gcG9pbnQgYmVoaW5kIHRoZSByYXlcblxuXG4gICAgICBpZiAoZGlyZWN0aW9uRGlzdGFuY2UgPCAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZChwb2ludCk7XG4gICAgICB9XG5cbiAgICAgIF92ZWN0b3IkYS5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihkaXJlY3Rpb25EaXN0YW5jZSkuYWRkKHRoaXMub3JpZ2luKTtcblxuICAgICAgcmV0dXJuIF92ZWN0b3IkYS5kaXN0YW5jZVRvU3F1YXJlZChwb2ludCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlU3FUb1NlZ21lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VTcVRvU2VnbWVudCh2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCkge1xuICAgICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcG1qb25pYWsvR2VvbWV0cmljVG9vbHMvYmxvYi9tYXN0ZXIvR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVEaXN0UmF5U2VnbWVudC5oXG4gICAgICAvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuICAgICAgLy8gZGVmaW5lZCBieSB2MCBhbmQgdjFcbiAgICAgIC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XG4gICAgICAvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcbiAgICAgIC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcbiAgICAgIF9zZWdDZW50ZXIuY29weSh2MCkuYWRkKHYxKS5tdWx0aXBseVNjYWxhcigwLjUpO1xuXG4gICAgICBfc2VnRGlyLmNvcHkodjEpLnN1Yih2MCkubm9ybWFsaXplKCk7XG5cbiAgICAgIF9kaWZmLmNvcHkodGhpcy5vcmlnaW4pLnN1Yihfc2VnQ2VudGVyKTtcblxuICAgICAgdmFyIHNlZ0V4dGVudCA9IHYwLmRpc3RhbmNlVG8odjEpICogMC41O1xuICAgICAgdmFyIGEwMSA9IC10aGlzLmRpcmVjdGlvbi5kb3QoX3NlZ0Rpcik7XG5cbiAgICAgIHZhciBiMCA9IF9kaWZmLmRvdCh0aGlzLmRpcmVjdGlvbik7XG5cbiAgICAgIHZhciBiMSA9IC1fZGlmZi5kb3QoX3NlZ0Rpcik7XG5cbiAgICAgIHZhciBjID0gX2RpZmYubGVuZ3RoU3EoKTtcblxuICAgICAgdmFyIGRldCA9IE1hdGguYWJzKDEgLSBhMDEgKiBhMDEpO1xuICAgICAgdmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xuXG4gICAgICBpZiAoZGV0ID4gMCkge1xuICAgICAgICAvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXG4gICAgICAgIHMwID0gYTAxICogYjEgLSBiMDtcbiAgICAgICAgczEgPSBhMDEgKiBiMCAtIGIxO1xuICAgICAgICBleHREZXQgPSBzZWdFeHRlbnQgKiBkZXQ7XG5cbiAgICAgICAgaWYgKHMwID49IDApIHtcbiAgICAgICAgICBpZiAoczEgPj0gLWV4dERldCkge1xuICAgICAgICAgICAgaWYgKHMxIDw9IGV4dERldCkge1xuICAgICAgICAgICAgICAvLyByZWdpb24gMFxuICAgICAgICAgICAgICAvLyBNaW5pbXVtIGF0IGludGVyaW9yIHBvaW50cyBvZiByYXkgYW5kIHNlZ21lbnQuXG4gICAgICAgICAgICAgIHZhciBpbnZEZXQgPSAxIC8gZGV0O1xuICAgICAgICAgICAgICBzMCAqPSBpbnZEZXQ7XG4gICAgICAgICAgICAgIHMxICo9IGludkRldDtcbiAgICAgICAgICAgICAgc3FyRGlzdCA9IHMwICogKHMwICsgYTAxICogczEgKyAyICogYjApICsgczEgKiAoYTAxICogczAgKyBzMSArIDIgKiBiMSkgKyBjO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVnaW9uIDFcbiAgICAgICAgICAgICAgczEgPSBzZWdFeHRlbnQ7XG4gICAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoMCwgLShhMDEgKiBzMSArIGIwKSk7XG4gICAgICAgICAgICAgIHNxckRpc3QgPSAtczAgKiBzMCArIHMxICogKHMxICsgMiAqIGIxKSArIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlZ2lvbiA1XG4gICAgICAgICAgICBzMSA9IC1zZWdFeHRlbnQ7XG4gICAgICAgICAgICBzMCA9IE1hdGgubWF4KDAsIC0oYTAxICogczEgKyBiMCkpO1xuICAgICAgICAgICAgc3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHMxIDw9IC1leHREZXQpIHtcbiAgICAgICAgICAgIC8vIHJlZ2lvbiA0XG4gICAgICAgICAgICBzMCA9IE1hdGgubWF4KDAsIC0oLWEwMSAqIHNlZ0V4dGVudCArIGIwKSk7XG4gICAgICAgICAgICBzMSA9IHMwID4gMCA/IC1zZWdFeHRlbnQgOiBNYXRoLm1pbihNYXRoLm1heCgtc2VnRXh0ZW50LCAtYjEpLCBzZWdFeHRlbnQpO1xuICAgICAgICAgICAgc3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcbiAgICAgICAgICB9IGVsc2UgaWYgKHMxIDw9IGV4dERldCkge1xuICAgICAgICAgICAgLy8gcmVnaW9uIDNcbiAgICAgICAgICAgIHMwID0gMDtcbiAgICAgICAgICAgIHMxID0gTWF0aC5taW4oTWF0aC5tYXgoLXNlZ0V4dGVudCwgLWIxKSwgc2VnRXh0ZW50KTtcbiAgICAgICAgICAgIHNxckRpc3QgPSBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByZWdpb24gMlxuICAgICAgICAgICAgczAgPSBNYXRoLm1heCgwLCAtKGEwMSAqIHNlZ0V4dGVudCArIGIwKSk7XG4gICAgICAgICAgICBzMSA9IHMwID4gMCA/IHNlZ0V4dGVudCA6IE1hdGgubWluKE1hdGgubWF4KC1zZWdFeHRlbnQsIC1iMSksIHNlZ0V4dGVudCk7XG4gICAgICAgICAgICBzcXJEaXN0ID0gLXMwICogczAgKyBzMSAqIChzMSArIDIgKiBiMSkgKyBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cbiAgICAgICAgczEgPSBhMDEgPiAwID8gLXNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcbiAgICAgICAgczAgPSBNYXRoLm1heCgwLCAtKGEwMSAqIHMxICsgYjApKTtcbiAgICAgICAgc3FyRGlzdCA9IC1zMCAqIHMwICsgczEgKiAoczEgKyAyICogYjEpICsgYztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbmFsUG9pbnRPblJheSkge1xuICAgICAgICBvcHRpb25hbFBvaW50T25SYXkuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoczApLmFkZCh0aGlzLm9yaWdpbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25hbFBvaW50T25TZWdtZW50KSB7XG4gICAgICAgIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weShfc2VnRGlyKS5tdWx0aXBseVNjYWxhcihzMSkuYWRkKF9zZWdDZW50ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3FyRGlzdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0U3BoZXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdFNwaGVyZShzcGhlcmUsIHRhcmdldCkge1xuICAgICAgX3ZlY3RvciRhLnN1YlZlY3RvcnMoc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4pO1xuXG4gICAgICB2YXIgdGNhID0gX3ZlY3RvciRhLmRvdCh0aGlzLmRpcmVjdGlvbik7XG5cbiAgICAgIHZhciBkMiA9IF92ZWN0b3IkYS5kb3QoX3ZlY3RvciRhKSAtIHRjYSAqIHRjYTtcbiAgICAgIHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG4gICAgICBpZiAoZDIgPiByYWRpdXMyKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB0aGMgPSBNYXRoLnNxcnQocmFkaXVzMiAtIGQyKTsgLy8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcblxuICAgICAgdmFyIHQwID0gdGNhIC0gdGhjOyAvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG5cbiAgICAgIHZhciB0MSA9IHRjYSArIHRoYzsgLy8gdGVzdCB0byBzZWUgaWYgYm90aCB0MCBhbmQgdDEgYXJlIGJlaGluZCB0aGUgcmF5IC0gaWYgc28sIHJldHVybiBudWxsXG5cbiAgICAgIGlmICh0MCA8IDAgJiYgdDEgPCAwKSByZXR1cm4gbnVsbDsgLy8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XG4gICAgICAvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXG4gICAgICAvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXG5cbiAgICAgIGlmICh0MCA8IDApIHJldHVybiB0aGlzLmF0KHQxLCB0YXJnZXQpOyAvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxuXG4gICAgICByZXR1cm4gdGhpcy5hdCh0MCwgdGFyZ2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0c1NwaGVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3RzU3BoZXJlKHNwaGVyZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoc3BoZXJlLmNlbnRlcikgPD0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9QbGFuZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvUGxhbmUocGxhbmUpIHtcbiAgICAgIHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICAgICAgLy8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuICAgICAgICBpZiAocGxhbmUuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcblxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdCA9IC0odGhpcy5vcmlnaW4uZG90KHBsYW5lLm5vcm1hbCkgKyBwbGFuZS5jb25zdGFudCkgLyBkZW5vbWluYXRvcjsgLy8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcblxuICAgICAgcmV0dXJuIHQgPj0gMCA/IHQgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RQbGFuZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3RQbGFuZShwbGFuZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKHBsYW5lKTtcblxuICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmF0KHQsIHRhcmdldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVyc2VjdHNQbGFuZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3RzUGxhbmUocGxhbmUpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcbiAgICAgIHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik7XG5cbiAgICAgIGlmIChkaXN0VG9Qb2ludCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCh0aGlzLmRpcmVjdGlvbik7XG5cbiAgICAgIGlmIChkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0Qm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdEJveChib3gsIHRhcmdldCkge1xuICAgICAgdmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xuICAgICAgdmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcbiAgICAgICAgICBpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXG4gICAgICAgICAgaW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xuICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG4gICAgICBpZiAoaW52ZGlyeCA+PSAwKSB7XG4gICAgICAgIHRtaW4gPSAoYm94Lm1pbi54IC0gb3JpZ2luLngpICogaW52ZGlyeDtcbiAgICAgICAgdG1heCA9IChib3gubWF4LnggLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1pbiA9IChib3gubWF4LnggLSBvcmlnaW4ueCkgKiBpbnZkaXJ4O1xuICAgICAgICB0bWF4ID0gKGJveC5taW4ueCAtIG9yaWdpbi54KSAqIGludmRpcng7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZkaXJ5ID49IDApIHtcbiAgICAgICAgdHltaW4gPSAoYm94Lm1pbi55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcbiAgICAgICAgdHltYXggPSAoYm94Lm1heC55IC0gb3JpZ2luLnkpICogaW52ZGlyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5bWluID0gKGJveC5tYXgueSAtIG9yaWdpbi55KSAqIGludmRpcnk7XG4gICAgICAgIHR5bWF4ID0gKGJveC5taW4ueSAtIG9yaWdpbi55KSAqIGludmRpcnk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0bWluID4gdHltYXggfHwgdHltaW4gPiB0bWF4KSByZXR1cm4gbnVsbDsgLy8gVGhlc2UgbGluZXMgYWxzbyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdG1pbiBvciB0bWF4IGlzIE5hTlxuICAgICAgLy8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxuXG4gICAgICBpZiAodHltaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4pIHRtaW4gPSB0eW1pbjtcbiAgICAgIGlmICh0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCkgdG1heCA9IHR5bWF4O1xuXG4gICAgICBpZiAoaW52ZGlyeiA+PSAwKSB7XG4gICAgICAgIHR6bWluID0gKGJveC5taW4ueiAtIG9yaWdpbi56KSAqIGludmRpcno7XG4gICAgICAgIHR6bWF4ID0gKGJveC5tYXgueiAtIG9yaWdpbi56KSAqIGludmRpcno7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0em1pbiA9IChib3gubWF4LnogLSBvcmlnaW4ueikgKiBpbnZkaXJ6O1xuICAgICAgICB0em1heCA9IChib3gubWluLnogLSBvcmlnaW4ueikgKiBpbnZkaXJ6O1xuICAgICAgfVxuXG4gICAgICBpZiAodG1pbiA+IHR6bWF4IHx8IHR6bWluID4gdG1heCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4pIHRtaW4gPSB0em1pbjtcbiAgICAgIGlmICh0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCkgdG1heCA9IHR6bWF4OyAvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cbiAgICAgIGlmICh0bWF4IDwgMCkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5hdCh0bWluID49IDAgPyB0bWluIDogdG1heCwgdGFyZ2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0c0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KGJveCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KGJveCwgX3ZlY3RvciRhKSAhPT0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0VHJpYW5nbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0VHJpYW5nbGUoYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCB0YXJnZXQpIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuICAgICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcG1qb25pYWsvR2VvbWV0cmljVG9vbHMvYmxvYi9tYXN0ZXIvR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXG4gICAgICBfZWRnZTEuc3ViVmVjdG9ycyhiLCBhKTtcblxuICAgICAgX2VkZ2UyLnN1YlZlY3RvcnMoYywgYSk7XG5cbiAgICAgIF9ub3JtYWwkMS5jcm9zc1ZlY3RvcnMoX2VkZ2UxLCBfZWRnZTIpOyAvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcbiAgICAgIC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcbiAgICAgIC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuICAgICAgLy8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG4gICAgICAvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuXG5cbiAgICAgIHZhciBEZE4gPSB0aGlzLmRpcmVjdGlvbi5kb3QoX25vcm1hbCQxKTtcbiAgICAgIHZhciBzaWduO1xuXG4gICAgICBpZiAoRGROID4gMCkge1xuICAgICAgICBpZiAoYmFja2ZhY2VDdWxsaW5nKSByZXR1cm4gbnVsbDtcbiAgICAgICAgc2lnbiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKERkTiA8IDApIHtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICBEZE4gPSAtRGROO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIF9kaWZmLnN1YlZlY3RvcnModGhpcy5vcmlnaW4sIGEpO1xuXG4gICAgICB2YXIgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdChfZWRnZTIuY3Jvc3NWZWN0b3JzKF9kaWZmLCBfZWRnZTIpKTsgLy8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cblxuICAgICAgaWYgKERkUXhFMiA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KF9lZGdlMS5jcm9zcyhfZGlmZikpOyAvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuXG4gICAgICBpZiAoRGRFMXhRIDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cblxuXG4gICAgICBpZiAoRGRReEUyICsgRGRFMXhRID4gRGROKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxuXG5cbiAgICAgIHZhciBRZE4gPSAtc2lnbiAqIF9kaWZmLmRvdChfbm9ybWFsJDEpOyAvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXG5cblxuICAgICAgaWYgKFFkTiA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxuXG5cbiAgICAgIHJldHVybiB0aGlzLmF0KFFkTiAvIERkTiwgdGFyZ2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlNYXRyaXg0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5TWF0cml4NChtYXRyaXg0KSB7XG4gICAgICB0aGlzLm9yaWdpbi5hcHBseU1hdHJpeDQobWF0cml4NCk7XG4gICAgICB0aGlzLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24obWF0cml4NCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhyYXkpIHtcbiAgICAgIHJldHVybiByYXkub3JpZ2luLmVxdWFscyh0aGlzLm9yaWdpbikgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHModGhpcy5kaXJlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJheTtcbn0oKTtcblxudmFyIE1hdHJpeDQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXRyaXg0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXRyaXg0KTtcblxuICAgIHRoaXMuaXNNYXRyaXg0ID0gdHJ1ZTtcbiAgICB0aGlzLmVsZW1lbnRzID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXRyaXg0LCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCkge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHRlWzBdID0gbjExO1xuICAgICAgdGVbNF0gPSBuMTI7XG4gICAgICB0ZVs4XSA9IG4xMztcbiAgICAgIHRlWzEyXSA9IG4xNDtcbiAgICAgIHRlWzFdID0gbjIxO1xuICAgICAgdGVbNV0gPSBuMjI7XG4gICAgICB0ZVs5XSA9IG4yMztcbiAgICAgIHRlWzEzXSA9IG4yNDtcbiAgICAgIHRlWzJdID0gbjMxO1xuICAgICAgdGVbNl0gPSBuMzI7XG4gICAgICB0ZVsxMF0gPSBuMzM7XG4gICAgICB0ZVsxNF0gPSBuMzQ7XG4gICAgICB0ZVszXSA9IG40MTtcbiAgICAgIHRlWzddID0gbjQyO1xuICAgICAgdGVbMTFdID0gbjQzO1xuICAgICAgdGVbMTVdID0gbjQ0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlkZW50aXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlkZW50aXR5KCkge1xuICAgICAgdGhpcy5zZXQoMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShtKSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcbiAgICAgIHRlWzBdID0gbWVbMF07XG4gICAgICB0ZVsxXSA9IG1lWzFdO1xuICAgICAgdGVbMl0gPSBtZVsyXTtcbiAgICAgIHRlWzNdID0gbWVbM107XG4gICAgICB0ZVs0XSA9IG1lWzRdO1xuICAgICAgdGVbNV0gPSBtZVs1XTtcbiAgICAgIHRlWzZdID0gbWVbNl07XG4gICAgICB0ZVs3XSA9IG1lWzddO1xuICAgICAgdGVbOF0gPSBtZVs4XTtcbiAgICAgIHRlWzldID0gbWVbOV07XG4gICAgICB0ZVsxMF0gPSBtZVsxMF07XG4gICAgICB0ZVsxMV0gPSBtZVsxMV07XG4gICAgICB0ZVsxMl0gPSBtZVsxMl07XG4gICAgICB0ZVsxM10gPSBtZVsxM107XG4gICAgICB0ZVsxNF0gPSBtZVsxNF07XG4gICAgICB0ZVsxNV0gPSBtZVsxNV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlQb3NpdGlvbihtKSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLFxuICAgICAgICAgIG1lID0gbS5lbGVtZW50cztcbiAgICAgIHRlWzEyXSA9IG1lWzEyXTtcbiAgICAgIHRlWzEzXSA9IG1lWzEzXTtcbiAgICAgIHRlWzE0XSA9IG1lWzE0XTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tTWF0cml4M1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tTWF0cml4MyhtKSB7XG4gICAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuICAgICAgdGhpcy5zZXQobWVbMF0sIG1lWzNdLCBtZVs2XSwgMCwgbWVbMV0sIG1lWzRdLCBtZVs3XSwgMCwgbWVbMl0sIG1lWzVdLCBtZVs4XSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdEJhc2lzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RCYXNpcyh4QXhpcywgeUF4aXMsIHpBeGlzKSB7XG4gICAgICB4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDApO1xuICAgICAgeUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAxKTtcbiAgICAgIHpBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFrZUJhc2lzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VCYXNpcyh4QXhpcywgeUF4aXMsIHpBeGlzKSB7XG4gICAgICB0aGlzLnNldCh4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLCB4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLCB4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLCAwLCAwLCAwLCAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHRyYWN0Um90YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdFJvdGF0aW9uKG0pIHtcbiAgICAgIC8vIHRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgcmVmbGVjdGlvbiBtYXRyaWNlc1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgIHZhciBzY2FsZVggPSAxIC8gX3YxJDUuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAwKS5sZW5ndGgoKTtcblxuICAgICAgdmFyIHNjYWxlWSA9IDEgLyBfdjEkNS5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDEpLmxlbmd0aCgpO1xuXG4gICAgICB2YXIgc2NhbGVaID0gMSAvIF92MSQ1LnNldEZyb21NYXRyaXhDb2x1bW4obSwgMikubGVuZ3RoKCk7XG5cbiAgICAgIHRlWzBdID0gbWVbMF0gKiBzY2FsZVg7XG4gICAgICB0ZVsxXSA9IG1lWzFdICogc2NhbGVYO1xuICAgICAgdGVbMl0gPSBtZVsyXSAqIHNjYWxlWDtcbiAgICAgIHRlWzNdID0gMDtcbiAgICAgIHRlWzRdID0gbWVbNF0gKiBzY2FsZVk7XG4gICAgICB0ZVs1XSA9IG1lWzVdICogc2NhbGVZO1xuICAgICAgdGVbNl0gPSBtZVs2XSAqIHNjYWxlWTtcbiAgICAgIHRlWzddID0gMDtcbiAgICAgIHRlWzhdID0gbWVbOF0gKiBzY2FsZVo7XG4gICAgICB0ZVs5XSA9IG1lWzldICogc2NhbGVaO1xuICAgICAgdGVbMTBdID0gbWVbMTBdICogc2NhbGVaO1xuICAgICAgdGVbMTFdID0gMDtcbiAgICAgIHRlWzEyXSA9IDA7XG4gICAgICB0ZVsxM10gPSAwO1xuICAgICAgdGVbMTRdID0gMDtcbiAgICAgIHRlWzE1XSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFrZVJvdGF0aW9uRnJvbUV1bGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VSb3RhdGlvbkZyb21FdWxlcihldWxlcikge1xuICAgICAgaWYgKCEoZXVsZXIgJiYgZXVsZXIuaXNFdWxlcikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuTWF0cml4NDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciB4ID0gZXVsZXIueCxcbiAgICAgICAgICB5ID0gZXVsZXIueSxcbiAgICAgICAgICB6ID0gZXVsZXIuejtcbiAgICAgIHZhciBhID0gTWF0aC5jb3MoeCksXG4gICAgICAgICAgYiA9IE1hdGguc2luKHgpO1xuICAgICAgdmFyIGMgPSBNYXRoLmNvcyh5KSxcbiAgICAgICAgICBkID0gTWF0aC5zaW4oeSk7XG4gICAgICB2YXIgZSA9IE1hdGguY29zKHopLFxuICAgICAgICAgIGYgPSBNYXRoLnNpbih6KTtcblxuICAgICAgaWYgKGV1bGVyLm9yZGVyID09PSAnWFlaJykge1xuICAgICAgICB2YXIgYWUgPSBhICogZSxcbiAgICAgICAgICAgIGFmID0gYSAqIGYsXG4gICAgICAgICAgICBiZSA9IGIgKiBlLFxuICAgICAgICAgICAgYmYgPSBiICogZjtcbiAgICAgICAgdGVbMF0gPSBjICogZTtcbiAgICAgICAgdGVbNF0gPSAtYyAqIGY7XG4gICAgICAgIHRlWzhdID0gZDtcbiAgICAgICAgdGVbMV0gPSBhZiArIGJlICogZDtcbiAgICAgICAgdGVbNV0gPSBhZSAtIGJmICogZDtcbiAgICAgICAgdGVbOV0gPSAtYiAqIGM7XG4gICAgICAgIHRlWzJdID0gYmYgLSBhZSAqIGQ7XG4gICAgICAgIHRlWzZdID0gYmUgKyBhZiAqIGQ7XG4gICAgICAgIHRlWzEwXSA9IGEgKiBjO1xuICAgICAgfSBlbHNlIGlmIChldWxlci5vcmRlciA9PT0gJ1lYWicpIHtcbiAgICAgICAgdmFyIGNlID0gYyAqIGUsXG4gICAgICAgICAgICBjZiA9IGMgKiBmLFxuICAgICAgICAgICAgZGUgPSBkICogZSxcbiAgICAgICAgICAgIGRmID0gZCAqIGY7XG4gICAgICAgIHRlWzBdID0gY2UgKyBkZiAqIGI7XG4gICAgICAgIHRlWzRdID0gZGUgKiBiIC0gY2Y7XG4gICAgICAgIHRlWzhdID0gYSAqIGQ7XG4gICAgICAgIHRlWzFdID0gYSAqIGY7XG4gICAgICAgIHRlWzVdID0gYSAqIGU7XG4gICAgICAgIHRlWzldID0gLWI7XG4gICAgICAgIHRlWzJdID0gY2YgKiBiIC0gZGU7XG4gICAgICAgIHRlWzZdID0gZGYgKyBjZSAqIGI7XG4gICAgICAgIHRlWzEwXSA9IGEgKiBjO1xuICAgICAgfSBlbHNlIGlmIChldWxlci5vcmRlciA9PT0gJ1pYWScpIHtcbiAgICAgICAgdmFyIF9jZSA9IGMgKiBlLFxuICAgICAgICAgICAgX2NmID0gYyAqIGYsXG4gICAgICAgICAgICBfZGUgPSBkICogZSxcbiAgICAgICAgICAgIF9kZiA9IGQgKiBmO1xuXG4gICAgICAgIHRlWzBdID0gX2NlIC0gX2RmICogYjtcbiAgICAgICAgdGVbNF0gPSAtYSAqIGY7XG4gICAgICAgIHRlWzhdID0gX2RlICsgX2NmICogYjtcbiAgICAgICAgdGVbMV0gPSBfY2YgKyBfZGUgKiBiO1xuICAgICAgICB0ZVs1XSA9IGEgKiBlO1xuICAgICAgICB0ZVs5XSA9IF9kZiAtIF9jZSAqIGI7XG4gICAgICAgIHRlWzJdID0gLWEgKiBkO1xuICAgICAgICB0ZVs2XSA9IGI7XG4gICAgICAgIHRlWzEwXSA9IGEgKiBjO1xuICAgICAgfSBlbHNlIGlmIChldWxlci5vcmRlciA9PT0gJ1pZWCcpIHtcbiAgICAgICAgdmFyIF9hZSA9IGEgKiBlLFxuICAgICAgICAgICAgX2FmID0gYSAqIGYsXG4gICAgICAgICAgICBfYmUgPSBiICogZSxcbiAgICAgICAgICAgIF9iZiA9IGIgKiBmO1xuXG4gICAgICAgIHRlWzBdID0gYyAqIGU7XG4gICAgICAgIHRlWzRdID0gX2JlICogZCAtIF9hZjtcbiAgICAgICAgdGVbOF0gPSBfYWUgKiBkICsgX2JmO1xuICAgICAgICB0ZVsxXSA9IGMgKiBmO1xuICAgICAgICB0ZVs1XSA9IF9iZiAqIGQgKyBfYWU7XG4gICAgICAgIHRlWzldID0gX2FmICogZCAtIF9iZTtcbiAgICAgICAgdGVbMl0gPSAtZDtcbiAgICAgICAgdGVbNl0gPSBiICogYztcbiAgICAgICAgdGVbMTBdID0gYSAqIGM7XG4gICAgICB9IGVsc2UgaWYgKGV1bGVyLm9yZGVyID09PSAnWVpYJykge1xuICAgICAgICB2YXIgYWMgPSBhICogYyxcbiAgICAgICAgICAgIGFkID0gYSAqIGQsXG4gICAgICAgICAgICBiYyA9IGIgKiBjLFxuICAgICAgICAgICAgYmQgPSBiICogZDtcbiAgICAgICAgdGVbMF0gPSBjICogZTtcbiAgICAgICAgdGVbNF0gPSBiZCAtIGFjICogZjtcbiAgICAgICAgdGVbOF0gPSBiYyAqIGYgKyBhZDtcbiAgICAgICAgdGVbMV0gPSBmO1xuICAgICAgICB0ZVs1XSA9IGEgKiBlO1xuICAgICAgICB0ZVs5XSA9IC1iICogZTtcbiAgICAgICAgdGVbMl0gPSAtZCAqIGU7XG4gICAgICAgIHRlWzZdID0gYWQgKiBmICsgYmM7XG4gICAgICAgIHRlWzEwXSA9IGFjIC0gYmQgKiBmO1xuICAgICAgfSBlbHNlIGlmIChldWxlci5vcmRlciA9PT0gJ1haWScpIHtcbiAgICAgICAgdmFyIF9hYyA9IGEgKiBjLFxuICAgICAgICAgICAgX2FkID0gYSAqIGQsXG4gICAgICAgICAgICBfYmMgPSBiICogYyxcbiAgICAgICAgICAgIF9iZCA9IGIgKiBkO1xuXG4gICAgICAgIHRlWzBdID0gYyAqIGU7XG4gICAgICAgIHRlWzRdID0gLWY7XG4gICAgICAgIHRlWzhdID0gZCAqIGU7XG4gICAgICAgIHRlWzFdID0gX2FjICogZiArIF9iZDtcbiAgICAgICAgdGVbNV0gPSBhICogZTtcbiAgICAgICAgdGVbOV0gPSBfYWQgKiBmIC0gX2JjO1xuICAgICAgICB0ZVsyXSA9IF9iYyAqIGYgLSBfYWQ7XG4gICAgICAgIHRlWzZdID0gYiAqIGU7XG4gICAgICAgIHRlWzEwXSA9IF9iZCAqIGYgKyBfYWM7XG4gICAgICB9IC8vIGJvdHRvbSByb3dcblxuXG4gICAgICB0ZVszXSA9IDA7XG4gICAgICB0ZVs3XSA9IDA7XG4gICAgICB0ZVsxMV0gPSAwOyAvLyBsYXN0IGNvbHVtblxuXG4gICAgICB0ZVsxMl0gPSAwO1xuICAgICAgdGVbMTNdID0gMDtcbiAgICAgIHRlWzE0XSA9IDA7XG4gICAgICB0ZVsxNV0gPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvc2UoX3plcm8sIHEsIF9vbmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb29rQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9va0F0KGV5ZSwgdGFyZ2V0LCB1cCkge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgX3ouc3ViVmVjdG9ycyhleWUsIHRhcmdldCk7XG5cbiAgICAgIGlmIChfei5sZW5ndGhTcSgpID09PSAwKSB7XG4gICAgICAgIC8vIGV5ZSBhbmQgdGFyZ2V0IGFyZSBpbiB0aGUgc2FtZSBwb3NpdGlvblxuICAgICAgICBfei56ID0gMTtcbiAgICAgIH1cblxuICAgICAgX3oubm9ybWFsaXplKCk7XG5cbiAgICAgIF94LmNyb3NzVmVjdG9ycyh1cCwgX3opO1xuXG4gICAgICBpZiAoX3gubGVuZ3RoU3EoKSA9PT0gMCkge1xuICAgICAgICAvLyB1cCBhbmQgeiBhcmUgcGFyYWxsZWxcbiAgICAgICAgaWYgKE1hdGguYWJzKHVwLnopID09PSAxKSB7XG4gICAgICAgICAgX3oueCArPSAwLjAwMDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3oueiArPSAwLjAwMDE7XG4gICAgICAgIH1cblxuICAgICAgICBfei5ub3JtYWxpemUoKTtcblxuICAgICAgICBfeC5jcm9zc1ZlY3RvcnModXAsIF96KTtcbiAgICAgIH1cblxuICAgICAgX3gubm9ybWFsaXplKCk7XG5cbiAgICAgIF95LmNyb3NzVmVjdG9ycyhfeiwgX3gpO1xuXG4gICAgICB0ZVswXSA9IF94Lng7XG4gICAgICB0ZVs0XSA9IF95Lng7XG4gICAgICB0ZVs4XSA9IF96Lng7XG4gICAgICB0ZVsxXSA9IF94Lnk7XG4gICAgICB0ZVs1XSA9IF95Lnk7XG4gICAgICB0ZVs5XSA9IF96Lnk7XG4gICAgICB0ZVsyXSA9IF94Lno7XG4gICAgICB0ZVs2XSA9IF95Lno7XG4gICAgICB0ZVsxMF0gPSBfei56O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5KG0sIG4pIHtcbiAgICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyhtLCBuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLCBtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlbXVsdGlwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlbXVsdGlwbHkobSkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyhtLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibXVsdGlwbHlNYXRyaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtdWx0aXBseU1hdHJpY2VzKGEsIGIpIHtcbiAgICAgIHZhciBhZSA9IGEuZWxlbWVudHM7XG4gICAgICB2YXIgYmUgPSBiLmVsZW1lbnRzO1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciBhMTEgPSBhZVswXSxcbiAgICAgICAgICBhMTIgPSBhZVs0XSxcbiAgICAgICAgICBhMTMgPSBhZVs4XSxcbiAgICAgICAgICBhMTQgPSBhZVsxMl07XG4gICAgICB2YXIgYTIxID0gYWVbMV0sXG4gICAgICAgICAgYTIyID0gYWVbNV0sXG4gICAgICAgICAgYTIzID0gYWVbOV0sXG4gICAgICAgICAgYTI0ID0gYWVbMTNdO1xuICAgICAgdmFyIGEzMSA9IGFlWzJdLFxuICAgICAgICAgIGEzMiA9IGFlWzZdLFxuICAgICAgICAgIGEzMyA9IGFlWzEwXSxcbiAgICAgICAgICBhMzQgPSBhZVsxNF07XG4gICAgICB2YXIgYTQxID0gYWVbM10sXG4gICAgICAgICAgYTQyID0gYWVbN10sXG4gICAgICAgICAgYTQzID0gYWVbMTFdLFxuICAgICAgICAgIGE0NCA9IGFlWzE1XTtcbiAgICAgIHZhciBiMTEgPSBiZVswXSxcbiAgICAgICAgICBiMTIgPSBiZVs0XSxcbiAgICAgICAgICBiMTMgPSBiZVs4XSxcbiAgICAgICAgICBiMTQgPSBiZVsxMl07XG4gICAgICB2YXIgYjIxID0gYmVbMV0sXG4gICAgICAgICAgYjIyID0gYmVbNV0sXG4gICAgICAgICAgYjIzID0gYmVbOV0sXG4gICAgICAgICAgYjI0ID0gYmVbMTNdO1xuICAgICAgdmFyIGIzMSA9IGJlWzJdLFxuICAgICAgICAgIGIzMiA9IGJlWzZdLFxuICAgICAgICAgIGIzMyA9IGJlWzEwXSxcbiAgICAgICAgICBiMzQgPSBiZVsxNF07XG4gICAgICB2YXIgYjQxID0gYmVbM10sXG4gICAgICAgICAgYjQyID0gYmVbN10sXG4gICAgICAgICAgYjQzID0gYmVbMTFdLFxuICAgICAgICAgIGI0NCA9IGJlWzE1XTtcbiAgICAgIHRlWzBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuICAgICAgdGVbNF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG4gICAgICB0ZVs4XSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcbiAgICAgIHRlWzEyXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcbiAgICAgIHRlWzFdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xuICAgICAgdGVbNV0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XG4gICAgICB0ZVs5XSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0MztcbiAgICAgIHRlWzEzXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcbiAgICAgIHRlWzJdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuICAgICAgdGVbNl0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG4gICAgICB0ZVsxMF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG4gICAgICB0ZVsxNF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG4gICAgICB0ZVszXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcbiAgICAgIHRlWzddID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuICAgICAgdGVbMTFdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuICAgICAgdGVbMTVdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm11bHRpcGx5U2NhbGFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKHMpIHtcbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB0ZVswXSAqPSBzO1xuICAgICAgdGVbNF0gKj0gcztcbiAgICAgIHRlWzhdICo9IHM7XG4gICAgICB0ZVsxMl0gKj0gcztcbiAgICAgIHRlWzFdICo9IHM7XG4gICAgICB0ZVs1XSAqPSBzO1xuICAgICAgdGVbOV0gKj0gcztcbiAgICAgIHRlWzEzXSAqPSBzO1xuICAgICAgdGVbMl0gKj0gcztcbiAgICAgIHRlWzZdICo9IHM7XG4gICAgICB0ZVsxMF0gKj0gcztcbiAgICAgIHRlWzE0XSAqPSBzO1xuICAgICAgdGVbM10gKj0gcztcbiAgICAgIHRlWzddICo9IHM7XG4gICAgICB0ZVsxMV0gKj0gcztcbiAgICAgIHRlWzE1XSAqPSBzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluYW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGVybWluYW50KCkge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciBuMTEgPSB0ZVswXSxcbiAgICAgICAgICBuMTIgPSB0ZVs0XSxcbiAgICAgICAgICBuMTMgPSB0ZVs4XSxcbiAgICAgICAgICBuMTQgPSB0ZVsxMl07XG4gICAgICB2YXIgbjIxID0gdGVbMV0sXG4gICAgICAgICAgbjIyID0gdGVbNV0sXG4gICAgICAgICAgbjIzID0gdGVbOV0sXG4gICAgICAgICAgbjI0ID0gdGVbMTNdO1xuICAgICAgdmFyIG4zMSA9IHRlWzJdLFxuICAgICAgICAgIG4zMiA9IHRlWzZdLFxuICAgICAgICAgIG4zMyA9IHRlWzEwXSxcbiAgICAgICAgICBuMzQgPSB0ZVsxNF07XG4gICAgICB2YXIgbjQxID0gdGVbM10sXG4gICAgICAgICAgbjQyID0gdGVbN10sXG4gICAgICAgICAgbjQzID0gdGVbMTFdLFxuICAgICAgICAgIG40NCA9IHRlWzE1XTsgLy9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcbiAgICAgIC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG4gICAgICByZXR1cm4gbjQxICogKCtuMTQgKiBuMjMgKiBuMzIgLSBuMTMgKiBuMjQgKiBuMzIgLSBuMTQgKiBuMjIgKiBuMzMgKyBuMTIgKiBuMjQgKiBuMzMgKyBuMTMgKiBuMjIgKiBuMzQgLSBuMTIgKiBuMjMgKiBuMzQpICsgbjQyICogKCtuMTEgKiBuMjMgKiBuMzQgLSBuMTEgKiBuMjQgKiBuMzMgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEpICsgbjQzICogKCtuMTEgKiBuMjQgKiBuMzIgLSBuMTEgKiBuMjIgKiBuMzQgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgKyBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEpICsgbjQ0ICogKC1uMTMgKiBuMjIgKiBuMzEgLSBuMTEgKiBuMjMgKiBuMzIgKyBuMTEgKiBuMjIgKiBuMzMgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTIgKiBuMjMgKiBuMzEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNwb3NlKCkge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciB0bXA7XG4gICAgICB0bXAgPSB0ZVsxXTtcbiAgICAgIHRlWzFdID0gdGVbNF07XG4gICAgICB0ZVs0XSA9IHRtcDtcbiAgICAgIHRtcCA9IHRlWzJdO1xuICAgICAgdGVbMl0gPSB0ZVs4XTtcbiAgICAgIHRlWzhdID0gdG1wO1xuICAgICAgdG1wID0gdGVbNl07XG4gICAgICB0ZVs2XSA9IHRlWzldO1xuICAgICAgdGVbOV0gPSB0bXA7XG4gICAgICB0bXAgPSB0ZVszXTtcbiAgICAgIHRlWzNdID0gdGVbMTJdO1xuICAgICAgdGVbMTJdID0gdG1wO1xuICAgICAgdG1wID0gdGVbN107XG4gICAgICB0ZVs3XSA9IHRlWzEzXTtcbiAgICAgIHRlWzEzXSA9IHRtcDtcbiAgICAgIHRtcCA9IHRlWzExXTtcbiAgICAgIHRlWzExXSA9IHRlWzE0XTtcbiAgICAgIHRlWzE0XSA9IHRtcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbih4LCB5LCB6KSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICBpZiAoeC5pc1ZlY3RvcjMpIHtcbiAgICAgICAgdGVbMTJdID0geC54O1xuICAgICAgICB0ZVsxM10gPSB4Lnk7XG4gICAgICAgIHRlWzE0XSA9IHguejtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlWzEyXSA9IHg7XG4gICAgICAgIHRlWzEzXSA9IHk7XG4gICAgICAgIHRlWzE0XSA9IHo7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW52ZXJ0KCkge1xuICAgICAgLy8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLFxuICAgICAgICAgIG4xMSA9IHRlWzBdLFxuICAgICAgICAgIG4yMSA9IHRlWzFdLFxuICAgICAgICAgIG4zMSA9IHRlWzJdLFxuICAgICAgICAgIG40MSA9IHRlWzNdLFxuICAgICAgICAgIG4xMiA9IHRlWzRdLFxuICAgICAgICAgIG4yMiA9IHRlWzVdLFxuICAgICAgICAgIG4zMiA9IHRlWzZdLFxuICAgICAgICAgIG40MiA9IHRlWzddLFxuICAgICAgICAgIG4xMyA9IHRlWzhdLFxuICAgICAgICAgIG4yMyA9IHRlWzldLFxuICAgICAgICAgIG4zMyA9IHRlWzEwXSxcbiAgICAgICAgICBuNDMgPSB0ZVsxMV0sXG4gICAgICAgICAgbjE0ID0gdGVbMTJdLFxuICAgICAgICAgIG4yNCA9IHRlWzEzXSxcbiAgICAgICAgICBuMzQgPSB0ZVsxNF0sXG4gICAgICAgICAgbjQ0ID0gdGVbMTVdLFxuICAgICAgICAgIHQxMSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NCxcbiAgICAgICAgICB0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG4gICAgICAgICAgdDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxuICAgICAgICAgIHQxNCA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcbiAgICAgIHZhciBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XG4gICAgICBpZiAoZGV0ID09PSAwKSByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICB2YXIgZGV0SW52ID0gMSAvIGRldDtcbiAgICAgIHRlWzBdID0gdDExICogZGV0SW52O1xuICAgICAgdGVbMV0gPSAobjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0KSAqIGRldEludjtcbiAgICAgIHRlWzJdID0gKG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCkgKiBkZXRJbnY7XG4gICAgICB0ZVszXSA9IChuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMpICogZGV0SW52O1xuICAgICAgdGVbNF0gPSB0MTIgKiBkZXRJbnY7XG4gICAgICB0ZVs1XSA9IChuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQpICogZGV0SW52O1xuICAgICAgdGVbNl0gPSAobjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0KSAqIGRldEludjtcbiAgICAgIHRlWzddID0gKG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MykgKiBkZXRJbnY7XG4gICAgICB0ZVs4XSA9IHQxMyAqIGRldEludjtcbiAgICAgIHRlWzldID0gKG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCkgKiBkZXRJbnY7XG4gICAgICB0ZVsxMF0gPSAobjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0KSAqIGRldEludjtcbiAgICAgIHRlWzExXSA9IChuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMpICogZGV0SW52O1xuICAgICAgdGVbMTJdID0gdDE0ICogZGV0SW52O1xuICAgICAgdGVbMTNdID0gKG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCkgKiBkZXRJbnY7XG4gICAgICB0ZVsxNF0gPSAobjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0KSAqIGRldEludjtcbiAgICAgIHRlWzE1XSA9IChuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMpICogZGV0SW52O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlKHYpIHtcbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB2YXIgeCA9IHYueCxcbiAgICAgICAgICB5ID0gdi55LFxuICAgICAgICAgIHogPSB2Lno7XG4gICAgICB0ZVswXSAqPSB4O1xuICAgICAgdGVbNF0gKj0geTtcbiAgICAgIHRlWzhdICo9IHo7XG4gICAgICB0ZVsxXSAqPSB4O1xuICAgICAgdGVbNV0gKj0geTtcbiAgICAgIHRlWzldICo9IHo7XG4gICAgICB0ZVsyXSAqPSB4O1xuICAgICAgdGVbNl0gKj0geTtcbiAgICAgIHRlWzEwXSAqPSB6O1xuICAgICAgdGVbM10gKj0geDtcbiAgICAgIHRlWzddICo9IHk7XG4gICAgICB0ZVsxMV0gKj0gejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXhTY2FsZU9uQXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhTY2FsZU9uQXhpcygpIHtcbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB2YXIgc2NhbGVYU3EgPSB0ZVswXSAqIHRlWzBdICsgdGVbMV0gKiB0ZVsxXSArIHRlWzJdICogdGVbMl07XG4gICAgICB2YXIgc2NhbGVZU3EgPSB0ZVs0XSAqIHRlWzRdICsgdGVbNV0gKiB0ZVs1XSArIHRlWzZdICogdGVbNl07XG4gICAgICB2YXIgc2NhbGVaU3EgPSB0ZVs4XSAqIHRlWzhdICsgdGVbOV0gKiB0ZVs5XSArIHRlWzEwXSAqIHRlWzEwXTtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYWtlVHJhbnNsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVRyYW5zbGF0aW9uKHgsIHksIHopIHtcbiAgICAgIHRoaXMuc2V0KDEsIDAsIDAsIHgsIDAsIDEsIDAsIHksIDAsIDAsIDEsIHosIDAsIDAsIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VSb3RhdGlvblhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVJvdGF0aW9uWCh0aGV0YSkge1xuICAgICAgdmFyIGMgPSBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgcyA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHRoaXMuc2V0KDEsIDAsIDAsIDAsIDAsIGMsIC1zLCAwLCAwLCBzLCBjLCAwLCAwLCAwLCAwLCAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYWtlUm90YXRpb25ZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VSb3RhdGlvblkodGhldGEpIHtcbiAgICAgIHZhciBjID0gTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgIHMgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICB0aGlzLnNldChjLCAwLCBzLCAwLCAwLCAxLCAwLCAwLCAtcywgMCwgYywgMCwgMCwgMCwgMCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFrZVJvdGF0aW9uWlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlUm90YXRpb25aKHRoZXRhKSB7XG4gICAgICB2YXIgYyA9IE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgdGhpcy5zZXQoYywgLXMsIDAsIDAsIHMsIGMsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VSb3RhdGlvbkF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVJvdGF0aW9uQXhpcyhheGlzLCBhbmdsZSkge1xuICAgICAgLy8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG4gICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdmFyIHQgPSAxIC0gYztcbiAgICAgIHZhciB4ID0gYXhpcy54LFxuICAgICAgICAgIHkgPSBheGlzLnksXG4gICAgICAgICAgeiA9IGF4aXMuejtcbiAgICAgIHZhciB0eCA9IHQgKiB4LFxuICAgICAgICAgIHR5ID0gdCAqIHk7XG4gICAgICB0aGlzLnNldCh0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsIHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCwgdHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLCAwLCAwLCAwLCAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYWtlU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVNjYWxlKHgsIHksIHopIHtcbiAgICAgIHRoaXMuc2V0KHgsIDAsIDAsIDAsIDAsIHksIDAsIDAsIDAsIDAsIHosIDAsIDAsIDAsIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VTaGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlU2hlYXIoeHksIHh6LCB5eCwgeXosIHp4LCB6eSkge1xuICAgICAgdGhpcy5zZXQoMSwgeXgsIHp4LCAwLCB4eSwgMSwgenksIDAsIHh6LCB5eiwgMSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb3NlKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSkge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciB4ID0gcXVhdGVybmlvbi5feCxcbiAgICAgICAgICB5ID0gcXVhdGVybmlvbi5feSxcbiAgICAgICAgICB6ID0gcXVhdGVybmlvbi5feixcbiAgICAgICAgICB3ID0gcXVhdGVybmlvbi5fdztcbiAgICAgIHZhciB4MiA9IHggKyB4LFxuICAgICAgICAgIHkyID0geSArIHksXG4gICAgICAgICAgejIgPSB6ICsgejtcbiAgICAgIHZhciB4eCA9IHggKiB4MixcbiAgICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgICB4eiA9IHggKiB6MjtcbiAgICAgIHZhciB5eSA9IHkgKiB5MixcbiAgICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgICB6eiA9IHogKiB6MjtcbiAgICAgIHZhciB3eCA9IHcgKiB4MixcbiAgICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgICB3eiA9IHcgKiB6MjtcbiAgICAgIHZhciBzeCA9IHNjYWxlLngsXG4gICAgICAgICAgc3kgPSBzY2FsZS55LFxuICAgICAgICAgIHN6ID0gc2NhbGUuejtcbiAgICAgIHRlWzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gICAgICB0ZVsxXSA9ICh4eSArIHd6KSAqIHN4O1xuICAgICAgdGVbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgICAgIHRlWzNdID0gMDtcbiAgICAgIHRlWzRdID0gKHh5IC0gd3opICogc3k7XG4gICAgICB0ZVs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICAgICAgdGVbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgICAgIHRlWzddID0gMDtcbiAgICAgIHRlWzhdID0gKHh6ICsgd3kpICogc3o7XG4gICAgICB0ZVs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICAgICAgdGVbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gICAgICB0ZVsxMV0gPSAwO1xuICAgICAgdGVbMTJdID0gcG9zaXRpb24ueDtcbiAgICAgIHRlWzEzXSA9IHBvc2l0aW9uLnk7XG4gICAgICB0ZVsxNF0gPSBwb3NpdGlvbi56O1xuICAgICAgdGVbMTVdID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvbXBvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb21wb3NlKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSkge1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgdmFyIHN4ID0gX3YxJDUuc2V0KHRlWzBdLCB0ZVsxXSwgdGVbMl0pLmxlbmd0aCgpO1xuXG4gICAgICB2YXIgc3kgPSBfdjEkNS5zZXQodGVbNF0sIHRlWzVdLCB0ZVs2XSkubGVuZ3RoKCk7XG5cbiAgICAgIHZhciBzeiA9IF92MSQ1LnNldCh0ZVs4XSwgdGVbOV0sIHRlWzEwXSkubGVuZ3RoKCk7IC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG5cblxuICAgICAgdmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcbiAgICAgIGlmIChkZXQgPCAwKSBzeCA9IC1zeDtcbiAgICAgIHBvc2l0aW9uLnggPSB0ZVsxMl07XG4gICAgICBwb3NpdGlvbi55ID0gdGVbMTNdO1xuICAgICAgcG9zaXRpb24ueiA9IHRlWzE0XTsgLy8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcblxuICAgICAgX20xJDIuY29weSh0aGlzKTtcblxuICAgICAgdmFyIGludlNYID0gMSAvIHN4O1xuICAgICAgdmFyIGludlNZID0gMSAvIHN5O1xuICAgICAgdmFyIGludlNaID0gMSAvIHN6O1xuICAgICAgX20xJDIuZWxlbWVudHNbMF0gKj0gaW52U1g7XG4gICAgICBfbTEkMi5lbGVtZW50c1sxXSAqPSBpbnZTWDtcbiAgICAgIF9tMSQyLmVsZW1lbnRzWzJdICo9IGludlNYO1xuICAgICAgX20xJDIuZWxlbWVudHNbNF0gKj0gaW52U1k7XG4gICAgICBfbTEkMi5lbGVtZW50c1s1XSAqPSBpbnZTWTtcbiAgICAgIF9tMSQyLmVsZW1lbnRzWzZdICo9IGludlNZO1xuICAgICAgX20xJDIuZWxlbWVudHNbOF0gKj0gaW52U1o7XG4gICAgICBfbTEkMi5lbGVtZW50c1s5XSAqPSBpbnZTWjtcbiAgICAgIF9tMSQyLmVsZW1lbnRzWzEwXSAqPSBpbnZTWjtcbiAgICAgIHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KF9tMSQyKTtcbiAgICAgIHNjYWxlLnggPSBzeDtcbiAgICAgIHNjYWxlLnkgPSBzeTtcbiAgICAgIHNjYWxlLnogPSBzejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYWtlUGVyc3BlY3RpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZVBlcnNwZWN0aXZlKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKSB7XG4gICAgICBpZiAoZmFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5NYXRyaXg0OiAubWFrZVBlcnNwZWN0aXZlKCkgaGFzIGJlZW4gcmVkZWZpbmVkIGFuZCBoYXMgYSBuZXcgc2lnbmF0dXJlLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3MuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB2YXIgeCA9IDIgKiBuZWFyIC8gKHJpZ2h0IC0gbGVmdCk7XG4gICAgICB2YXIgeSA9IDIgKiBuZWFyIC8gKHRvcCAtIGJvdHRvbSk7XG4gICAgICB2YXIgYSA9IChyaWdodCArIGxlZnQpIC8gKHJpZ2h0IC0gbGVmdCk7XG4gICAgICB2YXIgYiA9ICh0b3AgKyBib3R0b20pIC8gKHRvcCAtIGJvdHRvbSk7XG4gICAgICB2YXIgYyA9IC0oZmFyICsgbmVhcikgLyAoZmFyIC0gbmVhcik7XG4gICAgICB2YXIgZCA9IC0yICogZmFyICogbmVhciAvIChmYXIgLSBuZWFyKTtcbiAgICAgIHRlWzBdID0geDtcbiAgICAgIHRlWzRdID0gMDtcbiAgICAgIHRlWzhdID0gYTtcbiAgICAgIHRlWzEyXSA9IDA7XG4gICAgICB0ZVsxXSA9IDA7XG4gICAgICB0ZVs1XSA9IHk7XG4gICAgICB0ZVs5XSA9IGI7XG4gICAgICB0ZVsxM10gPSAwO1xuICAgICAgdGVbMl0gPSAwO1xuICAgICAgdGVbNl0gPSAwO1xuICAgICAgdGVbMTBdID0gYztcbiAgICAgIHRlWzE0XSA9IGQ7XG4gICAgICB0ZVszXSA9IDA7XG4gICAgICB0ZVs3XSA9IDA7XG4gICAgICB0ZVsxMV0gPSAtMTtcbiAgICAgIHRlWzE1XSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFrZU9ydGhvZ3JhcGhpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlT3J0aG9ncmFwaGljKGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyKSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIHcgPSAxLjAgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICAgIHZhciBoID0gMS4wIC8gKHRvcCAtIGJvdHRvbSk7XG4gICAgICB2YXIgcCA9IDEuMCAvIChmYXIgLSBuZWFyKTtcbiAgICAgIHZhciB4ID0gKHJpZ2h0ICsgbGVmdCkgKiB3O1xuICAgICAgdmFyIHkgPSAodG9wICsgYm90dG9tKSAqIGg7XG4gICAgICB2YXIgeiA9IChmYXIgKyBuZWFyKSAqIHA7XG4gICAgICB0ZVswXSA9IDIgKiB3O1xuICAgICAgdGVbNF0gPSAwO1xuICAgICAgdGVbOF0gPSAwO1xuICAgICAgdGVbMTJdID0gLXg7XG4gICAgICB0ZVsxXSA9IDA7XG4gICAgICB0ZVs1XSA9IDIgKiBoO1xuICAgICAgdGVbOV0gPSAwO1xuICAgICAgdGVbMTNdID0gLXk7XG4gICAgICB0ZVsyXSA9IDA7XG4gICAgICB0ZVs2XSA9IDA7XG4gICAgICB0ZVsxMF0gPSAtMiAqIHA7XG4gICAgICB0ZVsxNF0gPSAtejtcbiAgICAgIHRlWzNdID0gMDtcbiAgICAgIHRlWzddID0gMDtcbiAgICAgIHRlWzExXSA9IDA7XG4gICAgICB0ZVsxNV0gPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMobWF0cml4KSB7XG4gICAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICBmb3IgKHZhciBfaTE3ID0gMDsgX2kxNyA8IDE2OyBfaTE3KyspIHtcbiAgICAgICAgaWYgKHRlW19pMTddICE9PSBtZVtfaTE3XSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21BcnJheShhcnJheSkge1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgZm9yICh2YXIgX2kxOCA9IDA7IF9pMTggPCAxNjsgX2kxOCsrKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbX2kxOF0gPSBhcnJheVtfaTE4ICsgb2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIGFycmF5W29mZnNldF0gPSB0ZVswXTtcbiAgICAgIGFycmF5W29mZnNldCArIDFdID0gdGVbMV07XG4gICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IHRlWzJdO1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSB0ZVszXTtcbiAgICAgIGFycmF5W29mZnNldCArIDRdID0gdGVbNF07XG4gICAgICBhcnJheVtvZmZzZXQgKyA1XSA9IHRlWzVdO1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgNl0gPSB0ZVs2XTtcbiAgICAgIGFycmF5W29mZnNldCArIDddID0gdGVbN107XG4gICAgICBhcnJheVtvZmZzZXQgKyA4XSA9IHRlWzhdO1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgOV0gPSB0ZVs5XTtcbiAgICAgIGFycmF5W29mZnNldCArIDEwXSA9IHRlWzEwXTtcbiAgICAgIGFycmF5W29mZnNldCArIDExXSA9IHRlWzExXTtcbiAgICAgIGFycmF5W29mZnNldCArIDEyXSA9IHRlWzEyXTtcbiAgICAgIGFycmF5W29mZnNldCArIDEzXSA9IHRlWzEzXTtcbiAgICAgIGFycmF5W29mZnNldCArIDE0XSA9IHRlWzE0XTtcbiAgICAgIGFycmF5W29mZnNldCArIDE1XSA9IHRlWzE1XTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWF0cml4NDtcbn0oKTtcblxudmFyIF92MSQ1ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfbTEkMiA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG52YXIgX3plcm8gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG5cbnZhciBfb25lID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDEsIDEsIDEpO1xuXG52YXIgX3ggPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF95ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfeiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX21hdHJpeCQxID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfcXVhdGVybmlvbiQzID0gLypAX19QVVJFX18qL25ldyBRdWF0ZXJuaW9uKCk7XG5cbnZhciBFdWxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N5bWJvbCRpdGVyYXRvcjYpIHtcbiAgZnVuY3Rpb24gRXVsZXIoKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIG9yZGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBFdWxlci5EZWZhdWx0T3JkZXI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXVsZXIpO1xuXG4gICAgdGhpcy5pc0V1bGVyID0gdHJ1ZTtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl96ID0gejtcbiAgICB0aGlzLl9vcmRlciA9IG9yZGVyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEV1bGVyLCBbe1xuICAgIGtleTogXCJ4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl94ID0gdmFsdWU7XG5cbiAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5feSA9IHZhbHVlO1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInpcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl96O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3ogPSB2YWx1ZTtcblxuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcmRlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29yZGVyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuX29yZGVyID0gdmFsdWU7XG5cbiAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldCh4LCB5LCB6KSB7XG4gICAgICB2YXIgb3JkZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRoaXMuX29yZGVyO1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIHRoaXMuX3ogPSB6O1xuICAgICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoZXVsZXIpIHtcbiAgICAgIHRoaXMuX3ggPSBldWxlci5feDtcbiAgICAgIHRoaXMuX3kgPSBldWxlci5feTtcbiAgICAgIHRoaXMuX3ogPSBldWxlci5fejtcbiAgICAgIHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tUm90YXRpb25NYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVJvdGF0aW9uTWF0cml4KG0pIHtcbiAgICAgIHZhciBvcmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5fb3JkZXI7XG4gICAgICB2YXIgdXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcbiAgICAgIHZhciB0ZSA9IG0uZWxlbWVudHM7XG4gICAgICB2YXIgbTExID0gdGVbMF0sXG4gICAgICAgICAgbTEyID0gdGVbNF0sXG4gICAgICAgICAgbTEzID0gdGVbOF07XG4gICAgICB2YXIgbTIxID0gdGVbMV0sXG4gICAgICAgICAgbTIyID0gdGVbNV0sXG4gICAgICAgICAgbTIzID0gdGVbOV07XG4gICAgICB2YXIgbTMxID0gdGVbMl0sXG4gICAgICAgICAgbTMyID0gdGVbNl0sXG4gICAgICAgICAgbTMzID0gdGVbMTBdO1xuXG4gICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICAgIGNhc2UgJ1hZWic6XG4gICAgICAgICAgdGhpcy5feSA9IE1hdGguYXNpbihjbGFtcChtMTMsIC0xLCAxKSk7XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMobTEzKSA8IDAuOTk5OTk5OSkge1xuICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoLW0yMywgbTMzKTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1tMTIsIG0xMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKG0zMiwgbTIyKTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1lYWic6XG4gICAgICAgICAgdGhpcy5feCA9IE1hdGguYXNpbigtY2xhbXAobTIzLCAtMSwgMSkpO1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKG0yMykgPCAwLjk5OTk5OTkpIHtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKG0xMywgbTMzKTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKG0yMSwgbTIyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoLW0zMSwgbTExKTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1pYWSc6XG4gICAgICAgICAgdGhpcy5feCA9IE1hdGguYXNpbihjbGFtcChtMzIsIC0xLCAxKSk7XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMobTMyKSA8IDAuOTk5OTk5OSkge1xuICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoLW0zMSwgbTMzKTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIobTIxLCBtMTEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1pZWCc6XG4gICAgICAgICAgdGhpcy5feSA9IE1hdGguYXNpbigtY2xhbXAobTMxLCAtMSwgMSkpO1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKG0zMSkgPCAwLjk5OTk5OTkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKG0zMiwgbTMzKTtcbiAgICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKG0yMSwgbTExKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMigtbTEyLCBtMjIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1laWCc6XG4gICAgICAgICAgdGhpcy5feiA9IE1hdGguYXNpbihjbGFtcChtMjEsIC0xLCAxKSk7XG5cbiAgICAgICAgICBpZiAoTWF0aC5hYnMobTIxKSA8IDAuOTk5OTk5OSkge1xuICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoLW0yMywgbTIyKTtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKC1tMzEsIG0xMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1haWSc6XG4gICAgICAgICAgdGhpcy5feiA9IE1hdGguYXNpbigtY2xhbXAobTEyLCAtMSwgMSkpO1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKG0xMikgPCAwLjk5OTk5OTkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKG0zMiwgbTIyKTtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKG0xMywgbTExKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoLW0yMywgbTMzKTtcbiAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICcgKyBvcmRlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29yZGVyID0gb3JkZXI7XG4gICAgICBpZiAodXBkYXRlID09PSB0cnVlKSB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbVF1YXRlcm5pb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVF1YXRlcm5pb24ocSwgb3JkZXIsIHVwZGF0ZSkge1xuICAgICAgX21hdHJpeCQxLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpO1xuXG4gICAgICByZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoX21hdHJpeCQxLCBvcmRlciwgdXBkYXRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbVZlY3RvcjNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVZlY3RvcjModikge1xuICAgICAgdmFyIG9yZGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLl9vcmRlcjtcbiAgICAgIHJldHVybiB0aGlzLnNldCh2LngsIHYueSwgdi56LCBvcmRlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVvcmRlcihuZXdPcmRlcikge1xuICAgICAgLy8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuICAgICAgX3F1YXRlcm5pb24kMy5zZXRGcm9tRXVsZXIodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uJDMsIG5ld09yZGVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhldWxlcikge1xuICAgICAgcmV0dXJuIGV1bGVyLl94ID09PSB0aGlzLl94ICYmIGV1bGVyLl95ID09PSB0aGlzLl95ICYmIGV1bGVyLl96ID09PSB0aGlzLl96ICYmIGV1bGVyLl9vcmRlciA9PT0gdGhpcy5fb3JkZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgIHRoaXMuX3ggPSBhcnJheVswXTtcbiAgICAgIHRoaXMuX3kgPSBhcnJheVsxXTtcbiAgICAgIHRoaXMuX3ogPSBhcnJheVsyXTtcbiAgICAgIGlmIChhcnJheVszXSAhPT0gdW5kZWZpbmVkKSB0aGlzLl9vcmRlciA9IGFycmF5WzNdO1xuXG4gICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICAgICAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIGFycmF5W29mZnNldF0gPSB0aGlzLl94O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLl95O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLl96O1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSB0aGlzLl9vcmRlcjtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNoYW5nZShjYWxsYmFjaykge1xuICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkNoYW5nZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNoYW5nZUNhbGxiYWNrKCkge31cbiAgfSwge1xuICAgIGtleTogX1N5bWJvbCRpdGVyYXRvcjYsXG4gICAgdmFsdWU6IC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIHZhbHVlJChfY29udGV4dDcpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3o7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JkZXI7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB2YWx1ZSwgdGhpcyk7XG4gICAgfSkgLy8gQGRlcHJlY2F0ZWQgc2luY2UgcjEzOCwgMDJjZjBkZjFjYjQ1NzVkNTg0MmZlZjljODViYjVhODlmZTAyMGQ1M1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9WZWN0b3IzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvVmVjdG9yMygpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkV1bGVyOiAudG9WZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbUV1bGVyKCkgaW5zdGVhZCcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdWxlcjtcbn0oU3ltYm9sLml0ZXJhdG9yKTtcblxuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XG5FdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnXTtcblxudmFyIExheWVycyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExheWVycygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5ZXJzKTtcblxuICAgIHRoaXMubWFzayA9IDEgfCAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExheWVycywgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChjaGFubmVsKSB7XG4gICAgICB0aGlzLm1hc2sgPSAoMSA8PCBjaGFubmVsIHwgMCkgPj4+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoY2hhbm5lbCkge1xuICAgICAgdGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbCB8IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZUFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVBbGwoKSB7XG4gICAgICB0aGlzLm1hc2sgPSAweGZmZmZmZmZmIHwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShjaGFubmVsKSB7XG4gICAgICB0aGlzLm1hc2sgXj0gMSA8PCBjaGFubmVsIHwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKGNoYW5uZWwpIHtcbiAgICAgIHRoaXMubWFzayAmPSB+KDEgPDwgY2hhbm5lbCB8IDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVBbGwoKSB7XG4gICAgICB0aGlzLm1hc2sgPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlc3QobGF5ZXJzKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWFzayAmIGxheWVycy5tYXNrKSAhPT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNFbmFibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW5hYmxlZChjaGFubmVsKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWFzayAmICgxIDw8IGNoYW5uZWwgfCAwKSkgIT09IDA7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheWVycztcbn0oKTtcblxudmFyIF9vYmplY3QzRElkID0gMDtcblxudmFyIF92MSQ0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfcTEgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxudmFyIF9tMSQxID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfdGFyZ2V0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfcG9zaXRpb24kMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3NjYWxlJDIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9xdWF0ZXJuaW9uJDIgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxudmFyIF94QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygxLCAwLCAwKTtcblxudmFyIF95QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCAxLCAwKTtcblxudmFyIF96QXhpcyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygwLCAwLCAxKTtcblxudmFyIF9hZGRlZEV2ZW50ID0ge1xuICB0eXBlOiAnYWRkZWQnXG59O1xudmFyIF9yZW1vdmVkRXZlbnQgPSB7XG4gIHR5cGU6ICdyZW1vdmVkJ1xufTtcblxudmFyIE9iamVjdDNEID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnREaXNwYXRjaGVyMykge1xuICBfaW5oZXJpdHMoT2JqZWN0M0QsIF9FdmVudERpc3BhdGNoZXIzKTtcblxuICB2YXIgX3N1cGVyOCA9IF9jcmVhdGVTdXBlcihPYmplY3QzRCk7XG5cbiAgZnVuY3Rpb24gT2JqZWN0M0QoKSB7XG4gICAgdmFyIF90aGlzOTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3QzRCk7XG5cbiAgICBfdGhpczkgPSBfc3VwZXI4LmNhbGwodGhpcyk7XG4gICAgX3RoaXM5LmlzT2JqZWN0M0QgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzOSksICdpZCcsIHtcbiAgICAgIHZhbHVlOiBfb2JqZWN0M0RJZCsrXG4gICAgfSk7XG4gICAgX3RoaXM5LnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICBfdGhpczkubmFtZSA9ICcnO1xuICAgIF90aGlzOS50eXBlID0gJ09iamVjdDNEJztcbiAgICBfdGhpczkucGFyZW50ID0gbnVsbDtcbiAgICBfdGhpczkuY2hpbGRyZW4gPSBbXTtcbiAgICBfdGhpczkudXAgPSBPYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIHZhciByb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICB2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMygxLCAxLCAxKTtcblxuICAgIGZ1bmN0aW9uIG9uUm90YXRpb25DaGFuZ2UoKSB7XG4gICAgICBxdWF0ZXJuaW9uLnNldEZyb21FdWxlcihyb3RhdGlvbiwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUXVhdGVybmlvbkNoYW5nZSgpIHtcbiAgICAgIHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJvdGF0aW9uLl9vbkNoYW5nZShvblJvdGF0aW9uQ2hhbmdlKTtcblxuICAgIHF1YXRlcm5pb24uX29uQ2hhbmdlKG9uUXVhdGVybmlvbkNoYW5nZSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzOSksIHtcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHBvc2l0aW9uXG4gICAgICB9LFxuICAgICAgcm90YXRpb246IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogcm90YXRpb25cbiAgICAgIH0sXG4gICAgICBxdWF0ZXJuaW9uOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHF1YXRlcm5pb25cbiAgICAgIH0sXG4gICAgICBzY2FsZToge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBzY2FsZVxuICAgICAgfSxcbiAgICAgIG1vZGVsVmlld01hdHJpeDoge1xuICAgICAgICB2YWx1ZTogbmV3IE1hdHJpeDQoKVxuICAgICAgfSxcbiAgICAgIG5vcm1hbE1hdHJpeDoge1xuICAgICAgICB2YWx1ZTogbmV3IE1hdHJpeDMoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIF90aGlzOS5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIF90aGlzOS5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgX3RoaXM5Lm1hdHJpeEF1dG9VcGRhdGUgPSBPYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcbiAgICBfdGhpczkubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgIF90aGlzOS5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG4gICAgX3RoaXM5LnZpc2libGUgPSB0cnVlO1xuICAgIF90aGlzOS5jYXN0U2hhZG93ID0gZmFsc2U7XG4gICAgX3RoaXM5LnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcbiAgICBfdGhpczkuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgX3RoaXM5LnJlbmRlck9yZGVyID0gMDtcbiAgICBfdGhpczkuYW5pbWF0aW9ucyA9IFtdO1xuICAgIF90aGlzOS51c2VyRGF0YSA9IHt9O1xuICAgIHJldHVybiBfdGhpczk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0M0QsIFt7XG4gICAga2V5OiBcIm9uQmVmb3JlUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uXG4gICAgICAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCAqL1xuICAgIG9uQmVmb3JlUmVuZGVyKCkge31cbiAgfSwge1xuICAgIGtleTogXCJvbkFmdGVyUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uXG4gICAgICAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCAqL1xuICAgIG9uQWZ0ZXJSZW5kZXIoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5TWF0cml4NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseU1hdHJpeDQobWF0cml4KSB7XG4gICAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgdGhpcy5tYXRyaXgucHJlbXVsdGlwbHkobWF0cml4KTtcbiAgICAgIHRoaXMubWF0cml4LmRlY29tcG9zZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVF1YXRlcm5pb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlRdWF0ZXJuaW9uKHEpIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRSb3RhdGlvbkZyb21BeGlzQW5nbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKSB7XG4gICAgICAvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRSb3RhdGlvbkZyb21FdWxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSb3RhdGlvbkZyb21FdWxlcihldWxlcikge1xuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihldWxlciwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFJvdGF0aW9uRnJvbU1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSb3RhdGlvbkZyb21NYXRyaXgobSkge1xuICAgICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgobSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbihxKSB7XG4gICAgICAvLyBhc3N1bWVzIHEgaXMgbm9ybWFsaXplZFxuICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkocSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZU9uQXhpc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVPbkF4aXMoYXhpcywgYW5nbGUpIHtcbiAgICAgIC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcbiAgICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG4gICAgICBfcTEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG5cbiAgICAgIHRoaXMucXVhdGVybmlvbi5tdWx0aXBseShfcTEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZU9uV29ybGRBeGlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZU9uV29ybGRBeGlzKGF4aXMsIGFuZ2xlKSB7XG4gICAgICAvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2VcbiAgICAgIC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG4gICAgICAvLyBtZXRob2QgYXNzdW1lcyBubyByb3RhdGVkIHBhcmVudFxuICAgICAgX3ExLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xuXG4gICAgICB0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoX3ExKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZVgoYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhfeEF4aXMsIGFuZ2xlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVZKGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoX3lBeGlzLCBhbmdsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZVpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlWihhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKF96QXhpcywgYW5nbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2xhdGVPbkF4aXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNsYXRlT25BeGlzKGF4aXMsIGRpc3RhbmNlKSB7XG4gICAgICAvLyB0cmFuc2xhdGUgb2JqZWN0IGJ5IGRpc3RhbmNlIGFsb25nIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG4gICAgICAvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuICAgICAgX3YxJDQuY29weShheGlzKS5hcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcblxuICAgICAgdGhpcy5wb3NpdGlvbi5hZGQoX3YxJDQubXVsdGlwbHlTY2FsYXIoZGlzdGFuY2UpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2xhdGVYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zbGF0ZVgoZGlzdGFuY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhfeEF4aXMsIGRpc3RhbmNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNsYXRlWVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGVZKGRpc3RhbmNlKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoX3lBeGlzLCBkaXN0YW5jZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZVpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNsYXRlWihkaXN0YW5jZSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKF96QXhpcywgZGlzdGFuY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2NhbFRvV29ybGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYWxUb1dvcmxkKHZlY3Rvcikge1xuICAgICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndvcmxkVG9Mb2NhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3b3JsZFRvTG9jYWwodmVjdG9yKSB7XG4gICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NChfbTEkMS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9va0F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvb2tBdCh4LCB5LCB6KSB7XG4gICAgICAvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIHBhcmVudChzKVxuICAgICAgaWYgKHguaXNWZWN0b3IzKSB7XG4gICAgICAgIF90YXJnZXQuY29weSh4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90YXJnZXQuc2V0KHgsIHksIHopO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblxuICAgICAgX3Bvc2l0aW9uJDMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuXG4gICAgICBpZiAodGhpcy5pc0NhbWVyYSB8fCB0aGlzLmlzTGlnaHQpIHtcbiAgICAgICAgX20xJDEubG9va0F0KF9wb3NpdGlvbiQzLCBfdGFyZ2V0LCB0aGlzLnVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9tMSQxLmxvb2tBdChfdGFyZ2V0LCBfcG9zaXRpb24kMywgdGhpcy51cCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xJDEpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIF9tMSQxLmV4dHJhY3RSb3RhdGlvbihwYXJlbnQubWF0cml4V29ybGQpO1xuXG4gICAgICAgIF9xMS5zZXRGcm9tUm90YXRpb25NYXRyaXgoX20xJDEpO1xuXG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShfcTEuaW52ZXJ0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIF9pMTkgPSAwOyBfaTE5IDwgYXJndW1lbnRzLmxlbmd0aDsgX2kxOSsrKSB7XG4gICAgICAgICAgdGhpcy5hZGQoYXJndW1lbnRzW19pMTldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ID09PSB0aGlzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhblxcJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuJywgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QpIHtcbiAgICAgICAgaWYgKG9iamVjdC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBvYmplY3QucGFyZW50LnJlbW92ZShvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChvYmplY3QpO1xuICAgICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudChfYWRkZWRFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuJywgb2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgX2kyMCA9IDA7IF9pMjAgPCBhcmd1bWVudHMubGVuZ3RoOyBfaTIwKyspIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZShhcmd1bWVudHNbX2kyMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihvYmplY3QpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KF9yZW1vdmVkRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRnJvbVBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGcm9tUGFyZW50KCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIGZvciAodmFyIF9pMjEgPSAwOyBfaTIxIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IF9pMjErKykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcy5jaGlsZHJlbltfaTIxXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KF9yZW1vdmVkRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0YWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaChvYmplY3QpIHtcbiAgICAgIC8vIGFkZHMgb2JqZWN0IGFzIGEgY2hpbGQgb2YgdGhpcywgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIG9iamVjdCdzIHdvcmxkIHRyYW5zZm9ybVxuICAgICAgLy8gTm90ZTogVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBzY2VuZSBncmFwaHMgaGF2aW5nIG5vbi11bmlmb3JtbHktc2NhbGVkIG5vZGVzKHMpXG4gICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblxuICAgICAgX20xJDEuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblxuICAgICAgaWYgKG9iamVjdC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgb2JqZWN0LnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgX20xJDEubXVsdGlwbHkob2JqZWN0LnBhcmVudC5tYXRyaXhXb3JsZCk7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdC5hcHBseU1hdHJpeDQoX20xJDEpO1xuICAgICAgdGhpcy5hZGQob2JqZWN0KTtcbiAgICAgIG9iamVjdC51cGRhdGVXb3JsZE1hdHJpeChmYWxzZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T2JqZWN0QnlJZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPYmplY3RCeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCdpZCcsIGlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T2JqZWN0QnlOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9iamVjdEJ5TmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCduYW1lJywgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9iamVjdEJ5UHJvcGVydHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T2JqZWN0QnlQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXNbbmFtZV0gPT09IHZhbHVlKSByZXR1cm4gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2kyMiA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgX2kyMiA8IGw7IF9pMjIrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW19pMjJdO1xuICAgICAgICB2YXIgb2JqZWN0ID0gY2hpbGQuZ2V0T2JqZWN0QnlQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXb3JsZFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdvcmxkUG9zaXRpb24odGFyZ2V0KSB7XG4gICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXb3JsZFF1YXRlcm5pb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V29ybGRRdWF0ZXJuaW9uKHRhcmdldCkge1xuICAgICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gICAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShfcG9zaXRpb24kMywgdGFyZ2V0LCBfc2NhbGUkMik7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXb3JsZFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdvcmxkU2NhbGUodGFyZ2V0KSB7XG4gICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKF9wb3NpdGlvbiQzLCBfcXVhdGVybmlvbiQyLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0V29ybGREaXJlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24odGFyZ2V0KSB7XG4gICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICAgIHZhciBlID0gdGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50cztcbiAgICAgIHJldHVybiB0YXJnZXQuc2V0KGVbOF0sIGVbOV0sIGVbMTBdKS5ub3JtYWxpemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmF5Y2FzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvblxuICAgICAgLyogcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICovXG4gICAgcmF5Y2FzdCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhdmVyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhdmVyc2UoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgX2kyMyA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IF9pMjMgPCBsOyBfaTIzKyspIHtcbiAgICAgICAgY2hpbGRyZW5bX2kyM10udHJhdmVyc2UoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmF2ZXJzZVZpc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhdmVyc2VWaXNpYmxlKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBfaTI0ID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgX2kyNCA8IGw7IF9pMjQrKykge1xuICAgICAgICBjaGlsZHJlbltfaTI0XS50cmF2ZXJzZVZpc2libGUoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmF2ZXJzZUFuY2VzdG9yc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmF2ZXJzZUFuY2VzdG9ycyhjYWxsYmFjaykge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGNhbGxiYWNrKHBhcmVudCk7XG4gICAgICAgIHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyhjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNYXRyaXgoKSB7XG4gICAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVNYXRyaXhXb3JsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuICAgICAgaWYgKHRoaXMubWF0cml4QXV0b1VwZGF0ZSkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgIH0gLy8gdXBkYXRlIGNoaWxkcmVuXG5cblxuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgX2kyNSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IF9pMjUgPCBsOyBfaTI1KyspIHtcbiAgICAgICAgY2hpbGRyZW5bX2kyNV0udXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVXb3JsZE1hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVXb3JsZE1hdHJpeCh1cGRhdGVQYXJlbnRzLCB1cGRhdGVDaGlsZHJlbikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICBpZiAodXBkYXRlUGFyZW50cyA9PT0gdHJ1ZSAmJiBwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF0cml4QXV0b1VwZGF0ZSkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4KTtcbiAgICAgIH0gLy8gdXBkYXRlIGNoaWxkcmVuXG5cblxuICAgICAgaWYgKHVwZGF0ZUNoaWxkcmVuID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgX2kyNiA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IF9pMjYgPCBsOyBfaTI2KyspIHtcbiAgICAgICAgICBjaGlsZHJlbltfaTI2XS51cGRhdGVXb3JsZE1hdHJpeChmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihtZXRhKSB7XG4gICAgICAvLyBtZXRhIGlzIGEgc3RyaW5nIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcbiAgICAgIHZhciBpc1Jvb3RPYmplY3QgPSBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIG91dHB1dCA9IHt9OyAvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuICAgICAgLy8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcbiAgICAgIC8vIGJlaW5nIHNlcmlhbGl6ZWQuXG5cbiAgICAgIGlmIChpc1Jvb3RPYmplY3QpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuICAgICAgICBtZXRhID0ge1xuICAgICAgICAgIGdlb21ldHJpZXM6IHt9LFxuICAgICAgICAgIG1hdGVyaWFsczoge30sXG4gICAgICAgICAgdGV4dHVyZXM6IHt9LFxuICAgICAgICAgIGltYWdlczoge30sXG4gICAgICAgICAgc2hhcGVzOiB7fSxcbiAgICAgICAgICBza2VsZXRvbnM6IHt9LFxuICAgICAgICAgIGFuaW1hdGlvbnM6IHt9LFxuICAgICAgICAgIG5vZGVzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBvdXRwdXQubWV0YWRhdGEgPSB7XG4gICAgICAgICAgdmVyc2lvbjogNC41LFxuICAgICAgICAgIHR5cGU6ICdPYmplY3QnLFxuICAgICAgICAgIGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxuXG5cbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xuICAgICAgb2JqZWN0LnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICBpZiAodGhpcy5uYW1lICE9PSAnJykgb2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICBpZiAodGhpcy5jYXN0U2hhZG93ID09PSB0cnVlKSBvYmplY3QuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgICBpZiAodGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRydWU7XG4gICAgICBpZiAodGhpcy52aXNpYmxlID09PSBmYWxzZSkgb2JqZWN0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmZydXN0dW1DdWxsZWQgPT09IGZhbHNlKSBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMucmVuZGVyT3JkZXIgIT09IDApIG9iamVjdC5yZW5kZXJPcmRlciA9IHRoaXMucmVuZGVyT3JkZXI7XG4gICAgICBpZiAoSlNPTi5zdHJpbmdpZnkodGhpcy51c2VyRGF0YSkgIT09ICd7fScpIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XG4gICAgICBvYmplY3QubGF5ZXJzID0gdGhpcy5sYXllcnMubWFzaztcbiAgICAgIG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XG4gICAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSBmYWxzZSkgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTsgLy8gb2JqZWN0IHNwZWNpZmljIHByb3BlcnRpZXNcblxuICAgICAgaWYgKHRoaXMuaXNJbnN0YW5jZWRNZXNoKSB7XG4gICAgICAgIG9iamVjdC50eXBlID0gJ0luc3RhbmNlZE1lc2gnO1xuICAgICAgICBvYmplY3QuY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBvYmplY3QuaW5zdGFuY2VNYXRyaXggPSB0aGlzLmluc3RhbmNlTWF0cml4LnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUNvbG9yICE9PSBudWxsKSBvYmplY3QuaW5zdGFuY2VDb2xvciA9IHRoaXMuaW5zdGFuY2VDb2xvci50b0pTT04oKTtcbiAgICAgIH0gLy9cblxuXG4gICAgICBmdW5jdGlvbiBzZXJpYWxpemUobGlicmFyeSwgZWxlbWVudCkge1xuICAgICAgICBpZiAobGlicmFyeVtlbGVtZW50LnV1aWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaWJyYXJ5W2VsZW1lbnQudXVpZF0gPSBlbGVtZW50LnRvSlNPTihtZXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50LnV1aWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzU2NlbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xuICAgICAgICAgIGlmICh0aGlzLmJhY2tncm91bmQuaXNDb2xvcikge1xuICAgICAgICAgICAgb2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2tncm91bmQuaXNUZXh0dXJlKSB7XG4gICAgICAgICAgICBvYmplY3QuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04obWV0YSkudXVpZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5lbnZpcm9ubWVudCAmJiB0aGlzLmVudmlyb25tZW50LmlzVGV4dHVyZSkge1xuICAgICAgICAgIG9iamVjdC5lbnZpcm9ubWVudCA9IHRoaXMuZW52aXJvbm1lbnQudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc01lc2ggfHwgdGhpcy5pc0xpbmUgfHwgdGhpcy5pc1BvaW50cykge1xuICAgICAgICBvYmplY3QuZ2VvbWV0cnkgPSBzZXJpYWxpemUobWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5KTtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XG5cbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCAmJiBwYXJhbWV0ZXJzLnNoYXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNoYXBlcyA9IHBhcmFtZXRlcnMuc2hhcGVzO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kyNyA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBfaTI3IDwgbDsgX2kyNysrKSB7XG4gICAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tfaTI3XTtcbiAgICAgICAgICAgICAgc2VyaWFsaXplKG1ldGEuc2hhcGVzLCBzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZShtZXRhLnNoYXBlcywgc2hhcGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNTa2lubmVkTWVzaCkge1xuICAgICAgICBvYmplY3QuYmluZE1vZGUgPSB0aGlzLmJpbmRNb2RlO1xuICAgICAgICBvYmplY3QuYmluZE1hdHJpeCA9IHRoaXMuYmluZE1hdHJpeC50b0FycmF5KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlcmlhbGl6ZShtZXRhLnNrZWxldG9ucywgdGhpcy5za2VsZXRvbik7XG4gICAgICAgICAgb2JqZWN0LnNrZWxldG9uID0gdGhpcy5za2VsZXRvbi51dWlkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5tYXRlcmlhbCkpIHtcbiAgICAgICAgICB2YXIgdXVpZHMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMjggPSAwLCBfbDIgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgX2kyOCA8IF9sMjsgX2kyOCsrKSB7XG4gICAgICAgICAgICB1dWlkcy5wdXNoKHNlcmlhbGl6ZShtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbFtfaTI4XSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9iamVjdC5tYXRlcmlhbCA9IHV1aWRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iamVjdC5tYXRlcmlhbCA9IHNlcmlhbGl6ZShtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy9cblxuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9iamVjdC5jaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pMjkgPSAwOyBfaTI5IDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IF9pMjkrKykge1xuICAgICAgICAgIG9iamVjdC5jaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5bX2kyOV0udG9KU09OKG1ldGEpLm9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy9cblxuXG4gICAgICBpZiAodGhpcy5hbmltYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb2JqZWN0LmFuaW1hdGlvbnMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfaTMwID0gMDsgX2kzMCA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IF9pMzArKykge1xuICAgICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNbX2kzMF07XG4gICAgICAgICAgb2JqZWN0LmFuaW1hdGlvbnMucHVzaChzZXJpYWxpemUobWV0YS5hbmltYXRpb25zLCBhbmltYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNSb290T2JqZWN0KSB7XG4gICAgICAgIHZhciBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLmdlb21ldHJpZXMpO1xuICAgICAgICB2YXIgbWF0ZXJpYWxzID0gZXh0cmFjdEZyb21DYWNoZShtZXRhLm1hdGVyaWFscyk7XG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS50ZXh0dXJlcyk7XG4gICAgICAgIHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEuaW1hZ2VzKTtcblxuICAgICAgICB2YXIgX3NoYXBlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5zaGFwZXMpO1xuXG4gICAgICAgIHZhciBza2VsZXRvbnMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEuc2tlbGV0b25zKTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEuYW5pbWF0aW9ucyk7XG4gICAgICAgIHZhciBub2RlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS5ub2Rlcyk7XG4gICAgICAgIGlmIChnZW9tZXRyaWVzLmxlbmd0aCA+IDApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcbiAgICAgICAgaWYgKG1hdGVyaWFscy5sZW5ndGggPiAwKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuICAgICAgICBpZiAodGV4dHVyZXMubGVuZ3RoID4gMCkgb3V0cHV0LnRleHR1cmVzID0gdGV4dHVyZXM7XG4gICAgICAgIGlmIChpbWFnZXMubGVuZ3RoID4gMCkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcbiAgICAgICAgaWYgKF9zaGFwZXMubGVuZ3RoID4gMCkgb3V0cHV0LnNoYXBlcyA9IF9zaGFwZXM7XG4gICAgICAgIGlmIChza2VsZXRvbnMubGVuZ3RoID4gMCkgb3V0cHV0LnNrZWxldG9ucyA9IHNrZWxldG9ucztcbiAgICAgICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoID4gMCkgb3V0cHV0LmFuaW1hdGlvbnMgPSBhbmltYXRpb25zO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkgb3V0cHV0Lm5vZGVzID0gbm9kZXM7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dC5vYmplY3QgPSBvYmplY3Q7XG4gICAgICByZXR1cm4gb3V0cHV0OyAvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuICAgICAgLy8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuICAgICAgLy8gYW5kIHJldHVybiBhcyBhcnJheVxuXG4gICAgICBmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKGNhY2hlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGNhY2hlW2tleV07XG4gICAgICAgICAgZGVsZXRlIGRhdGEubWV0YWRhdGE7XG4gICAgICAgICAgdmFsdWVzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZShyZWN1cnNpdmUpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcywgcmVjdXJzaXZlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuICAgICAgdGhpcy51cC5jb3B5KHNvdXJjZS51cCk7XG4gICAgICB0aGlzLnBvc2l0aW9uLmNvcHkoc291cmNlLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMucm90YXRpb24ub3JkZXIgPSBzb3VyY2Uucm90YXRpb24ub3JkZXI7XG4gICAgICB0aGlzLnF1YXRlcm5pb24uY29weShzb3VyY2UucXVhdGVybmlvbik7XG4gICAgICB0aGlzLnNjYWxlLmNvcHkoc291cmNlLnNjYWxlKTtcbiAgICAgIHRoaXMubWF0cml4LmNvcHkoc291cmNlLm1hdHJpeCk7XG4gICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkoc291cmNlLm1hdHJpeFdvcmxkKTtcbiAgICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG4gICAgICB0aGlzLmxheWVycy5tYXNrID0gc291cmNlLmxheWVycy5tYXNrO1xuICAgICAgdGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG4gICAgICB0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcbiAgICAgIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xuICAgICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gc291cmNlLmZydXN0dW1DdWxsZWQ7XG4gICAgICB0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xuICAgICAgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc291cmNlLnVzZXJEYXRhKSk7XG5cbiAgICAgIGlmIChyZWN1cnNpdmUgPT09IHRydWUpIHtcbiAgICAgICAgZm9yICh2YXIgX2kzMSA9IDA7IF9pMzEgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBfaTMxKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bX2kzMV07XG4gICAgICAgICAgdGhpcy5hZGQoY2hpbGQuY2xvbmUoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9iamVjdDNEO1xufShFdmVudERpc3BhdGNoZXIpO1xuXG5PYmplY3QzRC5EZWZhdWx0VXAgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcbk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblxudmFyIF92MCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdjEkMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3YyJDIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF92MyQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdmFiID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdmFjID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdmJjID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdmFwID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdmJwID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdmNwID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBUcmlhbmdsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRyaWFuZ2xlKCkge1xuICAgIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgVmVjdG9yMygpO1xuICAgIHZhciBiID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBuZXcgVmVjdG9yMygpO1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBuZXcgVmVjdG9yMygpO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlKTtcblxuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRyaWFuZ2xlLCBbe1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGEsIGIsIGMpIHtcbiAgICAgIHRoaXMuYS5jb3B5KGEpO1xuICAgICAgdGhpcy5iLmNvcHkoYik7XG4gICAgICB0aGlzLmMuY29weShjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tUG9pbnRzQW5kSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tUG9pbnRzQW5kSW5kaWNlcyhwb2ludHMsIGkwLCBpMSwgaTIpIHtcbiAgICAgIHRoaXMuYS5jb3B5KHBvaW50c1tpMF0pO1xuICAgICAgdGhpcy5iLmNvcHkocG9pbnRzW2kxXSk7XG4gICAgICB0aGlzLmMuY29weShwb2ludHNbaTJdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tQXR0cmlidXRlQW5kSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tQXR0cmlidXRlQW5kSW5kaWNlcyhhdHRyaWJ1dGUsIGkwLCBpMSwgaTIpIHtcbiAgICAgIHRoaXMuYS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSwgaTApO1xuICAgICAgdGhpcy5iLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpMSk7XG4gICAgICB0aGlzLmMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGkyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weSh0cmlhbmdsZSkge1xuICAgICAgdGhpcy5hLmNvcHkodHJpYW5nbGUuYSk7XG4gICAgICB0aGlzLmIuY29weSh0cmlhbmdsZS5iKTtcbiAgICAgIHRoaXMuYy5jb3B5KHRyaWFuZ2xlLmMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXJlYSgpIHtcbiAgICAgIF92MCQxLnN1YlZlY3RvcnModGhpcy5jLCB0aGlzLmIpO1xuXG4gICAgICBfdjEkMy5zdWJWZWN0b3JzKHRoaXMuYSwgdGhpcy5iKTtcblxuICAgICAgcmV0dXJuIF92MCQxLmNyb3NzKF92MSQzKS5sZW5ndGgoKSAqIDAuNTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWlkcG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWlkcG9pbnQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmFkZFZlY3RvcnModGhpcy5hLCB0aGlzLmIpLmFkZCh0aGlzLmMpLm11bHRpcGx5U2NhbGFyKDEgLyAzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9ybWFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vcm1hbCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBUcmlhbmdsZS5nZXROb3JtYWwodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGFyZ2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGxhbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxhbmUodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LnNldEZyb21Db3BsYW5hclBvaW50cyh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFyeWNvb3JkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhcnljb29yZChwb2ludCwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gVHJpYW5nbGUuZ2V0QmFyeWNvb3JkKHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0YXJnZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRVVlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVVihwb2ludCwgdXYxLCB1djIsIHV2MywgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gVHJpYW5nbGUuZ2V0VVYocG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHV2MSwgdXYyLCB1djMsIHRhcmdldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRhaW5zUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgcmV0dXJuIFRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQocG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0Zyb250RmFjaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRnJvbnRGYWNpbmcoZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gVHJpYW5nbGUuaXNGcm9udEZhY2luZyh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RzQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdHNCb3goYm94KSB7XG4gICAgICByZXR1cm4gYm94LmludGVyc2VjdHNUcmlhbmdsZSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VzdFBvaW50VG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KHAsIHRhcmdldCkge1xuICAgICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgICBjID0gdGhpcy5jO1xuICAgICAgdmFyIHYsIHc7IC8vIGFsZ29yaXRobSB0aGFua3MgdG8gUmVhbC1UaW1lIENvbGxpc2lvbiBEZXRlY3Rpb24gYnkgQ2hyaXN0ZXIgRXJpY3NvbixcbiAgICAgIC8vIHB1Ymxpc2hlZCBieSBNb3JnYW4gS2F1Zm1hbm4gUHVibGlzaGVycywgKGMpIDIwMDUgRWxzZXZpZXIgSW5jLixcbiAgICAgIC8vIHVuZGVyIHRoZSBhY2NvbXBhbnlpbmcgbGljZW5zZTsgc2VlIGNoYXB0ZXIgNS4xLjUgZm9yIGRldGFpbGVkIGV4cGxhbmF0aW9uLlxuICAgICAgLy8gYmFzaWNhbGx5LCB3ZSdyZSBkaXN0aW5ndWlzaGluZyB3aGljaCBvZiB0aGUgdm9yb25vaSByZWdpb25zIG9mIHRoZSB0cmlhbmdsZVxuICAgICAgLy8gdGhlIHBvaW50IGxpZXMgaW4gd2l0aCB0aGUgbWluaW11bSBhbW91bnQgb2YgcmVkdW5kYW50IGNvbXB1dGF0aW9uLlxuXG4gICAgICBfdmFiLnN1YlZlY3RvcnMoYiwgYSk7XG5cbiAgICAgIF92YWMuc3ViVmVjdG9ycyhjLCBhKTtcblxuICAgICAgX3ZhcC5zdWJWZWN0b3JzKHAsIGEpO1xuXG4gICAgICB2YXIgZDEgPSBfdmFiLmRvdChfdmFwKTtcblxuICAgICAgdmFyIGQyID0gX3ZhYy5kb3QoX3ZhcCk7XG5cbiAgICAgIGlmIChkMSA8PSAwICYmIGQyIDw9IDApIHtcbiAgICAgICAgLy8gdmVydGV4IHJlZ2lvbiBvZiBBOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDEsIDAsIDApXG4gICAgICAgIHJldHVybiB0YXJnZXQuY29weShhKTtcbiAgICAgIH1cblxuICAgICAgX3ZicC5zdWJWZWN0b3JzKHAsIGIpO1xuXG4gICAgICB2YXIgZDMgPSBfdmFiLmRvdChfdmJwKTtcblxuICAgICAgdmFyIGQ0ID0gX3ZhYy5kb3QoX3ZicCk7XG5cbiAgICAgIGlmIChkMyA+PSAwICYmIGQ0IDw9IGQzKSB7XG4gICAgICAgIC8vIHZlcnRleCByZWdpb24gb2YgQjsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAxLCAwKVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvcHkoYik7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YyA9IGQxICogZDQgLSBkMyAqIGQyO1xuXG4gICAgICBpZiAodmMgPD0gMCAmJiBkMSA+PSAwICYmIGQzIDw9IDApIHtcbiAgICAgICAgdiA9IGQxIC8gKGQxIC0gZDMpOyAvLyBlZGdlIHJlZ2lvbiBvZiBBQjsgYmFyeWNlbnRyaWMgY29vcmRzICgxLXYsIHYsIDApXG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5jb3B5KGEpLmFkZFNjYWxlZFZlY3RvcihfdmFiLCB2KTtcbiAgICAgIH1cblxuICAgICAgX3ZjcC5zdWJWZWN0b3JzKHAsIGMpO1xuXG4gICAgICB2YXIgZDUgPSBfdmFiLmRvdChfdmNwKTtcblxuICAgICAgdmFyIGQ2ID0gX3ZhYy5kb3QoX3ZjcCk7XG5cbiAgICAgIGlmIChkNiA+PSAwICYmIGQ1IDw9IGQ2KSB7XG4gICAgICAgIC8vIHZlcnRleCByZWdpb24gb2YgQzsgYmFyeWNlbnRyaWMgY29vcmRzICgwLCAwLCAxKVxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvcHkoYyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YiA9IGQ1ICogZDIgLSBkMSAqIGQ2O1xuXG4gICAgICBpZiAodmIgPD0gMCAmJiBkMiA+PSAwICYmIGQ2IDw9IDApIHtcbiAgICAgICAgdyA9IGQyIC8gKGQyIC0gZDYpOyAvLyBlZGdlIHJlZ2lvbiBvZiBBQzsgYmFyeWNlbnRyaWMgY29vcmRzICgxLXcsIDAsIHcpXG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5jb3B5KGEpLmFkZFNjYWxlZFZlY3RvcihfdmFjLCB3KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhID0gZDMgKiBkNiAtIGQ1ICogZDQ7XG5cbiAgICAgIGlmICh2YSA8PSAwICYmIGQ0IC0gZDMgPj0gMCAmJiBkNSAtIGQ2ID49IDApIHtcbiAgICAgICAgX3ZiYy5zdWJWZWN0b3JzKGMsIGIpO1xuXG4gICAgICAgIHcgPSAoZDQgLSBkMykgLyAoZDQgLSBkMyArIChkNSAtIGQ2KSk7IC8vIGVkZ2UgcmVnaW9uIG9mIEJDOyBiYXJ5Y2VudHJpYyBjb29yZHMgKDAsIDEtdywgdylcblxuICAgICAgICByZXR1cm4gdGFyZ2V0LmNvcHkoYikuYWRkU2NhbGVkVmVjdG9yKF92YmMsIHcpOyAvLyBlZGdlIHJlZ2lvbiBvZiBCQ1xuICAgICAgfSAvLyBmYWNlIHJlZ2lvblxuXG5cbiAgICAgIHZhciBkZW5vbSA9IDEgLyAodmEgKyB2YiArIHZjKTsgLy8gdSA9IHZhICogZGVub21cblxuICAgICAgdiA9IHZiICogZGVub207XG4gICAgICB3ID0gdmMgKiBkZW5vbTtcbiAgICAgIHJldHVybiB0YXJnZXQuY29weShhKS5hZGRTY2FsZWRWZWN0b3IoX3ZhYiwgdikuYWRkU2NhbGVkVmVjdG9yKF92YWMsIHcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcXVhbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXF1YWxzKHRyaWFuZ2xlKSB7XG4gICAgICByZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHModGhpcy5hKSAmJiB0cmlhbmdsZS5iLmVxdWFscyh0aGlzLmIpICYmIHRyaWFuZ2xlLmMuZXF1YWxzKHRoaXMuYyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0Tm9ybWFsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vcm1hbChhLCBiLCBjLCB0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5zdWJWZWN0b3JzKGMsIGIpO1xuXG4gICAgICBfdjAkMS5zdWJWZWN0b3JzKGEsIGIpO1xuXG4gICAgICB0YXJnZXQuY3Jvc3MoX3YwJDEpO1xuICAgICAgdmFyIHRhcmdldExlbmd0aFNxID0gdGFyZ2V0Lmxlbmd0aFNxKCk7XG5cbiAgICAgIGlmICh0YXJnZXRMZW5ndGhTcSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5tdWx0aXBseVNjYWxhcigxIC8gTWF0aC5zcXJ0KHRhcmdldExlbmd0aFNxKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQuc2V0KDAsIDAsIDApO1xuICAgIH0gLy8gc3RhdGljL2luc3RhbmNlIG1ldGhvZCB0byBjYWxjdWxhdGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXNcbiAgICAvLyBiYXNlZCBvbjogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFyeWNvb3JkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhcnljb29yZChwb2ludCwgYSwgYiwgYywgdGFyZ2V0KSB7XG4gICAgICBfdjAkMS5zdWJWZWN0b3JzKGMsIGEpO1xuXG4gICAgICBfdjEkMy5zdWJWZWN0b3JzKGIsIGEpO1xuXG4gICAgICBfdjIkMi5zdWJWZWN0b3JzKHBvaW50LCBhKTtcblxuICAgICAgdmFyIGRvdDAwID0gX3YwJDEuZG90KF92MCQxKTtcblxuICAgICAgdmFyIGRvdDAxID0gX3YwJDEuZG90KF92MSQzKTtcblxuICAgICAgdmFyIGRvdDAyID0gX3YwJDEuZG90KF92MiQyKTtcblxuICAgICAgdmFyIGRvdDExID0gX3YxJDMuZG90KF92MSQzKTtcblxuICAgICAgdmFyIGRvdDEyID0gX3YxJDMuZG90KF92MiQyKTtcblxuICAgICAgdmFyIGRlbm9tID0gZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDE7IC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXG4gICAgICBpZiAoZGVub20gPT09IDApIHtcbiAgICAgICAgLy8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XG4gICAgICAgIC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIHRhcmdldC5zZXQoLTIsIC0xLCAtMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcbiAgICAgIHZhciB1ID0gKGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSAqIGludkRlbm9tO1xuICAgICAgdmFyIHYgPSAoZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpICogaW52RGVub207IC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG5cbiAgICAgIHJldHVybiB0YXJnZXQuc2V0KDEgLSB1IC0gdiwgdiwgdSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRhaW5zUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNQb2ludChwb2ludCwgYSwgYiwgYykge1xuICAgICAgdGhpcy5nZXRCYXJ5Y29vcmQocG9pbnQsIGEsIGIsIGMsIF92MyQxKTtcbiAgICAgIHJldHVybiBfdjMkMS54ID49IDAgJiYgX3YzJDEueSA+PSAwICYmIF92MyQxLnggKyBfdjMkMS55IDw9IDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVWXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVWKHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzLCB0YXJnZXQpIHtcbiAgICAgIHRoaXMuZ2V0QmFyeWNvb3JkKHBvaW50LCBwMSwgcDIsIHAzLCBfdjMkMSk7XG4gICAgICB0YXJnZXQuc2V0KDAsIDApO1xuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcih1djEsIF92MyQxLngpO1xuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcih1djIsIF92MyQxLnkpO1xuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcih1djMsIF92MyQxLnopO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGcm9udEZhY2luZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Zyb250RmFjaW5nKGEsIGIsIGMsIGRpcmVjdGlvbikge1xuICAgICAgX3YwJDEuc3ViVmVjdG9ycyhjLCBiKTtcblxuICAgICAgX3YxJDMuc3ViVmVjdG9ycyhhLCBiKTsgLy8gc3RyaWN0bHkgZnJvbnQgZmFjaW5nXG5cblxuICAgICAgcmV0dXJuIF92MCQxLmNyb3NzKF92MSQzKS5kb3QoZGlyZWN0aW9uKSA8IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRyaWFuZ2xlO1xufSgpO1xuXG52YXIgbWF0ZXJpYWxJZCA9IDA7XG5cbnZhciBNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RGlzcGF0Y2hlcjQpIHtcbiAgX2luaGVyaXRzKE1hdGVyaWFsLCBfRXZlbnREaXNwYXRjaGVyNCk7XG5cbiAgdmFyIF9zdXBlcjkgPSBfY3JlYXRlU3VwZXIoTWF0ZXJpYWwpO1xuXG4gIGZ1bmN0aW9uIE1hdGVyaWFsKCkge1xuICAgIHZhciBfdGhpczEwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hdGVyaWFsKTtcblxuICAgIF90aGlzMTAgPSBfc3VwZXI5LmNhbGwodGhpcyk7XG4gICAgX3RoaXMxMC5pc01hdGVyaWFsID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczEwKSwgJ2lkJywge1xuICAgICAgdmFsdWU6IG1hdGVyaWFsSWQrK1xuICAgIH0pO1xuICAgIF90aGlzMTAudXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgIF90aGlzMTAubmFtZSA9ICcnO1xuICAgIF90aGlzMTAudHlwZSA9ICdNYXRlcmlhbCc7XG4gICAgX3RoaXMxMC5ibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xuICAgIF90aGlzMTAuc2lkZSA9IEZyb250U2lkZTtcbiAgICBfdGhpczEwLnZlcnRleENvbG9ycyA9IGZhbHNlO1xuICAgIF90aGlzMTAub3BhY2l0eSA9IDE7XG4gICAgX3RoaXMxMC50cmFuc3BhcmVudCA9IGZhbHNlO1xuICAgIF90aGlzMTAuYmxlbmRTcmMgPSBTcmNBbHBoYUZhY3RvcjtcbiAgICBfdGhpczEwLmJsZW5kRHN0ID0gT25lTWludXNTcmNBbHBoYUZhY3RvcjtcbiAgICBfdGhpczEwLmJsZW5kRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcbiAgICBfdGhpczEwLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICAgIF90aGlzMTAuYmxlbmREc3RBbHBoYSA9IG51bGw7XG4gICAgX3RoaXMxMC5ibGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuICAgIF90aGlzMTAuZGVwdGhGdW5jID0gTGVzc0VxdWFsRGVwdGg7XG4gICAgX3RoaXMxMC5kZXB0aFRlc3QgPSB0cnVlO1xuICAgIF90aGlzMTAuZGVwdGhXcml0ZSA9IHRydWU7XG4gICAgX3RoaXMxMC5zdGVuY2lsV3JpdGVNYXNrID0gMHhmZjtcbiAgICBfdGhpczEwLnN0ZW5jaWxGdW5jID0gQWx3YXlzU3RlbmNpbEZ1bmM7XG4gICAgX3RoaXMxMC5zdGVuY2lsUmVmID0gMDtcbiAgICBfdGhpczEwLnN0ZW5jaWxGdW5jTWFzayA9IDB4ZmY7XG4gICAgX3RoaXMxMC5zdGVuY2lsRmFpbCA9IEtlZXBTdGVuY2lsT3A7XG4gICAgX3RoaXMxMC5zdGVuY2lsWkZhaWwgPSBLZWVwU3RlbmNpbE9wO1xuICAgIF90aGlzMTAuc3RlbmNpbFpQYXNzID0gS2VlcFN0ZW5jaWxPcDtcbiAgICBfdGhpczEwLnN0ZW5jaWxXcml0ZSA9IGZhbHNlO1xuICAgIF90aGlzMTAuY2xpcHBpbmdQbGFuZXMgPSBudWxsO1xuICAgIF90aGlzMTAuY2xpcEludGVyc2VjdGlvbiA9IGZhbHNlO1xuICAgIF90aGlzMTAuY2xpcFNoYWRvd3MgPSBmYWxzZTtcbiAgICBfdGhpczEwLnNoYWRvd1NpZGUgPSBudWxsO1xuICAgIF90aGlzMTAuY29sb3JXcml0ZSA9IHRydWU7XG4gICAgX3RoaXMxMC5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxuXG4gICAgX3RoaXMxMC5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XG4gICAgX3RoaXMxMC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcbiAgICBfdGhpczEwLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG4gICAgX3RoaXMxMC5kaXRoZXJpbmcgPSBmYWxzZTtcbiAgICBfdGhpczEwLmFscGhhVG9Db3ZlcmFnZSA9IGZhbHNlO1xuICAgIF90aGlzMTAucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG4gICAgX3RoaXMxMC52aXNpYmxlID0gdHJ1ZTtcbiAgICBfdGhpczEwLnRvbmVNYXBwZWQgPSB0cnVlO1xuICAgIF90aGlzMTAudXNlckRhdGEgPSB7fTtcbiAgICBfdGhpczEwLnZlcnNpb24gPSAwO1xuICAgIF90aGlzMTAuX2FscGhhVGVzdCA9IDA7XG4gICAgcmV0dXJuIF90aGlzMTA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWF0ZXJpYWwsIFt7XG4gICAga2V5OiBcImFscGhhVGVzdFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FscGhhVGVzdDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fYWxwaGFUZXN0ID4gMCAhPT0gdmFsdWUgPiAwKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbisrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hbHBoYVRlc3QgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25CdWlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvblxuICAgICAgLyogc2hhZGVyb2JqZWN0LCByZW5kZXJlciAqL1xuICAgIG9uQnVpbGQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm9uQmVmb3JlUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uXG4gICAgICAvKiByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG9iamVjdCwgZ3JvdXAgKi9cbiAgICBvbkJlZm9yZVJlbmRlcigpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25CZWZvcmVDb21waWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uXG4gICAgICAvKiBzaGFkZXJvYmplY3QsIHJlbmRlcmVyICovXG4gICAgb25CZWZvcmVDb21waWxlKCkge31cbiAgfSwge1xuICAgIGtleTogXCJjdXN0b21Qcm9ncmFtQ2FjaGVLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkge1xuICAgICAgcmV0dXJuIHRoaXMub25CZWZvcmVDb21waWxlLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZXModmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlcykge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZXNba2V5XTtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuTWF0ZXJpYWw6IFxcJycgKyBrZXkgKyAnXFwnIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgaWYgc2hhZGluZyBpcyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXG5cblxuICAgICAgICBpZiAoa2V5ID09PSAnc2hhZGluZycpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyk7XG4gICAgICAgICAgdGhpcy5mbGF0U2hhZGluZyA9IG5ld1ZhbHVlID09PSBGbGF0U2hhZGluZyA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogXFwnJyArIGtleSArICdcXCcgaXMgbm90IGEgcHJvcGVydHkgb2YgdGhpcyBtYXRlcmlhbC4nKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLmlzQ29sb3IpIHtcbiAgICAgICAgICBjdXJyZW50VmFsdWUuc2V0KG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLmlzVmVjdG9yMyAmJiBuZXdWYWx1ZSAmJiBuZXdWYWx1ZS5pc1ZlY3RvcjMpIHtcbiAgICAgICAgICBjdXJyZW50VmFsdWUuY29weShuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1trZXldID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihtZXRhKSB7XG4gICAgICB2YXIgaXNSb290T2JqZWN0ID0gbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJztcblxuICAgICAgaWYgKGlzUm9vdE9iamVjdCkge1xuICAgICAgICBtZXRhID0ge1xuICAgICAgICAgIHRleHR1cmVzOiB7fSxcbiAgICAgICAgICBpbWFnZXM6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHZlcnNpb246IDQuNSxcbiAgICAgICAgICB0eXBlOiAnTWF0ZXJpYWwnLFxuICAgICAgICAgIGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcbiAgICAgICAgfVxuICAgICAgfTsgLy8gc3RhbmRhcmQgTWF0ZXJpYWwgc2VyaWFsaXphdGlvblxuXG4gICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICBpZiAodGhpcy5uYW1lICE9PSAnJykgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgaWYgKHRoaXMuY29sb3IgJiYgdGhpcy5jb2xvci5pc0NvbG9yKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgICAgIGlmICh0aGlzLnJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLnJvdWdobmVzcyA9IHRoaXMucm91Z2huZXNzO1xuICAgICAgaWYgKHRoaXMubWV0YWxuZXNzICE9PSB1bmRlZmluZWQpIGRhdGEubWV0YWxuZXNzID0gdGhpcy5tZXRhbG5lc3M7XG4gICAgICBpZiAodGhpcy5zaGVlbiAhPT0gdW5kZWZpbmVkKSBkYXRhLnNoZWVuID0gdGhpcy5zaGVlbjtcbiAgICAgIGlmICh0aGlzLnNoZWVuQ29sb3IgJiYgdGhpcy5zaGVlbkNvbG9yLmlzQ29sb3IpIGRhdGEuc2hlZW5Db2xvciA9IHRoaXMuc2hlZW5Db2xvci5nZXRIZXgoKTtcbiAgICAgIGlmICh0aGlzLnNoZWVuUm91Z2huZXNzICE9PSB1bmRlZmluZWQpIGRhdGEuc2hlZW5Sb3VnaG5lc3MgPSB0aGlzLnNoZWVuUm91Z2huZXNzO1xuICAgICAgaWYgKHRoaXMuZW1pc3NpdmUgJiYgdGhpcy5lbWlzc2l2ZS5pc0NvbG9yKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcbiAgICAgIGlmICh0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICYmIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgIT09IDEpIGRhdGEuZW1pc3NpdmVJbnRlbnNpdHkgPSB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5O1xuICAgICAgaWYgKHRoaXMuc3BlY3VsYXIgJiYgdGhpcy5zcGVjdWxhci5pc0NvbG9yKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcbiAgICAgIGlmICh0aGlzLnNwZWN1bGFySW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIGRhdGEuc3BlY3VsYXJJbnRlbnNpdHkgPSB0aGlzLnNwZWN1bGFySW50ZW5zaXR5O1xuICAgICAgaWYgKHRoaXMuc3BlY3VsYXJDb2xvciAmJiB0aGlzLnNwZWN1bGFyQ29sb3IuaXNDb2xvcikgZGF0YS5zcGVjdWxhckNvbG9yID0gdGhpcy5zcGVjdWxhckNvbG9yLmdldEhleCgpO1xuICAgICAgaWYgKHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQpIGRhdGEuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG4gICAgICBpZiAodGhpcy5jbGVhcmNvYXQgIT09IHVuZGVmaW5lZCkgZGF0YS5jbGVhcmNvYXQgPSB0aGlzLmNsZWFyY29hdDtcbiAgICAgIGlmICh0aGlzLmNsZWFyY29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBkYXRhLmNsZWFyY29hdFJvdWdobmVzcyA9IHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzO1xuXG4gICAgICBpZiAodGhpcy5jbGVhcmNvYXRNYXAgJiYgdGhpcy5jbGVhcmNvYXRNYXAuaXNUZXh0dXJlKSB7XG4gICAgICAgIGRhdGEuY2xlYXJjb2F0TWFwID0gdGhpcy5jbGVhcmNvYXRNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcCAmJiB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcC5pc1RleHR1cmUpIHtcbiAgICAgICAgZGF0YS5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSB0aGlzLmNsZWFyY29hdFJvdWdobmVzc01hcC50b0pTT04obWV0YSkudXVpZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwICYmIHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwLmlzVGV4dHVyZSkge1xuICAgICAgICBkYXRhLmNsZWFyY29hdE5vcm1hbE1hcCA9IHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuICAgICAgICBkYXRhLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gdGhpcy5jbGVhcmNvYXROb3JtYWxTY2FsZS50b0FycmF5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlyaWRlc2NlbmNlICE9PSB1bmRlZmluZWQpIGRhdGEuaXJpZGVzY2VuY2UgPSB0aGlzLmlyaWRlc2NlbmNlO1xuICAgICAgaWYgKHRoaXMuaXJpZGVzY2VuY2VJT1IgIT09IHVuZGVmaW5lZCkgZGF0YS5pcmlkZXNjZW5jZUlPUiA9IHRoaXMuaXJpZGVzY2VuY2VJT1I7XG4gICAgICBpZiAodGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlICE9PSB1bmRlZmluZWQpIGRhdGEuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZTtcblxuICAgICAgaWYgKHRoaXMuaXJpZGVzY2VuY2VNYXAgJiYgdGhpcy5pcmlkZXNjZW5jZU1hcC5pc1RleHR1cmUpIHtcbiAgICAgICAgZGF0YS5pcmlkZXNjZW5jZU1hcCA9IHRoaXMuaXJpZGVzY2VuY2VNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICYmIHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAuaXNUZXh0dXJlKSB7XG4gICAgICAgIGRhdGEuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPSB0aGlzLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXAgJiYgdGhpcy5tYXAuaXNUZXh0dXJlKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTihtZXRhKS51dWlkO1xuICAgICAgaWYgKHRoaXMubWF0Y2FwICYmIHRoaXMubWF0Y2FwLmlzVGV4dHVyZSkgZGF0YS5tYXRjYXAgPSB0aGlzLm1hdGNhcC50b0pTT04obWV0YSkudXVpZDtcbiAgICAgIGlmICh0aGlzLmFscGhhTWFwICYmIHRoaXMuYWxwaGFNYXAuaXNUZXh0dXJlKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04obWV0YSkudXVpZDtcblxuICAgICAgaWYgKHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUpIHtcbiAgICAgICAgZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICAgIGRhdGEubGlnaHRNYXBJbnRlbnNpdHkgPSB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hb01hcCAmJiB0aGlzLmFvTWFwLmlzVGV4dHVyZSkge1xuICAgICAgICBkYXRhLmFvTWFwID0gdGhpcy5hb01hcC50b0pTT04obWV0YSkudXVpZDtcbiAgICAgICAgZGF0YS5hb01hcEludGVuc2l0eSA9IHRoaXMuYW9NYXBJbnRlbnNpdHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJ1bXBNYXAgJiYgdGhpcy5idW1wTWFwLmlzVGV4dHVyZSkge1xuICAgICAgICBkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICAgIGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5vcm1hbE1hcCAmJiB0aGlzLm5vcm1hbE1hcC5pc1RleHR1cmUpIHtcbiAgICAgICAgZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04obWV0YSkudXVpZDtcbiAgICAgICAgZGF0YS5ub3JtYWxNYXBUeXBlID0gdGhpcy5ub3JtYWxNYXBUeXBlO1xuICAgICAgICBkYXRhLm5vcm1hbFNjYWxlID0gdGhpcy5ub3JtYWxTY2FsZS50b0FycmF5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRpc3BsYWNlbWVudE1hcCAmJiB0aGlzLmRpc3BsYWNlbWVudE1hcC5pc1RleHR1cmUpIHtcbiAgICAgICAgZGF0YS5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmRpc3BsYWNlbWVudE1hcC50b0pTT04obWV0YSkudXVpZDtcbiAgICAgICAgZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgICAgIGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucm91Z2huZXNzTWFwICYmIHRoaXMucm91Z2huZXNzTWFwLmlzVGV4dHVyZSkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04obWV0YSkudXVpZDtcbiAgICAgIGlmICh0aGlzLm1ldGFsbmVzc01hcCAmJiB0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUpIGRhdGEubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICBpZiAodGhpcy5lbWlzc2l2ZU1hcCAmJiB0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSkgZGF0YS5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICBpZiAodGhpcy5zcGVjdWxhck1hcCAmJiB0aGlzLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICBpZiAodGhpcy5zcGVjdWxhckludGVuc2l0eU1hcCAmJiB0aGlzLnNwZWN1bGFySW50ZW5zaXR5TWFwLmlzVGV4dHVyZSkgZGF0YS5zcGVjdWxhckludGVuc2l0eU1hcCA9IHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAudG9KU09OKG1ldGEpLnV1aWQ7XG4gICAgICBpZiAodGhpcy5zcGVjdWxhckNvbG9yTWFwICYmIHRoaXMuc3BlY3VsYXJDb2xvck1hcC5pc1RleHR1cmUpIGRhdGEuc3BlY3VsYXJDb2xvck1hcCA9IHRoaXMuc3BlY3VsYXJDb2xvck1hcC50b0pTT04obWV0YSkudXVpZDtcblxuICAgICAgaWYgKHRoaXMuZW52TWFwICYmIHRoaXMuZW52TWFwLmlzVGV4dHVyZSkge1xuICAgICAgICBkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTihtZXRhKS51dWlkO1xuICAgICAgICBpZiAodGhpcy5jb21iaW5lICE9PSB1bmRlZmluZWQpIGRhdGEuY29tYmluZSA9IHRoaXMuY29tYmluZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZW52TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIGRhdGEuZW52TWFwSW50ZW5zaXR5ID0gdGhpcy5lbnZNYXBJbnRlbnNpdHk7XG4gICAgICBpZiAodGhpcy5yZWZsZWN0aXZpdHkgIT09IHVuZGVmaW5lZCkgZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcbiAgICAgIGlmICh0aGlzLnJlZnJhY3Rpb25SYXRpbyAhPT0gdW5kZWZpbmVkKSBkYXRhLnJlZnJhY3Rpb25SYXRpbyA9IHRoaXMucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgICBpZiAodGhpcy5ncmFkaWVudE1hcCAmJiB0aGlzLmdyYWRpZW50TWFwLmlzVGV4dHVyZSkge1xuICAgICAgICBkYXRhLmdyYWRpZW50TWFwID0gdGhpcy5ncmFkaWVudE1hcC50b0pTT04obWV0YSkudXVpZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHJhbnNtaXNzaW9uICE9PSB1bmRlZmluZWQpIGRhdGEudHJhbnNtaXNzaW9uID0gdGhpcy50cmFuc21pc3Npb247XG4gICAgICBpZiAodGhpcy50cmFuc21pc3Npb25NYXAgJiYgdGhpcy50cmFuc21pc3Npb25NYXAuaXNUZXh0dXJlKSBkYXRhLnRyYW5zbWlzc2lvbk1hcCA9IHRoaXMudHJhbnNtaXNzaW9uTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuICAgICAgaWYgKHRoaXMudGhpY2tuZXNzICE9PSB1bmRlZmluZWQpIGRhdGEudGhpY2tuZXNzID0gdGhpcy50aGlja25lc3M7XG4gICAgICBpZiAodGhpcy50aGlja25lc3NNYXAgJiYgdGhpcy50aGlja25lc3NNYXAuaXNUZXh0dXJlKSBkYXRhLnRoaWNrbmVzc01hcCA9IHRoaXMudGhpY2tuZXNzTWFwLnRvSlNPTihtZXRhKS51dWlkO1xuICAgICAgaWYgKHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSBkYXRhLmF0dGVudWF0aW9uRGlzdGFuY2UgPSB0aGlzLmF0dGVudWF0aW9uRGlzdGFuY2U7XG4gICAgICBpZiAodGhpcy5hdHRlbnVhdGlvbkNvbG9yICE9PSB1bmRlZmluZWQpIGRhdGEuYXR0ZW51YXRpb25Db2xvciA9IHRoaXMuYXR0ZW51YXRpb25Db2xvci5nZXRIZXgoKTtcbiAgICAgIGlmICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xuICAgICAgaWYgKHRoaXMuc2hhZG93U2lkZSAhPT0gbnVsbCkgZGF0YS5zaGFkb3dTaWRlID0gdGhpcy5zaGFkb3dTaWRlO1xuICAgICAgaWYgKHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQpIGRhdGEuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XG4gICAgICBpZiAodGhpcy5ibGVuZGluZyAhPT0gTm9ybWFsQmxlbmRpbmcpIGRhdGEuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuICAgICAgaWYgKHRoaXMuc2lkZSAhPT0gRnJvbnRTaWRlKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG4gICAgICBpZiAodGhpcy52ZXJ0ZXhDb2xvcnMpIGRhdGEudmVydGV4Q29sb3JzID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgPCAxKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgICBpZiAodGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XG4gICAgICBkYXRhLmRlcHRoRnVuYyA9IHRoaXMuZGVwdGhGdW5jO1xuICAgICAgZGF0YS5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcbiAgICAgIGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcbiAgICAgIGRhdGEuY29sb3JXcml0ZSA9IHRoaXMuY29sb3JXcml0ZTtcbiAgICAgIGRhdGEuc3RlbmNpbFdyaXRlID0gdGhpcy5zdGVuY2lsV3JpdGU7XG4gICAgICBkYXRhLnN0ZW5jaWxXcml0ZU1hc2sgPSB0aGlzLnN0ZW5jaWxXcml0ZU1hc2s7XG4gICAgICBkYXRhLnN0ZW5jaWxGdW5jID0gdGhpcy5zdGVuY2lsRnVuYztcbiAgICAgIGRhdGEuc3RlbmNpbFJlZiA9IHRoaXMuc3RlbmNpbFJlZjtcbiAgICAgIGRhdGEuc3RlbmNpbEZ1bmNNYXNrID0gdGhpcy5zdGVuY2lsRnVuY01hc2s7XG4gICAgICBkYXRhLnN0ZW5jaWxGYWlsID0gdGhpcy5zdGVuY2lsRmFpbDtcbiAgICAgIGRhdGEuc3RlbmNpbFpGYWlsID0gdGhpcy5zdGVuY2lsWkZhaWw7XG4gICAgICBkYXRhLnN0ZW5jaWxaUGFzcyA9IHRoaXMuc3RlbmNpbFpQYXNzOyAvLyByb3RhdGlvbiAoU3ByaXRlTWF0ZXJpYWwpXG5cbiAgICAgIGlmICh0aGlzLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yb3RhdGlvbiAhPT0gMCkgZGF0YS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICBpZiAodGhpcy5wb2x5Z29uT2Zmc2V0ID09PSB0cnVlKSBkYXRhLnBvbHlnb25PZmZzZXQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMucG9seWdvbk9mZnNldEZhY3RvciAhPT0gMCkgZGF0YS5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuICAgICAgaWYgKHRoaXMucG9seWdvbk9mZnNldFVuaXRzICE9PSAwKSBkYXRhLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMucG9seWdvbk9mZnNldFVuaXRzO1xuICAgICAgaWYgKHRoaXMubGluZXdpZHRoICE9PSB1bmRlZmluZWQgJiYgdGhpcy5saW5ld2lkdGggIT09IDEpIGRhdGEubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XG4gICAgICBpZiAodGhpcy5kYXNoU2l6ZSAhPT0gdW5kZWZpbmVkKSBkYXRhLmRhc2hTaXplID0gdGhpcy5kYXNoU2l6ZTtcbiAgICAgIGlmICh0aGlzLmdhcFNpemUgIT09IHVuZGVmaW5lZCkgZGF0YS5nYXBTaXplID0gdGhpcy5nYXBTaXplO1xuICAgICAgaWYgKHRoaXMuc2NhbGUgIT09IHVuZGVmaW5lZCkgZGF0YS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICBpZiAodGhpcy5kaXRoZXJpbmcgPT09IHRydWUpIGRhdGEuZGl0aGVyaW5nID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmFscGhhVGVzdCA+IDApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG4gICAgICBpZiAodGhpcy5hbHBoYVRvQ292ZXJhZ2UgPT09IHRydWUpIGRhdGEuYWxwaGFUb0NvdmVyYWdlID0gdGhpcy5hbHBoYVRvQ292ZXJhZ2U7XG4gICAgICBpZiAodGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUpIGRhdGEucHJlbXVsdGlwbGllZEFscGhhID0gdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE7XG4gICAgICBpZiAodGhpcy53aXJlZnJhbWUgPT09IHRydWUpIGRhdGEud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG4gICAgICBpZiAodGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgICAgaWYgKHRoaXMud2lyZWZyYW1lTGluZWNhcCAhPT0gJ3JvdW5kJykgZGF0YS53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xuICAgICAgaWYgKHRoaXMud2lyZWZyYW1lTGluZWpvaW4gIT09ICdyb3VuZCcpIGRhdGEud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuICAgICAgaWYgKHRoaXMuZmxhdFNoYWRpbmcgPT09IHRydWUpIGRhdGEuZmxhdFNoYWRpbmcgPSB0aGlzLmZsYXRTaGFkaW5nO1xuICAgICAgaWYgKHRoaXMudmlzaWJsZSA9PT0gZmFsc2UpIGRhdGEudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMudG9uZU1hcHBlZCA9PT0gZmFsc2UpIGRhdGEudG9uZU1hcHBlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuZm9nID09PSBmYWxzZSkgZGF0YS5mb2cgPSBmYWxzZTtcbiAgICAgIGlmIChKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJEYXRhKSAhPT0gJ3t9JykgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7IC8vIFRPRE86IENvcGllZCBmcm9tIE9iamVjdDNELnRvSlNPTlxuXG4gICAgICBmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKGNhY2hlKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICB2YXIgX2RhdGEyID0gY2FjaGVba2V5XTtcbiAgICAgICAgICBkZWxldGUgX2RhdGEyLm1ldGFkYXRhO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKF9kYXRhMik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNSb290T2JqZWN0KSB7XG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUobWV0YS50ZXh0dXJlcyk7XG4gICAgICAgIHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKG1ldGEuaW1hZ2VzKTtcbiAgICAgICAgaWYgKHRleHR1cmVzLmxlbmd0aCA+IDApIGRhdGEudGV4dHVyZXMgPSB0ZXh0dXJlcztcbiAgICAgICAgaWYgKGltYWdlcy5sZW5ndGggPiAwKSBkYXRhLmltYWdlcyA9IGltYWdlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG4gICAgICB0aGlzLmJsZW5kaW5nID0gc291cmNlLmJsZW5kaW5nO1xuICAgICAgdGhpcy5zaWRlID0gc291cmNlLnNpZGU7XG4gICAgICB0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XG4gICAgICB0aGlzLm9wYWNpdHkgPSBzb3VyY2Uub3BhY2l0eTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSBzb3VyY2UudHJhbnNwYXJlbnQ7XG4gICAgICB0aGlzLmJsZW5kU3JjID0gc291cmNlLmJsZW5kU3JjO1xuICAgICAgdGhpcy5ibGVuZERzdCA9IHNvdXJjZS5ibGVuZERzdDtcbiAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbiA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uO1xuICAgICAgdGhpcy5ibGVuZFNyY0FscGhhID0gc291cmNlLmJsZW5kU3JjQWxwaGE7XG4gICAgICB0aGlzLmJsZW5kRHN0QWxwaGEgPSBzb3VyY2UuYmxlbmREc3RBbHBoYTtcbiAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gc291cmNlLmJsZW5kRXF1YXRpb25BbHBoYTtcbiAgICAgIHRoaXMuZGVwdGhGdW5jID0gc291cmNlLmRlcHRoRnVuYztcbiAgICAgIHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcbiAgICAgIHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xuICAgICAgdGhpcy5zdGVuY2lsV3JpdGVNYXNrID0gc291cmNlLnN0ZW5jaWxXcml0ZU1hc2s7XG4gICAgICB0aGlzLnN0ZW5jaWxGdW5jID0gc291cmNlLnN0ZW5jaWxGdW5jO1xuICAgICAgdGhpcy5zdGVuY2lsUmVmID0gc291cmNlLnN0ZW5jaWxSZWY7XG4gICAgICB0aGlzLnN0ZW5jaWxGdW5jTWFzayA9IHNvdXJjZS5zdGVuY2lsRnVuY01hc2s7XG4gICAgICB0aGlzLnN0ZW5jaWxGYWlsID0gc291cmNlLnN0ZW5jaWxGYWlsO1xuICAgICAgdGhpcy5zdGVuY2lsWkZhaWwgPSBzb3VyY2Uuc3RlbmNpbFpGYWlsO1xuICAgICAgdGhpcy5zdGVuY2lsWlBhc3MgPSBzb3VyY2Uuc3RlbmNpbFpQYXNzO1xuICAgICAgdGhpcy5zdGVuY2lsV3JpdGUgPSBzb3VyY2Uuc3RlbmNpbFdyaXRlO1xuICAgICAgdmFyIHNyY1BsYW5lcyA9IHNvdXJjZS5jbGlwcGluZ1BsYW5lcztcbiAgICAgIHZhciBkc3RQbGFuZXMgPSBudWxsO1xuXG4gICAgICBpZiAoc3JjUGxhbmVzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBuID0gc3JjUGxhbmVzLmxlbmd0aDtcbiAgICAgICAgZHN0UGxhbmVzID0gbmV3IEFycmF5KG4pO1xuXG4gICAgICAgIGZvciAodmFyIF9pMzIgPSAwOyBfaTMyICE9PSBuOyArK19pMzIpIHtcbiAgICAgICAgICBkc3RQbGFuZXNbX2kzMl0gPSBzcmNQbGFuZXNbX2kzMl0uY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNsaXBwaW5nUGxhbmVzID0gZHN0UGxhbmVzO1xuICAgICAgdGhpcy5jbGlwSW50ZXJzZWN0aW9uID0gc291cmNlLmNsaXBJbnRlcnNlY3Rpb247XG4gICAgICB0aGlzLmNsaXBTaGFkb3dzID0gc291cmNlLmNsaXBTaGFkb3dzO1xuICAgICAgdGhpcy5zaGFkb3dTaWRlID0gc291cmNlLnNoYWRvd1NpZGU7XG4gICAgICB0aGlzLmNvbG9yV3JpdGUgPSBzb3VyY2UuY29sb3JXcml0ZTtcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gc291cmNlLnByZWNpc2lvbjtcbiAgICAgIHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xuICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XG4gICAgICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XG4gICAgICB0aGlzLmRpdGhlcmluZyA9IHNvdXJjZS5kaXRoZXJpbmc7XG4gICAgICB0aGlzLmFscGhhVGVzdCA9IHNvdXJjZS5hbHBoYVRlc3Q7XG4gICAgICB0aGlzLmFscGhhVG9Db3ZlcmFnZSA9IHNvdXJjZS5hbHBoYVRvQ292ZXJhZ2U7XG4gICAgICB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBsaWVkQWxwaGE7XG4gICAgICB0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcbiAgICAgIHRoaXMudG9uZU1hcHBlZCA9IHNvdXJjZS50b25lTWFwcGVkO1xuICAgICAgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc291cmNlLnVzZXJEYXRhKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2Rpc3Bvc2UnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmVlZHNVcGRhdGVcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcbiAgICB9IC8vIEBkZXByZWNhdGVkIHNpbmNlIHIxMzEsIGY1ODAzYzYyY2M0YTI5ZDkwNzQ0ZTlkYzc4MTFkMDg2ZTM1NGMxZDhcblxuICB9LCB7XG4gICAga2V5OiBcInZlcnRleFRhbmdlbnRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAudmVydGV4VGFuZ2VudHMgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAudmVydGV4VGFuZ2VudHMgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWF0ZXJpYWw7XG59KEV2ZW50RGlzcGF0Y2hlcik7XG5cbk1hdGVyaWFsLmZyb21UeXBlID0gZnVuY3Rpb25cbiAgLyp0eXBlKi9cbigpIHtcbiAgLy8gVE9ETzogQmVoYXZpb3IgYWRkZWQgaW4gTWF0ZXJpYWxzLmpzXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIE1lc2hCYXNpY01hdGVyaWFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWF0ZXJpYWwpIHtcbiAgX2luaGVyaXRzKE1lc2hCYXNpY01hdGVyaWFsLCBfTWF0ZXJpYWwpO1xuXG4gIHZhciBfc3VwZXIxMCA9IF9jcmVhdGVTdXBlcihNZXNoQmFzaWNNYXRlcmlhbCk7XG5cbiAgZnVuY3Rpb24gTWVzaEJhc2ljTWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczExO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc2hCYXNpY01hdGVyaWFsKTtcblxuICAgIF90aGlzMTEgPSBfc3VwZXIxMC5jYWxsKHRoaXMpO1xuICAgIF90aGlzMTEuaXNNZXNoQmFzaWNNYXRlcmlhbCA9IHRydWU7XG4gICAgX3RoaXMxMS50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcbiAgICBfdGhpczExLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZW1pc3NpdmVcblxuICAgIF90aGlzMTEubWFwID0gbnVsbDtcbiAgICBfdGhpczExLmxpZ2h0TWFwID0gbnVsbDtcbiAgICBfdGhpczExLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuICAgIF90aGlzMTEuYW9NYXAgPSBudWxsO1xuICAgIF90aGlzMTEuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG4gICAgX3RoaXMxMS5zcGVjdWxhck1hcCA9IG51bGw7XG4gICAgX3RoaXMxMS5hbHBoYU1hcCA9IG51bGw7XG4gICAgX3RoaXMxMS5lbnZNYXAgPSBudWxsO1xuICAgIF90aGlzMTEuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuICAgIF90aGlzMTEucmVmbGVjdGl2aXR5ID0gMTtcbiAgICBfdGhpczExLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG4gICAgX3RoaXMxMS53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBfdGhpczExLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgX3RoaXMxMS53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICBfdGhpczExLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcbiAgICBfdGhpczExLmZvZyA9IHRydWU7XG5cbiAgICBfdGhpczExLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblxuICAgIHJldHVybiBfdGhpczExO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1lc2hCYXNpY01hdGVyaWFsLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcbiAgICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcbiAgICAgIHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG4gICAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuICAgICAgdGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG4gICAgICB0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuICAgICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcbiAgICAgIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICAgIHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuICAgICAgdGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuICAgICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuICAgICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuICAgICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lc2hCYXNpY01hdGVyaWFsO1xufShNYXRlcmlhbCk7XG5cbnZhciBfdmVjdG9yJDkgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF92ZWN0b3IyJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxudmFyIEJ1ZmZlckF0dHJpYnV0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyQXR0cmlidXRlKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgdGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuICAgIHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemUgOiAwO1xuICAgIHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgdGhpcy51c2FnZSA9IFN0YXRpY0RyYXdVc2FnZTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlID0ge1xuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgY291bnQ6IC0xXG4gICAgfTtcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJ1ZmZlckF0dHJpYnV0ZSwgW3tcbiAgICBrZXk6IFwib25VcGxvYWRDYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblVwbG9hZENhbGxiYWNrKCkge31cbiAgfSwge1xuICAgIGtleTogXCJuZWVkc1VwZGF0ZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHRydWUpIHRoaXMudmVyc2lvbisrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRVc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVc2FnZSh2YWx1ZSkge1xuICAgICAgdGhpcy51c2FnZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIHRoaXMubmFtZSA9IHNvdXJjZS5uYW1lO1xuICAgICAgdGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3Ioc291cmNlLmFycmF5KTtcbiAgICAgIHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XG4gICAgICB0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuICAgICAgdGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG4gICAgICB0aGlzLnVzYWdlID0gc291cmNlLnVzYWdlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5QXQoaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4Mikge1xuICAgICAgaW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG4gICAgICBpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG4gICAgICBmb3IgKHZhciBfaTMzID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IF9pMzMgPCBsOyBfaTMzKyspIHtcbiAgICAgICAgdGhpcy5hcnJheVtpbmRleDEgKyBfaTMzXSA9IGF0dHJpYnV0ZS5hcnJheVtpbmRleDIgKyBfaTMzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyYXkpIHtcbiAgICAgIHRoaXMuYXJyYXkuc2V0KGFycmF5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5Q29sb3JzQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weUNvbG9yc0FycmF5KGNvbG9ycykge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTM0ID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IF9pMzQgPCBsOyBfaTM0KyspIHtcbiAgICAgICAgdmFyIGNvbG9yID0gY29sb3JzW19pMzRdO1xuXG4gICAgICAgIGlmIChjb2xvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIF9pMzQpO1xuICAgICAgICAgIGNvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtvZmZzZXQrK10gPSBjb2xvci5yO1xuICAgICAgICBhcnJheVtvZmZzZXQrK10gPSBjb2xvci5nO1xuICAgICAgICBhcnJheVtvZmZzZXQrK10gPSBjb2xvci5iO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVZlY3RvcjJzQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weVZlY3RvcjJzQXJyYXkodmVjdG9ycykge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTM1ID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBfaTM1IDwgbDsgX2kzNSsrKSB7XG4gICAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzW19pMzVdO1xuXG4gICAgICAgIGlmICh2ZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBfaTM1KTtcbiAgICAgICAgICB2ZWN0b3IgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLng7XG4gICAgICAgIGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci55O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVZlY3RvcjNzQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weVZlY3RvcjNzQXJyYXkodmVjdG9ycykge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTM2ID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBfaTM2IDwgbDsgX2kzNisrKSB7XG4gICAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzW19pMzZdO1xuXG4gICAgICAgIGlmICh2ZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBfaTM2KTtcbiAgICAgICAgICB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLng7XG4gICAgICAgIGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci55O1xuICAgICAgICBhcnJheVtvZmZzZXQrK10gPSB2ZWN0b3IuejtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlWZWN0b3I0c0FycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlWZWN0b3I0c0FycmF5KHZlY3RvcnMpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgZm9yICh2YXIgX2kzNyA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgX2kzNyA8IGw7IF9pMzcrKykge1xuICAgICAgICB2YXIgdmVjdG9yID0gdmVjdG9yc1tfaTM3XTtcblxuICAgICAgICBpZiAodmVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgX2kzNyk7XG4gICAgICAgICAgdmVjdG9yID0gbmV3IFZlY3RvcjQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci54O1xuICAgICAgICBhcnJheVtvZmZzZXQrK10gPSB2ZWN0b3IueTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0KytdID0gdmVjdG9yLno7XG4gICAgICAgIGFycmF5W29mZnNldCsrXSA9IHZlY3Rvci53O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlNYXRyaXgzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5TWF0cml4MyhtKSB7XG4gICAgICBpZiAodGhpcy5pdGVtU2l6ZSA9PT0gMikge1xuICAgICAgICBmb3IgKHZhciBfaTM4ID0gMCwgbCA9IHRoaXMuY291bnQ7IF9pMzggPCBsOyBfaTM4KyspIHtcbiAgICAgICAgICBfdmVjdG9yMiQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgX2kzOCk7XG5cbiAgICAgICAgICBfdmVjdG9yMiQxLmFwcGx5TWF0cml4MyhtKTtcblxuICAgICAgICAgIHRoaXMuc2V0WFkoX2kzOCwgX3ZlY3RvcjIkMS54LCBfdmVjdG9yMiQxLnkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXRlbVNpemUgPT09IDMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kzOSA9IDAsIF9sMyA9IHRoaXMuY291bnQ7IF9pMzkgPCBfbDM7IF9pMzkrKykge1xuICAgICAgICAgIF92ZWN0b3IkOS5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIF9pMzkpO1xuXG4gICAgICAgICAgX3ZlY3RvciQ5LmFwcGx5TWF0cml4MyhtKTtcblxuICAgICAgICAgIHRoaXMuc2V0WFlaKF9pMzksIF92ZWN0b3IkOS54LCBfdmVjdG9yJDkueSwgX3ZlY3RvciQ5LnopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseU1hdHJpeDRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlNYXRyaXg0KG0pIHtcbiAgICAgIGZvciAodmFyIF9pNDAgPSAwLCBsID0gdGhpcy5jb3VudDsgX2k0MCA8IGw7IF9pNDArKykge1xuICAgICAgICBfdmVjdG9yJDkuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLCBfaTQwKTtcblxuICAgICAgICBfdmVjdG9yJDkuYXBwbHlNYXRyaXg0KG0pO1xuXG4gICAgICAgIHRoaXMuc2V0WFlaKF9pNDAsIF92ZWN0b3IkOS54LCBfdmVjdG9yJDkueSwgX3ZlY3RvciQ5LnopO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlOb3JtYWxNYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlOb3JtYWxNYXRyaXgobSkge1xuICAgICAgZm9yICh2YXIgX2k0MSA9IDAsIGwgPSB0aGlzLmNvdW50OyBfaTQxIDwgbDsgX2k0MSsrKSB7XG4gICAgICAgIF92ZWN0b3IkOS5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIF9pNDEpO1xuXG4gICAgICAgIF92ZWN0b3IkOS5hcHBseU5vcm1hbE1hdHJpeChtKTtcblxuICAgICAgICB0aGlzLnNldFhZWihfaTQxLCBfdmVjdG9yJDkueCwgX3ZlY3RvciQ5LnksIF92ZWN0b3IkOS56KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybURpcmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1EaXJlY3Rpb24obSkge1xuICAgICAgZm9yICh2YXIgX2k0MiA9IDAsIGwgPSB0aGlzLmNvdW50OyBfaTQyIDwgbDsgX2k0MisrKSB7XG4gICAgICAgIF92ZWN0b3IkOS5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIF9pNDIpO1xuXG4gICAgICAgIF92ZWN0b3IkOS50cmFuc2Zvcm1EaXJlY3Rpb24obSk7XG5cbiAgICAgICAgdGhpcy5zZXRYWVooX2k0MiwgX3ZlY3RvciQ5LngsIF92ZWN0b3IkOS55LCBfdmVjdG9yJDkueik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdGhpcy5hcnJheS5zZXQodmFsdWUsIG9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRYXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFgoaW5kZXgsIHgpIHtcbiAgICAgIHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplXSA9IHg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRZKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZKGluZGV4LCB5KSB7XG4gICAgICB0aGlzLmFycmF5W2luZGV4ICogdGhpcy5pdGVtU2l6ZSArIDFdID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRaXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFooaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycmF5W2luZGV4ICogdGhpcy5pdGVtU2l6ZSArIDJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRaXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFooaW5kZXgsIHopIHtcbiAgICAgIHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMl0gPSB6O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VyhpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlbaW5kZXggKiB0aGlzLml0ZW1TaXplICsgM107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VyhpbmRleCwgdykge1xuICAgICAgdGhpcy5hcnJheVtpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzXSA9IHc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WFkoaW5kZXgsIHgsIHkpIHtcbiAgICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG4gICAgICB0aGlzLmFycmF5W2luZGV4ICsgMF0gPSB4O1xuICAgICAgdGhpcy5hcnJheVtpbmRleCArIDFdID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRYWVpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WFlaKGluZGV4LCB4LCB5LCB6KSB7XG4gICAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuICAgICAgdGhpcy5hcnJheVtpbmRleCArIDBdID0geDtcbiAgICAgIHRoaXMuYXJyYXlbaW5kZXggKyAxXSA9IHk7XG4gICAgICB0aGlzLmFycmF5W2luZGV4ICsgMl0gPSB6O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFhZWldcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WFlaVyhpbmRleCwgeCwgeSwgeiwgdykge1xuICAgICAgaW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcbiAgICAgIHRoaXMuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG4gICAgICB0aGlzLmFycmF5W2luZGV4ICsgMV0gPSB5O1xuICAgICAgdGhpcy5hcnJheVtpbmRleCArIDJdID0gejtcbiAgICAgIHRoaXMuYXJyYXlbaW5kZXggKyAzXSA9IHc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25VcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25VcGxvYWQoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXJyYXksIHRoaXMuaXRlbVNpemUpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgaXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG4gICAgICAgIHR5cGU6IHRoaXMuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgYXJyYXk6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuYXJyYXkpLFxuICAgICAgICBub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5uYW1lICE9PSAnJykgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgaWYgKHRoaXMudXNhZ2UgIT09IFN0YXRpY0RyYXdVc2FnZSkgZGF0YS51c2FnZSA9IHRoaXMudXNhZ2U7XG4gICAgICBpZiAodGhpcy51cGRhdGVSYW5nZS5vZmZzZXQgIT09IDAgfHwgdGhpcy51cGRhdGVSYW5nZS5jb3VudCAhPT0gLTEpIGRhdGEudXBkYXRlUmFuZ2UgPSB0aGlzLnVwZGF0ZVJhbmdlO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckF0dHJpYnV0ZTtcbn0oKTsgLy9cblxuXG52YXIgSW50OEJ1ZmZlckF0dHJpYnV0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckF0dHJpYnV0ZSkge1xuICBfaW5oZXJpdHMoSW50OEJ1ZmZlckF0dHJpYnV0ZSwgX0J1ZmZlckF0dHJpYnV0ZSk7XG5cbiAgdmFyIF9zdXBlcjExID0gX2NyZWF0ZVN1cGVyKEludDhCdWZmZXJBdHRyaWJ1dGUpO1xuXG4gIGZ1bmN0aW9uIEludDhCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludDhCdWZmZXJBdHRyaWJ1dGUpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjExLmNhbGwodGhpcywgbmV3IEludDhBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoSW50OEJ1ZmZlckF0dHJpYnV0ZSk7XG59KEJ1ZmZlckF0dHJpYnV0ZSk7XG5cbnZhciBVaW50OEJ1ZmZlckF0dHJpYnV0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckF0dHJpYnV0ZTIpIHtcbiAgX2luaGVyaXRzKFVpbnQ4QnVmZmVyQXR0cmlidXRlLCBfQnVmZmVyQXR0cmlidXRlMik7XG5cbiAgdmFyIF9zdXBlcjEyID0gX2NyZWF0ZVN1cGVyKFVpbnQ4QnVmZmVyQXR0cmlidXRlKTtcblxuICBmdW5jdGlvbiBVaW50OEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVWludDhCdWZmZXJBdHRyaWJ1dGUpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjEyLmNhbGwodGhpcywgbmV3IFVpbnQ4QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFVpbnQ4QnVmZmVyQXR0cmlidXRlKTtcbn0oQnVmZmVyQXR0cmlidXRlKTtcblxudmFyIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckF0dHJpYnV0ZTMpIHtcbiAgX2luaGVyaXRzKFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSwgX0J1ZmZlckF0dHJpYnV0ZTMpO1xuXG4gIHZhciBfc3VwZXIxMyA9IF9jcmVhdGVTdXBlcihVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUpO1xuXG4gIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKTtcblxuICAgIHJldHVybiBfc3VwZXIxMy5jYWxsKHRoaXMsIG5ldyBVaW50OENsYW1wZWRBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKTtcbn0oQnVmZmVyQXR0cmlidXRlKTtcblxudmFyIEludDE2QnVmZmVyQXR0cmlidXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyQXR0cmlidXRlNCkge1xuICBfaW5oZXJpdHMoSW50MTZCdWZmZXJBdHRyaWJ1dGUsIF9CdWZmZXJBdHRyaWJ1dGU0KTtcblxuICB2YXIgX3N1cGVyMTQgPSBfY3JlYXRlU3VwZXIoSW50MTZCdWZmZXJBdHRyaWJ1dGUpO1xuXG4gIGZ1bmN0aW9uIEludDE2QnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyMTQuY2FsbCh0aGlzLCBuZXcgSW50MTZBcnJheShhcnJheSksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoSW50MTZCdWZmZXJBdHRyaWJ1dGUpO1xufShCdWZmZXJBdHRyaWJ1dGUpO1xuXG52YXIgVWludDE2QnVmZmVyQXR0cmlidXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyQXR0cmlidXRlNSkge1xuICBfaW5oZXJpdHMoVWludDE2QnVmZmVyQXR0cmlidXRlLCBfQnVmZmVyQXR0cmlidXRlNSk7XG5cbiAgdmFyIF9zdXBlcjE1ID0gX2NyZWF0ZVN1cGVyKFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSk7XG5cbiAgZnVuY3Rpb24gVWludDE2QnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVaW50MTZCdWZmZXJBdHRyaWJ1dGUpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjE1LmNhbGwodGhpcywgbmV3IFVpbnQxNkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhVaW50MTZCdWZmZXJBdHRyaWJ1dGUpO1xufShCdWZmZXJBdHRyaWJ1dGUpO1xuXG52YXIgSW50MzJCdWZmZXJBdHRyaWJ1dGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CdWZmZXJBdHRyaWJ1dGU2KSB7XG4gIF9pbmhlcml0cyhJbnQzMkJ1ZmZlckF0dHJpYnV0ZSwgX0J1ZmZlckF0dHJpYnV0ZTYpO1xuXG4gIHZhciBfc3VwZXIxNiA9IF9jcmVhdGVTdXBlcihJbnQzMkJ1ZmZlckF0dHJpYnV0ZSk7XG5cbiAgZnVuY3Rpb24gSW50MzJCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludDMyQnVmZmVyQXR0cmlidXRlKTtcblxuICAgIHJldHVybiBfc3VwZXIxNi5jYWxsKHRoaXMsIG5ldyBJbnQzMkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhJbnQzMkJ1ZmZlckF0dHJpYnV0ZSk7XG59KEJ1ZmZlckF0dHJpYnV0ZSk7XG5cbnZhciBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CdWZmZXJBdHRyaWJ1dGU3KSB7XG4gIF9pbmhlcml0cyhVaW50MzJCdWZmZXJBdHRyaWJ1dGUsIF9CdWZmZXJBdHRyaWJ1dGU3KTtcblxuICB2YXIgX3N1cGVyMTcgPSBfY3JlYXRlU3VwZXIoVWludDMyQnVmZmVyQXR0cmlidXRlKTtcblxuICBmdW5jdGlvbiBVaW50MzJCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyMTcuY2FsbCh0aGlzLCBuZXcgVWludDMyQXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSk7XG59KEJ1ZmZlckF0dHJpYnV0ZSk7XG5cbnZhciBGbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyQXR0cmlidXRlOCkge1xuICBfaW5oZXJpdHMoRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSwgX0J1ZmZlckF0dHJpYnV0ZTgpO1xuXG4gIHZhciBfc3VwZXIxOCA9IF9jcmVhdGVTdXBlcihGbG9hdDE2QnVmZmVyQXR0cmlidXRlKTtcblxuICBmdW5jdGlvbiBGbG9hdDE2QnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuICAgIHZhciBfdGhpczEyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZsb2F0MTZCdWZmZXJBdHRyaWJ1dGUpO1xuXG4gICAgX3RoaXMxMiA9IF9zdXBlcjE4LmNhbGwodGhpcywgbmV3IFVpbnQxNkFycmF5KGFycmF5KSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICAgIF90aGlzMTIuaXNGbG9hdDE2QnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXMxMjtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSk7XG59KEJ1ZmZlckF0dHJpYnV0ZSk7XG5cbnZhciBGbG9hdDMyQnVmZmVyQXR0cmlidXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyQXR0cmlidXRlOSkge1xuICBfaW5oZXJpdHMoRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSwgX0J1ZmZlckF0dHJpYnV0ZTkpO1xuXG4gIHZhciBfc3VwZXIxOSA9IF9jcmVhdGVTdXBlcihGbG9hdDMyQnVmZmVyQXR0cmlidXRlKTtcblxuICBmdW5jdGlvbiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKTtcblxuICAgIHJldHVybiBfc3VwZXIxOS5jYWxsKHRoaXMsIG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUpO1xufShCdWZmZXJBdHRyaWJ1dGUpO1xuXG52YXIgRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckF0dHJpYnV0ZTEwKSB7XG4gIF9pbmhlcml0cyhGbG9hdDY0QnVmZmVyQXR0cmlidXRlLCBfQnVmZmVyQXR0cmlidXRlMTApO1xuXG4gIHZhciBfc3VwZXIyMCA9IF9jcmVhdGVTdXBlcihGbG9hdDY0QnVmZmVyQXR0cmlidXRlKTtcblxuICBmdW5jdGlvbiBGbG9hdDY0QnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbG9hdDY0QnVmZmVyQXR0cmlidXRlKTtcblxuICAgIHJldHVybiBfc3VwZXIyMC5jYWxsKHRoaXMsIG5ldyBGbG9hdDY0QXJyYXkoYXJyYXkpLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUpO1xufShCdWZmZXJBdHRyaWJ1dGUpO1xuXG52YXIgX2lkJDEgPSAwO1xuXG52YXIgX20xID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfb2JqID0gLypAX19QVVJFX18qL25ldyBPYmplY3QzRCgpO1xuXG52YXIgX29mZnNldCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX2JveCQxID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5cbnZhciBfYm94TW9ycGhUYXJnZXRzID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5cbnZhciBfdmVjdG9yJDggPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIEJ1ZmZlckdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnREaXNwYXRjaGVyNSkge1xuICBfaW5oZXJpdHMoQnVmZmVyR2VvbWV0cnksIF9FdmVudERpc3BhdGNoZXI1KTtcblxuICB2YXIgX3N1cGVyMjEgPSBfY3JlYXRlU3VwZXIoQnVmZmVyR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIEJ1ZmZlckdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczEzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckdlb21ldHJ5KTtcblxuICAgIF90aGlzMTMgPSBfc3VwZXIyMS5jYWxsKHRoaXMpO1xuICAgIF90aGlzMTMuaXNCdWZmZXJHZW9tZXRyeSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMyksICdpZCcsIHtcbiAgICAgIHZhbHVlOiBfaWQkMSsrXG4gICAgfSk7XG4gICAgX3RoaXMxMy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgX3RoaXMxMy5uYW1lID0gJyc7XG4gICAgX3RoaXMxMy50eXBlID0gJ0J1ZmZlckdlb21ldHJ5JztcbiAgICBfdGhpczEzLmluZGV4ID0gbnVsbDtcbiAgICBfdGhpczEzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICBfdGhpczEzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuICAgIF90aGlzMTMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBmYWxzZTtcbiAgICBfdGhpczEzLmdyb3VwcyA9IFtdO1xuICAgIF90aGlzMTMuYm91bmRpbmdCb3ggPSBudWxsO1xuICAgIF90aGlzMTMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuICAgIF90aGlzMTMuZHJhd1JhbmdlID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBjb3VudDogSW5maW5pdHlcbiAgICB9O1xuICAgIF90aGlzMTMudXNlckRhdGEgPSB7fTtcbiAgICByZXR1cm4gX3RoaXMxMztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJHZW9tZXRyeSwgW3tcbiAgICBrZXk6IFwiZ2V0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5kZXgoaW5kZXgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4KSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gbmV3IChhcnJheU5lZWRzVWludDMyKGluZGV4KSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSkoaW5kZXgsIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJpYnV0ZSkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gYXR0cmlidXRlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQXR0cmlidXRlKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkR3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkR3JvdXAoc3RhcnQsIGNvdW50KSB7XG4gICAgICB2YXIgbWF0ZXJpYWxJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICAgIHRoaXMuZ3JvdXBzLnB1c2goe1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgbWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyR3JvdXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyR3JvdXBzKCkge1xuICAgICAgdGhpcy5ncm91cHMgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RHJhd1JhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERyYXdSYW5nZShzdGFydCwgY291bnQpIHtcbiAgICAgIHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseU1hdHJpeDRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlNYXRyaXg0KG1hdHJpeCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICBpZiAocG9zaXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgICAgcG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgICAgaWYgKG5vcm1hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeChtYXRyaXgpO1xuICAgICAgICBub3JtYWwuYXBwbHlOb3JtYWxNYXRyaXgobm9ybWFsTWF0cml4KTtcbiAgICAgICAgbm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhbmdlbnQgPSB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDtcblxuICAgICAgaWYgKHRhbmdlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YW5nZW50LnRyYW5zZm9ybURpcmVjdGlvbihtYXRyaXgpO1xuICAgICAgICB0YW5nZW50Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5UXVhdGVybmlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVF1YXRlcm5pb24ocSkge1xuICAgICAgX20xLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpO1xuXG4gICAgICB0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0ZVhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm90YXRlWChhbmdsZSkge1xuICAgICAgLy8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcbiAgICAgIF9tMS5tYWtlUm90YXRpb25YKGFuZ2xlKTtcblxuICAgICAgdGhpcy5hcHBseU1hdHJpeDQoX20xKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVZXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0ZVkoYW5nbGUpIHtcbiAgICAgIC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG4gICAgICBfbTEubWFrZVJvdGF0aW9uWShhbmdsZSk7XG5cbiAgICAgIHRoaXMuYXBwbHlNYXRyaXg0KF9tMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm90YXRlWlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByb3RhdGVaKGFuZ2xlKSB7XG4gICAgICAvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuICAgICAgX20xLm1ha2VSb3RhdGlvblooYW5nbGUpO1xuXG4gICAgICB0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSwgeikge1xuICAgICAgLy8gdHJhbnNsYXRlIGdlb21ldHJ5XG4gICAgICBfbTEubWFrZVRyYW5zbGF0aW9uKHgsIHksIHopO1xuXG4gICAgICB0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlKHgsIHksIHopIHtcbiAgICAgIC8vIHNjYWxlIGdlb21ldHJ5XG4gICAgICBfbTEubWFrZVNjYWxlKHgsIHksIHopO1xuXG4gICAgICB0aGlzLmFwcGx5TWF0cml4NChfbTEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvb2tBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb29rQXQodmVjdG9yKSB7XG4gICAgICBfb2JqLmxvb2tBdCh2ZWN0b3IpO1xuXG4gICAgICBfb2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICB0aGlzLmFwcGx5TWF0cml4NChfb2JqLm1hdHJpeCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlbnRlcigpIHtcbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcihfb2Zmc2V0KS5uZWdhdGUoKTtcbiAgICAgIHRoaXMudHJhbnNsYXRlKF9vZmZzZXQueCwgX29mZnNldC55LCBfb2Zmc2V0LnopO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZyb21Qb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVBvaW50cyhwb2ludHMpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTQzID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IF9pNDMgPCBsOyBfaTQzKyspIHtcbiAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW19pNDNdO1xuICAgICAgICBwb3NpdGlvbi5wdXNoKHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCAzKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICAgIGlmICh0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24gPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgaWYgKHBvc2l0aW9uICYmIHBvc2l0aW9uLmlzR0xCdWZmZXJBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIGJveC4gQWx0ZXJuYXRpdmVseSBzZXQgXCJtZXNoLmZydXN0dW1DdWxsZWRcIiB0byBcImZhbHNlXCIuJywgdGhpcyk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guc2V0KG5ldyBWZWN0b3IzKC1JbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHkpLCBuZXcgVmVjdG9yMygrSW5maW5pdHksICtJbmZpbml0eSwgK0luZmluaXR5KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uKTsgLy8gcHJvY2VzcyBtb3JwaCBhdHRyaWJ1dGVzIGlmIHByZXNlbnRcblxuICAgICAgICBpZiAobW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTQ0ID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IF9pNDQgPCBpbDsgX2k0NCsrKSB7XG4gICAgICAgICAgICB2YXIgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbltfaTQ0XTtcblxuICAgICAgICAgICAgX2JveCQxLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhBdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgICBfdmVjdG9yJDguYWRkVmVjdG9ycyh0aGlzLmJvdW5kaW5nQm94Lm1pbiwgX2JveCQxLm1pbik7XG5cbiAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KF92ZWN0b3IkOCk7XG5cbiAgICAgICAgICAgICAgX3ZlY3RvciQ4LmFkZFZlY3RvcnModGhpcy5ib3VuZGluZ0JveC5tYXgsIF9ib3gkMS5tYXgpO1xuXG4gICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChfdmVjdG9yJDgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KF9ib3gkMS5taW4pO1xuICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmV4cGFuZEJ5UG9pbnQoX2JveCQxLm1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueCkgfHwgaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueSkgfHwgaXNOYU4odGhpcy5ib3VuZGluZ0JveC5taW4ueikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wdXRlQm91bmRpbmdTcGhlcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuICAgICAgaWYgKHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgdmFyIG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgIGlmIChwb3NpdGlvbiAmJiBwb3NpdGlvbi5pc0dMQnVmZmVyQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBHTEJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBhIG1hbnVhbCBib3VuZGluZyBzcGhlcmUuIEFsdGVybmF0aXZlbHkgc2V0IFwibWVzaC5mcnVzdHVtQ3VsbGVkXCIgdG8gXCJmYWxzZVwiLicsIHRoaXMpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChuZXcgVmVjdG9yMygpLCBJbmZpbml0eSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgIC8vIGZpcnN0LCBmaW5kIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHNwaGVyZVxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG5cbiAgICAgICAgX2JveCQxLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24pOyAvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cbiAgICAgICAgaWYgKG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2k0NSA9IDAsIGlsID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb24ubGVuZ3RoOyBfaTQ1IDwgaWw7IF9pNDUrKykge1xuICAgICAgICAgICAgdmFyIG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzUG9zaXRpb25bX2k0NV07XG5cbiAgICAgICAgICAgIF9ib3hNb3JwaFRhcmdldHMuc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaEF0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgIF92ZWN0b3IkOC5hZGRWZWN0b3JzKF9ib3gkMS5taW4sIF9ib3hNb3JwaFRhcmdldHMubWluKTtcblxuICAgICAgICAgICAgICBfYm94JDEuZXhwYW5kQnlQb2ludChfdmVjdG9yJDgpO1xuXG4gICAgICAgICAgICAgIF92ZWN0b3IkOC5hZGRWZWN0b3JzKF9ib3gkMS5tYXgsIF9ib3hNb3JwaFRhcmdldHMubWF4KTtcblxuICAgICAgICAgICAgICBfYm94JDEuZXhwYW5kQnlQb2ludChfdmVjdG9yJDgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2JveCQxLmV4cGFuZEJ5UG9pbnQoX2JveE1vcnBoVGFyZ2V0cy5taW4pO1xuXG4gICAgICAgICAgICAgIF9ib3gkMS5leHBhbmRCeVBvaW50KF9ib3hNb3JwaFRhcmdldHMubWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfYm94JDEuZ2V0Q2VudGVyKGNlbnRlcik7IC8vIHNlY29uZCwgdHJ5IHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxuXG5cbiAgICAgICAgdmFyIG1heFJhZGl1c1NxID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfaTQ2ID0gMCwgX2lsID0gcG9zaXRpb24uY291bnQ7IF9pNDYgPCBfaWw7IF9pNDYrKykge1xuICAgICAgICAgIF92ZWN0b3IkOC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBfaTQ2KTtcblxuICAgICAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgobWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChfdmVjdG9yJDgpKTtcbiAgICAgICAgfSAvLyBwcm9jZXNzIG1vcnBoIGF0dHJpYnV0ZXMgaWYgcHJlc2VudFxuXG5cbiAgICAgICAgaWYgKG1vcnBoQXR0cmlidXRlc1Bvc2l0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2k0NyA9IDAsIF9pbDIgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbi5sZW5ndGg7IF9pNDcgPCBfaWwyOyBfaTQ3KyspIHtcbiAgICAgICAgICAgIHZhciBfbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNQb3NpdGlvbltfaTQ3XTtcbiAgICAgICAgICAgIHZhciBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IF9tb3JwaEF0dHJpYnV0ZS5jb3VudDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgX3ZlY3RvciQ4LmZyb21CdWZmZXJBdHRyaWJ1dGUoX21vcnBoQXR0cmlidXRlLCBqKTtcblxuICAgICAgICAgICAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBfb2Zmc2V0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGopO1xuXG4gICAgICAgICAgICAgICAgX3ZlY3RvciQ4LmFkZChfb2Zmc2V0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG1heFJhZGl1c1NxID0gTWF0aC5tYXgobWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZChfdmVjdG9yJDgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydChtYXhSYWRpdXNTcSk7XG5cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzKSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXB1dGVUYW5nZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlVGFuZ2VudHMoKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7IC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG4gICAgICAvLyAocGVyIHZlcnRleCB0YW5nZW50cylcblxuICAgICAgaWYgKGluZGV4ID09PSBudWxsIHx8IGF0dHJpYnV0ZXMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkIHx8IGF0dHJpYnV0ZXMudXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGZhaWxlZC4gTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1diknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuICAgICAgdmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYuYXJyYXk7XG4gICAgICB2YXIgblZlcnRpY2VzID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7XG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgndGFuZ2VudCcpID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFuZ2VudCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSg0ICogblZlcnRpY2VzKSwgNCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFuZ2VudHMgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGFuZ2VudCcpLmFycmF5O1xuICAgICAgdmFyIHRhbjEgPSBbXSxcbiAgICAgICAgICB0YW4yID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pNDggPSAwOyBfaTQ4IDwgblZlcnRpY2VzOyBfaTQ4KyspIHtcbiAgICAgICAgdGFuMVtfaTQ4XSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHRhbjJbX2k0OF0gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdkEgPSBuZXcgVmVjdG9yMygpLFxuICAgICAgICAgIHZCID0gbmV3IFZlY3RvcjMoKSxcbiAgICAgICAgICB2QyA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgdXZBID0gbmV3IFZlY3RvcjIoKSxcbiAgICAgICAgICB1dkIgPSBuZXcgVmVjdG9yMigpLFxuICAgICAgICAgIHV2QyA9IG5ldyBWZWN0b3IyKCksXG4gICAgICAgICAgc2RpciA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgdGRpciA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKGEsIGIsIGMpIHtcbiAgICAgICAgdkEuZnJvbUFycmF5KHBvc2l0aW9ucywgYSAqIDMpO1xuICAgICAgICB2Qi5mcm9tQXJyYXkocG9zaXRpb25zLCBiICogMyk7XG4gICAgICAgIHZDLmZyb21BcnJheShwb3NpdGlvbnMsIGMgKiAzKTtcbiAgICAgICAgdXZBLmZyb21BcnJheSh1dnMsIGEgKiAyKTtcbiAgICAgICAgdXZCLmZyb21BcnJheSh1dnMsIGIgKiAyKTtcbiAgICAgICAgdXZDLmZyb21BcnJheSh1dnMsIGMgKiAyKTtcbiAgICAgICAgdkIuc3ViKHZBKTtcbiAgICAgICAgdkMuc3ViKHZBKTtcbiAgICAgICAgdXZCLnN1Yih1dkEpO1xuICAgICAgICB1dkMuc3ViKHV2QSk7XG4gICAgICAgIHZhciByID0gMS4wIC8gKHV2Qi54ICogdXZDLnkgLSB1dkMueCAqIHV2Qi55KTsgLy8gc2lsZW50bHkgaWdub3JlIGRlZ2VuZXJhdGUgdXYgdHJpYW5nbGVzIGhhdmluZyBjb2luY2lkZW50IG9yIGNvbGluZWFyIHZlcnRpY2VzXG5cbiAgICAgICAgaWYgKCFpc0Zpbml0ZShyKSkgcmV0dXJuO1xuICAgICAgICBzZGlyLmNvcHkodkIpLm11bHRpcGx5U2NhbGFyKHV2Qy55KS5hZGRTY2FsZWRWZWN0b3IodkMsIC11dkIueSkubXVsdGlwbHlTY2FsYXIocik7XG4gICAgICAgIHRkaXIuY29weSh2QykubXVsdGlwbHlTY2FsYXIodXZCLngpLmFkZFNjYWxlZFZlY3Rvcih2QiwgLXV2Qy54KS5tdWx0aXBseVNjYWxhcihyKTtcbiAgICAgICAgdGFuMVthXS5hZGQoc2Rpcik7XG4gICAgICAgIHRhbjFbYl0uYWRkKHNkaXIpO1xuICAgICAgICB0YW4xW2NdLmFkZChzZGlyKTtcbiAgICAgICAgdGFuMlthXS5hZGQodGRpcik7XG4gICAgICAgIHRhbjJbYl0uYWRkKHRkaXIpO1xuICAgICAgICB0YW4yW2NdLmFkZCh0ZGlyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG4gICAgICBpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBncm91cHMgPSBbe1xuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGNvdW50OiBpbmRpY2VzLmxlbmd0aFxuICAgICAgICB9XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2k0OSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgX2k0OSA8IGlsOyArK19pNDkpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW19pNDldO1xuICAgICAgICB2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcbiAgICAgICAgdmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgaGFuZGxlVHJpYW5nbGUoaW5kaWNlc1tqICsgMF0sIGluZGljZXNbaiArIDFdLCBpbmRpY2VzW2ogKyAyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRtcCA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgdG1wMiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB2YXIgbiA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgbjIgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVWZXJ0ZXgodikge1xuICAgICAgICBuLmZyb21BcnJheShub3JtYWxzLCB2ICogMyk7XG4gICAgICAgIG4yLmNvcHkobik7XG4gICAgICAgIHZhciB0ID0gdGFuMVt2XTsgLy8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcblxuICAgICAgICB0bXAuY29weSh0KTtcbiAgICAgICAgdG1wLnN1YihuLm11bHRpcGx5U2NhbGFyKG4uZG90KHQpKSkubm9ybWFsaXplKCk7IC8vIENhbGN1bGF0ZSBoYW5kZWRuZXNzXG5cbiAgICAgICAgdG1wMi5jcm9zc1ZlY3RvcnMobjIsIHQpO1xuICAgICAgICB2YXIgdGVzdCA9IHRtcDIuZG90KHRhbjJbdl0pO1xuICAgICAgICB2YXIgdyA9IHRlc3QgPCAwLjAgPyAtMS4wIDogMS4wO1xuICAgICAgICB0YW5nZW50c1t2ICogNF0gPSB0bXAueDtcbiAgICAgICAgdGFuZ2VudHNbdiAqIDQgKyAxXSA9IHRtcC55O1xuICAgICAgICB0YW5nZW50c1t2ICogNCArIDJdID0gdG1wLno7XG4gICAgICAgIHRhbmdlbnRzW3YgKiA0ICsgM10gPSB3O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTUwID0gMCwgX2lsMyA9IGdyb3Vwcy5sZW5ndGg7IF9pNTAgPCBfaWwzOyArK19pNTApIHtcbiAgICAgICAgdmFyIF9ncm91cCA9IGdyb3Vwc1tfaTUwXTtcbiAgICAgICAgdmFyIF9zdGFydDIgPSBfZ3JvdXAuc3RhcnQ7XG4gICAgICAgIHZhciBfY291bnQgPSBfZ3JvdXAuY291bnQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2ogPSBfc3RhcnQyLCBfamwgPSBfc3RhcnQyICsgX2NvdW50OyBfaiA8IF9qbDsgX2ogKz0gMykge1xuICAgICAgICAgIGhhbmRsZVZlcnRleChpbmRpY2VzW19qICsgMF0pO1xuICAgICAgICAgIGhhbmRsZVZlcnRleChpbmRpY2VzW19qICsgMV0pO1xuICAgICAgICAgIGhhbmRsZVZlcnRleChpbmRpY2VzW19qICsgMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXB1dGVWZXJ0ZXhOb3JtYWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXG4gICAgICBpZiAocG9zaXRpb25BdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9ybWFsQXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ25vcm1hbCcpO1xuXG4gICAgICAgIGlmIChub3JtYWxBdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIDMpLCAzKTtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbm9ybWFsQXR0cmlidXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cbiAgICAgICAgICBmb3IgKHZhciBfaTUxID0gMCwgaWwgPSBub3JtYWxBdHRyaWJ1dGUuY291bnQ7IF9pNTEgPCBpbDsgX2k1MSsrKSB7XG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKF9pNTEsIDAsIDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwQSA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgICBwQiA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgICBwQyA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHZhciBuQSA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgICBuQiA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgICBuQyA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHZhciBjYiA9IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgICBhYiA9IG5ldyBWZWN0b3IzKCk7IC8vIGluZGV4ZWQgZWxlbWVudHNcblxuICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTUyID0gMCwgX2lsNCA9IGluZGV4LmNvdW50OyBfaTUyIDwgX2lsNDsgX2k1MiArPSAzKSB7XG4gICAgICAgICAgICB2YXIgdkEgPSBpbmRleC5nZXRYKF9pNTIgKyAwKTtcbiAgICAgICAgICAgIHZhciB2QiA9IGluZGV4LmdldFgoX2k1MiArIDEpO1xuICAgICAgICAgICAgdmFyIHZDID0gaW5kZXguZ2V0WChfaTUyICsgMik7XG4gICAgICAgICAgICBwQS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCB2QSk7XG4gICAgICAgICAgICBwQi5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCB2Qik7XG4gICAgICAgICAgICBwQy5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCB2Qyk7XG4gICAgICAgICAgICBjYi5zdWJWZWN0b3JzKHBDLCBwQik7XG4gICAgICAgICAgICBhYi5zdWJWZWN0b3JzKHBBLCBwQik7XG4gICAgICAgICAgICBjYi5jcm9zcyhhYik7XG4gICAgICAgICAgICBuQS5mcm9tQnVmZmVyQXR0cmlidXRlKG5vcm1hbEF0dHJpYnV0ZSwgdkEpO1xuICAgICAgICAgICAgbkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBdHRyaWJ1dGUsIHZCKTtcbiAgICAgICAgICAgIG5DLmZyb21CdWZmZXJBdHRyaWJ1dGUobm9ybWFsQXR0cmlidXRlLCB2Qyk7XG4gICAgICAgICAgICBuQS5hZGQoY2IpO1xuICAgICAgICAgICAgbkIuYWRkKGNiKTtcbiAgICAgICAgICAgIG5DLmFkZChjYik7XG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKHZBLCBuQS54LCBuQS55LCBuQS56KTtcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVoodkIsIG5CLngsIG5CLnksIG5CLnopO1xuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLnNldFhZWih2QywgbkMueCwgbkMueSwgbkMueik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuICAgICAgICAgIGZvciAodmFyIF9pNTMgPSAwLCBfaWw1ID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IF9pNTMgPCBfaWw1OyBfaTUzICs9IDMpIHtcbiAgICAgICAgICAgIHBBLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIF9pNTMgKyAwKTtcbiAgICAgICAgICAgIHBCLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIF9pNTMgKyAxKTtcbiAgICAgICAgICAgIHBDLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIF9pNTMgKyAyKTtcbiAgICAgICAgICAgIGNiLnN1YlZlY3RvcnMocEMsIHBCKTtcbiAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMocEEsIHBCKTtcbiAgICAgICAgICAgIGNiLmNyb3NzKGFiKTtcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZS5zZXRYWVooX2k1MyArIDAsIGNiLngsIGNiLnksIGNiLnopO1xuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLnNldFhZWihfaTUzICsgMSwgY2IueCwgY2IueSwgY2Iueik7XG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUuc2V0WFlaKF9pNTMgKyAyLCBjYi54LCBjYi55LCBjYi56KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcbiAgICAgICAgbm9ybWFsQXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVyZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVyZ2UoZ2VvbWV0cnksIG9mZnNldCkge1xuICAgICAgaWYgKCEoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBPdmVyd3JpdGluZyBvcmlnaW5hbCBnZW9tZXRyeSwgc3RhcnRpbmcgYXQgb2Zmc2V0PTAuICcgKyAnVXNlIEJ1ZmZlckdlb21ldHJ5VXRpbHMubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZm9yIGxvc3NsZXNzIG1lcmdlLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xuICAgICAgICB2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZUFycmF5MiA9IGF0dHJpYnV0ZTIuYXJyYXk7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVPZmZzZXQgPSBhdHRyaWJ1dGUyLml0ZW1TaXplICogb2Zmc2V0O1xuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oYXR0cmlidXRlQXJyYXkyLmxlbmd0aCwgYXR0cmlidXRlQXJyYXkxLmxlbmd0aCAtIGF0dHJpYnV0ZU9mZnNldCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2k1NCA9IDAsIGogPSBhdHRyaWJ1dGVPZmZzZXQ7IF9pNTQgPCBsZW5ndGg7IF9pNTQrKywgaisrKSB7XG4gICAgICAgICAgYXR0cmlidXRlQXJyYXkxW2pdID0gYXR0cmlidXRlQXJyYXkyW19pNTRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVOb3JtYWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZU5vcm1hbHMoKSB7XG4gICAgICB2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cbiAgICAgIGZvciAodmFyIF9pNTUgPSAwLCBpbCA9IG5vcm1hbHMuY291bnQ7IF9pNTUgPCBpbDsgX2k1NSsrKSB7XG4gICAgICAgIF92ZWN0b3IkOC5mcm9tQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIF9pNTUpO1xuXG4gICAgICAgIF92ZWN0b3IkOC5ub3JtYWxpemUoKTtcblxuICAgICAgICBub3JtYWxzLnNldFhZWihfaTU1LCBfdmVjdG9yJDgueCwgX3ZlY3RvciQ4LnksIF92ZWN0b3IkOC56KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9Ob25JbmRleGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvTm9uSW5kZXhlZCgpIHtcbiAgICAgIGZ1bmN0aW9uIGNvbnZlcnRCdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBpbmRpY2VzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZS5ub3JtYWxpemVkO1xuICAgICAgICB2YXIgYXJyYXkyID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGluZGljZXMubGVuZ3RoICogaXRlbVNpemUpO1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgaW5kZXgyID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfaTU2ID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBfaTU2IDwgbDsgX2k1NisrKSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpbmRleCA9IGluZGljZXNbX2k1Nl0gKiBhdHRyaWJ1dGUuZGF0YS5zdHJpZGUgKyBhdHRyaWJ1dGUub2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IGluZGljZXNbX2k1Nl0gKiBpdGVtU2l6ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW1TaXplOyBqKyspIHtcbiAgICAgICAgICAgIGFycmF5MltpbmRleDIrK10gPSBhcnJheVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheTIsIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgICAgIH0gLy9cblxuXG4gICAgICBpZiAodGhpcy5pbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7IC8vIGF0dHJpYnV0ZXNcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICB2YXIgbmV3QXR0cmlidXRlID0gY29udmVydEJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGluZGljZXMpO1xuICAgICAgICBnZW9tZXRyeTIuc2V0QXR0cmlidXRlKG5hbWUsIG5ld0F0dHJpYnV0ZSk7XG4gICAgICB9IC8vIG1vcnBoIGF0dHJpYnV0ZXNcblxuXG4gICAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXM7XG5cbiAgICAgIGZvciAodmFyIF9uYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuICAgICAgICB2YXIgbW9ycGhBcnJheSA9IFtdO1xuICAgICAgICB2YXIgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbX25hbWVdOyAvLyBtb3JwaEF0dHJpYnV0ZTogYXJyYXkgb2YgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZXNcblxuICAgICAgICBmb3IgKHZhciBfaTU3ID0gMCwgaWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IF9pNTcgPCBpbDsgX2k1NysrKSB7XG4gICAgICAgICAgdmFyIF9hdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZVtfaTU3XTtcblxuICAgICAgICAgIHZhciBfbmV3QXR0cmlidXRlID0gY29udmVydEJ1ZmZlckF0dHJpYnV0ZShfYXR0cmlidXRlLCBpbmRpY2VzKTtcblxuICAgICAgICAgIG1vcnBoQXJyYXkucHVzaChfbmV3QXR0cmlidXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJ5Mi5tb3JwaEF0dHJpYnV0ZXNbX25hbWVdID0gbW9ycGhBcnJheTtcbiAgICAgIH1cblxuICAgICAgZ2VvbWV0cnkyLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTsgLy8gZ3JvdXBzXG5cbiAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuICAgICAgZm9yICh2YXIgX2k1OCA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBfaTU4IDwgbDsgX2k1OCsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tfaTU4XTtcbiAgICAgICAgZ2VvbWV0cnkyLmFkZEdyb3VwKGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZW9tZXRyeTI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB2ZXJzaW9uOiA0LjUsXG4gICAgICAgICAgdHlwZTogJ0J1ZmZlckdlb21ldHJ5JyxcbiAgICAgICAgICBnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXG4gICAgICAgIH1cbiAgICAgIH07IC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuICAgICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgICAgZGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgICAgaWYgKHRoaXMubmFtZSAhPT0gJycpIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGggPiAwKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcblxuICAgICAgaWYgKHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgaWYgKHBhcmFtZXRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSBkYXRhW2tleV0gPSBwYXJhbWV0ZXJzW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0gLy8gZm9yIHNpbXBsaWNpdHkgdGhlIGNvZGUgYXNzdW1lcyBhdHRyaWJ1dGVzIGFyZSBub3Qgc2hhcmVkIGFjcm9zcyBnZW9tZXRyaWVzLCBzZWUgIzE1ODExXG5cblxuICAgICAgZGF0YS5kYXRhID0ge1xuICAgICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgICAgfTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhLmRhdGEuaW5kZXggPSB7XG4gICAgICAgICAgdHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICBhcnJheTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5kZXguYXJyYXkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICBmb3IgKHZhciBfa2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbX2tleV07XG4gICAgICAgIGRhdGEuZGF0YS5hdHRyaWJ1dGVzW19rZXldID0gYXR0cmlidXRlLnRvSlNPTihkYXRhLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzID0ge307XG4gICAgICB2YXIgaGFzTW9ycGhBdHRyaWJ1dGVzID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIF9rZXkyIGluIHRoaXMubW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVBcnJheSA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzW19rZXkyXTtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2k1OSA9IDAsIGlsID0gYXR0cmlidXRlQXJyYXkubGVuZ3RoOyBfaTU5IDwgaWw7IF9pNTkrKykge1xuICAgICAgICAgIHZhciBfYXR0cmlidXRlMiA9IGF0dHJpYnV0ZUFycmF5W19pNTldO1xuICAgICAgICAgIGFycmF5LnB1c2goX2F0dHJpYnV0ZTIudG9KU09OKGRhdGEuZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBtb3JwaEF0dHJpYnV0ZXNbX2tleTJdID0gYXJyYXk7XG4gICAgICAgICAgaGFzTW9ycGhBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzTW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGRhdGEuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBtb3JwaEF0dHJpYnV0ZXM7XG4gICAgICAgIGRhdGEuZGF0YS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcblxuICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdyb3VwcykpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG4gICAgICBpZiAoYm91bmRpbmdTcGhlcmUgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xuICAgICAgICAgIGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcbiAgICAgICAgICByYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICAvLyByZXNldFxuICAgICAgdGhpcy5pbmRleCA9IG51bGw7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG4gICAgICB0aGlzLmdyb3VwcyA9IFtdO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG4gICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDsgLy8gdXNlZCBmb3Igc3RvcmluZyBjbG9uZWQsIHNoYXJlZCBkYXRhXG5cbiAgICAgIHZhciBkYXRhID0ge307IC8vIG5hbWVcblxuICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7IC8vIGluZGV4XG5cbiAgICAgIHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgoaW5kZXguY2xvbmUoZGF0YSkpO1xuICAgICAgfSAvLyBhdHRyaWJ1dGVzXG5cblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoZGF0YSkpO1xuICAgICAgfSAvLyBtb3JwaCBhdHRyaWJ1dGVzXG5cblxuICAgICAgdmFyIG1vcnBoQXR0cmlidXRlcyA9IHNvdXJjZS5tb3JwaEF0dHJpYnV0ZXM7XG5cbiAgICAgIGZvciAodmFyIF9uYW1lMiBpbiBtb3JwaEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIHZhciBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1tfbmFtZTJdOyAvLyBtb3JwaEF0dHJpYnV0ZTogYXJyYXkgb2YgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZXNcblxuICAgICAgICBmb3IgKHZhciBfaTYwID0gMCwgbCA9IG1vcnBoQXR0cmlidXRlLmxlbmd0aDsgX2k2MCA8IGw7IF9pNjArKykge1xuICAgICAgICAgIGFycmF5LnB1c2gobW9ycGhBdHRyaWJ1dGVbX2k2MF0uY2xvbmUoZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXNbX25hbWUyXSA9IGFycmF5O1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gc291cmNlLm1vcnBoVGFyZ2V0c1JlbGF0aXZlOyAvLyBncm91cHNcblxuICAgICAgdmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cbiAgICAgIGZvciAodmFyIF9pNjEgPSAwLCBfbDQgPSBncm91cHMubGVuZ3RoOyBfaTYxIDwgX2w0OyBfaTYxKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW19pNjFdO1xuICAgICAgICB0aGlzLmFkZEdyb3VwKGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCk7XG4gICAgICB9IC8vIGJvdW5kaW5nIGJveFxuXG5cbiAgICAgIHZhciBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcblxuICAgICAgaWYgKGJvdW5kaW5nQm94ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuICAgICAgfSAvLyBib3VuZGluZyBzcGhlcmVcblxuXG4gICAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmU7XG5cbiAgICAgIGlmIChib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcbiAgICAgIH0gLy8gZHJhdyByYW5nZVxuXG5cbiAgICAgIHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcbiAgICAgIHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gc291cmNlLmRyYXdSYW5nZS5jb3VudDsgLy8gdXNlciBkYXRhXG5cbiAgICAgIHRoaXMudXNlckRhdGEgPSBzb3VyY2UudXNlckRhdGE7IC8vIGdlb21ldHJ5IGdlbmVyYXRvciBwYXJhbWV0ZXJzXG5cbiAgICAgIGlmIChzb3VyY2UucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkKSB0aGlzLnBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UucGFyYW1ldGVycyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2Rpc3Bvc2UnXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnVmZmVyR2VvbWV0cnk7XG59KEV2ZW50RGlzcGF0Y2hlcik7XG5cbnZhciBfaW52ZXJzZU1hdHJpeCQyID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfcmF5JDIgPSAvKkBfX1BVUkVfXyovbmV3IFJheSgpO1xuXG52YXIgX3NwaGVyZSQzID0gLypAX19QVVJFX18qL25ldyBTcGhlcmUoKTtcblxudmFyIF92QSQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdkIkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3ZDJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF90ZW1wQSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3RlbXBCID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdGVtcEMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9tb3JwaEEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9tb3JwaEIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9tb3JwaEMgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF91dkEkMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMigpO1xuXG52YXIgX3V2QiQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cbnZhciBfdXZDJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxudmFyIF9pbnRlcnNlY3Rpb25Qb2ludCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX2ludGVyc2VjdGlvblBvaW50V29ybGQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIE1lc2ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmplY3QzRCkge1xuICBfaW5oZXJpdHMoTWVzaCwgX09iamVjdDNEKTtcblxuICB2YXIgX3N1cGVyMjIgPSBfY3JlYXRlU3VwZXIoTWVzaCk7XG5cbiAgZnVuY3Rpb24gTWVzaCgpIHtcbiAgICB2YXIgX3RoaXMxNDtcblxuICAgIHZhciBnZW9tZXRyeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgdmFyIG1hdGVyaWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoKTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZXNoKTtcblxuICAgIF90aGlzMTQgPSBfc3VwZXIyMi5jYWxsKHRoaXMpO1xuICAgIF90aGlzMTQuaXNNZXNoID0gdHJ1ZTtcbiAgICBfdGhpczE0LnR5cGUgPSAnTWVzaCc7XG4gICAgX3RoaXMxNC5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgIF90aGlzMTQubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuICAgIF90aGlzMTQudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cbiAgICByZXR1cm4gX3RoaXMxNDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZXNoLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1lc2gucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlLCByZWN1cnNpdmUpO1xuXG4gICAgICBpZiAoc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gc291cmNlLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBzb3VyY2UubWF0ZXJpYWw7XG4gICAgICB0aGlzLmdlb21ldHJ5ID0gc291cmNlLmdlb21ldHJ5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU1vcnBoVGFyZ2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNb3JwaFRhcmdldHMoKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobW9ycGhBdHRyaWJ1dGVzKTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNba2V5c1swXV07XG5cbiAgICAgICAgaWYgKG1vcnBoQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xuICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBtID0gMCwgbWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG1vcnBoQXR0cmlidXRlW21dLm5hbWUgfHwgU3RyaW5nKG0pO1xuICAgICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCgwKTtcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W25hbWVdID0gbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmF5Y2FzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgIHZhciBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICB2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuICAgICAgaWYgKG1hdGVyaWFsID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cbiAgICAgIGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgIF9zcGhlcmUkMy5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKTtcblxuICAgICAgX3NwaGVyZSQzLmFwcGx5TWF0cml4NChtYXRyaXhXb3JsZCk7XG5cbiAgICAgIGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSQzKSA9PT0gZmFsc2UpIHJldHVybjsgLy9cblxuICAgICAgX2ludmVyc2VNYXRyaXgkMi5jb3B5KG1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblxuICAgICAgX3JheSQyLmNvcHkocmF5Y2FzdGVyLnJheSkuYXBwbHlNYXRyaXg0KF9pbnZlcnNlTWF0cml4JDIpOyAvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xuXG5cbiAgICAgIGlmIChnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoX3JheSQyLmludGVyc2VjdHNCb3goZ2VvbWV0cnkuYm91bmRpbmdCb3gpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJzZWN0aW9uO1xuICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgdmFyIG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICB2YXIgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgICAgIHZhciB1diA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudXY7XG4gICAgICB2YXIgdXYyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djI7XG4gICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICAgICAgdmFyIGRyYXdSYW5nZSA9IGdlb21ldHJ5LmRyYXdSYW5nZTtcblxuICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgICAgIGZvciAodmFyIF9pNjIgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IF9pNjIgPCBpbDsgX2k2MisrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbX2k2Ml07XG4gICAgICAgICAgICB2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4oaW5kZXguY291bnQsIE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCkpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgICAgICB2YXIgYSA9IGluZGV4LmdldFgoaik7XG4gICAgICAgICAgICAgIHZhciBiID0gaW5kZXguZ2V0WChqICsgMSk7XG4gICAgICAgICAgICAgIHZhciBjID0gaW5kZXguZ2V0WChqICsgMik7XG4gICAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24odGhpcywgZ3JvdXBNYXRlcmlhbCwgcmF5Y2FzdGVyLCBfcmF5JDIsIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgYSwgYiwgYyk7XG5cbiAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKGogLyAzKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2UubWF0ZXJpYWxJbmRleCA9IGdyb3VwLm1hdGVyaWFsSW5kZXg7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKGludGVyc2VjdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9zdGFydDMgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXG4gICAgICAgICAgdmFyIF9lbmQyID0gTWF0aC5taW4oaW5kZXguY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTYzID0gX3N0YXJ0MywgX2lsNiA9IF9lbmQyOyBfaTYzIDwgX2lsNjsgX2k2MyArPSAzKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBpbmRleC5nZXRYKF9pNjMpO1xuXG4gICAgICAgICAgICB2YXIgX2IgPSBpbmRleC5nZXRYKF9pNjMgKyAxKTtcblxuICAgICAgICAgICAgdmFyIF9jID0gaW5kZXguZ2V0WChfaTYzICsgMik7XG5cbiAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24odGhpcywgbWF0ZXJpYWwsIHJheWNhc3RlciwgX3JheSQyLCBwb3NpdGlvbiwgbW9ycGhQb3NpdGlvbiwgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIHV2LCB1djIsIF9hLCBfYiwgX2MpO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKF9pNjMgLyAzKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXG4gICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaChpbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIG5vbi1pbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTY0ID0gMCwgX2lsNyA9IGdyb3Vwcy5sZW5ndGg7IF9pNjQgPCBfaWw3OyBfaTY0KyspIHtcbiAgICAgICAgICAgIHZhciBfZ3JvdXAyID0gZ3JvdXBzW19pNjRdO1xuICAgICAgICAgICAgdmFyIF9ncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbX2dyb3VwMi5tYXRlcmlhbEluZGV4XTtcblxuICAgICAgICAgICAgdmFyIF9zdGFydDQgPSBNYXRoLm1heChfZ3JvdXAyLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXG4gICAgICAgICAgICB2YXIgX2VuZDMgPSBNYXRoLm1pbihwb3NpdGlvbi5jb3VudCwgTWF0aC5taW4oX2dyb3VwMi5zdGFydCArIF9ncm91cDIuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCkpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfajIgPSBfc3RhcnQ0LCBfamwyID0gX2VuZDM7IF9qMiA8IF9qbDI7IF9qMiArPSAzKSB7XG4gICAgICAgICAgICAgIHZhciBfYTIgPSBfajI7XG5cbiAgICAgICAgICAgICAgdmFyIF9iMiA9IF9qMiArIDE7XG5cbiAgICAgICAgICAgICAgdmFyIF9jMiA9IF9qMiArIDI7XG5cbiAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbih0aGlzLCBfZ3JvdXBNYXRlcmlhbCwgcmF5Y2FzdGVyLCBfcmF5JDIsIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgX2EyLCBfYjIsIF9jMik7XG5cbiAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBNYXRoLmZsb29yKF9qMiAvIDMpOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gbm9uLWluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2UubWF0ZXJpYWxJbmRleCA9IF9ncm91cDIubWF0ZXJpYWxJbmRleDtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3N0YXJ0NSA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG5cbiAgICAgICAgICB2YXIgX2VuZDQgPSBNYXRoLm1pbihwb3NpdGlvbi5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNjUgPSBfc3RhcnQ1LCBfaWw4ID0gX2VuZDQ7IF9pNjUgPCBfaWw4OyBfaTY1ICs9IDMpIHtcbiAgICAgICAgICAgIHZhciBfYTMgPSBfaTY1O1xuXG4gICAgICAgICAgICB2YXIgX2IzID0gX2k2NSArIDE7XG5cbiAgICAgICAgICAgIHZhciBfYzMgPSBfaTY1ICsgMjtcblxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbih0aGlzLCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCBfcmF5JDIsIHBvc2l0aW9uLCBtb3JwaFBvc2l0aW9uLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgdXYsIHV2MiwgX2EzLCBfYjMsIF9jMyk7XG5cbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoX2k2NSAvIDMpOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gbm9uLWluZGV4ZWQgYnVmZmVyIHNlbWFudGljc1xuXG4gICAgICAgICAgICAgIGludGVyc2VjdHMucHVzaChpbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNoO1xufShPYmplY3QzRCk7XG5cbmZ1bmN0aW9uIGNoZWNrSW50ZXJzZWN0aW9uKG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCkge1xuICB2YXIgaW50ZXJzZWN0O1xuXG4gIGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkge1xuICAgIGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZShwQywgcEIsIHBBLCB0cnVlLCBwb2ludCk7XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKHBBLCBwQiwgcEMsIG1hdGVyaWFsLnNpZGUgIT09IERvdWJsZVNpZGUsIHBvaW50KTtcbiAgfVxuXG4gIGlmIChpbnRlcnNlY3QgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkocG9pbnQpO1xuXG4gIF9pbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NChvYmplY3QubWF0cml4V29ybGQpO1xuXG4gIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oX2ludGVyc2VjdGlvblBvaW50V29ybGQpO1xuICBpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICBwb2ludDogX2ludGVyc2VjdGlvblBvaW50V29ybGQuY2xvbmUoKSxcbiAgICBvYmplY3Q6IG9iamVjdFxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgbW9ycGhQb3NpdGlvbiwgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIHV2LCB1djIsIGEsIGIsIGMpIHtcbiAgX3ZBJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgYSk7XG5cbiAgX3ZCJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgYik7XG5cbiAgX3ZDJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbiwgYyk7XG5cbiAgdmFyIG1vcnBoSW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgaWYgKG1vcnBoUG9zaXRpb24gJiYgbW9ycGhJbmZsdWVuY2VzKSB7XG4gICAgX21vcnBoQS5zZXQoMCwgMCwgMCk7XG5cbiAgICBfbW9ycGhCLnNldCgwLCAwLCAwKTtcblxuICAgIF9tb3JwaEMuc2V0KDAsIDAsIDApO1xuXG4gICAgZm9yICh2YXIgX2k2NiA9IDAsIGlsID0gbW9ycGhQb3NpdGlvbi5sZW5ndGg7IF9pNjYgPCBpbDsgX2k2NisrKSB7XG4gICAgICB2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzW19pNjZdO1xuICAgICAgdmFyIG1vcnBoQXR0cmlidXRlID0gbW9ycGhQb3NpdGlvbltfaTY2XTtcbiAgICAgIGlmIChpbmZsdWVuY2UgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICBfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaEF0dHJpYnV0ZSwgYSk7XG5cbiAgICAgIF90ZW1wQi5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQXR0cmlidXRlLCBiKTtcblxuICAgICAgX3RlbXBDLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhBdHRyaWJ1dGUsIGMpO1xuXG4gICAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUpIHtcbiAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuXG4gICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQiwgaW5mbHVlbmNlKTtcblxuICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMsIGluZmx1ZW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbW9ycGhBLmFkZFNjYWxlZFZlY3RvcihfdGVtcEEuc3ViKF92QSQxKSwgaW5mbHVlbmNlKTtcblxuICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIuc3ViKF92QiQxKSwgaW5mbHVlbmNlKTtcblxuICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyQxKSwgaW5mbHVlbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdkEkMS5hZGQoX21vcnBoQSk7XG5cbiAgICBfdkIkMS5hZGQoX21vcnBoQik7XG5cbiAgICBfdkMkMS5hZGQoX21vcnBoQyk7XG4gIH1cblxuICBpZiAob2JqZWN0LmlzU2tpbm5lZE1lc2gpIHtcbiAgICBvYmplY3QuYm9uZVRyYW5zZm9ybShhLCBfdkEkMSk7XG4gICAgb2JqZWN0LmJvbmVUcmFuc2Zvcm0oYiwgX3ZCJDEpO1xuICAgIG9iamVjdC5ib25lVHJhbnNmb3JtKGMsIF92QyQxKTtcbiAgfVxuXG4gIHZhciBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbihvYmplY3QsIG1hdGVyaWFsLCByYXljYXN0ZXIsIHJheSwgX3ZBJDEsIF92QiQxLCBfdkMkMSwgX2ludGVyc2VjdGlvblBvaW50KTtcblxuICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgaWYgKHV2KSB7XG4gICAgICBfdXZBJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh1diwgYSk7XG5cbiAgICAgIF91dkIkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2LCBiKTtcblxuICAgICAgX3V2QyQxLmZyb21CdWZmZXJBdHRyaWJ1dGUodXYsIGMpO1xuXG4gICAgICBpbnRlcnNlY3Rpb24udXYgPSBUcmlhbmdsZS5nZXRVVihfaW50ZXJzZWN0aW9uUG9pbnQsIF92QSQxLCBfdkIkMSwgX3ZDJDEsIF91dkEkMSwgX3V2QiQxLCBfdXZDJDEsIG5ldyBWZWN0b3IyKCkpO1xuICAgIH1cblxuICAgIGlmICh1djIpIHtcbiAgICAgIF91dkEkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2MiwgYSk7XG5cbiAgICAgIF91dkIkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2MiwgYik7XG5cbiAgICAgIF91dkMkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHV2MiwgYyk7XG5cbiAgICAgIGludGVyc2VjdGlvbi51djIgPSBUcmlhbmdsZS5nZXRVVihfaW50ZXJzZWN0aW9uUG9pbnQsIF92QSQxLCBfdkIkMSwgX3ZDJDEsIF91dkEkMSwgX3V2QiQxLCBfdXZDJDEsIG5ldyBWZWN0b3IyKCkpO1xuICAgIH1cblxuICAgIHZhciBmYWNlID0ge1xuICAgICAgYTogYSxcbiAgICAgIGI6IGIsXG4gICAgICBjOiBjLFxuICAgICAgbm9ybWFsOiBuZXcgVmVjdG9yMygpLFxuICAgICAgbWF0ZXJpYWxJbmRleDogMFxuICAgIH07XG4gICAgVHJpYW5nbGUuZ2V0Tm9ybWFsKF92QSQxLCBfdkIkMSwgX3ZDJDEsIGZhY2Uubm9ybWFsKTtcbiAgICBpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG4gIH1cblxuICByZXR1cm4gaW50ZXJzZWN0aW9uO1xufVxuXG52YXIgQm94R2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CdWZmZXJHZW9tZXRyeSkge1xuICBfaW5oZXJpdHMoQm94R2VvbWV0cnksIF9CdWZmZXJHZW9tZXRyeSk7XG5cbiAgdmFyIF9zdXBlcjIzID0gX2NyZWF0ZVN1cGVyKEJveEdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBCb3hHZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXMxNTtcblxuICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICB2YXIgd2lkdGhTZWdtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcbiAgICB2YXIgaGVpZ2h0U2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDE7XG4gICAgdmFyIGRlcHRoU2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94R2VvbWV0cnkpO1xuXG4gICAgX3RoaXMxNSA9IF9zdXBlcjIzLmNhbGwodGhpcyk7XG4gICAgX3RoaXMxNS50eXBlID0gJ0JveEdlb21ldHJ5JztcbiAgICBfdGhpczE1LnBhcmFtZXRlcnMgPSB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgICBkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG4gICAgfTtcblxuICAgIHZhciBzY29wZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxNSk7IC8vIHNlZ21lbnRzXG5cblxuICAgIHdpZHRoU2VnbWVudHMgPSBNYXRoLmZsb29yKHdpZHRoU2VnbWVudHMpO1xuICAgIGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vcihoZWlnaHRTZWdtZW50cyk7XG4gICAgZGVwdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoZGVwdGhTZWdtZW50cyk7IC8vIGJ1ZmZlcnNcblxuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICB2YXIgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuICAgIHZhciBudW1iZXJPZlZlcnRpY2VzID0gMDtcbiAgICB2YXIgZ3JvdXBTdGFydCA9IDA7IC8vIGJ1aWxkIGVhY2ggc2lkZSBvZiB0aGUgYm94IGdlb21ldHJ5XG5cbiAgICBidWlsZFBsYW5lKCd6JywgJ3knLCAneCcsIC0xLCAtMSwgZGVwdGgsIGhlaWdodCwgd2lkdGgsIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAwKTsgLy8gcHhcblxuICAgIGJ1aWxkUGxhbmUoJ3onLCAneScsICd4JywgMSwgLTEsIGRlcHRoLCBoZWlnaHQsIC13aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDEpOyAvLyBueFxuXG4gICAgYnVpbGRQbGFuZSgneCcsICd6JywgJ3knLCAxLCAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMik7IC8vIHB5XG5cbiAgICBidWlsZFBsYW5lKCd4JywgJ3onLCAneScsIDEsIC0xLCB3aWR0aCwgZGVwdGgsIC1oZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDMpOyAvLyBueVxuXG4gICAgYnVpbGRQbGFuZSgneCcsICd5JywgJ3onLCAxLCAtMSwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA0KTsgLy8gcHpcblxuICAgIGJ1aWxkUGxhbmUoJ3gnLCAneScsICd6JywgLTEsIC0xLCB3aWR0aCwgaGVpZ2h0LCAtZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA1KTsgLy8gbnpcbiAgICAvLyBidWlsZCBnZW9tZXRyeVxuXG4gICAgX3RoaXMxNS5zZXRJbmRleChpbmRpY2VzKTtcblxuICAgIF90aGlzMTUuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cbiAgICBfdGhpczE1LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXG4gICAgX3RoaXMxNS5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cbiAgICBmdW5jdGlvbiBidWlsZFBsYW5lKHUsIHYsIHcsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBncmlkWCwgZ3JpZFksIG1hdGVyaWFsSW5kZXgpIHtcbiAgICAgIHZhciBzZWdtZW50V2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuICAgICAgdmFyIHNlZ21lbnRIZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcbiAgICAgIHZhciB3aWR0aEhhbGYgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xuICAgICAgdmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcbiAgICAgIHZhciBncmlkWTEgPSBncmlkWSArIDE7XG4gICAgICB2YXIgdmVydGV4Q291bnRlciA9IDA7XG4gICAgICB2YXIgZ3JvdXBDb3VudCA9IDA7XG4gICAgICB2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTsgLy8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgICBmb3IgKHZhciBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSsrKSB7XG4gICAgICAgIHZhciB5ID0gaXkgKiBzZWdtZW50SGVpZ2h0IC0gaGVpZ2h0SGFsZjtcblxuICAgICAgICBmb3IgKHZhciBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCsrKSB7XG4gICAgICAgICAgdmFyIHggPSBpeCAqIHNlZ21lbnRXaWR0aCAtIHdpZHRoSGFsZjsgLy8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcblxuICAgICAgICAgIHZlY3Rvclt1XSA9IHggKiB1ZGlyO1xuICAgICAgICAgIHZlY3Rvclt2XSA9IHkgKiB2ZGlyO1xuICAgICAgICAgIHZlY3Rvclt3XSA9IGRlcHRoSGFsZjsgLy8gbm93IGFwcGx5IHZlY3RvciB0byB2ZXJ0ZXggYnVmZmVyXG5cbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnopOyAvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuXG4gICAgICAgICAgdmVjdG9yW3VdID0gMDtcbiAgICAgICAgICB2ZWN0b3Jbdl0gPSAwO1xuICAgICAgICAgIHZlY3Rvclt3XSA9IGRlcHRoID4gMCA/IDEgOiAtMTsgLy8gbm93IGFwcGx5IHZlY3RvciB0byBub3JtYWwgYnVmZmVyXG5cbiAgICAgICAgICBub3JtYWxzLnB1c2godmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3Iueik7IC8vIHV2c1xuXG4gICAgICAgICAgdXZzLnB1c2goaXggLyBncmlkWCk7XG4gICAgICAgICAgdXZzLnB1c2goMSAtIGl5IC8gZ3JpZFkpOyAvLyBjb3VudGVyc1xuXG4gICAgICAgICAgdmVydGV4Q291bnRlciArPSAxO1xuICAgICAgICB9XG4gICAgICB9IC8vIGluZGljZXNcbiAgICAgIC8vIDEuIHlvdSBuZWVkIHRocmVlIGluZGljZXMgdG8gZHJhdyBhIHNpbmdsZSBmYWNlXG4gICAgICAvLyAyLiBhIHNpbmdsZSBzZWdtZW50IGNvbnNpc3RzIG9mIHR3byBmYWNlc1xuICAgICAgLy8gMy4gc28gd2UgbmVlZCB0byBnZW5lcmF0ZSBzaXggKDIqMykgaW5kaWNlcyBwZXIgc2VnbWVudFxuXG5cbiAgICAgIGZvciAodmFyIF9peSA9IDA7IF9peSA8IGdyaWRZOyBfaXkrKykge1xuICAgICAgICBmb3IgKHZhciBfaXggPSAwOyBfaXggPCBncmlkWDsgX2l4KyspIHtcbiAgICAgICAgICB2YXIgYSA9IG51bWJlck9mVmVydGljZXMgKyBfaXggKyBncmlkWDEgKiBfaXk7XG4gICAgICAgICAgdmFyIGIgPSBudW1iZXJPZlZlcnRpY2VzICsgX2l4ICsgZ3JpZFgxICogKF9peSArIDEpO1xuICAgICAgICAgIHZhciBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArIChfaXggKyAxKSArIGdyaWRYMSAqIChfaXkgKyAxKTtcbiAgICAgICAgICB2YXIgZCA9IG51bWJlck9mVmVydGljZXMgKyAoX2l4ICsgMSkgKyBncmlkWDEgKiBfaXk7IC8vIGZhY2VzXG5cbiAgICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpOyAvLyBpbmNyZWFzZSBjb3VudGVyXG5cbiAgICAgICAgICBncm91cENvdW50ICs9IDY7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXG4gICAgICBzY29wZS5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCBtYXRlcmlhbEluZGV4KTsgLy8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXG5cbiAgICAgIGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDsgLy8gdXBkYXRlIHRvdGFsIG51bWJlciBvZiB2ZXJ0aWNlc1xuXG4gICAgICBudW1iZXJPZlZlcnRpY2VzICs9IHZlcnRleENvdW50ZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzMTU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQm94R2VvbWV0cnksIG51bGwsIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgQm94R2VvbWV0cnkoZGF0YS53aWR0aCwgZGF0YS5oZWlnaHQsIGRhdGEuZGVwdGgsIGRhdGEud2lkdGhTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5kZXB0aFNlZ21lbnRzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm94R2VvbWV0cnk7XG59KEJ1ZmZlckdlb21ldHJ5KTtcbi8qKlxuICogVW5pZm9ybSBVdGlsaXRpZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lVW5pZm9ybXMoc3JjKSB7XG4gIHZhciBkc3QgPSB7fTtcblxuICBmb3IgKHZhciB1IGluIHNyYykge1xuICAgIGRzdFt1XSA9IHt9O1xuXG4gICAgZm9yICh2YXIgcCBpbiBzcmNbdV0pIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHNyY1t1XVtwXTtcblxuICAgICAgaWYgKHByb3BlcnR5ICYmIChwcm9wZXJ0eS5pc0NvbG9yIHx8IHByb3BlcnR5LmlzTWF0cml4MyB8fCBwcm9wZXJ0eS5pc01hdHJpeDQgfHwgcHJvcGVydHkuaXNWZWN0b3IyIHx8IHByb3BlcnR5LmlzVmVjdG9yMyB8fCBwcm9wZXJ0eS5pc1ZlY3RvcjQgfHwgcHJvcGVydHkuaXNUZXh0dXJlIHx8IHByb3BlcnR5LmlzUXVhdGVybmlvbikpIHtcbiAgICAgICAgZHN0W3VdW3BdID0gcHJvcGVydHkuY2xvbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eSkpIHtcbiAgICAgICAgZHN0W3VdW3BdID0gcHJvcGVydHkuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRzdFt1XVtwXSA9IHByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59XG5cbmZ1bmN0aW9uIG1lcmdlVW5pZm9ybXModW5pZm9ybXMpIHtcbiAgdmFyIG1lcmdlZCA9IHt9O1xuXG4gIGZvciAodmFyIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1KyspIHtcbiAgICB2YXIgX3RtcCA9IGNsb25lVW5pZm9ybXModW5pZm9ybXNbdV0pO1xuXG4gICAgZm9yICh2YXIgcCBpbiBfdG1wKSB7XG4gICAgICBtZXJnZWRbcF0gPSBfdG1wW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXJnZWQ7XG59IC8vIExlZ2FjeVxuXG5cbnZhciBVbmlmb3Jtc1V0aWxzID0ge1xuICBjbG9uZTogY2xvbmVVbmlmb3JtcyxcbiAgbWVyZ2U6IG1lcmdlVW5pZm9ybXNcbn07XG52YXIgZGVmYXVsdF92ZXJ0ZXggPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufVwiO1xudmFyIGRlZmF1bHRfZnJhZ21lbnQgPSBcInZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59XCI7XG5cbnZhciBTaGFkZXJNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01hdGVyaWFsMikge1xuICBfaW5oZXJpdHMoU2hhZGVyTWF0ZXJpYWwsIF9NYXRlcmlhbDIpO1xuXG4gIHZhciBfc3VwZXIyNCA9IF9jcmVhdGVTdXBlcihTaGFkZXJNYXRlcmlhbCk7XG5cbiAgZnVuY3Rpb24gU2hhZGVyTWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczE2O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYWRlck1hdGVyaWFsKTtcblxuICAgIF90aGlzMTYgPSBfc3VwZXIyNC5jYWxsKHRoaXMpO1xuICAgIF90aGlzMTYuaXNTaGFkZXJNYXRlcmlhbCA9IHRydWU7XG4gICAgX3RoaXMxNi50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcbiAgICBfdGhpczE2LmRlZmluZXMgPSB7fTtcbiAgICBfdGhpczE2LnVuaWZvcm1zID0ge307XG4gICAgX3RoaXMxNi52ZXJ0ZXhTaGFkZXIgPSBkZWZhdWx0X3ZlcnRleDtcbiAgICBfdGhpczE2LmZyYWdtZW50U2hhZGVyID0gZGVmYXVsdF9mcmFnbWVudDtcbiAgICBfdGhpczE2LmxpbmV3aWR0aCA9IDE7XG4gICAgX3RoaXMxNi53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBfdGhpczE2LndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgX3RoaXMxNi5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuICAgIF90aGlzMTYubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXG5cbiAgICBfdGhpczE2LmNsaXBwaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2UgdXNlci1kZWZpbmVkIGNsaXBwaW5nIHBsYW5lc1xuXG4gICAgX3RoaXMxNi5leHRlbnNpb25zID0ge1xuICAgICAgZGVyaXZhdGl2ZXM6IGZhbHNlLFxuICAgICAgLy8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xuICAgICAgZnJhZ0RlcHRoOiBmYWxzZSxcbiAgICAgIC8vIHNldCB0byB1c2UgZnJhZ21lbnQgZGVwdGggdmFsdWVzXG4gICAgICBkcmF3QnVmZmVyczogZmFsc2UsXG4gICAgICAvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xuICAgICAgc2hhZGVyVGV4dHVyZUxPRDogZmFsc2UgLy8gc2V0IHRvIHVzZSBzaGFkZXIgdGV4dHVyZSBMT0RcblxuICAgIH07IC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxuICAgIC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cblxuICAgIF90aGlzMTYuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcbiAgICAgICdjb2xvcic6IFsxLCAxLCAxXSxcbiAgICAgICd1dic6IFswLCAwXSxcbiAgICAgICd1djInOiBbMCwgMF1cbiAgICB9O1xuICAgIF90aGlzMTYuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcbiAgICBfdGhpczE2LnVuaWZvcm1zTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIF90aGlzMTYuZ2xzbFZlcnNpb24gPSBudWxsO1xuXG4gICAgaWYgKHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHBhcmFtZXRlcnMuYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiBhdHRyaWJ1dGVzIHNob3VsZCBub3cgYmUgZGVmaW5lZCBpbiBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicpO1xuICAgICAgfVxuXG4gICAgICBfdGhpczE2LnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXMxNjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTaGFkZXJNYXRlcmlhbCwgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcbiAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gc291cmNlLnZlcnRleFNoYWRlcjtcbiAgICAgIHRoaXMudW5pZm9ybXMgPSBjbG9uZVVuaWZvcm1zKHNvdXJjZS51bmlmb3Jtcyk7XG4gICAgICB0aGlzLmRlZmluZXMgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuZGVmaW5lcyk7XG4gICAgICB0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG4gICAgICB0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XG4gICAgICB0aGlzLmNsaXBwaW5nID0gc291cmNlLmNsaXBwaW5nO1xuICAgICAgdGhpcy5leHRlbnNpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLmV4dGVuc2lvbnMpO1xuICAgICAgdGhpcy5nbHNsVmVyc2lvbiA9IHNvdXJjZS5nbHNsVmVyc2lvbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKG1ldGEpIHtcbiAgICAgIHZhciBkYXRhID0gX2dldChfZ2V0UHJvdG90eXBlT2YoU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlKSwgXCJ0b0pTT05cIiwgdGhpcykuY2FsbCh0aGlzLCBtZXRhKTtcblxuICAgICAgZGF0YS5nbHNsVmVyc2lvbiA9IHRoaXMuZ2xzbFZlcnNpb247XG4gICAgICBkYXRhLnVuaWZvcm1zID0ge307XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy51bmlmb3Jtcykge1xuICAgICAgICB2YXIgdW5pZm9ybSA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgICAgIHZhciBfdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXG4gICAgICAgIGlmIChfdmFsdWUgJiYgX3ZhbHVlLmlzVGV4dHVyZSkge1xuICAgICAgICAgIGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgICAgICAgICB0eXBlOiAndCcsXG4gICAgICAgICAgICB2YWx1ZTogX3ZhbHVlLnRvSlNPTihtZXRhKS51dWlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChfdmFsdWUgJiYgX3ZhbHVlLmlzQ29sb3IpIHtcbiAgICAgICAgICBkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogJ2MnLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZS5nZXRIZXgoKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlICYmIF92YWx1ZS5pc1ZlY3RvcjIpIHtcbiAgICAgICAgICBkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogJ3YyJyxcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWUudG9BcnJheSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChfdmFsdWUgJiYgX3ZhbHVlLmlzVmVjdG9yMykge1xuICAgICAgICAgIGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgICAgICAgICB0eXBlOiAndjMnLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZS50b0FycmF5KClcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKF92YWx1ZSAmJiBfdmFsdWUuaXNWZWN0b3I0KSB7XG4gICAgICAgICAgZGF0YS51bmlmb3Jtc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd2NCcsXG4gICAgICAgICAgICB2YWx1ZTogX3ZhbHVlLnRvQXJyYXkoKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlICYmIF92YWx1ZS5pc01hdHJpeDMpIHtcbiAgICAgICAgICBkYXRhLnVuaWZvcm1zW25hbWVdID0ge1xuICAgICAgICAgICAgdHlwZTogJ20zJyxcbiAgICAgICAgICAgIHZhbHVlOiBfdmFsdWUudG9BcnJheSgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChfdmFsdWUgJiYgX3ZhbHVlLmlzTWF0cml4NCkge1xuICAgICAgICAgIGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbTQnLFxuICAgICAgICAgICAgdmFsdWU6IF92YWx1ZS50b0FycmF5KClcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEudW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgICAgfTsgLy8gbm90ZTogdGhlIGFycmF5IHZhcmlhbnRzIHYydiwgdjN2LCB2NHYsIG00diBhbmQgdHYgYXJlIG5vdCBzdXBwb3J0ZWQgc28gZmFyXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZGVmaW5lcykubGVuZ3RoID4gMCkgZGF0YS5kZWZpbmVzID0gdGhpcy5kZWZpbmVzO1xuICAgICAgZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcbiAgICAgIGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuICAgICAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZXh0ZW5zaW9ucykge1xuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25zW2tleV0gPT09IHRydWUpIGV4dGVuc2lvbnNba2V5XSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhleHRlbnNpb25zKS5sZW5ndGggPiAwKSBkYXRhLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoYWRlck1hdGVyaWFsO1xufShNYXRlcmlhbCk7XG5cbnZhciBDYW1lcmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmplY3QzRDIpIHtcbiAgX2luaGVyaXRzKENhbWVyYSwgX09iamVjdDNEMik7XG5cbiAgdmFyIF9zdXBlcjI1ID0gX2NyZWF0ZVN1cGVyKENhbWVyYSk7XG5cbiAgZnVuY3Rpb24gQ2FtZXJhKCkge1xuICAgIHZhciBfdGhpczE3O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbWVyYSk7XG5cbiAgICBfdGhpczE3ID0gX3N1cGVyMjUuY2FsbCh0aGlzKTtcbiAgICBfdGhpczE3LmlzQ2FtZXJhID0gdHJ1ZTtcbiAgICBfdGhpczE3LnR5cGUgPSAnQ2FtZXJhJztcbiAgICBfdGhpczE3Lm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgX3RoaXMxNy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBfdGhpczE3LnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcbiAgICByZXR1cm4gX3RoaXMxNztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDYW1lcmEsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQ2FtZXJhLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlKTtcblxuICAgICAgdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weShzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlKTtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KHNvdXJjZS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UuY29weShzb3VyY2UucHJvamVjdGlvbk1hdHJpeEludmVyc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFdvcmxkRGlyZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdvcmxkRGlyZWN0aW9uKHRhcmdldCkge1xuICAgICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCBmYWxzZSk7XG4gICAgICB2YXIgZSA9IHRoaXMubWF0cml4V29ybGQuZWxlbWVudHM7XG4gICAgICByZXR1cm4gdGFyZ2V0LnNldCgtZVs4XSwgLWVbOV0sIC1lWzEwXSkubm9ybWFsaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU1hdHJpeFdvcmxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihDYW1lcmEucHJvdG90eXBlKSwgXCJ1cGRhdGVNYXRyaXhXb3JsZFwiLCB0aGlzKS5jYWxsKHRoaXMsIGZvcmNlKTtcblxuICAgICAgdGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlV29ybGRNYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlV29ybGRNYXRyaXgodXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKENhbWVyYS5wcm90b3R5cGUpLCBcInVwZGF0ZVdvcmxkTWF0cml4XCIsIHRoaXMpLmNhbGwodGhpcywgdXBkYXRlUGFyZW50cywgdXBkYXRlQ2hpbGRyZW4pO1xuXG4gICAgICB0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KHRoaXMubWF0cml4V29ybGQpLmludmVydCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbWVyYTtcbn0oT2JqZWN0M0QpO1xuXG52YXIgUGVyc3BlY3RpdmVDYW1lcmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DYW1lcmEpIHtcbiAgX2luaGVyaXRzKFBlcnNwZWN0aXZlQ2FtZXJhLCBfQ2FtZXJhKTtcblxuICB2YXIgX3N1cGVyMjYgPSBfY3JlYXRlU3VwZXIoUGVyc3BlY3RpdmVDYW1lcmEpO1xuXG4gIGZ1bmN0aW9uIFBlcnNwZWN0aXZlQ2FtZXJhKCkge1xuICAgIHZhciBfdGhpczE4O1xuXG4gICAgdmFyIGZvdiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogNTA7XG4gICAgdmFyIGFzcGVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICB2YXIgbmVhciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMC4xO1xuICAgIHZhciBmYXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDIwMDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyc3BlY3RpdmVDYW1lcmEpO1xuXG4gICAgX3RoaXMxOCA9IF9zdXBlcjI2LmNhbGwodGhpcyk7XG4gICAgX3RoaXMxOC5pc1BlcnNwZWN0aXZlQ2FtZXJhID0gdHJ1ZTtcbiAgICBfdGhpczE4LnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuICAgIF90aGlzMTguZm92ID0gZm92O1xuICAgIF90aGlzMTguem9vbSA9IDE7XG4gICAgX3RoaXMxOC5uZWFyID0gbmVhcjtcbiAgICBfdGhpczE4LmZhciA9IGZhcjtcbiAgICBfdGhpczE4LmZvY3VzID0gMTA7XG4gICAgX3RoaXMxOC5hc3BlY3QgPSBhc3BlY3Q7XG4gICAgX3RoaXMxOC52aWV3ID0gbnVsbDtcbiAgICBfdGhpczE4LmZpbG1HYXVnZSA9IDM1OyAvLyB3aWR0aCBvZiB0aGUgZmlsbSAoZGVmYXVsdCBpbiBtaWxsaW1ldGVycylcblxuICAgIF90aGlzMTguZmlsbU9mZnNldCA9IDA7IC8vIGhvcml6b250YWwgZmlsbSBvZmZzZXQgKHNhbWUgdW5pdCBhcyBnYXVnZSlcblxuICAgIF90aGlzMTgudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgcmV0dXJuIF90aGlzMTg7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGVyc3BlY3RpdmVDYW1lcmEsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlLCByZWN1cnNpdmUpO1xuXG4gICAgICB0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG4gICAgICB0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcbiAgICAgIHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuICAgICAgdGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuICAgICAgdGhpcy5mb2N1cyA9IHNvdXJjZS5mb2N1cztcbiAgICAgIHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcbiAgICAgIHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS52aWV3KTtcbiAgICAgIHRoaXMuZmlsbUdhdWdlID0gc291cmNlLmZpbG1HYXVnZTtcbiAgICAgIHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEZPViBieSBmb2NhbCBsZW5ndGggaW4gcmVzcGVjdCB0byB0aGUgY3VycmVudCAuZmlsbUdhdWdlLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgZmlsbSBnYXVnZSBpcyAzNSwgc28gdGhhdCB0aGUgZm9jYWwgbGVuZ3RoIGNhbiBiZSBzcGVjaWZpZWQgZm9yXG4gICAgICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgZm9yIGZvY2FsIGxlbmd0aCBhbmQgZmlsbSBnYXVnZSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldEZvY2FsTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZvY2FsTGVuZ3RoKGZvY2FsTGVuZ3RoKSB7XG4gICAgICAvKiogc2VlIHtAbGluayBodHRwOi8vd3d3LmJvYmF0a2lucy5jb20vcGhvdG9ncmFwaHkvdGVjaG5pY2FsL2ZpZWxkX29mX3ZpZXcuaHRtbH0gKi9cbiAgICAgIHZhciB2RXh0ZW50U2xvcGUgPSAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIGZvY2FsTGVuZ3RoO1xuICAgICAgdGhpcy5mb3YgPSBSQUQyREVHICogMiAqIE1hdGguYXRhbih2RXh0ZW50U2xvcGUpO1xuICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGZvY2FsIGxlbmd0aCBmcm9tIHRoZSBjdXJyZW50IC5mb3YgYW5kIC5maWxtR2F1Z2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb2NhbExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb2NhbExlbmd0aCgpIHtcbiAgICAgIHZhciB2RXh0ZW50U2xvcGUgPSBNYXRoLnRhbihERUcyUkFEICogMC41ICogdGhpcy5mb3YpO1xuICAgICAgcmV0dXJuIDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gdkV4dGVudFNsb3BlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZmZlY3RpdmVGT1ZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWZmZWN0aXZlRk9WKCkge1xuICAgICAgcmV0dXJuIFJBRDJERUcgKiAyICogTWF0aC5hdGFuKE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdikgLyB0aGlzLnpvb20pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGaWxtV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsbVdpZHRoKCkge1xuICAgICAgLy8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIHBvcnRyYWl0IGZvcm1hdCAoYXNwZWN0IDwgMSlcbiAgICAgIHJldHVybiB0aGlzLmZpbG1HYXVnZSAqIE1hdGgubWluKHRoaXMuYXNwZWN0LCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmlsbUhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWxtSGVpZ2h0KCkge1xuICAgICAgLy8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIGxhbmRzY2FwZSBmb3JtYXQgKGFzcGVjdCA+IDEpXG4gICAgICByZXR1cm4gdGhpcy5maWxtR2F1Z2UgLyBNYXRoLm1heCh0aGlzLmFzcGVjdCwgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3JcbiAgICAgKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcbiAgICAgKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXG4gICAgICpcbiAgICAgKiAgICstLS0rLS0tKy0tLStcbiAgICAgKiAgIHwgQSB8IEIgfCBDIHxcbiAgICAgKiAgICstLS0rLS0tKy0tLStcbiAgICAgKiAgIHwgRCB8IEUgfCBGIHxcbiAgICAgKiAgICstLS0rLS0tKy0tLStcbiAgICAgKlxuICAgICAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXNcbiAgICAgKlxuICAgICAqICAgY29uc3QgdyA9IDE5MjA7XG4gICAgICogICBjb25zdCBoID0gMTA4MDtcbiAgICAgKiAgIGNvbnN0IGZ1bGxXaWR0aCA9IHcgKiAzO1xuICAgICAqICAgY29uc3QgZnVsbEhlaWdodCA9IGggKiAyO1xuICAgICAqXG4gICAgICogICAtLUEtLVxuICAgICAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XG4gICAgICogICAtLUItLVxuICAgICAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XG4gICAgICogICAtLUMtLVxuICAgICAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XG4gICAgICogICAtLUQtLVxuICAgICAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XG4gICAgICogICAtLUUtLVxuICAgICAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XG4gICAgICogICAtLUYtLVxuICAgICAqICAgY2FtZXJhLnNldFZpZXdPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XG4gICAgICpcbiAgICAgKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRWaWV3T2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZpZXdPZmZzZXQoZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmFzcGVjdCA9IGZ1bGxXaWR0aCAvIGZ1bGxIZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLnZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy52aWV3ID0ge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgZnVsbFdpZHRoOiAxLFxuICAgICAgICAgIGZ1bGxIZWlnaHQ6IDEsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuICAgICAgdGhpcy52aWV3LmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuICAgICAgdGhpcy52aWV3Lm9mZnNldFggPSB4O1xuICAgICAgdGhpcy52aWV3Lm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyVmlld09mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclZpZXdPZmZzZXQoKSB7XG4gICAgICBpZiAodGhpcy52aWV3ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudmlldy5lbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSB7XG4gICAgICB2YXIgbmVhciA9IHRoaXMubmVhcjtcbiAgICAgIHZhciB0b3AgPSBuZWFyICogTWF0aC50YW4oREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92KSAvIHRoaXMuem9vbTtcbiAgICAgIHZhciBoZWlnaHQgPSAyICogdG9wO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5hc3BlY3QgKiBoZWlnaHQ7XG4gICAgICB2YXIgbGVmdCA9IC0wLjUgKiB3aWR0aDtcbiAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xuXG4gICAgICBpZiAodGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkKSB7XG4gICAgICAgIHZhciBmdWxsV2lkdGggPSB2aWV3LmZ1bGxXaWR0aCxcbiAgICAgICAgICAgIGZ1bGxIZWlnaHQgPSB2aWV3LmZ1bGxIZWlnaHQ7XG4gICAgICAgIGxlZnQgKz0gdmlldy5vZmZzZXRYICogd2lkdGggLyBmdWxsV2lkdGg7XG4gICAgICAgIHRvcCAtPSB2aWV3Lm9mZnNldFkgKiBoZWlnaHQgLyBmdWxsSGVpZ2h0O1xuICAgICAgICB3aWR0aCAqPSB2aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xuICAgICAgICBoZWlnaHQgKj0gdmlldy5oZWlnaHQgLyBmdWxsSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB2YXIgc2tldyA9IHRoaXMuZmlsbU9mZnNldDtcbiAgICAgIGlmIChza2V3ICE9PSAwKSBsZWZ0ICs9IG5lYXIgKiBza2V3IC8gdGhpcy5nZXRGaWxtV2lkdGgoKTtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUobGVmdCwgbGVmdCArIHdpZHRoLCB0b3AsIHRvcCAtIGhlaWdodCwgbmVhciwgdGhpcy5mYXIpO1xuICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04obWV0YSkge1xuICAgICAgdmFyIGRhdGEgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMsIG1ldGEpO1xuXG4gICAgICBkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcbiAgICAgIGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG4gICAgICBkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuICAgICAgZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG4gICAgICBkYXRhLm9iamVjdC5mb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgICBkYXRhLm9iamVjdC5hc3BlY3QgPSB0aGlzLmFzcGVjdDtcbiAgICAgIGlmICh0aGlzLnZpZXcgIT09IG51bGwpIGRhdGEub2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXcpO1xuICAgICAgZGF0YS5vYmplY3QuZmlsbUdhdWdlID0gdGhpcy5maWxtR2F1Z2U7XG4gICAgICBkYXRhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBlcnNwZWN0aXZlQ2FtZXJhO1xufShDYW1lcmEpO1xuXG52YXIgZm92ID0gOTAsXG4gICAgYXNwZWN0ID0gMTtcblxudmFyIEN1YmVDYW1lcmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmplY3QzRDMpIHtcbiAgX2luaGVyaXRzKEN1YmVDYW1lcmEsIF9PYmplY3QzRDMpO1xuXG4gIHZhciBfc3VwZXIyNyA9IF9jcmVhdGVTdXBlcihDdWJlQ2FtZXJhKTtcblxuICBmdW5jdGlvbiBDdWJlQ2FtZXJhKG5lYXIsIGZhciwgcmVuZGVyVGFyZ2V0KSB7XG4gICAgdmFyIF90aGlzMTk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3ViZUNhbWVyYSk7XG5cbiAgICBfdGhpczE5ID0gX3N1cGVyMjcuY2FsbCh0aGlzKTtcbiAgICBfdGhpczE5LnR5cGUgPSAnQ3ViZUNhbWVyYSc7XG5cbiAgICBpZiAocmVuZGVyVGFyZ2V0LmlzV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ICE9PSB0cnVlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5DdWJlQ2FtZXJhOiBUaGUgY29uc3RydWN0b3Igbm93IGV4cGVjdHMgYW4gaW5zdGFuY2Ugb2YgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IGFzIHRoaXJkIHBhcmFtZXRlci4nKTtcbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpczE5KTtcbiAgICB9XG5cbiAgICBfdGhpczE5LnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICB2YXIgY2FtZXJhUFggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG4gICAgY2FtZXJhUFgubGF5ZXJzID0gX3RoaXMxOS5sYXllcnM7XG4gICAgY2FtZXJhUFgudXAuc2V0KDAsIC0xLCAwKTtcbiAgICBjYW1lcmFQWC5sb29rQXQobmV3IFZlY3RvcjMoMSwgMCwgMCkpO1xuXG4gICAgX3RoaXMxOS5hZGQoY2FtZXJhUFgpO1xuXG4gICAgdmFyIGNhbWVyYU5YID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpO1xuICAgIGNhbWVyYU5YLmxheWVycyA9IF90aGlzMTkubGF5ZXJzO1xuICAgIGNhbWVyYU5YLnVwLnNldCgwLCAtMSwgMCk7XG4gICAgY2FtZXJhTlgubG9va0F0KG5ldyBWZWN0b3IzKC0xLCAwLCAwKSk7XG5cbiAgICBfdGhpczE5LmFkZChjYW1lcmFOWCk7XG5cbiAgICB2YXIgY2FtZXJhUFkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG4gICAgY2FtZXJhUFkubGF5ZXJzID0gX3RoaXMxOS5sYXllcnM7XG4gICAgY2FtZXJhUFkudXAuc2V0KDAsIDAsIDEpO1xuICAgIGNhbWVyYVBZLmxvb2tBdChuZXcgVmVjdG9yMygwLCAxLCAwKSk7XG5cbiAgICBfdGhpczE5LmFkZChjYW1lcmFQWSk7XG5cbiAgICB2YXIgY2FtZXJhTlkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG4gICAgY2FtZXJhTlkubGF5ZXJzID0gX3RoaXMxOS5sYXllcnM7XG4gICAgY2FtZXJhTlkudXAuc2V0KDAsIDAsIC0xKTtcbiAgICBjYW1lcmFOWS5sb29rQXQobmV3IFZlY3RvcjMoMCwgLTEsIDApKTtcblxuICAgIF90aGlzMTkuYWRkKGNhbWVyYU5ZKTtcblxuICAgIHZhciBjYW1lcmFQWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgICBjYW1lcmFQWi5sYXllcnMgPSBfdGhpczE5LmxheWVycztcbiAgICBjYW1lcmFQWi51cC5zZXQoMCwgLTEsIDApO1xuICAgIGNhbWVyYVBaLmxvb2tBdChuZXcgVmVjdG9yMygwLCAwLCAxKSk7XG5cbiAgICBfdGhpczE5LmFkZChjYW1lcmFQWik7XG5cbiAgICB2YXIgY2FtZXJhTlogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG4gICAgY2FtZXJhTloubGF5ZXJzID0gX3RoaXMxOS5sYXllcnM7XG4gICAgY2FtZXJhTloudXAuc2V0KDAsIC0xLCAwKTtcbiAgICBjYW1lcmFOWi5sb29rQXQobmV3IFZlY3RvcjMoMCwgMCwgLTEpKTtcblxuICAgIF90aGlzMTkuYWRkKGNhbWVyYU5aKTtcblxuICAgIHJldHVybiBfdGhpczE5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEN1YmVDYW1lcmEsIFt7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUocmVuZGVyZXIsIHNjZW5lKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQgPT09IG51bGwpIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcblxuICAgICAgdmFyIF90aGlzJGNoaWxkcmVuID0gX3NsaWNlZFRvQXJyYXkodGhpcy5jaGlsZHJlbiwgNiksXG4gICAgICAgICAgY2FtZXJhUFggPSBfdGhpcyRjaGlsZHJlblswXSxcbiAgICAgICAgICBjYW1lcmFOWCA9IF90aGlzJGNoaWxkcmVuWzFdLFxuICAgICAgICAgIGNhbWVyYVBZID0gX3RoaXMkY2hpbGRyZW5bMl0sXG4gICAgICAgICAgY2FtZXJhTlkgPSBfdGhpcyRjaGlsZHJlblszXSxcbiAgICAgICAgICBjYW1lcmFQWiA9IF90aGlzJGNoaWxkcmVuWzRdLFxuICAgICAgICAgIGNhbWVyYU5aID0gX3RoaXMkY2hpbGRyZW5bNV07XG5cbiAgICAgIHZhciBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG4gICAgICB2YXIgY3VycmVudFRvbmVNYXBwaW5nID0gcmVuZGVyZXIudG9uZU1hcHBpbmc7XG4gICAgICB2YXIgY3VycmVudFhyRW5hYmxlZCA9IHJlbmRlcmVyLnhyLmVuYWJsZWQ7XG4gICAgICByZW5kZXJlci50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG4gICAgICByZW5kZXJlci54ci5lbmFibGVkID0gZmFsc2U7XG4gICAgICB2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuICAgICAgcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0LCAwKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhUFgpO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgMSk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYU5YKTtcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQsIDIpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFQWSk7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0LCAzKTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhTlkpO1xuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCwgNCk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYVBaKTtcbiAgICAgIHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQsIDUpO1xuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmFOWik7XG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoY3VycmVudFJlbmRlclRhcmdldCk7XG4gICAgICByZW5kZXJlci50b25lTWFwcGluZyA9IGN1cnJlbnRUb25lTWFwcGluZztcbiAgICAgIHJlbmRlcmVyLnhyLmVuYWJsZWQgPSBjdXJyZW50WHJFbmFibGVkO1xuICAgICAgcmVuZGVyVGFyZ2V0LnRleHR1cmUubmVlZHNQTVJFTVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1YmVDYW1lcmE7XG59KE9iamVjdDNEKTtcblxudmFyIEN1YmVUZXh0dXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dHVyZTMpIHtcbiAgX2luaGVyaXRzKEN1YmVUZXh0dXJlLCBfVGV4dHVyZTMpO1xuXG4gIHZhciBfc3VwZXIyOCA9IF9jcmVhdGVTdXBlcihDdWJlVGV4dHVyZSk7XG5cbiAgZnVuY3Rpb24gQ3ViZVRleHR1cmUoaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nKSB7XG4gICAgdmFyIF90aGlzMjA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3ViZVRleHR1cmUpO1xuXG4gICAgaW1hZ2VzID0gaW1hZ2VzICE9PSB1bmRlZmluZWQgPyBpbWFnZXMgOiBbXTtcbiAgICBtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcbiAgICBfdGhpczIwID0gX3N1cGVyMjguY2FsbCh0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcpO1xuICAgIF90aGlzMjAuaXNDdWJlVGV4dHVyZSA9IHRydWU7XG4gICAgX3RoaXMyMC5mbGlwWSA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpczIwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEN1YmVUZXh0dXJlLCBbe1xuICAgIGtleTogXCJpbWFnZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuaW1hZ2UgPSB2YWx1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3ViZVRleHR1cmU7XG59KFRleHR1cmUpO1xuXG52YXIgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfV2ViR0xSZW5kZXJUYXJnZXQ0KSB7XG4gIF9pbmhlcml0cyhXZWJHTEN1YmVSZW5kZXJUYXJnZXQsIF9XZWJHTFJlbmRlclRhcmdldDQpO1xuXG4gIHZhciBfc3VwZXIyOSA9IF9jcmVhdGVTdXBlcihXZWJHTEN1YmVSZW5kZXJUYXJnZXQpO1xuXG4gIGZ1bmN0aW9uIFdlYkdMQ3ViZVJlbmRlclRhcmdldChzaXplKSB7XG4gICAgdmFyIF90aGlzMjE7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KTtcblxuICAgIF90aGlzMjEgPSBfc3VwZXIyOS5jYWxsKHRoaXMsIHNpemUsIHNpemUsIG9wdGlvbnMpO1xuICAgIF90aGlzMjEuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPSB0cnVlO1xuICAgIHZhciBpbWFnZSA9IHtcbiAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgZGVwdGg6IDFcbiAgICB9O1xuICAgIHZhciBpbWFnZXMgPSBbaW1hZ2UsIGltYWdlLCBpbWFnZSwgaW1hZ2UsIGltYWdlLCBpbWFnZV07XG4gICAgX3RoaXMyMS50ZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKGltYWdlcywgb3B0aW9ucy5tYXBwaW5nLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSwgb3B0aW9ucy5lbmNvZGluZyk7IC8vIEJ5IGNvbnZlbnRpb24gLS0gbGlrZWx5IGJhc2VkIG9uIHRoZSBSZW5kZXJNYW4gc3BlYyBmcm9tIHRoZSAxOTkwJ3MgLS0gY3ViZSBtYXBzIGFyZSBzcGVjaWZpZWQgYnkgV2ViR0wgKGFuZCB0aHJlZS5qcylcbiAgICAvLyBpbiBhIGNvb3JkaW5hdGUgc3lzdGVtIGluIHdoaWNoIHBvc2l0aXZlLXggaXMgdG8gdGhlIHJpZ2h0IHdoZW4gbG9va2luZyB1cCB0aGUgcG9zaXRpdmUteiBheGlzIC0tIGluIG90aGVyIHdvcmRzLFxuICAgIC8vIGluIGEgbGVmdC1oYW5kZWQgY29vcmRpbmF0ZSBzeXN0ZW0uIEJ5IGNvbnRpbnVpbmcgdGhpcyBjb252ZW50aW9uLCBwcmVleGlzdGluZyBjdWJlIG1hcHMgY29udGludWVkIHRvIHJlbmRlciBjb3JyZWN0bHkuXG4gICAgLy8gdGhyZWUuanMgdXNlcyBhIHJpZ2h0LWhhbmRlZCBjb29yZGluYXRlIHN5c3RlbS4gU28gZW52aXJvbm1lbnQgbWFwcyB1c2VkIGluIHRocmVlLmpzIGFwcGVhciB0byBoYXZlIHB4IGFuZCBueCBzd2FwcGVkXG4gICAgLy8gYW5kIHRoZSBmbGFnIGlzUmVuZGVyVGFyZ2V0VGV4dHVyZSBjb250cm9scyB0aGlzIGNvbnZlcnNpb24uIFRoZSBmbGlwIGlzIG5vdCByZXF1aXJlZCB3aGVuIHVzaW5nIFdlYkdMQ3ViZVJlbmRlclRhcmdldC50ZXh0dXJlXG4gICAgLy8gYXMgYSBjdWJlIHRleHR1cmUgKHRoaXMgaXMgZGV0ZWN0ZWQgd2hlbiBpc1JlbmRlclRhcmdldFRleHR1cmUgaXMgc2V0IHRvIHRydWUgZm9yIGN1YmUgdGV4dHVyZXMpLlxuXG4gICAgX3RoaXMyMS50ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9IHRydWU7XG4gICAgX3RoaXMyMS50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlO1xuICAgIF90aGlzMjEudGV4dHVyZS5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG4gICAgcmV0dXJuIF90aGlzMjE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViR0xDdWJlUmVuZGVyVGFyZ2V0LCBbe1xuICAgIGtleTogXCJmcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZShyZW5kZXJlciwgdGV4dHVyZSkge1xuICAgICAgdGhpcy50ZXh0dXJlLnR5cGUgPSB0ZXh0dXJlLnR5cGU7XG4gICAgICB0aGlzLnRleHR1cmUuZW5jb2RpbmcgPSB0ZXh0dXJlLmVuY29kaW5nO1xuICAgICAgdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuICAgICAgdGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHRleHR1cmUubWluRmlsdGVyO1xuICAgICAgdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHRleHR1cmUubWFnRmlsdGVyO1xuICAgICAgdmFyIHNoYWRlciA9IHtcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICB0RXF1aXJlY3Q6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6XG4gICAgICAgIC8qIGdsc2wgKi9cbiAgICAgICAgXCJcXG5cXG5cXHRcXHRcXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdFxcdHZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZvaWQgbWFpbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0XFx0XFx0XFx0XFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6XG4gICAgICAgIC8qIGdsc2wgKi9cbiAgICAgICAgXCJcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxuXFxuXFx0XFx0XFx0XFx0dmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHQjaW5jbHVkZSA8Y29tbW9uPlxcblxcblxcdFxcdFxcdFxcdHZvaWQgbWFpbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkRGlyZWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIlxuICAgICAgfTtcbiAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBCb3hHZW9tZXRyeSg1LCA1LCA1KTtcbiAgICAgIHZhciBtYXRlcmlhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbCh7XG4gICAgICAgIG5hbWU6ICdDdWJlbWFwRnJvbUVxdWlyZWN0JyxcbiAgICAgICAgdW5pZm9ybXM6IGNsb25lVW5pZm9ybXMoc2hhZGVyLnVuaWZvcm1zKSxcbiAgICAgICAgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgICAgICBzaWRlOiBCYWNrU2lkZSxcbiAgICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmdcbiAgICAgIH0pO1xuICAgICAgbWF0ZXJpYWwudW5pZm9ybXMudEVxdWlyZWN0LnZhbHVlID0gdGV4dHVyZTtcbiAgICAgIHZhciBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgIHZhciBjdXJyZW50TWluRmlsdGVyID0gdGV4dHVyZS5taW5GaWx0ZXI7IC8vIEF2b2lkIGJsdXJyZWQgcG9sZXNcblxuICAgICAgaWYgKHRleHR1cmUubWluRmlsdGVyID09PSBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIpIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgdmFyIGNhbWVyYSA9IG5ldyBDdWJlQ2FtZXJhKDEsIDEwLCB0aGlzKTtcbiAgICAgIGNhbWVyYS51cGRhdGUocmVuZGVyZXIsIG1lc2gpO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBjdXJyZW50TWluRmlsdGVyO1xuICAgICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICBtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcihyZW5kZXJlciwgY29sb3IsIGRlcHRoLCBzdGVuY2lsKSB7XG4gICAgICB2YXIgY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG4gICAgICBmb3IgKHZhciBfaTY3ID0gMDsgX2k2NyA8IDY7IF9pNjcrKykge1xuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcywgX2k2Nyk7XG4gICAgICAgIHJlbmRlcmVyLmNsZWFyKGNvbG9yLCBkZXB0aCwgc3RlbmNpbCk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViR0xDdWJlUmVuZGVyVGFyZ2V0O1xufShXZWJHTFJlbmRlclRhcmdldCk7XG5cbnZhciBfdmVjdG9yMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3ZlY3RvcjIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9ub3JtYWxNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDMoKTtcblxudmFyIFBsYW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGxhbmUoKSB7XG4gICAgdmFyIG5vcm1hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gICAgdmFyIGNvbnN0YW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYW5lKTtcblxuICAgIHRoaXMuaXNQbGFuZSA9IHRydWU7IC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xuICAgIHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQbGFuZSwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChub3JtYWwsIGNvbnN0YW50KSB7XG4gICAgICB0aGlzLm5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICB0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29tcG9uZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb21wb25lbnRzKHgsIHksIHosIHcpIHtcbiAgICAgIHRoaXMubm9ybWFsLnNldCh4LCB5LCB6KTtcbiAgICAgIHRoaXMuY29uc3RhbnQgPSB3O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KG5vcm1hbCwgcG9pbnQpIHtcbiAgICAgIHRoaXMubm9ybWFsLmNvcHkobm9ybWFsKTtcbiAgICAgIHRoaXMuY29uc3RhbnQgPSAtcG9pbnQuZG90KHRoaXMubm9ybWFsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tQ29wbGFuYXJQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbUNvcGxhbmFyUG9pbnRzKGEsIGIsIGMpIHtcbiAgICAgIHZhciBub3JtYWwgPSBfdmVjdG9yMS5zdWJWZWN0b3JzKGMsIGIpLmNyb3NzKF92ZWN0b3IyLnN1YlZlY3RvcnMoYSwgYikpLm5vcm1hbGl6ZSgpOyAvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xuXG5cbiAgICAgIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQobm9ybWFsLCBhKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkocGxhbmUpIHtcbiAgICAgIHRoaXMubm9ybWFsLmNvcHkocGxhbmUubm9ybWFsKTtcbiAgICAgIHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplKCkge1xuICAgICAgLy8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXG4gICAgICB2YXIgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpO1xuICAgICAgdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoaW52ZXJzZU5vcm1hbExlbmd0aCk7XG4gICAgICB0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibmVnYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgICAgIHRoaXMuY29uc3RhbnQgKj0gLTE7XG4gICAgICB0aGlzLm5vcm1hbC5uZWdhdGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KHBvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWwuZG90KHBvaW50KSArIHRoaXMuY29uc3RhbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9TcGhlcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb1NwaGVyZShzcGhlcmUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludChzcGhlcmUuY2VudGVyKSAtIHNwaGVyZS5yYWRpdXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2plY3RQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9qZWN0UG9pbnQocG9pbnQsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5kaXN0YW5jZVRvUG9pbnQocG9pbnQpKS5hZGQocG9pbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobGluZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gbGluZS5kZWx0YShfdmVjdG9yMSk7XG4gICAgICB2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcblxuICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwKSB7XG4gICAgICAgIC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cbiAgICAgICAgaWYgKHRoaXMuZGlzdGFuY2VUb1BvaW50KGxpbmUuc3RhcnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldC5jb3B5KGxpbmUuc3RhcnQpO1xuICAgICAgICB9IC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuXG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gLShsaW5lLnN0YXJ0LmRvdCh0aGlzLm5vcm1hbCkgKyB0aGlzLmNvbnN0YW50KSAvIGRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAodCA8IDAgfHwgdCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQuY29weShkaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKHQpLmFkZChsaW5lLnN0YXJ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0c0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmUobGluZSkge1xuICAgICAgLy8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXG4gICAgICB2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQobGluZS5zdGFydCk7XG4gICAgICB2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KGxpbmUuZW5kKTtcbiAgICAgIHJldHVybiBzdGFydFNpZ24gPCAwICYmIGVuZFNpZ24gPiAwIHx8IGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVyc2VjdHNCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c0JveChib3gpIHtcbiAgICAgIHJldHVybiBib3guaW50ZXJzZWN0c1BsYW5lKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RzU3BoZXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSB7XG4gICAgICByZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29wbGFuYXJQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3BsYW5hclBvaW50KHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcigtdGhpcy5jb25zdGFudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5TWF0cml4NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseU1hdHJpeDQobWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCkge1xuICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IF9ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeCk7XG5cbiAgICAgIHZhciByZWZlcmVuY2VQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludChfdmVjdG9yMSkuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICB2YXIgbm9ybWFsID0gdGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKG5vcm1hbE1hdHJpeCkubm9ybWFsaXplKCk7XG4gICAgICB0aGlzLmNvbnN0YW50ID0gLXJlZmVyZW5jZVBvaW50LmRvdChub3JtYWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGUob2Zmc2V0KSB7XG4gICAgICB0aGlzLmNvbnN0YW50IC09IG9mZnNldC5kb3QodGhpcy5ub3JtYWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMocGxhbmUpIHtcbiAgICAgIHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKHRoaXMubm9ybWFsKSAmJiBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbGFuZTtcbn0oKTtcblxudmFyIF9zcGhlcmUkMiA9IC8qQF9fUFVSRV9fKi9uZXcgU3BoZXJlKCk7XG5cbnZhciBfdmVjdG9yJDcgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIEZydXN0dW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGcnVzdHVtKCkge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFBsYW5lKCk7XG4gICAgdmFyIHAxID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBuZXcgUGxhbmUoKTtcbiAgICB2YXIgcDIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG5ldyBQbGFuZSgpO1xuICAgIHZhciBwMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbmV3IFBsYW5lKCk7XG4gICAgdmFyIHA0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBuZXcgUGxhbmUoKTtcbiAgICB2YXIgcDUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IG5ldyBQbGFuZSgpO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZydXN0dW0pO1xuXG4gICAgdGhpcy5wbGFuZXMgPSBbcDAsIHAxLCBwMiwgcDMsIHA0LCBwNV07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRnJ1c3R1bSwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChwMCwgcDEsIHAyLCBwMywgcDQsIHA1KSB7XG4gICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG4gICAgICBwbGFuZXNbMF0uY29weShwMCk7XG4gICAgICBwbGFuZXNbMV0uY29weShwMSk7XG4gICAgICBwbGFuZXNbMl0uY29weShwMik7XG4gICAgICBwbGFuZXNbM10uY29weShwMyk7XG4gICAgICBwbGFuZXNbNF0uY29weShwNCk7XG4gICAgICBwbGFuZXNbNV0uY29weShwNSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KGZydXN0dW0pIHtcbiAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgICAgZm9yICh2YXIgX2k2OCA9IDA7IF9pNjggPCA2OyBfaTY4KyspIHtcbiAgICAgICAgcGxhbmVzW19pNjhdLmNvcHkoZnJ1c3R1bS5wbGFuZXNbX2k2OF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbVByb2plY3Rpb25NYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVByb2plY3Rpb25NYXRyaXgobSkge1xuICAgICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuICAgICAgdmFyIG1lID0gbS5lbGVtZW50cztcbiAgICAgIHZhciBtZTAgPSBtZVswXSxcbiAgICAgICAgICBtZTEgPSBtZVsxXSxcbiAgICAgICAgICBtZTIgPSBtZVsyXSxcbiAgICAgICAgICBtZTMgPSBtZVszXTtcbiAgICAgIHZhciBtZTQgPSBtZVs0XSxcbiAgICAgICAgICBtZTUgPSBtZVs1XSxcbiAgICAgICAgICBtZTYgPSBtZVs2XSxcbiAgICAgICAgICBtZTcgPSBtZVs3XTtcbiAgICAgIHZhciBtZTggPSBtZVs4XSxcbiAgICAgICAgICBtZTkgPSBtZVs5XSxcbiAgICAgICAgICBtZTEwID0gbWVbMTBdLFxuICAgICAgICAgIG1lMTEgPSBtZVsxMV07XG4gICAgICB2YXIgbWUxMiA9IG1lWzEyXSxcbiAgICAgICAgICBtZTEzID0gbWVbMTNdLFxuICAgICAgICAgIG1lMTQgPSBtZVsxNF0sXG4gICAgICAgICAgbWUxNSA9IG1lWzE1XTtcbiAgICAgIHBsYW5lc1swXS5zZXRDb21wb25lbnRzKG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMikubm9ybWFsaXplKCk7XG4gICAgICBwbGFuZXNbMV0uc2V0Q29tcG9uZW50cyhtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIpLm5vcm1hbGl6ZSgpO1xuICAgICAgcGxhbmVzWzJdLnNldENvbXBvbmVudHMobWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzKS5ub3JtYWxpemUoKTtcbiAgICAgIHBsYW5lc1szXS5zZXRDb21wb25lbnRzKG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMykubm9ybWFsaXplKCk7XG4gICAgICBwbGFuZXNbNF0uc2V0Q29tcG9uZW50cyhtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0KS5ub3JtYWxpemUoKTtcbiAgICAgIHBsYW5lc1s1XS5zZXRDb21wb25lbnRzKG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQpLm5vcm1hbGl6ZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVyc2VjdHNPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c09iamVjdChvYmplY3QpIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgICAgIGlmIChnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICAgIF9zcGhlcmUkMi5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKS5hcHBseU1hdHJpeDQob2JqZWN0Lm1hdHJpeFdvcmxkKTtcblxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShfc3BoZXJlJDIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RzU3ByaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdHNTcHJpdGUoc3ByaXRlKSB7XG4gICAgICBfc3BoZXJlJDIuY2VudGVyLnNldCgwLCAwLCAwKTtcblxuICAgICAgX3NwaGVyZSQyLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3NjtcblxuICAgICAgX3NwaGVyZSQyLmFwcGx5TWF0cml4NChzcHJpdGUubWF0cml4V29ybGQpO1xuXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKF9zcGhlcmUkMik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVyc2VjdHNTcGhlcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0c1NwaGVyZShzcGhlcmUpIHtcbiAgICAgIHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcbiAgICAgIHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xuICAgICAgdmFyIG5lZ1JhZGl1cyA9IC1zcGhlcmUucmFkaXVzO1xuXG4gICAgICBmb3IgKHZhciBfaTY5ID0gMDsgX2k2OSA8IDY7IF9pNjkrKykge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBwbGFuZXNbX2k2OV0uZGlzdGFuY2VUb1BvaW50KGNlbnRlcik7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgbmVnUmFkaXVzKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RzQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdHNCb3goYm94KSB7XG4gICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICAgIGZvciAodmFyIF9pNzAgPSAwOyBfaTcwIDwgNjsgX2k3MCsrKSB7XG4gICAgICAgIHZhciBwbGFuZSA9IHBsYW5lc1tfaTcwXTsgLy8gY29ybmVyIGF0IG1heCBkaXN0YW5jZVxuXG4gICAgICAgIF92ZWN0b3IkNy54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xuICAgICAgICBfdmVjdG9yJDcueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5tYXgueSA6IGJveC5taW4ueTtcbiAgICAgICAgX3ZlY3RvciQ3LnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XG5cbiAgICAgICAgaWYgKHBsYW5lLmRpc3RhbmNlVG9Qb2ludChfdmVjdG9yJDcpIDwgMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGFpbnNQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICAgIGZvciAodmFyIF9pNzEgPSAwOyBfaTcxIDwgNjsgX2k3MSsrKSB7XG4gICAgICAgIGlmIChwbGFuZXNbX2k3MV0uZGlzdGFuY2VUb1BvaW50KHBvaW50KSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJ1c3R1bTtcbn0oKTtcblxuZnVuY3Rpb24gV2ViR0xBbmltYXRpb24oKSB7XG4gIHZhciBjb250ZXh0ID0gbnVsbDtcbiAgdmFyIGlzQW5pbWF0aW5nID0gZmFsc2U7XG4gIHZhciBhbmltYXRpb25Mb29wID0gbnVsbDtcbiAgdmFyIHJlcXVlc3RJZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gb25BbmltYXRpb25GcmFtZSh0aW1lLCBmcmFtZSkge1xuICAgIGFuaW1hdGlvbkxvb3AodGltZSwgZnJhbWUpO1xuICAgIHJlcXVlc3RJZCA9IGNvbnRleHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uQW5pbWF0aW9uRnJhbWUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBpZiAoaXNBbmltYXRpbmcgPT09IHRydWUpIHJldHVybjtcbiAgICAgIGlmIChhbmltYXRpb25Mb29wID09PSBudWxsKSByZXR1cm47XG4gICAgICByZXF1ZXN0SWQgPSBjb250ZXh0LnJlcXVlc3RBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcbiAgICAgIGlzQW5pbWF0aW5nID0gdHJ1ZTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBjb250ZXh0LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZCk7XG4gICAgICBpc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIH0sXG4gICAgc2V0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc2V0QW5pbWF0aW9uTG9vcChjYWxsYmFjaykge1xuICAgICAgYW5pbWF0aW9uTG9vcCA9IGNhbGxiYWNrO1xuICAgIH0sXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24gc2V0Q29udGV4dCh2YWx1ZSkge1xuICAgICAgY29udGV4dCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gV2ViR0xBdHRyaWJ1dGVzKGdsLCBjYXBhYmlsaXRpZXMpIHtcbiAgdmFyIGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuICB2YXIgYnVmZmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQnVmZmVyKGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSkge1xuICAgIHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcbiAgICB2YXIgdXNhZ2UgPSBhdHRyaWJ1dGUudXNhZ2U7XG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoYnVmZmVyVHlwZSwgYnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGJ1ZmZlclR5cGUsIGFycmF5LCB1c2FnZSk7XG4gICAgYXR0cmlidXRlLm9uVXBsb2FkQ2FsbGJhY2soKTtcbiAgICB2YXIgdHlwZTtcblxuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgICAgdHlwZSA9IDUxMjY7XG4gICAgfSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgICBpZiAoYXR0cmlidXRlLmlzRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgICB0eXBlID0gNTEzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLldlYkdMQXR0cmlidXRlczogVXNhZ2Ugb2YgRmxvYXQxNkJ1ZmZlckF0dHJpYnV0ZSByZXF1aXJlcyBXZWJHTDIuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSA1MTIzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5KSB7XG4gICAgICB0eXBlID0gNTEyMjtcbiAgICB9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHtcbiAgICAgIHR5cGUgPSA1MTI1O1xuICAgIH0gZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG4gICAgICB0eXBlID0gNTEyNDtcbiAgICB9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5KSB7XG4gICAgICB0eXBlID0gNTEyMDtcbiAgICB9IGVsc2UgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdHlwZSA9IDUxMjE7XG4gICAgfSBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICB0eXBlID0gNTEyMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5XZWJHTEF0dHJpYnV0ZXM6IFVuc3VwcG9ydGVkIGJ1ZmZlciBkYXRhIGZvcm1hdDogJyArIGFycmF5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgYnl0ZXNQZXJFbGVtZW50OiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgIHZlcnNpb246IGF0dHJpYnV0ZS52ZXJzaW9uXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlcihidWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSkge1xuICAgIHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcbiAgICB2YXIgdXBkYXRlUmFuZ2UgPSBhdHRyaWJ1dGUudXBkYXRlUmFuZ2U7XG4gICAgZ2wuYmluZEJ1ZmZlcihidWZmZXJUeXBlLCBidWZmZXIpO1xuXG4gICAgaWYgKHVwZGF0ZVJhbmdlLmNvdW50ID09PSAtMSkge1xuICAgICAgLy8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcbiAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoYnVmZmVyVHlwZSwgMCwgYXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgYXJyYXksIHVwZGF0ZVJhbmdlLm9mZnNldCwgdXBkYXRlUmFuZ2UuY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCwgYXJyYXkuc3ViYXJyYXkodXBkYXRlUmFuZ2Uub2Zmc2V0LCB1cGRhdGVSYW5nZS5vZmZzZXQgKyB1cGRhdGVSYW5nZS5jb3VudCkpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVSYW5nZS5jb3VudCA9IC0xOyAvLyByZXNldCByYW5nZVxuICAgIH1cbiAgfSAvL1xuXG5cbiAgZnVuY3Rpb24gZ2V0KGF0dHJpYnV0ZSkge1xuICAgIGlmIChhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XG4gICAgcmV0dXJuIGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoYXR0cmlidXRlKSB7XG4gICAgaWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcbiAgICB2YXIgZGF0YSA9IGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgZ2wuZGVsZXRlQnVmZmVyKGRhdGEuYnVmZmVyKTtcbiAgICAgIGJ1ZmZlcnMuZGVsZXRlKGF0dHJpYnV0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSkge1xuICAgIGlmIChhdHRyaWJ1dGUuaXNHTEJ1ZmZlckF0dHJpYnV0ZSkge1xuICAgICAgdmFyIGNhY2hlZCA9IGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICAgIGlmICghY2FjaGVkIHx8IGNhY2hlZC52ZXJzaW9uIDwgYXR0cmlidXRlLnZlcnNpb24pIHtcbiAgICAgICAgYnVmZmVycy5zZXQoYXR0cmlidXRlLCB7XG4gICAgICAgICAgYnVmZmVyOiBhdHRyaWJ1dGUuYnVmZmVyLFxuICAgICAgICAgIHR5cGU6IGF0dHJpYnV0ZS50eXBlLFxuICAgICAgICAgIGJ5dGVzUGVyRWxlbWVudDogYXR0cmlidXRlLmVsZW1lbnRTaXplLFxuICAgICAgICAgIHZlcnNpb246IGF0dHJpYnV0ZS52ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcbiAgICB2YXIgZGF0YSA9IGJ1ZmZlcnMuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWZmZXJzLnNldChhdHRyaWJ1dGUsIGNyZWF0ZUJ1ZmZlcihhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUpKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudmVyc2lvbiA8IGF0dHJpYnV0ZS52ZXJzaW9uKSB7XG4gICAgICB1cGRhdGVCdWZmZXIoZGF0YS5idWZmZXIsIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSk7XG4gICAgICBkYXRhLnZlcnNpb24gPSBhdHRyaWJ1dGUudmVyc2lvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldDogZ2V0LFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIHVwZGF0ZTogdXBkYXRlXG4gIH07XG59XG5cbnZhciBQbGFuZUdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyR2VvbWV0cnkyKSB7XG4gIF9pbmhlcml0cyhQbGFuZUdlb21ldHJ5LCBfQnVmZmVyR2VvbWV0cnkyKTtcblxuICB2YXIgX3N1cGVyMzAgPSBfY3JlYXRlU3VwZXIoUGxhbmVHZW9tZXRyeSk7XG5cbiAgZnVuY3Rpb24gUGxhbmVHZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXMyMjtcblxuICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHZhciB3aWR0aFNlZ21lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgIHZhciBoZWlnaHRTZWdtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGFuZUdlb21ldHJ5KTtcblxuICAgIF90aGlzMjIgPSBfc3VwZXIzMC5jYWxsKHRoaXMpO1xuICAgIF90aGlzMjIudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcbiAgICBfdGhpczIyLnBhcmFtZXRlcnMgPSB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcbiAgICB9O1xuICAgIHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuICAgIHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGdyaWRYID0gTWF0aC5mbG9vcih3aWR0aFNlZ21lbnRzKTtcbiAgICB2YXIgZ3JpZFkgPSBNYXRoLmZsb29yKGhlaWdodFNlZ21lbnRzKTtcbiAgICB2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuICAgIHZhciBncmlkWTEgPSBncmlkWSArIDE7XG4gICAgdmFyIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuICAgIHZhciBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZOyAvL1xuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgIHZhciB1dnMgPSBbXTtcblxuICAgIGZvciAodmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5KyspIHtcbiAgICAgIHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG4gICAgICBmb3IgKHZhciBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCsrKSB7XG4gICAgICAgIHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcbiAgICAgICAgdmVydGljZXMucHVzaCh4LCAteSwgMCk7XG4gICAgICAgIG5vcm1hbHMucHVzaCgwLCAwLCAxKTtcbiAgICAgICAgdXZzLnB1c2goaXggLyBncmlkWCk7XG4gICAgICAgIHV2cy5wdXNoKDEgLSBpeSAvIGdyaWRZKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaXkyID0gMDsgX2l5MiA8IGdyaWRZOyBfaXkyKyspIHtcbiAgICAgIGZvciAodmFyIF9peDIgPSAwOyBfaXgyIDwgZ3JpZFg7IF9peDIrKykge1xuICAgICAgICB2YXIgYSA9IF9peDIgKyBncmlkWDEgKiBfaXkyO1xuICAgICAgICB2YXIgYiA9IF9peDIgKyBncmlkWDEgKiAoX2l5MiArIDEpO1xuICAgICAgICB2YXIgYyA9IF9peDIgKyAxICsgZ3JpZFgxICogKF9peTIgKyAxKTtcbiAgICAgICAgdmFyIGQgPSBfaXgyICsgMSArIGdyaWRYMSAqIF9peTI7XG4gICAgICAgIGluZGljZXMucHVzaChhLCBiLCBkKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF90aGlzMjIuc2V0SW5kZXgoaW5kaWNlcyk7XG5cbiAgICBfdGhpczIyLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXG4gICAgX3RoaXMyMi5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblxuICAgIF90aGlzMjIuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXG4gICAgcmV0dXJuIF90aGlzMjI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGxhbmVHZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBQbGFuZUdlb21ldHJ5KGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0LCBkYXRhLndpZHRoU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbGFuZUdlb21ldHJ5O1xufShCdWZmZXJHZW9tZXRyeSk7XG5cbnZhciBhbHBoYW1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuI2VuZGlmXCI7XG52YXIgYWxwaGFtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlwiO1xudmFyIGFscGhhdGVzdF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQVRFU1RcXG5cXHRpZiAoIGRpZmZ1c2VDb2xvci5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDtcXG4jZW5kaWZcIjtcbnZhciBhbHBoYXRlc3RfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQVRFU1RcXG5cXHR1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDtcXG4jZW5kaWZcIjtcbnZhciBhb21hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcdGZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gYW1iaWVudE9jY2x1c2lvbjtcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFNUQU5EQVJEIClcXG5cXHRcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciAqPSBjb21wdXRlU3BlY3VsYXJPY2NsdXNpb24oIGRvdE5WLCBhbWJpZW50T2NjbHVzaW9uLCBtYXRlcmlhbC5yb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcbnZhciBhb21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXG4jZW5kaWZcIjtcbnZhciBiZWdpbl92ZXJ0ZXggPSBcInZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1wiO1xudmFyIGJlZ2lubm9ybWFsX3ZlcnRleCA9IFwidmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR2ZWMzIG9iamVjdFRhbmdlbnQgPSB2ZWMzKCB0YW5nZW50Lnh5eiApO1xcbiNlbmRpZlwiO1xudmFyIGJzZGZzID0gXCJ2ZWMzIEJSREZfTGFtYmVydCggY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IgKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XFxufVxcbnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkge1xcblxcdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC0gNS41NTQ3MyAqIGRvdFZIIC0gNi45ODMxNiApICogZG90VkggKTtcXG5cXHRyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApO1xcbn1cXG5mbG9hdCBGX1NjaGxpY2soIGNvbnN0IGluIGZsb2F0IGYwLCBjb25zdCBpbiBmbG9hdCBmOTAsIGNvbnN0IGluIGZsb2F0IGRvdFZIICkge1xcblxcdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC0gNS41NTQ3MyAqIGRvdFZIIC0gNi45ODMxNiApICogZG90VkggKTtcXG5cXHRyZXR1cm4gZjAgKiAoIDEuMCAtIGZyZXNuZWwgKSArICggZjkwICogZnJlc25lbCApO1xcbn1cXG52ZWMzIFNjaGxpY2tfdG9fRjAoIGNvbnN0IGluIHZlYzMgZiwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCBkb3RWSCApIHtcXG4gICAgZmxvYXQgeCA9IGNsYW1wKCAxLjAgLSBkb3RWSCwgMC4wLCAxLjAgKTtcXG4gICAgZmxvYXQgeDIgPSB4ICogeDtcXG4gICAgZmxvYXQgeDUgPSBjbGFtcCggeCAqIHgyICogeDIsIDAuMCwgMC45OTk5ICk7XFxuICAgIHJldHVybiAoIGYgLSB2ZWMzKCBmOTAgKSAqIHg1ICkgLyAoIDEuMCAtIHg1ICk7XFxufVxcbmZsb2F0IFZfR0dYX1NtaXRoQ29ycmVsYXRlZCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZ3YgPSBkb3ROTCAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xcblxcdGZsb2F0IGdsID0gZG90TlYgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXG5cXHRyZXR1cm4gMC41IC8gbWF4KCBndiArIGdsLCBFUFNJTE9OICk7XFxufVxcbmZsb2F0IERfR0dYKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGRlbm9tID0gcG93MiggZG90TkggKSAqICggYTIgLSAxLjAgKSArIDEuMDtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gcG93MiggZGVub20gKTtcXG59XFxudmVjMyBCUkRGX0dHWCggY29uc3QgaW4gdmVjMyBsaWdodERpciwgY29uc3QgaW4gdmVjMyB2aWV3RGlyLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCwgY29uc3QgaW4gdmVjMyBmMCwgY29uc3QgaW4gZmxvYXQgZjkwLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggZjAsIGY5MCwgZG90VkggKTtcXG5cXHRmbG9hdCBWID0gVl9HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxuXFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cXHRyZXR1cm4gRiAqICggViAqIEQgKTtcXG59XFxuI2lmZGVmIFVTRV9JUklERVNDRU5DRVxcbnZlYzMgQlJERl9HR1hfSXJpZGVzY2VuY2UoIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgZjAsIGNvbnN0IGluIGZsb2F0IGY5MCwgY29uc3QgaW4gZmxvYXQgaXJpZGVzY2VuY2UsIGNvbnN0IGluIHZlYzMgaXJpZGVzY2VuY2VGcmVzbmVsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGxpZ2h0RGlyICsgdmlld0RpciApO1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RWSCA9IHNhdHVyYXRlKCBkb3QoIHZpZXdEaXIsIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IG1peChGX1NjaGxpY2soIGYwLCBmOTAsIGRvdFZIICksIGlyaWRlc2NlbmNlRnJlc25lbCwgaXJpZGVzY2VuY2UpO1xcblxcdGZsb2F0IFYgPSBWX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTtcXG5cXHRmbG9hdCBEID0gRF9HR1goIGFscGhhLCBkb3ROSCApO1xcblxcdHJldHVybiBGICogKCBWICogRCApO1xcbn1cXG4jZW5kaWZcXG52ZWMyIExUQ19VdiggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRjb25zdCBmbG9hdCBMVVRfU0laRSA9IDY0LjA7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX1NDQUxFID0gKCBMVVRfU0laRSAtIDEuMCApIC8gTFVUX1NJWkU7XFxuXFx0Y29uc3QgZmxvYXQgTFVUX0JJQVMgPSAwLjUgLyBMVVRfU0laRTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIE4sIFYgKSApO1xcblxcdHZlYzIgdXYgPSB2ZWMyKCByb3VnaG5lc3MsIHNxcnQoIDEuMCAtIGRvdE5WICkgKTtcXG5cXHR1diA9IHV2ICogTFVUX1NDQUxFICsgTFVUX0JJQVM7XFxuXFx0cmV0dXJuIHV2O1xcbn1cXG5mbG9hdCBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgZiApIHtcXG5cXHRmbG9hdCBsID0gbGVuZ3RoKCBmICk7XFxuXFx0cmV0dXJuIG1heCggKCBsICogbCArIGYueiApIC8gKCBsICsgMS4wICksIDAuMCApO1xcbn1cXG52ZWMzIExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyB2MSwgY29uc3QgaW4gdmVjMyB2MiApIHtcXG5cXHRmbG9hdCB4ID0gZG90KCB2MSwgdjIgKTtcXG5cXHRmbG9hdCB5ID0gYWJzKCB4ICk7XFxuXFx0ZmxvYXQgYSA9IDAuODU0Mzk4NSArICggMC40OTY1MTU1ICsgMC4wMTQ1MjA2ICogeSApICogeTtcXG5cXHRmbG9hdCBiID0gMy40MTc1OTQwICsgKCA0LjE2MTY3MjQgKyB5ICkgKiB5O1xcblxcdGZsb2F0IHYgPSBhIC8gYjtcXG5cXHRmbG9hdCB0aGV0YV9zaW50aGV0YSA9ICggeCA+IDAuMCApID8gdiA6IDAuNSAqIGludmVyc2VzcXJ0KCBtYXgoIDEuMCAtIHggKiB4LCAxZS03ICkgKSAtIHY7XFxuXFx0cmV0dXJuIGNyb3NzKCB2MSwgdjIgKSAqIHRoZXRhX3NpbnRoZXRhO1xcbn1cXG52ZWMzIExUQ19FdmFsdWF0ZSggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIHZlYzMgUCwgY29uc3QgaW4gbWF0MyBtSW52LCBjb25zdCBpbiB2ZWMzIHJlY3RDb29yZHNbIDQgXSApIHtcXG5cXHR2ZWMzIHYxID0gcmVjdENvb3Jkc1sgMSBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcblxcdHZlYzMgdjIgPSByZWN0Q29vcmRzWyAzIF0gLSByZWN0Q29vcmRzWyAwIF07XFxuXFx0dmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTtcXG5cXHRpZiggZG90KCBsaWdodE5vcm1hbCwgUCAtIHJlY3RDb29yZHNbIDAgXSApIDwgMC4wICkgcmV0dXJuIHZlYzMoIDAuMCApO1xcblxcdHZlYzMgVDEsIFQyO1xcblxcdFQxID0gbm9ybWFsaXplKCBWIC0gTiAqIGRvdCggViwgTiApICk7XFxuXFx0VDIgPSAtIGNyb3NzKCBOLCBUMSApO1xcblxcdG1hdDMgbWF0ID0gbUludiAqIHRyYW5zcG9zZU1hdDMoIG1hdDMoIFQxLCBUMiwgTiApICk7XFxuXFx0dmVjMyBjb29yZHNbIDQgXTtcXG5cXHRjb29yZHNbIDAgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMCBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMSBdID0gbWF0ICogKCByZWN0Q29vcmRzWyAxIF0gLSBQICk7XFxuXFx0Y29vcmRzWyAyIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDIgXSAtIFAgKTtcXG5cXHRjb29yZHNbIDMgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMyBdIC0gUCApO1xcblxcdGNvb3Jkc1sgMCBdID0gbm9ybWFsaXplKCBjb29yZHNbIDAgXSApO1xcblxcdGNvb3Jkc1sgMSBdID0gbm9ybWFsaXplKCBjb29yZHNbIDEgXSApO1xcblxcdGNvb3Jkc1sgMiBdID0gbm9ybWFsaXplKCBjb29yZHNbIDIgXSApO1xcblxcdGNvb3Jkc1sgMyBdID0gbm9ybWFsaXplKCBjb29yZHNbIDMgXSApO1xcblxcdHZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDAgXSwgY29vcmRzWyAxIF0gKTtcXG5cXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAxIF0sIGNvb3Jkc1sgMiBdICk7XFxuXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApO1xcblxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDMgXSwgY29vcmRzWyAwIF0gKTtcXG5cXHRmbG9hdCByZXN1bHQgPSBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIHZlY3RvckZvcm1GYWN0b3IgKTtcXG5cXHRyZXR1cm4gdmVjMyggcmVzdWx0ICk7XFxufVxcbmZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKSB7XFxuXFx0cmV0dXJuIDAuMjU7XFxufVxcbmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXG59XFxudmVjMyBCUkRGX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzICkge1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdFZIID0gc2F0dXJhdGUoIGRvdCggdmlld0RpciwgaGFsZkRpciApICk7XFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCAxLjAsIGRvdFZIICk7XFxuXFx0ZmxvYXQgRyA9IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKTtcXG5cXHRmbG9hdCBEID0gRF9CbGlublBob25nKCBzaGluaW5lc3MsIGRvdE5IICk7XFxuXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxufVxcbiNpZiBkZWZpbmVkKCBVU0VfU0hFRU4gKVxcbmZsb2F0IERfQ2hhcmxpZSggZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBkb3ROSCApIHtcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdGZsb2F0IGludkFscGhhID0gMS4wIC8gYWxwaGE7XFxuXFx0ZmxvYXQgY29zMmggPSBkb3ROSCAqIGRvdE5IO1xcblxcdGZsb2F0IHNpbjJoID0gbWF4KCAxLjAgLSBjb3MyaCwgMC4wMDc4MTI1ICk7XFxuXFx0cmV0dXJuICggMi4wICsgaW52QWxwaGEgKSAqIHBvdyggc2luMmgsIGludkFscGhhICogMC41ICkgLyAoIDIuMCAqIFBJICk7XFxufVxcbmZsb2F0IFZfTmV1YmVsdCggZmxvYXQgZG90TlYsIGZsb2F0IGRvdE5MICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggMS4wIC8gKCA0LjAgKiAoIGRvdE5MICsgZG90TlYgLSBkb3ROTCAqIGRvdE5WICkgKSApO1xcbn1cXG52ZWMzIEJSREZfU2hlZW4oIGNvbnN0IGluIHZlYzMgbGlnaHREaXIsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBub3JtYWwsIHZlYzMgc2hlZW5Db2xvciwgY29uc3QgaW4gZmxvYXQgc2hlZW5Sb3VnaG5lc3MgKSB7XFxuXFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBsaWdodERpciArIHZpZXdEaXIgKTtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKSApO1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XFxuXFx0ZmxvYXQgRCA9IERfQ2hhcmxpZSggc2hlZW5Sb3VnaG5lc3MsIGRvdE5IICk7XFxuXFx0ZmxvYXQgViA9IFZfTmV1YmVsdCggZG90TlYsIGRvdE5MICk7XFxuXFx0cmV0dXJuIHNoZWVuQ29sb3IgKiAoIEQgKiBWICk7XFxufVxcbiNlbmRpZlwiO1xudmFyIGlyaWRlc2NlbmNlX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuY29uc3QgbWF0MyBYWVpfVE9fUkVDNzA5ID0gbWF0MyhcXG4gICAgMy4yNDA0NTQyLCAtMC45NjkyNjYwLCAgMC4wNTU2NDM0LFxcbiAgIC0xLjUzNzEzODUsICAxLjg3NjAxMDgsIC0wLjIwNDAyNTksXFxuICAgLTAuNDk4NTMxNCwgIDAuMDQxNTU2MCwgIDEuMDU3MjI1Mlxcbik7XFxudmVjMyBGcmVzbmVsMFRvSW9yKCB2ZWMzIGZyZXNuZWwwICkge1xcbiAgIHZlYzMgc3FydEYwID0gc3FydCggZnJlc25lbDAgKTtcXG4gICByZXR1cm4gKCB2ZWMzKCAxLjAgKSArIHNxcnRGMCApIC8gKCB2ZWMzKCAxLjAgKSAtIHNxcnRGMCApO1xcbn1cXG52ZWMzIElvclRvRnJlc25lbDAoIHZlYzMgdHJhbnNtaXR0ZWRJb3IsIGZsb2F0IGluY2lkZW50SW9yICkge1xcbiAgIHJldHVybiBwb3cyKCAoIHRyYW5zbWl0dGVkSW9yIC0gdmVjMyggaW5jaWRlbnRJb3IgKSApIC8gKCB0cmFuc21pdHRlZElvciArIHZlYzMoIGluY2lkZW50SW9yICkgKSApO1xcbn1cXG5mbG9hdCBJb3JUb0ZyZXNuZWwwKCBmbG9hdCB0cmFuc21pdHRlZElvciwgZmxvYXQgaW5jaWRlbnRJb3IgKSB7XFxuICAgcmV0dXJuIHBvdzIoICggdHJhbnNtaXR0ZWRJb3IgLSBpbmNpZGVudElvciApIC8gKCB0cmFuc21pdHRlZElvciArIGluY2lkZW50SW9yICkpO1xcbn1cXG52ZWMzIGV2YWxTZW5zaXRpdml0eSggZmxvYXQgT1BELCB2ZWMzIHNoaWZ0ICkge1xcbiAgIGZsb2F0IHBoYXNlID0gMi4wICogUEkgKiBPUEQgKiAxLjBlLTk7XFxuICAgdmVjMyB2YWwgPSB2ZWMzKCA1LjQ4NTZlLTEzLCA0LjQyMDFlLTEzLCA1LjI0ODFlLTEzICk7XFxuICAgdmVjMyBwb3MgPSB2ZWMzKCAxLjY4MTBlKzA2LCAxLjc5NTNlKzA2LCAyLjIwODRlKzA2ICk7XFxuICAgdmVjMyB2YXIgPSB2ZWMzKCA0LjMyNzhlKzA5LCA5LjMwNDZlKzA5LCA2LjYxMjFlKzA5ICk7XFxuICAgdmVjMyB4eXogPSB2YWwgKiBzcXJ0KCAyLjAgKiBQSSAqIHZhciApICogY29zKCBwb3MgKiBwaGFzZSArIHNoaWZ0ICkgKiBleHAoIC1wb3cyKCBwaGFzZSApICogdmFyICk7XFxuICAgeHl6LnggKz0gOS43NDcwZS0xNCAqIHNxcnQoIDIuMCAqIFBJICogNC41MjgyZSswOSApICogY29zKCAyLjIzOTllKzA2ICogcGhhc2UgKyBzaGlmdFswXSApICogZXhwKCAtNC41MjgyZSswOSAqIHBvdzIoIHBoYXNlICkgKTtcXG4gICB4eXogLz0gMS4wNjg1ZS03O1xcbiAgIHZlYzMgc3JnYiA9IFhZWl9UT19SRUM3MDkgKiB4eXo7XFxuICAgcmV0dXJuIHNyZ2I7XFxufVxcbnZlYzMgZXZhbElyaWRlc2NlbmNlKCBmbG9hdCBvdXRzaWRlSU9SLCBmbG9hdCBldGEyLCBmbG9hdCBjb3NUaGV0YTEsIGZsb2F0IHRoaW5GaWxtVGhpY2tuZXNzLCB2ZWMzIGJhc2VGMCApIHtcXG4gICB2ZWMzIEk7XFxuICAgZmxvYXQgaXJpZGVzY2VuY2VJT1IgPSBtaXgoIG91dHNpZGVJT1IsIGV0YTIsIHNtb290aHN0ZXAoIDAuMCwgMC4wMywgdGhpbkZpbG1UaGlja25lc3MgKSApO1xcbiAgIGZsb2F0IHNpblRoZXRhMlNxID0gcG93Miggb3V0c2lkZUlPUiAvIGlyaWRlc2NlbmNlSU9SICkgKiAoIDEuMCAtIHBvdzIoIGNvc1RoZXRhMSApICk7XFxuICAgZmxvYXQgY29zVGhldGEyU3EgPSAxLjAgLSBzaW5UaGV0YTJTcTtcXG4gICBpZiAoIGNvc1RoZXRhMlNxIDwgMC4wICkge1xcbiAgICAgICByZXR1cm4gdmVjMyggMS4wICk7XFxuICAgfVxcbiAgIGZsb2F0IGNvc1RoZXRhMiA9IHNxcnQoIGNvc1RoZXRhMlNxICk7XFxuICAgZmxvYXQgUjAgPSBJb3JUb0ZyZXNuZWwwKCBpcmlkZXNjZW5jZUlPUiwgb3V0c2lkZUlPUiApO1xcbiAgIGZsb2F0IFIxMiA9IEZfU2NobGljayggUjAsIDEuMCwgY29zVGhldGExICk7XFxuICAgZmxvYXQgUjIxID0gUjEyO1xcbiAgIGZsb2F0IFQxMjEgPSAxLjAgLSBSMTI7XFxuICAgZmxvYXQgcGhpMTIgPSAwLjA7XFxuICAgaWYgKCBpcmlkZXNjZW5jZUlPUiA8IG91dHNpZGVJT1IgKSBwaGkxMiA9IFBJO1xcbiAgIGZsb2F0IHBoaTIxID0gUEkgLSBwaGkxMjtcXG4gICB2ZWMzIGJhc2VJT1IgPSBGcmVzbmVsMFRvSW9yKCBjbGFtcCggYmFzZUYwLCAwLjAsIDAuOTk5OSApICk7ICAgdmVjMyBSMSA9IElvclRvRnJlc25lbDAoIGJhc2VJT1IsIGlyaWRlc2NlbmNlSU9SICk7XFxuICAgdmVjMyBSMjMgPSBGX1NjaGxpY2soIFIxLCAxLjAsIGNvc1RoZXRhMiApO1xcbiAgIHZlYzMgcGhpMjMgPSB2ZWMzKCAwLjAgKTtcXG4gICBpZiAoIGJhc2VJT1JbMF0gPCBpcmlkZXNjZW5jZUlPUiApIHBoaTIzWzBdID0gUEk7XFxuICAgaWYgKCBiYXNlSU9SWzFdIDwgaXJpZGVzY2VuY2VJT1IgKSBwaGkyM1sxXSA9IFBJO1xcbiAgIGlmICggYmFzZUlPUlsyXSA8IGlyaWRlc2NlbmNlSU9SICkgcGhpMjNbMl0gPSBQSTtcXG4gICBmbG9hdCBPUEQgPSAyLjAgKiBpcmlkZXNjZW5jZUlPUiAqIHRoaW5GaWxtVGhpY2tuZXNzICogY29zVGhldGEyO1xcbiAgIHZlYzMgcGhpID0gdmVjMyggcGhpMjEgKSArIHBoaTIzO1xcbiAgIHZlYzMgUjEyMyA9IGNsYW1wKCBSMTIgKiBSMjMsIDFlLTUsIDAuOTk5OSApO1xcbiAgIHZlYzMgcjEyMyA9IHNxcnQoIFIxMjMgKTtcXG4gICB2ZWMzIFJzID0gcG93MiggVDEyMSApICogUjIzIC8gKCB2ZWMzKCAxLjAgKSAtIFIxMjMgKTtcXG4gICB2ZWMzIEMwID0gUjEyICsgUnM7XFxuICAgSSA9IEMwO1xcbiAgIHZlYzMgQ20gPSBScyAtIFQxMjE7XFxuICAgZm9yICggaW50IG0gPSAxOyBtIDw9IDI7ICsrbSApIHtcXG4gICAgICAgQ20gKj0gcjEyMztcXG4gICAgICAgdmVjMyBTbSA9IDIuMCAqIGV2YWxTZW5zaXRpdml0eSggZmxvYXQoIG0gKSAqIE9QRCwgZmxvYXQoIG0gKSAqIHBoaSApO1xcbiAgICAgICBJICs9IENtICogU207XFxuICAgfVxcbiAgIHJldHVybiBtYXgoIEksIHZlYzMoIDAuMCApICk7XFxufVxcbiNlbmRpZlwiO1xudmFyIGJ1bXBtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXG5cXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXHRcXHR2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxuXFx0XFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcblxcdFxcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5cXHRcXHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcXG5cXHRcXHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXHRcXHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG5cXHR9XFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSwgZmxvYXQgZmFjZURpcmVjdGlvbiApIHtcXG5cXHRcXHR2ZWMzIHZTaWdtYVggPSB2ZWMzKCBkRmR4KCBzdXJmX3Bvcy54ICksIGRGZHgoIHN1cmZfcG9zLnkgKSwgZEZkeCggc3VyZl9wb3MueiApICk7XFxuXFx0XFx0dmVjMyB2U2lnbWFZID0gdmVjMyggZEZkeSggc3VyZl9wb3MueCApLCBkRmR5KCBzdXJmX3Bvcy55ICksIGRGZHkoIHN1cmZfcG9zLnogKSApO1xcblxcdFxcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblxcdFxcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXHRcXHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApICogZmFjZURpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFx0fVxcbiNlbmRpZlwiO1xudmFyIGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dmVjNCBwbGFuZTtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpICsrICkge1xcblxcdFxcdHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXG5cXHRcXHRpZiAoIGRvdCggdkNsaXBQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgZGlzY2FyZDtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjaWYgVU5JT05fQ0xJUFBJTkdfUExBTkVTIDwgTlVNX0NMSVBQSU5HX1BMQU5FU1xcblxcdFxcdGJvb2wgY2xpcHBlZCA9IHRydWU7XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdFxcdGZvciAoIGludCBpID0gVU5JT05fQ0xJUFBJTkdfUExBTkVTOyBpIDwgTlVNX0NMSVBQSU5HX1BMQU5FUzsgaSArKyApIHtcXG5cXHRcXHRcXHRwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxuXFx0XFx0XFx0Y2xpcHBlZCA9ICggZG90KCB2Q2xpcFBvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSAmJiBjbGlwcGVkO1xcblxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdFxcdGlmICggY2xpcHBlZCApIGRpc2NhcmQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG52YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMFxcblxcdHZhcnlpbmcgdmVjMyB2Q2xpcFBvc2l0aW9uO1xcblxcdHVuaWZvcm0gdmVjNCBjbGlwcGluZ1BsYW5lc1sgTlVNX0NMSVBQSU5HX1BMQU5FUyBdO1xcbiNlbmRpZlwiO1xudmFyIGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dmFyeWluZyB2ZWMzIHZDbGlwUG9zaXRpb247XFxuI2VuZGlmXCI7XG52YXIgY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0dkNsaXBQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxuI2VuZGlmXCI7XG52YXIgY29sb3JfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdGRpZmZ1c2VDb2xvciAqPSB2Q29sb3I7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0NPTE9SIClcXG5cXHRkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXG4jZW5kaWZcIjtcbnZhciBjb2xvcl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0NPTE9SX0FMUEhBIClcXG5cXHR2YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIjtcbnZhciBjb2xvcl9wYXJzX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXFxuXFx0dmFyeWluZyB2ZWM0IHZDb2xvcjtcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKSB8fCBkZWZpbmVkKCBVU0VfSU5TVEFOQ0lOR19DT0xPUiApXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIjtcbnZhciBjb2xvcl92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfQ09MT1JfQUxQSEEgKVxcblxcdHZDb2xvciA9IHZlYzQoIDEuMCApO1xcbiNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApIHx8IGRlZmluZWQoIFVTRV9JTlNUQU5DSU5HX0NPTE9SIClcXG5cXHR2Q29sb3IgPSB2ZWMzKCAxLjAgKTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NPTE9SXFxuXFx0dkNvbG9yICo9IGNvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSU5TVEFOQ0lOR19DT0xPUlxcblxcdHZDb2xvci54eXogKj0gaW5zdGFuY2VDb2xvci54eXo7XFxuI2VuZGlmXCI7XG52YXIgY29tbW9uID0gXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTg5NzkzXFxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxNzk1ODZcXG4jZGVmaW5lIFBJX0hBTEYgMS41NzA3OTYzMjY3OTQ4OTY2XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MTgzNzkwN1xcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NDMwOTE4OTUzNVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuI2lmbmRlZiBzYXR1cmF0ZVxcbiNkZWZpbmUgc2F0dXJhdGUoIGEgKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNlbmRpZlxcbiNkZWZpbmUgd2hpdGVDb21wbGVtZW50KCBhICkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5mbG9hdCBwb3cyKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxudmVjMyBwb3cyKCBjb25zdCBpbiB2ZWMzIHggKSB7IHJldHVybiB4Kng7IH1cXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cXG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XFxuZmxvYXQgbWF4MyggY29uc3QgaW4gdmVjMyB2ICkgeyByZXR1cm4gbWF4KCBtYXgoIHYueCwgdi55ICksIHYueiApOyB9XFxuZmxvYXQgYXZlcmFnZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHsgcmV0dXJuIGRvdCggY29sb3IsIHZlYzMoIDAuMzMzMyApICk7IH1cXG5oaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkge1xcblxcdGNvbnN0IGhpZ2hwIGZsb2F0IGEgPSAxMi45ODk4LCBiID0gNzguMjMzLCBjID0gNDM3NTguNTQ1MztcXG5cXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcXG5cXHRyZXR1cm4gZnJhY3QoIHNpbiggc24gKSAqIGMgKTtcXG59XFxuI2lmZGVmIEhJR0hfUFJFQ0lTSU9OXFxuXFx0ZmxvYXQgcHJlY2lzaW9uU2FmZUxlbmd0aCggdmVjMyB2ICkgeyByZXR1cm4gbGVuZ3RoKCB2ICk7IH1cXG4jZWxzZVxcblxcdGZsb2F0IHByZWNpc2lvblNhZmVMZW5ndGgoIHZlYzMgdiApIHtcXG5cXHRcXHRmbG9hdCBtYXhDb21wb25lbnQgPSBtYXgzKCBhYnMoIHYgKSApO1xcblxcdFxcdHJldHVybiBsZW5ndGgoIHYgLyBtYXhDb21wb25lbnQgKSAqIG1heENvbXBvbmVudDtcXG5cXHR9XFxuI2VuZGlmXFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0Ym9vbCB2aXNpYmxlO1xcbn07XFxuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcXG5cXHR2ZWMzIGRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGluZGlyZWN0U3BlY3VsYXI7XFxufTtcXG5zdHJ1Y3QgR2VvbWV0cmljQ29udGV4dCB7XFxuXFx0dmVjMyBwb3NpdGlvbjtcXG5cXHR2ZWMzIG5vcm1hbDtcXG5cXHR2ZWMzIHZpZXdEaXI7XFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR2ZWMzIGNsZWFyY29hdE5vcm1hbDtcXG4jZW5kaWZcXG59O1xcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxufVxcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcbn1cXG5tYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHtcXG5cXHRtYXQzIHRtcDtcXG5cXHR0bXBbIDAgXSA9IHZlYzMoIG1bIDAgXS54LCBtWyAxIF0ueCwgbVsgMiBdLnggKTtcXG5cXHR0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTtcXG5cXHR0bXBbIDIgXSA9IHZlYzMoIG1bIDAgXS56LCBtWyAxIF0ueiwgbVsgMiBdLnogKTtcXG5cXHRyZXR1cm4gdG1wO1xcbn1cXG5mbG9hdCBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKCBjb25zdCBpbiB2ZWMzIGNvbG9yICkge1xcblxcdHZlYzMgd2VpZ2h0cyA9IHZlYzMoIDAuMjEyNiwgMC43MTUyLCAwLjA3MjIgKTtcXG5cXHRyZXR1cm4gZG90KCB3ZWlnaHRzLCBjb2xvci5yZ2IgKTtcXG59XFxuYm9vbCBpc1BlcnNwZWN0aXZlTWF0cml4KCBtYXQ0IG0gKSB7XFxuXFx0cmV0dXJuIG1bIDIgXVsgMyBdID09IC0gMS4wO1xcbn1cXG52ZWMyIGVxdWlyZWN0VXYoIGluIHZlYzMgZGlyICkge1xcblxcdGZsb2F0IHUgPSBhdGFuKCBkaXIueiwgZGlyLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdGZsb2F0IHYgPSBhc2luKCBjbGFtcCggZGlyLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXG5cXHRyZXR1cm4gdmVjMiggdSwgdiApO1xcbn1cIjtcbnZhciBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQgPSBcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluTWlwTGV2ZWwgNC4wXFxuXFx0I2RlZmluZSBjdWJlVVZfbWluVGlsZVNpemUgMTYuMFxcblxcdGZsb2F0IGdldEZhY2UoIHZlYzMgZGlyZWN0aW9uICkge1xcblxcdFxcdHZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmYWNlID0gLSAxLjA7XFxuXFx0XFx0aWYgKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi56ICkge1xcblxcdFxcdFxcdGlmICggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMC4wIDogMy4wO1xcblxcdFxcdFxcdGVsc2VcXG5cXHRcXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxLjAgOiA0LjA7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRpZiAoIGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxcblxcdFxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueiA+IDAuMCA/IDIuMCA6IDUuMDtcXG5cXHRcXHRcXHRlbHNlXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMS4wIDogNC4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZmFjZTtcXG5cXHR9XFxuXFx0dmVjMiBnZXRVViggdmVjMyBkaXJlY3Rpb24sIGZsb2F0IGZhY2UgKSB7XFxuXFx0XFx0dmVjMiB1djtcXG5cXHRcXHRpZiAoIGZhY2UgPT0gMC4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55ICkgLyBhYnMoIGRpcmVjdGlvbi54ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAxLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCAtIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSAyLjAgKSB7XFxuXFx0XFx0XFx0dXYgPSB2ZWMyKCAtIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMy4wICkge1xcblxcdFxcdFxcdHV2ID0gdmVjMiggLSBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkgKSAvIGFicyggZGlyZWN0aW9uLnggKTtcXG5cXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDQuMCApIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIC0gZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56ICkgLyBhYnMoIGRpcmVjdGlvbi55ICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR1diA9IHZlYzIoIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSApIC8gYWJzKCBkaXJlY3Rpb24ueiApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMC41ICogKCB1diArIDEuMCApO1xcblxcdH1cXG5cXHR2ZWMzIGJpbGluZWFyQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIGRpcmVjdGlvbiwgZmxvYXQgbWlwSW50ICkge1xcblxcdFxcdGZsb2F0IGZhY2UgPSBnZXRGYWNlKCBkaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBmaWx0ZXJJbnQgPSBtYXgoIGN1YmVVVl9taW5NaXBMZXZlbCAtIG1pcEludCwgMC4wICk7XFxuXFx0XFx0bWlwSW50ID0gbWF4KCBtaXBJbnQsIGN1YmVVVl9taW5NaXBMZXZlbCApO1xcblxcdFxcdGZsb2F0IGZhY2VTaXplID0gZXhwMiggbWlwSW50ICk7XFxuXFx0XFx0dmVjMiB1diA9IGdldFVWKCBkaXJlY3Rpb24sIGZhY2UgKSAqICggZmFjZVNpemUgLSAyLjAgKSArIDEuMDtcXG5cXHRcXHRpZiAoIGZhY2UgPiAyLjAgKSB7XFxuXFx0XFx0XFx0dXYueSArPSBmYWNlU2l6ZTtcXG5cXHRcXHRcXHRmYWNlIC09IDMuMDtcXG5cXHRcXHR9XFxuXFx0XFx0dXYueCArPSBmYWNlICogZmFjZVNpemU7XFxuXFx0XFx0dXYueCArPSBmaWx0ZXJJbnQgKiAzLjAgKiBjdWJlVVZfbWluVGlsZVNpemU7XFxuXFx0XFx0dXYueSArPSA0LjAgKiAoIGV4cDIoIENVQkVVVl9NQVhfTUlQICkgLSBmYWNlU2l6ZSApO1xcblxcdFxcdHV2LnggKj0gQ1VCRVVWX1RFWEVMX1dJRFRIO1xcblxcdFxcdHV2LnkgKj0gQ1VCRVVWX1RFWEVMX0hFSUdIVDtcXG5cXHRcXHQjaWZkZWYgdGV4dHVyZTJER3JhZEVYVFxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRHcmFkRVhUKCBlbnZNYXAsIHV2LCB2ZWMyKCAwLjAgKSwgdmVjMiggMC4wICkgKS5yZ2I7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJEKCBlbnZNYXAsIHV2ICkucmdiO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHQjZGVmaW5lIHIwIDEuMFxcblxcdCNkZWZpbmUgdjAgMC4zMzlcXG5cXHQjZGVmaW5lIG0wIC0gMi4wXFxuXFx0I2RlZmluZSByMSAwLjhcXG5cXHQjZGVmaW5lIHYxIDAuMjc2XFxuXFx0I2RlZmluZSBtMSAtIDEuMFxcblxcdCNkZWZpbmUgcjQgMC40XFxuXFx0I2RlZmluZSB2NCAwLjA0NlxcblxcdCNkZWZpbmUgbTQgMi4wXFxuXFx0I2RlZmluZSByNSAwLjMwNVxcblxcdCNkZWZpbmUgdjUgMC4wMTZcXG5cXHQjZGVmaW5lIG01IDMuMFxcblxcdCNkZWZpbmUgcjYgMC4yMVxcblxcdCNkZWZpbmUgdjYgMC4wMDM4XFxuXFx0I2RlZmluZSBtNiA0LjBcXG5cXHRmbG9hdCByb3VnaG5lc3NUb01pcCggZmxvYXQgcm91Z2huZXNzICkge1xcblxcdFxcdGZsb2F0IG1pcCA9IDAuMDtcXG5cXHRcXHRpZiAoIHJvdWdobmVzcyA+PSByMSApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIHIwIC0gcm91Z2huZXNzICkgKiAoIG0xIC0gbTAgKSAvICggcjAgLSByMSApICsgbTA7XFxuXFx0XFx0fSBlbHNlIGlmICggcm91Z2huZXNzID49IHI0ICkge1xcblxcdFxcdFxcdG1pcCA9ICggcjEgLSByb3VnaG5lc3MgKSAqICggbTQgLSBtMSApIC8gKCByMSAtIHI0ICkgKyBtMTtcXG5cXHRcXHR9IGVsc2UgaWYgKCByb3VnaG5lc3MgPj0gcjUgKSB7XFxuXFx0XFx0XFx0bWlwID0gKCByNCAtIHJvdWdobmVzcyApICogKCBtNSAtIG00ICkgLyAoIHI0IC0gcjUgKSArIG00O1xcblxcdFxcdH0gZWxzZSBpZiAoIHJvdWdobmVzcyA+PSByNiApIHtcXG5cXHRcXHRcXHRtaXAgPSAoIHI1IC0gcm91Z2huZXNzICkgKiAoIG02IC0gbTUgKSAvICggcjUgLSByNiApICsgbTU7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtaXAgPSAtIDIuMCAqIGxvZzIoIDEuMTYgKiByb3VnaG5lc3MgKTtcXHRcXHR9XFxuXFx0XFx0cmV0dXJuIG1pcDtcXG5cXHR9XFxuXFx0dmVjNCB0ZXh0dXJlQ3ViZVVWKCBzYW1wbGVyMkQgZW52TWFwLCB2ZWMzIHNhbXBsZURpciwgZmxvYXQgcm91Z2huZXNzICkge1xcblxcdFxcdGZsb2F0IG1pcCA9IGNsYW1wKCByb3VnaG5lc3NUb01pcCggcm91Z2huZXNzICksIG0wLCBDVUJFVVZfTUFYX01JUCApO1xcblxcdFxcdGZsb2F0IG1pcEYgPSBmcmFjdCggbWlwICk7XFxuXFx0XFx0ZmxvYXQgbWlwSW50ID0gZmxvb3IoIG1pcCApO1xcblxcdFxcdHZlYzMgY29sb3IwID0gYmlsaW5lYXJDdWJlVVYoIGVudk1hcCwgc2FtcGxlRGlyLCBtaXBJbnQgKTtcXG5cXHRcXHRpZiAoIG1pcEYgPT0gMC4wICkge1xcblxcdFxcdFxcdHJldHVybiB2ZWM0KCBjb2xvcjAsIDEuMCApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dmVjMyBjb2xvcjEgPSBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXIsIG1pcEludCArIDEuMCApO1xcblxcdFxcdFxcdHJldHVybiB2ZWM0KCBtaXgoIGNvbG9yMCwgY29sb3IxLCBtaXBGICksIDEuMCApO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXCI7XG52YXIgZGVmYXVsdG5vcm1hbF92ZXJ0ZXggPSBcInZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBvYmplY3ROb3JtYWw7XFxuI2lmZGVmIFVTRV9JTlNUQU5DSU5HXFxuXFx0bWF0MyBtID0gbWF0MyggaW5zdGFuY2VNYXRyaXggKTtcXG5cXHR0cmFuc2Zvcm1lZE5vcm1hbCAvPSB2ZWMzKCBkb3QoIG1bIDAgXSwgbVsgMCBdICksIGRvdCggbVsgMSBdLCBtWyAxIF0gKSwgZG90KCBtWyAyIF0sIG1bIDIgXSApICk7XFxuXFx0dHJhbnNmb3JtZWROb3JtYWwgPSBtICogdHJhbnNmb3JtZWROb3JtYWw7XFxuI2VuZGlmXFxudHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiB0cmFuc2Zvcm1lZE5vcm1hbDtcXG4jaWZkZWYgRkxJUF9TSURFRFxcblxcdHRyYW5zZm9ybWVkTm9ybWFsID0gLSB0cmFuc2Zvcm1lZE5vcm1hbDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHR2ZWMzIHRyYW5zZm9ybWVkVGFuZ2VudCA9ICggbW9kZWxWaWV3TWF0cml4ICogdmVjNCggb2JqZWN0VGFuZ2VudCwgMC4wICkgKS54eXo7XFxuXFx0I2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHR0cmFuc2Zvcm1lZFRhbmdlbnQgPSAtIHRyYW5zZm9ybWVkVGFuZ2VudDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcbnZhciBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlzcGxhY2VtZW50TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzO1xcbiNlbmRpZlwiO1xudmFyIGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0dHJhbnNmb3JtZWQgKz0gbm9ybWFsaXplKCBvYmplY3ROb3JtYWwgKSAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHZVdiApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXG4jZW5kaWZcIjtcbnZhciBlbWlzc2l2ZW1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZVdiApO1xcblxcdHRvdGFsRW1pc3NpdmVSYWRpYW5jZSAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcXG4jZW5kaWZcIjtcbnZhciBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXCI7XG52YXIgZW5jb2RpbmdzX2ZyYWdtZW50ID0gXCJnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcIjtcbnZhciBlbmNvZGluZ3NfcGFyc19mcmFnbWVudCA9IFwidmVjNCBMaW5lYXJUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG5cXHRyZXR1cm4gdmFsdWU7XFxufVxcbnZlYzQgTGluZWFyVG9zUkdCKCBpbiB2ZWM0IHZhbHVlICkge1xcblxcdHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLmEgKTtcXG59XCI7XG52YXIgZW52bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2ZWMzIGNhbWVyYVRvRnJhZztcXG5cXHRcXHRpZiAoIGlzT3J0aG9ncmFwaGljICkge1xcblxcdFxcdFxcdGNhbWVyYVRvRnJhZyA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjYW1lcmFUb0ZyYWcgPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRcXHR9XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9GcmFnLCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXG5cXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCByZWZsZWN0VmVjLCAwLjAgKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB2ZWM0KCAwLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcbnZhciBlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0dW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuXFx0I2VuZGlmXFxuXFx0XFxuI2VuZGlmXCI7XG52YXIgZW52bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHQjZGVmaW5lIEVOVl9XT1JMRFBPU1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG52YXIgZW52bWFwX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0VOVk1BUFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHQjZGVmaW5lIEVOVl9XT1JMRFBPU1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZfV09STERQT1NcXG5cXHRcXHRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG52YXIgZW52bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWZkZWYgRU5WX1dPUkxEUE9TXFxuXFx0XFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXg7XFxuXFx0XFx0aWYgKCBpc09ydGhvZ3JhcGhpYyApIHtcXG5cXHRcXHRcXHRjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdmVjMyggLSB2aWV3TWF0cml4WyAwIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAxIF1bIDIgXSwgLSB2aWV3TWF0cml4WyAyIF1bIDIgXSApICk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcblxcdFxcdH1cXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcdFxcdFxcdHZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG52YXIgZm9nX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHR2Rm9nRGVwdGggPSAtIG12UG9zaXRpb24uejtcXG4jZW5kaWZcIjtcbnZhciBmb2dfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0dmFyeWluZyBmbG9hdCB2Rm9nRGVwdGg7XFxuI2VuZGlmXCI7XG52YXIgZm9nX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0ZPR1xcblxcdCNpZmRlZiBGT0dfRVhQMlxcblxcdFxcdGZsb2F0IGZvZ0ZhY3RvciA9IDEuMCAtIGV4cCggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIHZGb2dEZXB0aCAqIHZGb2dEZXB0aCApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCB2Rm9nRGVwdGggKTtcXG5cXHQjZW5kaWZcXG5cXHRnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBmb2dDb2xvciwgZm9nRmFjdG9yICk7XFxuI2VuZGlmXCI7XG52YXIgZm9nX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcblxcdHZhcnlpbmcgZmxvYXQgdkZvZ0RlcHRoO1xcblxcdCNpZmRlZiBGT0dfRVhQMlxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcbnZhciBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0dSQURJRU5UTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZ3JhZGllbnRNYXA7XFxuI2VuZGlmXFxudmVjMyBnZXRHcmFkaWVudElycmFkaWFuY2UoIHZlYzMgbm9ybWFsLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uICkge1xcblxcdGZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7XFxuXFx0dmVjMiBjb29yZCA9IHZlYzIoIGRvdE5MICogMC41ICsgMC41LCAwLjAgKTtcXG5cXHQjaWZkZWYgVVNFX0dSQURJRU5UTUFQXFxuXFx0XFx0cmV0dXJuIHZlYzMoIHRleHR1cmUyRCggZ3JhZGllbnRNYXAsIGNvb3JkICkuciApO1xcblxcdCNlbHNlXFxuXFx0XFx0cmV0dXJuICggY29vcmQueCA8IDAuNyApID8gdmVjMyggMC43ICkgOiB2ZWMzKCAxLjAgKTtcXG5cXHQjZW5kaWZcXG59XCI7XG52YXIgbGlnaHRtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHR2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XFxuXFx0dmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBsaWdodE1hcElycmFkaWFuY2U7XFxuI2VuZGlmXCI7XG52YXIgbGlnaHRtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XG52YXIgbGlnaHRzX2xhbWJlcnRfdmVydGV4ID0gXCJ2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcbmdlb21ldHJ5LnBvc2l0aW9uID0gbXZQb3NpdGlvbi54eXo7XFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbmdlb21ldHJ5LnZpZXdEaXIgPSAoIGlzT3J0aG9ncmFwaGljICkgPyB2ZWMzKCAwLCAwLCAxICkgOiBub3JtYWxpemUoIC1tdlBvc2l0aW9uLnh5eiApO1xcbkdlb21ldHJpY0NvbnRleHQgYmFja0dlb21ldHJ5O1xcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcbmJhY2tHZW9tZXRyeS5ub3JtYWwgPSAtZ2VvbWV0cnkubm9ybWFsO1xcbmJhY2tHZW9tZXRyeS52aWV3RGlyID0gZ2VvbWV0cnkudmlld0RpcjtcXG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcbnZJbmRpcmVjdEZyb250ID0gdmVjMyggMC4wICk7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2SW5kaXJlY3RCYWNrID0gdmVjMyggMC4wICk7XFxuI2VuZGlmXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG5mbG9hdCBkb3ROTDtcXG52ZWMzIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG52SW5kaXJlY3RGcm9udCArPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcbnZJbmRpcmVjdEZyb250ICs9IGdldExpZ2h0UHJvYmVJcnJhZGlhbmNlKCBsaWdodFByb2JlLCBnZW9tZXRyeS5ub3JtYWwgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dkluZGlyZWN0QmFjayArPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdHZJbmRpcmVjdEJhY2sgKz0gZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGxpZ2h0UHJvYmUsIGJhY2tHZW9tZXRyeS5ub3JtYWwgKTtcXG4jZW5kaWZcXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRnZXRQb2ludExpZ2h0SW5mbyggcG9pbnRMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC0gZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0U3BvdExpZ2h0SW5mbyggc3BvdExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLSBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0Z2V0RGlyZWN0aW9uYWxMaWdodEluZm8oIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZJbmRpcmVjdEZyb250ICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHZJbmRpcmVjdEJhY2sgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBiYWNrR2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXCI7XG52YXIgbGlnaHRzX3BhcnNfYmVnaW4gPSBcInVuaWZvcm0gYm9vbCByZWNlaXZlU2hhZG93O1xcbnVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG51bmlmb3JtIHZlYzMgbGlnaHRQcm9iZVsgOSBdO1xcbnZlYzMgc2hHZXRJcnJhZGlhbmNlQXQoIGluIHZlYzMgbm9ybWFsLCBpbiB2ZWMzIHNoQ29lZmZpY2llbnRzWyA5IF0gKSB7XFxuXFx0ZmxvYXQgeCA9IG5vcm1hbC54LCB5ID0gbm9ybWFsLnksIHogPSBub3JtYWwuejtcXG5cXHR2ZWMzIHJlc3VsdCA9IHNoQ29lZmZpY2llbnRzWyAwIF0gKiAwLjg4NjIyNztcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDEgXSAqIDIuMCAqIDAuNTExNjY0ICogeTtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDIgXSAqIDIuMCAqIDAuNTExNjY0ICogejtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDMgXSAqIDIuMCAqIDAuNTExNjY0ICogeDtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDQgXSAqIDIuMCAqIDAuNDI5MDQzICogeCAqIHk7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA1IF0gKiAyLjAgKiAwLjQyOTA0MyAqIHkgKiB6O1xcblxcdHJlc3VsdCArPSBzaENvZWZmaWNpZW50c1sgNiBdICogKCAwLjc0MzEyNSAqIHogKiB6IC0gMC4yNDc3MDggKTtcXG5cXHRyZXN1bHQgKz0gc2hDb2VmZmljaWVudHNbIDcgXSAqIDIuMCAqIDAuNDI5MDQzICogeCAqIHo7XFxuXFx0cmVzdWx0ICs9IHNoQ29lZmZpY2llbnRzWyA4IF0gKiAwLjQyOTA0MyAqICggeCAqIHggLSB5ICogeSApO1xcblxcdHJldHVybiByZXN1bHQ7XFxufVxcbnZlYzMgZ2V0TGlnaHRQcm9iZUlycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgbGlnaHRQcm9iZVsgOSBdLCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcXG5cXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gc2hHZXRJcnJhZGlhbmNlQXQoIHdvcmxkTm9ybWFsLCBsaWdodFByb2JlICk7XFxuXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxufVxcbnZlYzMgZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBhbWJpZW50TGlnaHRDb2xvciApIHtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG59XFxuZmxvYXQgZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggY29uc3QgaW4gZmxvYXQgbGlnaHREaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgY3V0b2ZmRGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGRlY2F5RXhwb25lbnQgKSB7XFxuXFx0I2lmIGRlZmluZWQgKCBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTIClcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZUZhbGxvZmYgPSAxLjAgLyBtYXgoIHBvdyggbGlnaHREaXN0YW5jZSwgZGVjYXlFeHBvbmVudCApLCAwLjAxICk7XFxuXFx0XFx0aWYgKCBjdXRvZmZEaXN0YW5jZSA+IDAuMCApIHtcXG5cXHRcXHRcXHRkaXN0YW5jZUZhbGxvZmYgKj0gcG93Miggc2F0dXJhdGUoIDEuMCAtIHBvdzQoIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSApICkgKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGRpc3RhbmNlRmFsbG9mZjtcXG5cXHQjZWxzZVxcblxcdFxcdGlmICggY3V0b2ZmRGlzdGFuY2UgPiAwLjAgJiYgZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXG5cXHRcXHRcXHRyZXR1cm4gcG93KCBzYXR1cmF0ZSggLSBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKyAxLjAgKSwgZGVjYXlFeHBvbmVudCApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMS4wO1xcblxcdCNlbmRpZlxcbn1cXG5mbG9hdCBnZXRTcG90QXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGNvbmVDb3NpbmUsIGNvbnN0IGluIGZsb2F0IHBlbnVtYnJhQ29zaW5lLCBjb25zdCBpbiBmbG9hdCBhbmdsZUNvc2luZSApIHtcXG5cXHRyZXR1cm4gc21vb3Roc3RlcCggY29uZUNvc2luZSwgcGVudW1icmFDb3NpbmUsIGFuZ2xlQ29zaW5lICk7XFxufVxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHR9O1xcblxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0c1sgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldERpcmVjdGlvbmFsTGlnaHRJbmZvKCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xcblxcdFxcdGxpZ2h0LmNvbG9yID0gZGlyZWN0aW9uYWxMaWdodC5jb2xvcjtcXG5cXHRcXHRsaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0LmRpcmVjdGlvbjtcXG5cXHRcXHRsaWdodC52aXNpYmxlID0gdHJ1ZTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFBvaW50TGlnaHQge1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHRcXHRmbG9hdCBkaXN0YW5jZTtcXG5cXHRcXHRmbG9hdCBkZWNheTtcXG5cXHR9O1xcblxcdHVuaWZvcm0gUG9pbnRMaWdodCBwb2ludExpZ2h0c1sgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0UG9pbnRMaWdodEluZm8oIGNvbnN0IGluIFBvaW50TGlnaHQgcG9pbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgbGlnaHQgKSB7XFxuXFx0XFx0dmVjMyBsVmVjdG9yID0gcG9pbnRMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdGxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXG5cXHRcXHRsaWdodC5jb2xvciA9IHBvaW50TGlnaHQuY29sb3I7XFxuXFx0XFx0bGlnaHQuY29sb3IgKj0gZ2V0RGlzdGFuY2VBdHRlbnVhdGlvbiggbGlnaHREaXN0YW5jZSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xcblxcdFxcdGxpZ2h0LnZpc2libGUgPSAoIGxpZ2h0LmNvbG9yICE9IHZlYzMoIDAuMCApICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IFNwb3RMaWdodCB7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdGZsb2F0IGRpc3RhbmNlO1xcblxcdFxcdGZsb2F0IGRlY2F5O1xcblxcdFxcdGZsb2F0IGNvbmVDb3M7XFxuXFx0XFx0ZmxvYXQgcGVudW1icmFDb3M7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIFNwb3RMaWdodCBzcG90TGlnaHRzWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldFNwb3RMaWdodEluZm8oIGNvbnN0IGluIFNwb3RMaWdodCBzcG90TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGxpZ2h0ICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdGxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGFuZ2xlQ29zID0gZG90KCBsaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBzcG90QXR0ZW51YXRpb24gPSBnZXRTcG90QXR0ZW51YXRpb24oIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7XFxuXFx0XFx0aWYgKCBzcG90QXR0ZW51YXRpb24gPiAwLjAgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcblxcdFxcdFxcdGxpZ2h0LmNvbG9yID0gc3BvdExpZ2h0LmNvbG9yICogc3BvdEF0dGVudWF0aW9uO1xcblxcdFxcdFxcdGxpZ2h0LmNvbG9yICo9IGdldERpc3RhbmNlQXR0ZW51YXRpb24oIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7XFxuXFx0XFx0XFx0bGlnaHQudmlzaWJsZSA9ICggbGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGxpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7XFxuXFx0XFx0XFx0bGlnaHQudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcblxcdHN0cnVjdCBSZWN0QXJlYUxpZ2h0IHtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdHZlYzMgcG9zaXRpb247XFxuXFx0XFx0dmVjMyBoYWxmV2lkdGg7XFxuXFx0XFx0dmVjMyBoYWxmSGVpZ2h0O1xcblxcdH07XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjXzE7XFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjXzI7XFxuXFx0dW5pZm9ybSBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHRzWyBOVU1fUkVDVF9BUkVBX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBza3lDb2xvcjtcXG5cXHRcXHR2ZWMzIGdyb3VuZENvbG9yO1xcblxcdH07XFxuXFx0dW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07XFxuXFx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcXG5cXHRcXHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBoZW1pTGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3ROTCArIDAuNTtcXG5cXHRcXHR2ZWMzIGlycmFkaWFuY2UgPSBtaXgoIGhlbWlMaWdodC5ncm91bmRDb2xvciwgaGVtaUxpZ2h0LnNreUNvbG9yLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcdFxcdHJldHVybiBpcnJhZGlhbmNlO1xcblxcdH1cXG4jZW5kaWZcIjtcbnZhciBlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcdHZlYzMgZ2V0SUJMSXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCB3b3JsZE5vcm1hbCwgMS4wICk7XFxuXFx0XFx0XFx0cmV0dXJuIFBJICogZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0cmV0dXJuIHZlYzMoIDAuMCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHR2ZWMzIGdldElCTFJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIC0gdmlld0Rpciwgbm9ybWFsICk7XFxuXFx0XFx0XFx0cmVmbGVjdFZlYyA9IG5vcm1hbGl6ZSggbWl4KCByZWZsZWN0VmVjLCBub3JtYWwsIHJvdWdobmVzcyAqIHJvdWdobmVzcykgKTtcXG5cXHRcXHRcXHRyZWZsZWN0VmVjID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggcmVmbGVjdFZlYywgdmlld01hdHJpeCApO1xcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIHJlZmxlY3RWZWMsIHJvdWdobmVzcyApO1xcblxcdFxcdFxcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMyggMC4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlwiO1xudmFyIGxpZ2h0c190b29uX2ZyYWdtZW50ID0gXCJUb29uTWF0ZXJpYWwgbWF0ZXJpYWw7XFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYjtcIjtcbnZhciBsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5zdHJ1Y3QgVG9vbk1hdGVyaWFsIHtcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcXG59O1xcbnZvaWQgUkVfRGlyZWN0X1Rvb24oIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFRvb25NYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfVG9vbiggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBUb29uTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfVG9vblxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX1Rvb25cXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcXHQoMClcIjtcbnZhciBsaWdodHNfcGhvbmdfZnJhZ21lbnQgPSBcIkJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xcbm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjtcXG5tYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzcztcXG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtcIjtcbnZhciBsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCA9IFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0IHNwZWN1bGFyU2hpbmluZXNzO1xcblxcdGZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxufTtcXG52b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9CbGlublBob25nKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKSAqIG1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGg7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X0JsaW5uUGhvbmdcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nXFxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXFx0KDApXCI7XG52YXIgbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50ID0gXCJQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbnZlYzMgZHh5ID0gbWF4KCBhYnMoIGRGZHgoIGdlb21ldHJ5Tm9ybWFsICkgKSwgYWJzKCBkRmR5KCBnZW9tZXRyeU5vcm1hbCApICkgKTtcXG5mbG9hdCBnZW9tZXRyeVJvdWdobmVzcyA9IG1heCggbWF4KCBkeHkueCwgZHh5LnkgKSwgZHh5LnogKTtcXG5tYXRlcmlhbC5yb3VnaG5lc3MgPSBtYXgoIHJvdWdobmVzc0ZhY3RvciwgMC4wNTI1ICk7bWF0ZXJpYWwucm91Z2huZXNzICs9IGdlb21ldHJ5Um91Z2huZXNzO1xcbm1hdGVyaWFsLnJvdWdobmVzcyA9IG1pbiggbWF0ZXJpYWwucm91Z2huZXNzLCAxLjAgKTtcXG4jaWZkZWYgSU9SXFxuXFx0I2lmZGVmIFNQRUNVTEFSXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSBzcGVjdWxhckludGVuc2l0eTtcXG5cXHRcXHR2ZWMzIHNwZWN1bGFyQ29sb3JGYWN0b3IgPSBzcGVjdWxhckNvbG9yO1xcblxcdFxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVBcXG5cXHRcXHRcXHRzcGVjdWxhckludGVuc2l0eUZhY3RvciAqPSB0ZXh0dXJlMkQoIHNwZWN1bGFySW50ZW5zaXR5TWFwLCB2VXYgKS5hO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJDT0xPUk1BUFxcblxcdFxcdFxcdHNwZWN1bGFyQ29sb3JGYWN0b3IgKj0gdGV4dHVyZTJEKCBzcGVjdWxhckNvbG9yTWFwLCB2VXYgKS5yZ2I7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSBtaXgoIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCAxLjAsIG1ldGFsbmVzc0ZhY3RvciApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHlGYWN0b3IgPSAxLjA7XFxuXFx0XFx0dmVjMyBzcGVjdWxhckNvbG9yRmFjdG9yID0gdmVjMyggMS4wICk7XFxuXFx0XFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggbWluKCBwb3cyKCAoIGlvciAtIDEuMCApIC8gKCBpb3IgKyAxLjAgKSApICogc3BlY3VsYXJDb2xvckZhY3RvciwgdmVjMyggMS4wICkgKSAqIHNwZWN1bGFySW50ZW5zaXR5RmFjdG9yLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG4jZWxzZVxcblxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIDAuMDQgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7XFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJGOTAgPSAxLjA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXQgPSBjbGVhcmNvYXQ7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gY2xlYXJjb2F0Um91Z2huZXNzO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdEYwID0gdmVjMyggMC4wNCApO1xcblxcdG1hdGVyaWFsLmNsZWFyY29hdEY5MCA9IDEuMDtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVE1BUFxcblxcdFxcdG1hdGVyaWFsLmNsZWFyY29hdCAqPSB0ZXh0dXJlMkQoIGNsZWFyY29hdE1hcCwgdlV2ICkueDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVF9ST1VHSE5FU1NNQVBcXG5cXHRcXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBjbGVhcmNvYXRSb3VnaG5lc3NNYXAsIHZVdiApLnk7XFxuXFx0I2VuZGlmXFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0ID0gc2F0dXJhdGUoIG1hdGVyaWFsLmNsZWFyY29hdCApO1xcdG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyA9IG1heCggbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzLCAwLjA1MjUgKTtcXG5cXHRtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKz0gZ2VvbWV0cnlSb3VnaG5lc3M7XFxuXFx0bWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzID0gbWluKCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MsIDEuMCApO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRtYXRlcmlhbC5pcmlkZXNjZW5jZSA9IGlyaWRlc2NlbmNlO1xcblxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SID0gaXJpZGVzY2VuY2VJT1I7XFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRU1BUFxcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlICo9IHRleHR1cmUyRCggaXJpZGVzY2VuY2VNYXAsIHZVdiApLnI7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVBcXG5cXHRcXHRtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzcyA9IChpcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0gLSBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0pICogdGV4dHVyZTJEKCBpcmlkZXNjZW5jZVRoaWNrbmVzc01hcCwgdlV2ICkuZyArIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bTtcXG5cXHQjZWxzZVxcblxcdFxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzID0gaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5cXG5cXHRtYXRlcmlhbC5zaGVlbkNvbG9yID0gc2hlZW5Db2xvcjtcXG5cXHQjaWZkZWYgVVNFX1NIRUVOQ09MT1JNQVBcXG5cXHRcXHRtYXRlcmlhbC5zaGVlbkNvbG9yICo9IHRleHR1cmUyRCggc2hlZW5Db2xvck1hcCwgdlV2ICkucmdiO1xcblxcdCNlbmRpZlxcblxcdG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzID0gY2xhbXAoIHNoZWVuUm91Z2huZXNzLCAwLjA3LCAxLjAgKTtcXG5cXHQjaWZkZWYgVVNFX1NIRUVOUk9VR0hORVNTTUFQXFxuXFx0XFx0bWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3MgKj0gdGV4dHVyZTJEKCBzaGVlblJvdWdobmVzc01hcCwgdlV2ICkuYTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcbnZhciBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcblxcdHZlYzMgZGlmZnVzZUNvbG9yO1xcblxcdGZsb2F0IHJvdWdobmVzcztcXG5cXHR2ZWMzIHNwZWN1bGFyQ29sb3I7XFxuXFx0ZmxvYXQgc3BlY3VsYXJGOTA7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBjbGVhcmNvYXQ7XFxuXFx0XFx0ZmxvYXQgY2xlYXJjb2F0Um91Z2huZXNzO1xcblxcdFxcdHZlYzMgY2xlYXJjb2F0RjA7XFxuXFx0XFx0ZmxvYXQgY2xlYXJjb2F0RjkwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHRmbG9hdCBpcmlkZXNjZW5jZTtcXG5cXHRcXHRmbG9hdCBpcmlkZXNjZW5jZUlPUjtcXG5cXHRcXHRmbG9hdCBpcmlkZXNjZW5jZVRoaWNrbmVzcztcXG5cXHRcXHR2ZWMzIGlyaWRlc2NlbmNlRnJlc25lbDtcXG5cXHRcXHR2ZWMzIGlyaWRlc2NlbmNlRjA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdHZlYzMgc2hlZW5Db2xvcjtcXG5cXHRcXHRmbG9hdCBzaGVlblJvdWdobmVzcztcXG5cXHQjZW5kaWZcXG59O1xcbnZlYzMgY2xlYXJjb2F0U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIHNoZWVuU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG5mbG9hdCBJQkxTaGVlbkJSREYoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcykge1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRmbG9hdCByMiA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcXG5cXHRmbG9hdCBhID0gcm91Z2huZXNzIDwgMC4yNSA/IC0zMzkuMiAqIHIyICsgMTYxLjQgKiByb3VnaG5lc3MgLSAyNS45IDogLTguNDggKiByMiArIDE0LjMgKiByb3VnaG5lc3MgLSA5Ljk1O1xcblxcdGZsb2F0IGIgPSByb3VnaG5lc3MgPCAwLjI1ID8gNDQuMCAqIHIyIC0gMjMuNyAqIHJvdWdobmVzcyArIDMuMjYgOiAxLjk3ICogcjIgLSAzLjI3ICogcm91Z2huZXNzICsgMC43MjtcXG5cXHRmbG9hdCBERyA9IGV4cCggYSAqIGRvdE5WICsgYiApICsgKCByb3VnaG5lc3MgPCAwLjI1ID8gMC4wIDogMC4xICogKCByb3VnaG5lc3MgLSAwLjI1ICkgKTtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIERHICogUkVDSVBST0NBTF9QSSApO1xcbn1cXG52ZWMyIERGR0FwcHJveCggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCB2aWV3RGlyICkgKTtcXG5cXHRjb25zdCB2ZWM0IGMwID0gdmVjNCggLSAxLCAtIDAuMDI3NSwgLSAwLjU3MiwgMC4wMjIgKTtcXG5cXHRjb25zdCB2ZWM0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTtcXG5cXHR2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcblxcdGZsb2F0IGEwMDQgPSBtaW4oIHIueCAqIHIueCwgZXhwMiggLSA5LjI4ICogZG90TlYgKSApICogci54ICsgci55O1xcblxcdHZlYzIgZmFiID0gdmVjMiggLSAxLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXG5cXHRyZXR1cm4gZmFiO1xcbn1cXG52ZWMzIEVudmlyb25tZW50QlJERiggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdHZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xcblxcdHJldHVybiBzcGVjdWxhckNvbG9yICogZmFiLnggKyBzcGVjdWxhckY5MCAqIGZhYi55O1xcbn1cXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxudm9pZCBjb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGNvbnN0IGluIHZlYzMgbm9ybWFsLCBjb25zdCBpbiB2ZWMzIHZpZXdEaXIsIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc3BlY3VsYXJGOTAsIGNvbnN0IGluIGZsb2F0IGlyaWRlc2NlbmNlLCBjb25zdCBpbiB2ZWMzIGlyaWRlc2NlbmNlRjAsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgaW5vdXQgdmVjMyBzaW5nbGVTY2F0dGVyLCBpbm91dCB2ZWMzIG11bHRpU2NhdHRlciApIHtcXG4jZWxzZVxcbnZvaWQgY29tcHV0ZU11bHRpc2NhdHRlcmluZyggY29uc3QgaW4gdmVjMyBub3JtYWwsIGNvbnN0IGluIHZlYzMgdmlld0RpciwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzLCBpbm91dCB2ZWMzIHNpbmdsZVNjYXR0ZXIsIGlub3V0IHZlYzMgbXVsdGlTY2F0dGVyICkge1xcbiNlbmRpZlxcblxcdHZlYzIgZmFiID0gREZHQXBwcm94KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHR2ZWMzIEZyID0gbWl4KCBzcGVjdWxhckNvbG9yLCBpcmlkZXNjZW5jZUYwLCBpcmlkZXNjZW5jZSApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjMyBGciA9IHNwZWN1bGFyQ29sb3I7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMyBGc3NFc3MgPSBGciAqIGZhYi54ICsgc3BlY3VsYXJGOTAgKiBmYWIueTtcXG5cXHRmbG9hdCBFc3MgPSBmYWIueCArIGZhYi55O1xcblxcdGZsb2F0IEVtcyA9IDEuMCAtIEVzcztcXG5cXHR2ZWMzIEZhdmcgPSBGciArICggMS4wIC0gRnIgKSAqIDAuMDQ3NjE5O1xcdHZlYzMgRm1zID0gRnNzRXNzICogRmF2ZyAvICggMS4wIC0gRW1zICogRmF2ZyApO1xcblxcdHNpbmdsZVNjYXR0ZXIgKz0gRnNzRXNzO1xcblxcdG11bHRpU2NhdHRlciArPSBGbXMgKiBFbXM7XFxufVxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXG5cXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRcXHR2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Lm5vcm1hbDtcXG5cXHRcXHR2ZWMzIHZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xcblxcdFxcdHZlYzMgcG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGhhbGZXaWR0aCA9IHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoO1xcblxcdFxcdHZlYzMgaGFsZkhlaWdodCA9IHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodDtcXG5cXHRcXHR2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xcblxcdFxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnJvdWdobmVzcztcXG5cXHRcXHR2ZWMzIHJlY3RDb29yZHNbIDQgXTtcXG5cXHRcXHRyZWN0Q29vcmRzWyAwIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XFx0XFx0cmVjdENvb3Jkc1sgMSBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcblxcdFxcdHJlY3RDb29yZHNbIDIgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoICsgaGFsZkhlaWdodDtcXG5cXHRcXHRyZWN0Q29vcmRzWyAzIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0dmVjMiB1diA9IExUQ19Vdiggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcXG5cXHRcXHR2ZWM0IHQxID0gdGV4dHVyZTJEKCBsdGNfMSwgdXYgKTtcXG5cXHRcXHR2ZWM0IHQyID0gdGV4dHVyZTJEKCBsdGNfMiwgdXYgKTtcXG5cXHRcXHRtYXQzIG1JbnYgPSBtYXQzKFxcblxcdFxcdFxcdHZlYzMoIHQxLngsIDAsIHQxLnkgKSxcXG5cXHRcXHRcXHR2ZWMzKCAgICAwLCAxLCAgICAwICksXFxuXFx0XFx0XFx0dmVjMyggdDEueiwgMCwgdDEudyApXFxuXFx0XFx0KTtcXG5cXHRcXHR2ZWMzIGZyZXNuZWwgPSAoIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKiB0Mi54ICsgKCB2ZWMzKCAxLjAgKSAtIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKSAqIHQyLnkgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBsaWdodENvbG9yICogZnJlc25lbCAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbUludiwgcmVjdENvb3JkcyApO1xcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRDb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbWF0MyggMS4wICksIHJlY3RDb29yZHMgKTtcXG5cXHR9XFxuI2VuZGlmXFxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRmbG9hdCBkb3ROTGNjID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcblxcdFxcdHZlYzMgY2NJcnJhZGlhbmNlID0gZG90TkxjYyAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdFxcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNjSXJyYWRpYW5jZSAqIEJSREZfR0dYKCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5LmNsZWFyY29hdE5vcm1hbCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjAsIG1hdGVyaWFsLmNsZWFyY29hdEY5MCwgbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdHNoZWVuU3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIEJSREZfU2hlZW4oIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zaGVlbkNvbG9yLCBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1hfSXJpZGVzY2VuY2UoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2UsIG1hdGVyaWFsLmlyaWRlc2NlbmNlRnJlc25lbCwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9HR1goIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhckY5MCwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhcmNvYXRSYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQpIHtcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGNsZWFyY29hdFNwZWN1bGFyICs9IGNsZWFyY29hdFJhZGlhbmNlICogRW52aXJvbm1lbnRCUkRGKCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLmNsZWFyY29hdEYwLCBtYXRlcmlhbC5jbGVhcmNvYXRGOTAsIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU0hFRU5cXG5cXHRcXHRzaGVlblNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBtYXRlcmlhbC5zaGVlbkNvbG9yICogSUJMU2hlZW5CUkRGKCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuXFx0dmVjMyBzaW5nbGVTY2F0dGVyaW5nID0gdmVjMyggMC4wICk7XFxuXFx0dmVjMyBtdWx0aVNjYXR0ZXJpbmcgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIGNvc2luZVdlaWdodGVkSXJyYWRpYW5jZSA9IGlycmFkaWFuY2UgKiBSRUNJUFJPQ0FMX1BJO1xcblxcdCNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5cXHRcXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nSXJpZGVzY2VuY2UoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsIG1hdGVyaWFsLmlyaWRlc2NlbmNlLCBtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwsIG1hdGVyaWFsLnJvdWdobmVzcywgc2luZ2xlU2NhdHRlcmluZywgbXVsdGlTY2F0dGVyaW5nICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRjb21wdXRlTXVsdGlzY2F0dGVyaW5nKCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyRjkwLCBtYXRlcmlhbC5yb3VnaG5lc3MsIHNpbmdsZVNjYXR0ZXJpbmcsIG11bHRpU2NhdHRlcmluZyApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgdG90YWxTY2F0dGVyaW5nID0gc2luZ2xlU2NhdHRlcmluZyArIG11bHRpU2NhdHRlcmluZztcXG5cXHR2ZWMzIGRpZmZ1c2UgPSBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiAoIDEuMCAtIG1heCggbWF4KCB0b3RhbFNjYXR0ZXJpbmcuciwgdG90YWxTY2F0dGVyaW5nLmcgKSwgdG90YWxTY2F0dGVyaW5nLmIgKSApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gcmFkaWFuY2UgKiBzaW5nbGVTY2F0dGVyaW5nO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gbXVsdGlTY2F0dGVyaW5nICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBkaWZmdXNlICogY29zaW5lV2VpZ2h0ZWRJcnJhZGlhbmNlO1xcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfRGlyZWN0X1JlY3RBcmVhXFx0XFx0UkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWxcXG4jZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXJcXHRcXHRSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsXFxuZmxvYXQgY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgYW1iaWVudE9jY2x1c2lvbiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggcG93KCBkb3ROViArIGFtYmllbnRPY2NsdXNpb24sIGV4cDIoIC0gMTYuMCAqIHJvdWdobmVzcyAtIDEuMCApICkgLSAxLjAgKyBhbWJpZW50T2NjbHVzaW9uICk7XFxufVwiO1xudmFyIGxpZ2h0c19mcmFnbWVudF9iZWdpbiA9IFwiXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IC0gdlZpZXdQb3NpdGlvbjtcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWw7XFxuZ2VvbWV0cnkudmlld0RpciA9ICggaXNPcnRob2dyYXBoaWMgKSA/IHZlYzMoIDAsIDAsIDEgKSA6IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUXFxuXFx0Z2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsID0gY2xlYXJjb2F0Tm9ybWFsO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VcXG5mbG9hdCBkb3ROVmkgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcbmlmICggbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MgPT0gMC4wICkge1xcblxcdG1hdGVyaWFsLmlyaWRlc2NlbmNlID0gMC4wO1xcbn0gZWxzZSB7XFxuXFx0bWF0ZXJpYWwuaXJpZGVzY2VuY2UgPSBzYXR1cmF0ZSggbWF0ZXJpYWwuaXJpZGVzY2VuY2UgKTtcXG59XFxuaWYgKCBtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDAuMCApIHtcXG5cXHRtYXRlcmlhbC5pcmlkZXNjZW5jZUZyZXNuZWwgPSBldmFsSXJpZGVzY2VuY2UoIDEuMCwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VJT1IsIGRvdE5WaSwgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3MsIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgKTtcXG5cXHRtYXRlcmlhbC5pcmlkZXNjZW5jZUYwID0gU2NobGlja190b19GMCggbWF0ZXJpYWwuaXJpZGVzY2VuY2VGcmVzbmVsLCAxLjAsIGRvdE5WaSApO1xcbn1cXG4jZW5kaWZcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcbiNpZiAoIE5VTV9QT0lOVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHRQb2ludExpZ2h0IHBvaW50TGlnaHQ7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3c7XFxuXFx0I2VuZGlmXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXFx0XFx0Z2V0UG9pbnRMaWdodEluZm8oIHBvaW50TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgKCBVTlJPTExFRF9MT09QX0lOREVYIDwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgKVxcblxcdFxcdHBvaW50TGlnaHRTaGFkb3cgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdExpZ2h0LnZpc2libGUsIHJlY2VpdmVTaGFkb3cgKSApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHRTaGFkb3cuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodFNoYWRvdy5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0U2hhZG93LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG4jZW5kaWZcXG4jaWYgKCBOVU1fU1BPVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0U2hhZG93O1xcblxcdCNlbmRpZlxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFNwb3RMaWdodEluZm8oIHNwb3RMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIClcXG5cXHRcXHRzcG90TGlnaHRTaGFkb3cgPSBzcG90TGlnaHRTaGFkb3dzWyBpIF07XFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggZGlyZWN0TGlnaHQudmlzaWJsZSwgcmVjZWl2ZVNoYWRvdyApICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodFNoYWRvdy5zaGFkb3dCaWFzLCBzcG90TGlnaHRTaGFkb3cuc2hhZG93UmFkaXVzLCB2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxuXFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93O1xcblxcdCNlbmRpZlxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXREaXJlY3Rpb25hbExpZ2h0SW5mbyggZGlyZWN0aW9uYWxMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9TSEFET1dNQVAgKSAmJiAoIFVOUk9MTEVEX0xPT1BfSU5ERVggPCBOVU1fRElSX0xJR0hUX1NIQURPV1MgKVxcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdExpZ2h0LnZpc2libGUsIHJlY2VpdmVTaGFkb3cgKSApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3cuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodFNoYWRvdy5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuI2VuZGlmXFxuI2lmICggTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0X1JlY3RBcmVhIClcXG5cXHRSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9SRUNUX0FSRUFfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHJlY3RBcmVhTGlnaHQgPSByZWN0QXJlYUxpZ2h0c1sgaSBdO1xcblxcdFxcdFJFX0RpcmVjdF9SZWN0QXJlYSggcmVjdEFyZWFMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcblxcdHZlYzMgaWJsSXJyYWRpYW5jZSA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxuXFx0aXJyYWRpYW5jZSArPSBnZXRMaWdodFByb2JlSXJyYWRpYW5jZSggbGlnaHRQcm9iZSwgZ2VvbWV0cnkubm9ybWFsICk7XFxuXFx0I2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApXFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRcXHRpcnJhZGlhbmNlICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdHZlYzMgcmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWMzIGNsZWFyY29hdFJhZGlhbmNlID0gdmVjMyggMC4wICk7XFxuI2VuZGlmXCI7XG52YXIgbGlnaHRzX2ZyYWdtZW50X21hcHMgPSBcIiNpZiBkZWZpbmVkKCBSRV9JbmRpcmVjdERpZmZ1c2UgKVxcblxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRcXHR2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XFxuXFx0XFx0dmVjMyBsaWdodE1hcElycmFkaWFuY2UgPSBsaWdodE1hcFRleGVsLnJnYiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcdFxcdGlycmFkaWFuY2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcblxcdCNlbmRpZlxcblxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggU1RBTkRBUkQgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRpYmxJcnJhZGlhbmNlICs9IGdldElCTElycmFkaWFuY2UoIGdlb21ldHJ5Lm5vcm1hbCApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXFx0cmFkaWFuY2UgKz0gZ2V0SUJMUmFkaWFuY2UoIGdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgbWF0ZXJpYWwucm91Z2huZXNzICk7XFxuXFx0I2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHRcXHRjbGVhcmNvYXRSYWRpYW5jZSArPSBnZXRJQkxSYWRpYW5jZSggZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkuY2xlYXJjb2F0Tm9ybWFsLCBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcbnZhciBsaWdodHNfZnJhZ21lbnRfZW5kID0gXCIjaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHRSRV9JbmRpcmVjdERpZmZ1c2UoIGlycmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3RTcGVjdWxhciApXFxuXFx0UkVfSW5kaXJlY3RTcGVjdWxhciggcmFkaWFuY2UsIGlibElycmFkaWFuY2UsIGNsZWFyY29hdFJhZGlhbmNlLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuI2VuZGlmXCI7XG52YXIgbG9nZGVwdGhidWZfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUYgKSAmJiBkZWZpbmVkKCBVU0VfTE9HREVQVEhCVUZfRVhUIClcXG5cXHRnbF9GcmFnRGVwdGhFWFQgPSB2SXNQZXJzcGVjdGl2ZSA9PSAwLjAgPyBnbF9GcmFnQ29vcmQueiA6IGxvZzIoIHZGcmFnRGVwdGggKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuI2VuZGlmXCI7XG52YXIgbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRiApICYmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRl9FWFQgKVxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxuXFx0dmFyeWluZyBmbG9hdCB2SXNQZXJzcGVjdGl2ZTtcXG4jZW5kaWZcIjtcbnZhciBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdFxcdHZhcnlpbmcgZmxvYXQgdklzUGVyc3BlY3RpdmU7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG52YXIgbG9nZGVwdGhidWZfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXHRcXHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXHRcXHR2SXNQZXJzcGVjdGl2ZSA9IGZsb2F0KCBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICkgKTtcXG5cXHQjZWxzZVxcblxcdFxcdGlmICggaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApICkge1xcblxcdFxcdFxcdGdsX1Bvc2l0aW9uLnogPSBsb2cyKCBtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSApICogbG9nRGVwdGhCdWZGQyAtIDEuMDtcXG5cXHRcXHRcXHRnbF9Qb3NpdGlvbi56ICo9IGdsX1Bvc2l0aW9uLnc7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xudmFyIG1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR2ZWM0IHNhbXBsZWREaWZmdXNlQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxuXFx0I2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFXFxuXFx0XFx0c2FtcGxlZERpZmZ1c2VDb2xvciA9IHZlYzQoIG1peCggcG93KCBzYW1wbGVkRGlmZnVzZUNvbG9yLnJnYiAqIDAuOTQ3ODY3Mjk4NiArIHZlYzMoIDAuMDUyMTMyNzAxNCApLCB2ZWMzKCAyLjQgKSApLCBzYW1wbGVkRGlmZnVzZUNvbG9yLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggc2FtcGxlZERpZmZ1c2VDb2xvci5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgc2FtcGxlZERpZmZ1c2VDb2xvci53ICk7XFxuXFx0I2VuZGlmXFxuXFx0ZGlmZnVzZUNvbG9yICo9IHNhbXBsZWREaWZmdXNlQ29sb3I7XFxuI2VuZGlmXCI7XG52YXIgbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlwiO1xudmFyIG1hcF9wYXJ0aWNsZV9mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKVxcblxcdHZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB1diApO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB1diApLmc7XFxuI2VuZGlmXCI7XG52YXIgbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQIClcXG5cXHR1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlwiO1xudmFyIG1ldGFsbmVzc21hcF9mcmFnbWVudCA9IFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2VXYgKTtcXG5cXHRtZXRhbG5lc3NGYWN0b3IgKj0gdGV4ZWxNZXRhbG5lc3MuYjtcXG4jZW5kaWZcIjtcbnZhciBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XFxuI2VuZGlmXCI7XG52YXIgbW9ycGhjb2xvcl92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTU9SUEhDT0xPUlMgKSAmJiBkZWZpbmVkKCBNT1JQSFRBUkdFVFNfVEVYVFVSRSApXFxuXFx0dkNvbG9yICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApXFxuXFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSB2Q29sb3IgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAyICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBVU0VfQ09MT1IgKVxcblxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdkNvbG9yICs9IGdldE1vcnBoKCBnbF9WZXJ0ZXhJRCwgaSwgMiApLnJnYiAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgaSBdO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcIjtcbnZhciBtb3JwaG5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0b2JqZWN0Tm9ybWFsICo9IG1vcnBoVGFyZ2V0QmFzZUluZmx1ZW5jZTtcXG5cXHQjaWZkZWYgTU9SUEhUQVJHRVRTX1RFWFRVUkVcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBNT1JQSFRBUkdFVFNfQ09VTlQ7IGkgKysgKSB7XFxuXFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXSAhPSAwLjAgKSBvYmplY3ROb3JtYWwgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAxICkueHl6ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XFxuXFx0XFx0fVxcblxcdCNlbHNlXFxuXFx0XFx0b2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMCAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdFxcdG9iamVjdE5vcm1hbCArPSBtb3JwaE5vcm1hbDEgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cXHRcXHRvYmplY3ROb3JtYWwgKz0gbW9ycGhOb3JtYWwyICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0XFx0b2JqZWN0Tm9ybWFsICs9IG1vcnBoTm9ybWFsMyAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xudmFyIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlO1xcblxcdCNpZmRlZiBNT1JQSFRBUkdFVFNfVEVYVFVSRVxcblxcdFxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBNT1JQSFRBUkdFVFNfQ09VTlQgXTtcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyREFycmF5IG1vcnBoVGFyZ2V0c1RleHR1cmU7XFxuXFx0XFx0dW5pZm9ybSBpdmVjMiBtb3JwaFRhcmdldHNUZXh0dXJlU2l6ZTtcXG5cXHRcXHR2ZWM0IGdldE1vcnBoKCBjb25zdCBpbiBpbnQgdmVydGV4SW5kZXgsIGNvbnN0IGluIGludCBtb3JwaFRhcmdldEluZGV4LCBjb25zdCBpbiBpbnQgb2Zmc2V0ICkge1xcblxcdFxcdFxcdGludCB0ZXhlbEluZGV4ID0gdmVydGV4SW5kZXggKiBNT1JQSFRBUkdFVFNfVEVYVFVSRV9TVFJJREUgKyBvZmZzZXQ7XFxuXFx0XFx0XFx0aW50IHkgPSB0ZXhlbEluZGV4IC8gbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUueDtcXG5cXHRcXHRcXHRpbnQgeCA9IHRleGVsSW5kZXggLSB5ICogbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUueDtcXG5cXHRcXHRcXHRpdmVjMyBtb3JwaFVWID0gaXZlYzMoIHgsIHksIG1vcnBoVGFyZ2V0SW5kZXggKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGV4ZWxGZXRjaCggbW9ycGhUYXJnZXRzVGV4dHVyZSwgbW9ycGhVViwgMCApO1xcblxcdFxcdH1cXG5cXHQjZWxzZVxcblxcdFxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdFxcdFxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xudmFyIG1vcnBodGFyZ2V0X3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXHR0cmFuc2Zvcm1lZCAqPSBtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2U7XFxuXFx0I2lmZGVmIE1PUlBIVEFSR0VUU19URVhUVVJFXFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTU9SUEhUQVJHRVRTX0NPVU5UOyBpICsrICkge1xcblxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF0gIT0gMC4wICkgdHJhbnNmb3JtZWQgKz0gZ2V0TW9ycGgoIGdsX1ZlcnRleElELCBpLCAwICkueHl6ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XFxuXFx0XFx0fVxcblxcdCNlbHNlXFxuXFx0XFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQwICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0XFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQxICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXFx0XFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQyICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0XFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQzICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFx0XFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFx0XFx0XFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQ0ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFx0XFx0XFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQ1ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuXFx0XFx0XFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQ2ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07XFxuXFx0XFx0XFx0dHJhbnNmb3JtZWQgKz0gbW9ycGhUYXJnZXQ3ICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG52YXIgbm9ybWFsX2ZyYWdtZW50X2JlZ2luID0gXCJmbG9hdCBmYWNlRGlyZWN0aW9uID0gZ2xfRnJvbnRGYWNpbmcgPyAxLjAgOiAtIDEuMDtcXG4jaWZkZWYgRkxBVF9TSEFERURcXG5cXHR2ZWMzIGZkeCA9IHZlYzMoIGRGZHgoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeCggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIGZkeSA9IHZlYzMoIGRGZHkoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeSggdlZpZXdQb3NpdGlvbi56ICkgKTtcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG4jZWxzZVxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdG5vcm1hbCA9IG5vcm1hbCAqIGZhY2VEaXJlY3Rpb247XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmVjMyB0YW5nZW50ID0gbm9ybWFsaXplKCB2VGFuZ2VudCApO1xcblxcdFxcdHZlYzMgYml0YW5nZW50ID0gbm9ybWFsaXplKCB2Qml0YW5nZW50ICk7XFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdFxcdHRhbmdlbnQgPSB0YW5nZW50ICogZmFjZURpcmVjdGlvbjtcXG5cXHRcXHRcXHRiaXRhbmdlbnQgPSBiaXRhbmdlbnQgKiBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdCNpZiBkZWZpbmVkKCBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVAgKVxcblxcdFxcdFxcdG1hdDMgdlRCTiA9IG1hdDMoIHRhbmdlbnQsIGJpdGFuZ2VudCwgbm9ybWFsICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxudmVjMyBnZW9tZXRyeU5vcm1hbCA9IG5vcm1hbDtcIjtcbnZhciBub3JtYWxfZnJhZ21lbnRfbWFwcyA9IFwiI2lmZGVmIE9CSkVDVFNQQUNFX05PUk1BTE1BUFxcblxcdG5vcm1hbCA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0I2lmZGVmIEZMSVBfU0lERURcXG5cXHRcXHRub3JtYWwgPSAtIG5vcm1hbDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0bm9ybWFsID0gbm9ybWFsICogZmFjZURpcmVjdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHRub3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1xcbiNlbGlmIGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxcblxcdHZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0bWFwTi54eSAqPSBub3JtYWxTY2FsZTtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHRub3JtYWwgPSBub3JtYWxpemUoIHZUQk4gKiBtYXBOICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsIG1hcE4sIGZhY2VEaXJlY3Rpb24gKTtcXG5cXHQjZW5kaWZcXG4jZWxpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxuXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLSB2Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpLCBmYWNlRGlyZWN0aW9uICk7XFxuI2VuZGlmXCI7XG52YXIgbm9ybWFsX3BhcnNfZnJhZ21lbnQgPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXHQjaWZkZWYgVVNFX1RBTkdFTlRcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG52YXIgbm9ybWFsX3BhcnNfdmVydGV4ID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcblxcdFxcdHZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xudmFyIG5vcm1hbF92ZXJ0ZXggPSBcIiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcdCNpZmRlZiBVU0VfVEFOR0VOVFxcblxcdFxcdHZUYW5nZW50ID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZFRhbmdlbnQgKTtcXG5cXHRcXHR2Qml0YW5nZW50ID0gbm9ybWFsaXplKCBjcm9zcyggdk5vcm1hbCwgdlRhbmdlbnQgKSAqIHRhbmdlbnQudyApO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xudmFyIG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG5cXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuI2VuZGlmXFxuI2lmZGVmIE9CSkVDVFNQQUNFX05PUk1BTE1BUFxcblxcdHVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7XFxuI2VuZGlmXFxuI2lmICEgZGVmaW5lZCAoIFVTRV9UQU5HRU5UICkgJiYgKCBkZWZpbmVkICggVEFOR0VOVFNQQUNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQgKCBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCApIClcXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMzIG1hcE4sIGZsb2F0IGZhY2VEaXJlY3Rpb24gKSB7XFxuXFx0XFx0dmVjMyBxMCA9IHZlYzMoIGRGZHgoIGV5ZV9wb3MueCApLCBkRmR4KCBleWVfcG9zLnkgKSwgZEZkeCggZXllX3Bvcy56ICkgKTtcXG5cXHRcXHR2ZWMzIHExID0gdmVjMyggZEZkeSggZXllX3Bvcy54ICksIGRGZHkoIGV5ZV9wb3MueSApLCBkRmR5KCBleWVfcG9zLnogKSApO1xcblxcdFxcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXFx0XFx0dmVjMiBzdDEgPSBkRmR5KCB2VXYuc3QgKTtcXG5cXHRcXHR2ZWMzIE4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBxMXBlcnAgPSBjcm9zcyggcTEsIE4gKTtcXG5cXHRcXHR2ZWMzIHEwcGVycCA9IGNyb3NzKCBOLCBxMCApO1xcblxcdFxcdHZlYzMgVCA9IHExcGVycCAqIHN0MC54ICsgcTBwZXJwICogc3QxLng7XFxuXFx0XFx0dmVjMyBCID0gcTFwZXJwICogc3QwLnkgKyBxMHBlcnAgKiBzdDEueTtcXG5cXHRcXHRmbG9hdCBkZXQgPSBtYXgoIGRvdCggVCwgVCApLCBkb3QoIEIsIEIgKSApO1xcblxcdFxcdGZsb2F0IHNjYWxlID0gKCBkZXQgPT0gMC4wICkgPyAwLjAgOiBmYWNlRGlyZWN0aW9uICogaW52ZXJzZXNxcnQoIGRldCApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIFQgKiAoIG1hcE4ueCAqIHNjYWxlICkgKyBCICogKCBtYXBOLnkgKiBzY2FsZSApICsgTiAqIG1hcE4ueiApO1xcblxcdH1cXG4jZW5kaWZcIjtcbnZhciBjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X2JlZ2luID0gXCIjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdHZlYzMgY2xlYXJjb2F0Tm9ybWFsID0gZ2VvbWV0cnlOb3JtYWw7XFxuI2VuZGlmXCI7XG52YXIgY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzID0gXCIjaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR2ZWMzIGNsZWFyY29hdE1hcE4gPSB0ZXh0dXJlMkQoIGNsZWFyY29hdE5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdGNsZWFyY29hdE1hcE4ueHkgKj0gY2xlYXJjb2F0Tm9ybWFsU2NhbGU7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0Y2xlYXJjb2F0Tm9ybWFsID0gbm9ybWFsaXplKCB2VEJOICogY2xlYXJjb2F0TWFwTiApO1xcblxcdCNlbHNlXFxuXFx0XFx0Y2xlYXJjb2F0Tm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC0gdlZpZXdQb3NpdGlvbiwgY2xlYXJjb2F0Tm9ybWFsLCBjbGVhcmNvYXRNYXBOLCBmYWNlRGlyZWN0aW9uICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXCI7XG52YXIgY2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQ0xFQVJDT0FUTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJjb2F0TWFwO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyY29hdFJvdWdobmVzc01hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0NMRUFSQ09BVF9OT1JNQUxNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBjbGVhcmNvYXROb3JtYWxNYXA7XFxuXFx0dW5pZm9ybSB2ZWMyIGNsZWFyY29hdE5vcm1hbFNjYWxlO1xcbiNlbmRpZlwiO1xudmFyIGlyaWRlc2NlbmNlX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfSVJJREVTQ0VOQ0VNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBpcmlkZXNjZW5jZU1hcDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFX1RISUNLTkVTU01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xcbiNlbmRpZlwiO1xudmFyIG91dHB1dF9mcmFnbWVudCA9IFwiI2lmZGVmIE9QQVFVRVxcbmRpZmZ1c2VDb2xvci5hID0gMS4wO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuZGlmZnVzZUNvbG9yLmEgKj0gdHJhbnNtaXNzaW9uQWxwaGEgKyAwLjE7XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIjtcbnZhciBwYWNraW5nID0gXCJ2ZWMzIHBhY2tOb3JtYWxUb1JHQiggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggbm9ybWFsICkgKiAwLjUgKyAwLjU7XFxufVxcbnZlYzMgdW5wYWNrUkdCVG9Ob3JtYWwoIGNvbnN0IGluIHZlYzMgcmdiICkge1xcblxcdHJldHVybiAyLjAgKiByZ2IueHl6IC0gMS4wO1xcbn1cXG5jb25zdCBmbG9hdCBQYWNrVXBzY2FsZSA9IDI1Ni4gLyAyNTUuO2NvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuO1xcbmNvbnN0IHZlYzMgUGFja0ZhY3RvcnMgPSB2ZWMzKCAyNTYuICogMjU2LiAqIDI1Ni4sIDI1Ni4gKiAyNTYuLCAyNTYuICk7XFxuY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzID0gVW5wYWNrRG93bnNjYWxlIC8gdmVjNCggUGFja0ZhY3RvcnMsIDEuICk7XFxuY29uc3QgZmxvYXQgU2hpZnRSaWdodDggPSAxLiAvIDI1Ni47XFxudmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7XFxuXFx0dmVjNCByID0gdmVjNCggZnJhY3QoIHYgKiBQYWNrRmFjdG9ycyApLCB2ICk7XFxuXFx0ci55encgLT0gci54eXogKiBTaGlmdFJpZ2h0ODtcXHRyZXR1cm4gciAqIFBhY2tVcHNjYWxlO1xcbn1cXG5mbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkge1xcblxcdHJldHVybiBkb3QoIHYsIFVucGFja0ZhY3RvcnMgKTtcXG59XFxudmVjNCBwYWNrMkhhbGZUb1JHQkEoIHZlYzIgdiApIHtcXG5cXHR2ZWM0IHIgPSB2ZWM0KCB2LngsIGZyYWN0KCB2LnggKiAyNTUuMCApLCB2LnksIGZyYWN0KCB2LnkgKiAyNTUuMCApICk7XFxuXFx0cmV0dXJuIHZlYzQoIHIueCAtIHIueSAvIDI1NS4wLCByLnksIHIueiAtIHIudyAvIDI1NS4wLCByLncgKTtcXG59XFxudmVjMiB1bnBhY2tSR0JBVG8ySGFsZiggdmVjNCB2ICkge1xcblxcdHJldHVybiB2ZWMyKCB2LnggKyAoIHYueSAvIDI1NS4wICksIHYueiArICggdi53IC8gMjU1LjAgKSApO1xcbn1cXG5mbG9hdCB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuICggdmlld1ogKyBuZWFyICkgLyAoIG5lYXIgLSBmYXIgKTtcXG59XFxuZmxvYXQgb3J0aG9ncmFwaGljRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBsaW5lYXJDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiBsaW5lYXJDbGlwWiAqICggbmVhciAtIGZhciApIC0gbmVhcjtcXG59XFxuZmxvYXQgdmlld1pUb1BlcnNwZWN0aXZlRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuXFx0cmV0dXJuICggKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIHZpZXdaICk7XFxufVxcbmZsb2F0IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBpbnZDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcblxcdHJldHVybiAoIG5lYXIgKiBmYXIgKSAvICggKCBmYXIgLSBuZWFyICkgKiBpbnZDbGlwWiAtIGZhciApO1xcbn1cIjtcbnZhciBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50ID0gXCIjaWZkZWYgUFJFTVVMVElQTElFRF9BTFBIQVxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgKj0gZ2xfRnJhZ0NvbG9yLmE7XFxuI2VuZGlmXCI7XG52YXIgcHJvamVjdF92ZXJ0ZXggPSBcInZlYzQgbXZQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG4jaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXHRtdlBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiBtdlBvc2l0aW9uO1xcbiNlbmRpZlxcbm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBtdlBvc2l0aW9uO1xcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCI7XG52YXIgZGl0aGVyaW5nX2ZyYWdtZW50ID0gXCIjaWZkZWYgRElUSEVSSU5HXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IGRpdGhlcmluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcbiNlbmRpZlwiO1xudmFyIGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgRElUSEVSSU5HXFxuXFx0dmVjMyBkaXRoZXJpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0XFx0ZmxvYXQgZ3JpZF9wb3NpdGlvbiA9IHJhbmQoIGdsX0ZyYWdDb29yZC54eSApO1xcblxcdFxcdHZlYzMgZGl0aGVyX3NoaWZ0X1JHQiA9IHZlYzMoIDAuMjUgLyAyNTUuMCwgLTAuMjUgLyAyNTUuMCwgMC4yNSAvIDI1NS4wICk7XFxuXFx0XFx0ZGl0aGVyX3NoaWZ0X1JHQiA9IG1peCggMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgLTIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIGdyaWRfcG9zaXRpb24gKTtcXG5cXHRcXHRyZXR1cm4gY29sb3IgKyBkaXRoZXJfc2hpZnRfUkdCO1xcblxcdH1cXG4jZW5kaWZcIjtcbnZhciByb3VnaG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XFxuI2VuZGlmXCI7XG52YXIgcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwO1xcbiNlbmRpZlwiO1xudmFyIHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90U2hhZG93TWFwWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHRzdHJ1Y3QgU3BvdExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gU3BvdExpZ2h0U2hhZG93IHNwb3RMaWdodFNoYWRvd3NbIE5VTV9TUE9UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHN0cnVjdCBQb2ludExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dDYW1lcmFOZWFyO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYUZhcjtcXG5cXHRcXHR9O1xcblxcdFxcdHVuaWZvcm0gUG9pbnRMaWdodFNoYWRvdyBwb2ludExpZ2h0U2hhZG93c1sgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHRmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcblxcdFxcdHJldHVybiBzdGVwKCBjb21wYXJlLCB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBkZXB0aHMsIHV2ICkgKSApO1xcblxcdH1cXG5cXHR2ZWMyIHRleHR1cmUyRERpc3RyaWJ1dGlvbiggc2FtcGxlcjJEIHNoYWRvdywgdmVjMiB1diApIHtcXG5cXHRcXHRyZXR1cm4gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93LCB1diApICk7XFxuXFx0fVxcblxcdGZsb2F0IFZTTVNoYWRvdyAoc2FtcGxlcjJEIHNoYWRvdywgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApe1xcblxcdFxcdGZsb2F0IG9jY2x1c2lvbiA9IDEuMDtcXG5cXHRcXHR2ZWMyIGRpc3RyaWJ1dGlvbiA9IHRleHR1cmUyRERpc3RyaWJ1dGlvbiggc2hhZG93LCB1diApO1xcblxcdFxcdGZsb2F0IGhhcmRfc2hhZG93ID0gc3RlcCggY29tcGFyZSAsIGRpc3RyaWJ1dGlvbi54ICk7XFxuXFx0XFx0aWYgKGhhcmRfc2hhZG93ICE9IDEuMCApIHtcXG5cXHRcXHRcXHRmbG9hdCBkaXN0YW5jZSA9IGNvbXBhcmUgLSBkaXN0cmlidXRpb24ueCA7XFxuXFx0XFx0XFx0ZmxvYXQgdmFyaWFuY2UgPSBtYXgoIDAuMDAwMDAsIGRpc3RyaWJ1dGlvbi55ICogZGlzdHJpYnV0aW9uLnkgKTtcXG5cXHRcXHRcXHRmbG9hdCBzb2Z0bmVzc19wcm9iYWJpbGl0eSA9IHZhcmlhbmNlIC8gKHZhcmlhbmNlICsgZGlzdGFuY2UgKiBkaXN0YW5jZSApO1xcdFxcdFxcdHNvZnRuZXNzX3Byb2JhYmlsaXR5ID0gY2xhbXAoICggc29mdG5lc3NfcHJvYmFiaWxpdHkgLSAwLjMgKSAvICggMC45NSAtIDAuMyApLCAwLjAsIDEuMCApO1xcdFxcdFxcdG9jY2x1c2lvbiA9IGNsYW1wKCBtYXgoIGhhcmRfc2hhZG93LCBzb2Z0bmVzc19wcm9iYWJpbGl0eSApLCAwLjAsIDEuMCApO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gb2NjbHVzaW9uO1xcblxcdH1cXG5cXHRmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblxcdFxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHRcXHRzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudztcXG5cXHRcXHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXM7XFxuXFx0XFx0YnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcblxcdFxcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXG5cXHRcXHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFx0XFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcXG5cXHRcXHRpZiAoIGZydXN0dW1UZXN0ICkge1xcblxcdFxcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4MCA9IC0gdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkwID0gLSB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MSA9ICsgdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHgyID0gZHgwIC8gMi4wO1xcblxcdFxcdFxcdGZsb2F0IGR5MiA9IGR5MCAvIDIuMDtcXG5cXHRcXHRcXHRmbG9hdCBkeDMgPSBkeDEgLyAyLjA7XFxuXFx0XFx0XFx0ZmxvYXQgZHkzID0gZHkxIC8gMi4wO1xcblxcdFxcdFxcdHNoYWRvdyA9IChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgzLCBkeTIgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgyLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDIsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDMsIGR5MyApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyAxNy4wICk7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IGR4ID0gdGV4ZWxTaXplLng7XFxuXFx0XFx0XFx0ZmxvYXQgZHkgPSB0ZXhlbFNpemUueTtcXG5cXHRcXHRcXHR2ZWMyIHV2ID0gc2hhZG93Q29vcmQueHk7XFxuXFx0XFx0XFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2hhZG93TWFwU2l6ZSArIDAuNSApO1xcblxcdFxcdFxcdHV2IC09IGYgKiB0ZXhlbFNpemU7XFxuXFx0XFx0XFx0c2hhZG93ID0gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYsIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMC4wLCBkeSApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB0ZXhlbFNpemUsIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLCBcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAwLjAgKSwgc2hhZG93Q29vcmQueiApLFxcblxcdFxcdFxcdFxcdFxcdCBmLnggKSArXFxuXFx0XFx0XFx0XFx0bWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCBkeSApLCBzaGFkb3dDb29yZC56ICksIFxcblxcdFxcdFxcdFxcdFxcdCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi54ICkgK1xcblxcdFxcdFxcdFxcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDAuMCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXFxuXFx0XFx0XFx0XFx0XFx0IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgdXYgKyB2ZWMyKCAwLjAsIDIuMCAqIGR5ICksIHNoYWRvd0Nvb3JkLnogKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55ICkgK1xcblxcdFxcdFxcdFxcdG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAtZHkgKSwgc2hhZG93Q29vcmQueiApLCBcXG5cXHRcXHRcXHRcXHRcXHQgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0IGYueSApICtcXG5cXHRcXHRcXHRcXHRtaXgoIG1peCggdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIC1keCwgLWR5ICksIHNoYWRvd0Nvb3JkLnogKSwgXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggMi4wICogZHgsIC1keSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICBmLnggKSxcXG5cXHRcXHRcXHRcXHRcXHQgbWl4KCB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHV2ICsgdmVjMiggLWR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksIFxcblxcdFxcdFxcdFxcdFxcdFxcdCAgdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCB1diArIHZlYzIoIDIuMCAqIGR4LCAyLjAgKiBkeSApLCBzaGFkb3dDb29yZC56ICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICBmLnggKSxcXG5cXHRcXHRcXHRcXHRcXHQgZi55IClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9WU00gKVxcblxcdFxcdFxcdHNoYWRvdyA9IFZTTVNoYWRvdyggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0c2hhZG93ID0gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gc2hhZG93O1xcblxcdH1cXG5cXHR2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7XFxuXFx0XFx0dmVjMyBhYnNWID0gYWJzKCB2ICk7XFxuXFx0XFx0ZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7XFxuXFx0XFx0YWJzViAqPSBzY2FsZVRvQ3ViZTtcXG5cXHRcXHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxuXFx0XFx0dmVjMiBwbGFuYXIgPSB2Lnh5O1xcblxcdFxcdGZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcblxcdFxcdGlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRpZiAoIHYueiA+IDAuMCApXFxuXFx0XFx0XFx0XFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxuXFx0XFx0fSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xcblxcdFxcdFxcdHBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDtcXG5cXHRcXHRcXHRwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7XFxuXFx0fVxcblxcdGZsb2F0IGdldFBvaW50U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCwgZmxvYXQgc2hhZG93Q2FtZXJhTmVhciwgZmxvYXQgc2hhZG93Q2FtZXJhRmFyICkge1xcblxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyAoIHNoYWRvd01hcFNpemUgKiB2ZWMyKCA0LjAsIDIuMCApICk7XFxuXFx0XFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XFxuXFx0XFx0ZmxvYXQgZHAgPSAoIGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICkgLSBzaGFkb3dDYW1lcmFOZWFyICkgLyAoIHNoYWRvd0NhbWVyYUZhciAtIHNoYWRvd0NhbWVyYU5lYXIgKTtcXHRcXHRkcCArPSBzaGFkb3dCaWFzO1xcblxcdFxcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfVlNNIClcXG5cXHRcXHRcXHR2ZWMyIG9mZnNldCA9IHZlYzIoIC0gMSwgMSApICogc2hhZG93UmFkaXVzICogdGV4ZWxTaXplLnk7XFxuXFx0XFx0XFx0cmV0dXJuIChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwIClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcIjtcbnZhciBzaGFkb3dtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgc3BvdFNoYWRvd01hdHJpeFsgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFNwb3RMaWdodFNoYWRvdyB7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93QmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0fTtcXG5cXHRcXHR1bmlmb3JtIFNwb3RMaWdodFNoYWRvdyBzcG90TGlnaHRTaGFkb3dzWyBOVU1fU1BPVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBwb2ludFNoYWRvd01hdHJpeFsgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTIF07XFxuXFx0XFx0c3RydWN0IFBvaW50TGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Q2FtZXJhRmFyO1xcblxcdFxcdH07XFxuXFx0XFx0dW5pZm9ybSBQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHRTaGFkb3dzWyBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xudmFyIHNoYWRvd21hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDAgfHwgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDAgfHwgTlVNX1BPSU5UX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0XFx0dmVjMyBzaGFkb3dXb3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0dmVjNCBzaGFkb3dXb3JsZFBvc2l0aW9uO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7XFxuXFx0XFx0dkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fU1BPVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHNoYWRvd1dvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uICsgdmVjNCggc2hhZG93V29ybGROb3JtYWwgKiBzcG90TGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93Tm9ybWFsQmlhcywgMCApO1xcblxcdFxcdHZTcG90U2hhZG93Q29vcmRbIGkgXSA9IHNwb3RTaGFkb3dNYXRyaXhbIGkgXSAqIHNoYWRvd1dvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTID4gMFxcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUzsgaSArKyApIHtcXG5cXHRcXHRzaGFkb3dXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbiArIHZlYzQoIHNoYWRvd1dvcmxkTm9ybWFsICogcG9pbnRMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzLCAwICk7XFxuXFx0XFx0dlBvaW50U2hhZG93Q29vcmRbIGkgXSA9IHBvaW50U2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvc2l0aW9uO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xudmFyIHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCA9IFwiZmxvYXQgZ2V0U2hhZG93TWFzaygpIHtcXG5cXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxuXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cgZGlyZWN0aW9uYWxMaWdodDtcXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHR9XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1NQT1RfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRTcG90TGlnaHRTaGFkb3cgc3BvdExpZ2h0O1xcblxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodFNoYWRvd3NbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gcmVjZWl2ZVNoYWRvdyA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRQb2ludExpZ2h0U2hhZG93IHBvaW50TGlnaHQ7XFxuXFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0U2hhZG93c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSByZWNlaXZlU2hhZG93ID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcblxcdH1cXG5cXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcdCNlbmRpZlxcblxcdCNlbmRpZlxcblxcdHJldHVybiBzaGFkb3c7XFxufVwiO1xudmFyIHNraW5iYXNlX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcbiNlbmRpZlwiO1xudmFyIHNraW5uaW5nX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXg7XFxuXFx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xcblxcdHVuaWZvcm0gaGlnaHAgc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcblxcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlU2l6ZTtcXG5cXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFx0XFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXFx0XFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XFxuXFx0XFx0ZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XFxuXFx0XFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XFxuXFx0XFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XFxuXFx0XFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFx0XFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcblxcdFxcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG5cXHRcXHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuXFx0XFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcdFxcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0fVxcbiNlbmRpZlwiO1xudmFyIHNraW5uaW5nX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXFx0dHJhbnNmb3JtZWQgPSAoIGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZCApLnh5ejtcXG4jZW5kaWZcIjtcbnZhciBza2lubm9ybWFsX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxuXFx0c2tpbk1hdHJpeCA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7XFxuXFx0b2JqZWN0Tm9ybWFsID0gdmVjNCggc2tpbk1hdHJpeCAqIHZlYzQoIG9iamVjdE5vcm1hbCwgMC4wICkgKS54eXo7XFxuXFx0I2lmZGVmIFVTRV9UQU5HRU5UXFxuXFx0XFx0b2JqZWN0VGFuZ2VudCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3RUYW5nZW50LCAwLjAgKSApLnh5ejtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcIjtcbnZhciBzcGVjdWxhcm1hcF9mcmFnbWVudCA9IFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG4jZWxzZVxcblxcdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuI2VuZGlmXCI7XG52YXIgc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcbiNlbmRpZlwiO1xudmFyIHRvbmVtYXBwaW5nX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcXG5cXHRnbF9GcmFnQ29sb3IucmdiID0gdG9uZU1hcHBpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcXG4jZW5kaWZcIjtcbnZhciB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50ID0gXCIjaWZuZGVmIHNhdHVyYXRlXFxuI2RlZmluZSBzYXR1cmF0ZSggYSApIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2VuZGlmXFxudW5pZm9ybSBmbG9hdCB0b25lTWFwcGluZ0V4cG9zdXJlO1xcbnZlYzMgTGluZWFyVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0cmV0dXJuIHRvbmVNYXBwaW5nRXhwb3N1cmUgKiBjb2xvcjtcXG59XFxudmVjMyBSZWluaGFyZFRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuXFx0cmV0dXJuIHNhdHVyYXRlKCBjb2xvciAvICggdmVjMyggMS4wICkgKyBjb2xvciApICk7XFxufVxcbnZlYzMgT3B0aW1pemVkQ2luZW9uVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxuXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG5cXHRjb2xvciA9IG1heCggdmVjMyggMC4wICksIGNvbG9yIC0gMC4wMDQgKTtcXG5cXHRyZXR1cm4gcG93KCAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDAuNSApICkgLyAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDEuNyApICsgMC4wNiApLCB2ZWMzKCAyLjIgKSApO1xcbn1cXG52ZWMzIFJSVEFuZE9EVEZpdCggdmVjMyB2ICkge1xcblxcdHZlYzMgYSA9IHYgKiAoIHYgKyAwLjAyNDU3ODYgKSAtIDAuMDAwMDkwNTM3O1xcblxcdHZlYzMgYiA9IHYgKiAoIDAuOTgzNzI5ICogdiArIDAuNDMyOTUxMCApICsgMC4yMzgwODE7XFxuXFx0cmV0dXJuIGEgLyBiO1xcbn1cXG52ZWMzIEFDRVNGaWxtaWNUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG5cXHRjb25zdCBtYXQzIEFDRVNJbnB1dE1hdCA9IG1hdDMoXFxuXFx0XFx0dmVjMyggMC41OTcxOSwgMC4wNzYwMCwgMC4wMjg0MCApLFxcdFxcdHZlYzMoIDAuMzU0NTgsIDAuOTA4MzQsIDAuMTMzODMgKSxcXG5cXHRcXHR2ZWMzKCAwLjA0ODIzLCAwLjAxNTY2LCAwLjgzNzc3IClcXG5cXHQpO1xcblxcdGNvbnN0IG1hdDMgQUNFU091dHB1dE1hdCA9IG1hdDMoXFxuXFx0XFx0dmVjMyggIDEuNjA0NzUsIC0wLjEwMjA4LCAtMC4wMDMyNyApLFxcdFxcdHZlYzMoIC0wLjUzMTA4LCAgMS4xMDgxMywgLTAuMDcyNzYgKSxcXG5cXHRcXHR2ZWMzKCAtMC4wNzM2NywgLTAuMDA2MDUsICAxLjA3NjAyIClcXG5cXHQpO1xcblxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmUgLyAwLjY7XFxuXFx0Y29sb3IgPSBBQ0VTSW5wdXRNYXQgKiBjb2xvcjtcXG5cXHRjb2xvciA9IFJSVEFuZE9EVEZpdCggY29sb3IgKTtcXG5cXHRjb2xvciA9IEFDRVNPdXRwdXRNYXQgKiBjb2xvcjtcXG5cXHRyZXR1cm4gc2F0dXJhdGUoIGNvbG9yICk7XFxufVxcbnZlYzMgQ3VzdG9tVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7IHJldHVybiBjb2xvcjsgfVwiO1xudmFyIHRyYW5zbWlzc2lvbl9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHRmbG9hdCB0cmFuc21pc3Npb25BbHBoYSA9IDEuMDtcXG5cXHRmbG9hdCB0cmFuc21pc3Npb25GYWN0b3IgPSB0cmFuc21pc3Npb247XFxuXFx0ZmxvYXQgdGhpY2tuZXNzRmFjdG9yID0gdGhpY2tuZXNzO1xcblxcdCNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OTUFQXFxuXFx0XFx0dHJhbnNtaXNzaW9uRmFjdG9yICo9IHRleHR1cmUyRCggdHJhbnNtaXNzaW9uTWFwLCB2VXYgKS5yO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfVEhJQ0tORVNTTUFQXFxuXFx0XFx0dGhpY2tuZXNzRmFjdG9yICo9IHRleHR1cmUyRCggdGhpY2tuZXNzTWFwLCB2VXYgKS5nO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgcG9zID0gdldvcmxkUG9zaXRpb247XFxuXFx0dmVjMyB2ID0gbm9ybWFsaXplKCBjYW1lcmFQb3NpdGlvbiAtIHBvcyApO1xcblxcdHZlYzMgbiA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcdHZlYzQgdHJhbnNtaXNzaW9uID0gZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbihcXG5cXHRcXHRuLCB2LCByb3VnaG5lc3NGYWN0b3IsIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJGOTAsXFxuXFx0XFx0cG9zLCBtb2RlbE1hdHJpeCwgdmlld01hdHJpeCwgcHJvamVjdGlvbk1hdHJpeCwgaW9yLCB0aGlja25lc3NGYWN0b3IsXFxuXFx0XFx0YXR0ZW51YXRpb25Db2xvciwgYXR0ZW51YXRpb25EaXN0YW5jZSApO1xcblxcdHRvdGFsRGlmZnVzZSA9IG1peCggdG90YWxEaWZmdXNlLCB0cmFuc21pc3Npb24ucmdiLCB0cmFuc21pc3Npb25GYWN0b3IgKTtcXG5cXHR0cmFuc21pc3Npb25BbHBoYSA9IG1peCggdHJhbnNtaXNzaW9uQWxwaGEsIHRyYW5zbWlzc2lvbi5hLCB0cmFuc21pc3Npb25GYWN0b3IgKTtcXG4jZW5kaWZcIjtcbnZhciB0cmFuc21pc3Npb25fcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9UUkFOU01JU1NJT05cXG5cXHR1bmlmb3JtIGZsb2F0IHRyYW5zbWlzc2lvbjtcXG5cXHR1bmlmb3JtIGZsb2F0IHRoaWNrbmVzcztcXG5cXHR1bmlmb3JtIGZsb2F0IGF0dGVudWF0aW9uRGlzdGFuY2U7XFxuXFx0dW5pZm9ybSB2ZWMzIGF0dGVudWF0aW9uQ29sb3I7XFxuXFx0I2lmZGVmIFVTRV9UUkFOU01JU1NJT05NQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCB0cmFuc21pc3Npb25NYXA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9USElDS05FU1NNQVBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCB0aGlja25lc3NNYXA7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSB2ZWMyIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplO1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHRyYW5zbWlzc2lvblNhbXBsZXJNYXA7XFxuXFx0dW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcblxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG5cXHR2ZWMzIGdldFZvbHVtZVRyYW5zbWlzc2lvblJheSggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHRoaWNrbmVzcywgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBtYXQ0IG1vZGVsTWF0cml4ICkge1xcblxcdFxcdHZlYzMgcmVmcmFjdGlvblZlY3RvciA9IHJlZnJhY3QoIC0gdiwgbm9ybWFsaXplKCBuICksIDEuMCAvIGlvciApO1xcblxcdFxcdHZlYzMgbW9kZWxTY2FsZTtcXG5cXHRcXHRtb2RlbFNjYWxlLnggPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAwIF0ueHl6ICkgKTtcXG5cXHRcXHRtb2RlbFNjYWxlLnkgPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAxIF0ueHl6ICkgKTtcXG5cXHRcXHRtb2RlbFNjYWxlLnogPSBsZW5ndGgoIHZlYzMoIG1vZGVsTWF0cml4WyAyIF0ueHl6ICkgKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCByZWZyYWN0aW9uVmVjdG9yICkgKiB0aGlja25lc3MgKiBtb2RlbFNjYWxlO1xcblxcdH1cXG5cXHRmbG9hdCBhcHBseUlvclRvUm91Z2huZXNzKCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcXG5cXHRcXHRyZXR1cm4gcm91Z2huZXNzICogY2xhbXAoIGlvciAqIDIuMCAtIDIuMCwgMC4wLCAxLjAgKTtcXG5cXHR9XFxuXFx0dmVjNCBnZXRUcmFuc21pc3Npb25TYW1wbGUoIGNvbnN0IGluIHZlYzIgZnJhZ0Nvb3JkLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGlvciApIHtcXG5cXHRcXHRmbG9hdCBmcmFtZWJ1ZmZlckxvZCA9IGxvZzIoIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplLnggKSAqIGFwcGx5SW9yVG9Sb3VnaG5lc3MoIHJvdWdobmVzcywgaW9yICk7XFxuXFx0XFx0I2lmZGVmIHRleHR1cmUyRExvZEVYVFxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRMb2RFWFQoIHRyYW5zbWlzc2lvblNhbXBsZXJNYXAsIGZyYWdDb29yZC54eSwgZnJhbWVidWZmZXJMb2QgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkQoIHRyYW5zbWlzc2lvblNhbXBsZXJNYXAsIGZyYWdDb29yZC54eSwgZnJhbWVidWZmZXJMb2QgKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHR9XFxuXFx0dmVjMyBhcHBseVZvbHVtZUF0dGVudWF0aW9uKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiBmbG9hdCB0cmFuc21pc3Npb25EaXN0YW5jZSwgY29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkge1xcblxcdFxcdGlmICggYXR0ZW51YXRpb25EaXN0YW5jZSA9PSAwLjAgKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHJhZGlhbmNlO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dmVjMyBhdHRlbnVhdGlvbkNvZWZmaWNpZW50ID0gLWxvZyggYXR0ZW51YXRpb25Db2xvciApIC8gYXR0ZW51YXRpb25EaXN0YW5jZTtcXG5cXHRcXHRcXHR2ZWMzIHRyYW5zbWl0dGFuY2UgPSBleHAoIC0gYXR0ZW51YXRpb25Db2VmZmljaWVudCAqIHRyYW5zbWlzc2lvbkRpc3RhbmNlICk7XFx0XFx0XFx0cmV0dXJuIHRyYW5zbWl0dGFuY2UgKiByYWRpYW5jZTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcdHZlYzQgZ2V0SUJMVm9sdW1lUmVmcmFjdGlvbiggY29uc3QgaW4gdmVjMyBuLCBjb25zdCBpbiB2ZWMzIHYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IsXFxuXFx0XFx0Y29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBzcGVjdWxhckY5MCwgY29uc3QgaW4gdmVjMyBwb3NpdGlvbiwgY29uc3QgaW4gbWF0NCBtb2RlbE1hdHJpeCxcXG5cXHRcXHRjb25zdCBpbiBtYXQ0IHZpZXdNYXRyaXgsIGNvbnN0IGluIG1hdDQgcHJvak1hdHJpeCwgY29uc3QgaW4gZmxvYXQgaW9yLCBjb25zdCBpbiBmbG9hdCB0aGlja25lc3MsXFxuXFx0XFx0Y29uc3QgaW4gdmVjMyBhdHRlbnVhdGlvbkNvbG9yLCBjb25zdCBpbiBmbG9hdCBhdHRlbnVhdGlvbkRpc3RhbmNlICkge1xcblxcdFxcdHZlYzMgdHJhbnNtaXNzaW9uUmF5ID0gZ2V0Vm9sdW1lVHJhbnNtaXNzaW9uUmF5KCBuLCB2LCB0aGlja25lc3MsIGlvciwgbW9kZWxNYXRyaXggKTtcXG5cXHRcXHR2ZWMzIHJlZnJhY3RlZFJheUV4aXQgPSBwb3NpdGlvbiArIHRyYW5zbWlzc2lvblJheTtcXG5cXHRcXHR2ZWM0IG5kY1BvcyA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogdmVjNCggcmVmcmFjdGVkUmF5RXhpdCwgMS4wICk7XFxuXFx0XFx0dmVjMiByZWZyYWN0aW9uQ29vcmRzID0gbmRjUG9zLnh5IC8gbmRjUG9zLnc7XFxuXFx0XFx0cmVmcmFjdGlvbkNvb3JkcyArPSAxLjA7XFxuXFx0XFx0cmVmcmFjdGlvbkNvb3JkcyAvPSAyLjA7XFxuXFx0XFx0dmVjNCB0cmFuc21pdHRlZExpZ2h0ID0gZ2V0VHJhbnNtaXNzaW9uU2FtcGxlKCByZWZyYWN0aW9uQ29vcmRzLCByb3VnaG5lc3MsIGlvciApO1xcblxcdFxcdHZlYzMgYXR0ZW51YXRlZENvbG9yID0gYXBwbHlWb2x1bWVBdHRlbnVhdGlvbiggdHJhbnNtaXR0ZWRMaWdodC5yZ2IsIGxlbmd0aCggdHJhbnNtaXNzaW9uUmF5ICksIGF0dGVudWF0aW9uQ29sb3IsIGF0dGVudWF0aW9uRGlzdGFuY2UgKTtcXG5cXHRcXHR2ZWMzIEYgPSBFbnZpcm9ubWVudEJSREYoIG4sIHYsIHNwZWN1bGFyQ29sb3IsIHNwZWN1bGFyRjkwLCByb3VnaG5lc3MgKTtcXG5cXHRcXHRyZXR1cm4gdmVjNCggKCAxLjAgLSBGICkgKiBhdHRlbnVhdGVkQ29sb3IgKiBkaWZmdXNlQ29sb3IsIHRyYW5zbWl0dGVkTGlnaHQuYSApO1xcblxcdH1cXG4jZW5kaWZcIjtcbnZhciB1dl9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgKCBkZWZpbmVkKCBVU0VfVVYgKSAmJiAhIGRlZmluZWQoIFVWU19WRVJURVhfT05MWSApIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlwiO1xudmFyIHV2X3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1VWXFxuXFx0I2lmZGVmIFVWU19WRVJURVhfT05MWVxcblxcdFxcdHZlYzIgdlV2O1xcblxcdCNlbHNlXFxuXFx0XFx0dmFyeWluZyB2ZWMyIHZVdjtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxuI2VuZGlmXCI7XG52YXIgdXZfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1VWXFxuXFx0dlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTtcXG4jZW5kaWZcIjtcbnZhciB1djJfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCI7XG52YXIgdXYyX3BhcnNfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXHRhdHRyaWJ1dGUgdmVjMiB1djI7XFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFx0dW5pZm9ybSBtYXQzIHV2MlRyYW5zZm9ybTtcXG4jZW5kaWZcIjtcbnZhciB1djJfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXHR2VXYyID0gKCB1djJUcmFuc2Zvcm0gKiB2ZWMzKCB1djIsIDEgKSApLnh5O1xcbiNlbmRpZlwiO1xudmFyIHdvcmxkcG9zX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBESVNUQU5DRSApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQICkgfHwgZGVmaW5lZCAoIFVTRV9UUkFOU01JU1NJT04gKVxcblxcdHZlYzQgd29ybGRQb3NpdGlvbiA9IHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXHQjaWZkZWYgVVNFX0lOU1RBTkNJTkdcXG5cXHRcXHR3b3JsZFBvc2l0aW9uID0gaW5zdGFuY2VNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xcblxcdCNlbmRpZlxcblxcdHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHdvcmxkUG9zaXRpb247XFxuI2VuZGlmXCI7XG52YXIgdmVydGV4JGcgPSBcInZhcnlpbmcgdmVjMiB2VXY7XFxudW5pZm9ybSBtYXQzIHV2VHJhbnNmb3JtO1xcbnZvaWQgbWFpbigpIHtcXG5cXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcblxcdGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24ueHksIDEuMCwgMS4wICk7XFxufVwiO1xudmFyIGZyYWdtZW50JGcgPSBcInVuaWZvcm0gc2FtcGxlcjJEIHQyRDtcXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHQyRCwgdlV2ICk7XFxuXFx0I2lmZGVmIERFQ09ERV9WSURFT19URVhUVVJFXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggbWl4KCBwb3coIGdsX0ZyYWdDb2xvci5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgZ2xfRnJhZ0NvbG9yLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggZ2xfRnJhZ0NvbG9yLnJnYiwgdmVjMyggMC4wNDA0NSApICkgKSApLCBnbF9GcmFnQ29sb3IudyApO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50Plxcbn1cIjtcbnZhciB2ZXJ0ZXgkZiA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdGdsX1Bvc2l0aW9uLnogPSBnbF9Qb3NpdGlvbi53O1xcbn1cIjtcbnZhciBmcmFnbWVudCRmID0gXCIjaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdldvcmxkRGlyZWN0aW9uO1xcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzMgdlJlZmxlY3QgPSB2V29ybGREaXJlY3Rpb247XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSBlbnZDb2xvcjtcXG5cXHRnbF9GcmFnQ29sb3IuYSAqPSBvcGFjaXR5O1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50Plxcbn1cIjtcbnZhciB2ZXJ0ZXgkZSA9IFwiI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXO1xcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHRcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZIaWdoUHJlY2lzaW9uWlcgPSBnbF9Qb3NpdGlvbi56dztcXG59XCI7XG52YXIgZnJhZ21lbnQkZSA9IFwiI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXO1xcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7XFxuXFx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdFxcdGRpZmZ1c2VDb2xvci5hID0gb3BhY2l0eTtcXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHRmbG9hdCBmcmFnQ29vcmRaID0gMC41ICogdkhpZ2hQcmVjaXNpb25aV1swXSAvIHZIaWdoUHJlY2lzaW9uWldbMV0gKyAwLjU7XFxuXFx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCAtIGZyYWdDb29yZFogKSwgb3BhY2l0eSApO1xcblxcdCNlbGlmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMVxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZnJhZ0Nvb3JkWiApO1xcblxcdCNlbmRpZlxcbn1cIjtcbnZhciB2ZXJ0ZXgkZCA9IFwiI2RlZmluZSBESVNUQU5DRVxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxuXFx0XFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjZW5kaWZcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcbn1cIjtcbnZhciBmcmFnbWVudCRkID0gXCIjZGVmaW5lIERJU1RBTkNFXFxudW5pZm9ybSB2ZWMzIHJlZmVyZW5jZVBvc2l0aW9uO1xcbnVuaWZvcm0gZmxvYXQgbmVhckRpc3RhbmNlO1xcbnVuaWZvcm0gZmxvYXQgZmFyRGlzdGFuY2U7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluICgpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRmbG9hdCBkaXN0ID0gbGVuZ3RoKCB2V29ybGRQb3NpdGlvbiAtIHJlZmVyZW5jZVBvc2l0aW9uICk7XFxuXFx0ZGlzdCA9ICggZGlzdCAtIG5lYXJEaXN0YW5jZSApIC8gKCBmYXJEaXN0YW5jZSAtIG5lYXJEaXN0YW5jZSApO1xcblxcdGRpc3QgPSBzYXR1cmF0ZSggZGlzdCApO1xcblxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZGlzdCApO1xcbn1cIjtcbnZhciB2ZXJ0ZXgkYyA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2V29ybGREaXJlY3Rpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4Plxcbn1cIjtcbnZhciBmcmFnbWVudCRjID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxudmFyeWluZyB2ZWMzIHZXb3JsZERpcmVjdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkRGlyZWN0aW9uICk7XFxuXFx0dmVjMiBzYW1wbGVVViA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50Plxcbn1cIjtcbnZhciB2ZXJ0ZXgkYiA9IFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1xcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG52YXIgZnJhZ21lbnQkYiA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XFxudW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHRpZiAoIG1vZCggdkxpbmVEaXN0YW5jZSwgdG90YWxTaXplICkgPiBkYXNoU2l6ZSApIHtcXG5cXHRcXHRkaXNjYXJkO1xcblxcdH1cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdCNpbmNsdWRlIDxvdXRwdXRfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG59XCI7XG52YXIgdmVydGV4JGEgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpZiBkZWZpbmVkICggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQgKCBVU0VfU0tJTk5JTkcgKVxcblxcdFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0XFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHRcXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG52YXIgZnJhZ21lbnQkYSA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRcXHR2ZWM0IGxpZ2h0TWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGxpZ2h0TWFwVGV4ZWwucmdiICogbGlnaHRNYXBJbnRlbnNpdHkgKiBSRUNJUFJPQ0FMX1BJO1xcblxcdCNlbHNlXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZlYzMoIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG52YXIgdmVydGV4JDkgPSBcIiNkZWZpbmUgTEFNQkVSVFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXG52YXJ5aW5nIHZlYzMgdkluZGlyZWN0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcblxcdHZhcnlpbmcgdmVjMyB2SW5kaXJlY3RCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG52YXIgZnJhZ21lbnQkOSA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxudmFyeWluZyB2ZWMzIHZJbmRpcmVjdEZyb250O1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5cXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcXG5cXHR2YXJ5aW5nIHZlYzMgdkluZGlyZWN0QmFjaztcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnNfYmVnaW4+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcblxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSAoIGdsX0Zyb250RmFjaW5nICkgPyB2SW5kaXJlY3RGcm9udCA6IHZJbmRpcmVjdEJhY2s7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdkluZGlyZWN0RnJvbnQ7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGxpZ2h0bWFwX2ZyYWdtZW50PlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBCUkRGX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSB2TGlnaHRGcm9udDtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICo9IEJSREZfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApICogZ2V0U2hhZG93TWFzaygpO1xcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xudmFyIHZlcnRleCQ4ID0gXCIjZGVmaW5lIE1BVENBUFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBoY29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxuXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxufVwiO1xudmFyIGZyYWdtZW50JDggPSBcIiNkZWZpbmUgTUFUQ0FQXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hdGNhcDtcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHR2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXHR2ZWMzIHggPSBub3JtYWxpemUoIHZlYzMoIHZpZXdEaXIueiwgMC4wLCAtIHZpZXdEaXIueCApICk7XFxuXFx0dmVjMyB5ID0gY3Jvc3MoIHZpZXdEaXIsIHggKTtcXG5cXHR2ZWMyIHV2ID0gdmVjMiggZG90KCB4LCBub3JtYWwgKSwgZG90KCB5LCBub3JtYWwgKSApICogMC40OTUgKyAwLjU7XFxuXFx0I2lmZGVmIFVTRV9NQVRDQVBcXG5cXHRcXHR2ZWM0IG1hdGNhcENvbG9yID0gdGV4dHVyZTJEKCBtYXRjYXAsIHV2ICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWM0IG1hdGNhcENvbG9yID0gdmVjNCggdmVjMyggbWl4KCAwLjIsIDAuOCwgdXYueSApICksIDEuMCApO1xcblxcdCNlbmRpZlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2IgKiBtYXRjYXBDb2xvci5yZ2I7XFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xudmFyIHZlcnRleCQ3ID0gXCIjZGVmaW5lIE5PUk1BTFxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVEFOR0VOVFNQQUNFX05PUk1BTE1BUCApXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcbiNlbmRpZlxcbn1cIjtcbnZhciBmcmFnbWVudCQ3ID0gXCIjZGVmaW5lIE5PUk1BTFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAgKVxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9tYXBzPlxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHBhY2tOb3JtYWxUb1JHQiggbm9ybWFsICksIG9wYWNpdHkgKTtcXG5cXHQjaWZkZWYgT1BBUVVFXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yLmEgPSAxLjA7XFxuXFx0I2VuZGlmXFxufVwiO1xudmFyIHZlcnRleCQ2ID0gXCIjZGVmaW5lIFBIT05HXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcbnZhciBmcmFnbWVudCQ2ID0gXCIjZGVmaW5lIFBIT05HXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9jb21tb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8bm9ybWFsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19mcmFnbWVudF9lbmQ+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG52YXIgdmVydGV4JDUgPSBcIiNkZWZpbmUgU1RBTkRBUkRcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZkZWYgVVNFX1RSQU5TTUlTU0lPTlxcblxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcbiNpZmRlZiBVU0VfVFJBTlNNSVNTSU9OXFxuXFx0dldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcXG59XCI7XG52YXIgZnJhZ21lbnQkNSA9IFwiI2RlZmluZSBTVEFOREFSRFxcbiNpZmRlZiBQSFlTSUNBTFxcblxcdCNkZWZpbmUgSU9SXFxuXFx0I2RlZmluZSBTUEVDVUxBUlxcbiNlbmRpZlxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXG51bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcXG51bmlmb3JtIGZsb2F0IG1ldGFsbmVzcztcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2lmZGVmIElPUlxcblxcdHVuaWZvcm0gZmxvYXQgaW9yO1xcbiNlbmRpZlxcbiNpZmRlZiBTUEVDVUxBUlxcblxcdHVuaWZvcm0gZmxvYXQgc3BlY3VsYXJJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSB2ZWMzIHNwZWN1bGFyQ29sb3I7XFxuXFx0I2lmZGVmIFVTRV9TUEVDVUxBUklOVEVOU0lUWU1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFySW50ZW5zaXR5TWFwO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBVU0VfU1BFQ1VMQVJDT0xPUk1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyQ29sb3JNYXA7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9DTEVBUkNPQVRcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdDtcXG5cXHR1bmlmb3JtIGZsb2F0IGNsZWFyY29hdFJvdWdobmVzcztcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0lSSURFU0NFTkNFXFxuXFx0dW5pZm9ybSBmbG9hdCBpcmlkZXNjZW5jZTtcXG5cXHR1bmlmb3JtIGZsb2F0IGlyaWRlc2NlbmNlSU9SO1xcblxcdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtO1xcblxcdHVuaWZvcm0gZmxvYXQgaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0hFRU5cXG5cXHR1bmlmb3JtIHZlYzMgc2hlZW5Db2xvcjtcXG5cXHR1bmlmb3JtIGZsb2F0IHNoZWVuUm91Z2huZXNzO1xcblxcdCNpZmRlZiBVU0VfU0hFRU5DT0xPUk1BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuQ29sb3JNYXA7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIFVTRV9TSEVFTlJPVUdITkVTU01BUFxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuUm91Z2huZXNzTWFwO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8aXJpZGVzY2VuY2VfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xlYXJjb2F0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGlyaWRlc2NlbmNlX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXG5cXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cm91Z2huZXNzbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfYmVnaW4+XFxuXFx0I2luY2x1ZGUgPGNsZWFyY29hdF9ub3JtYWxfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyB0b3RhbERpZmZ1c2UgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgdG90YWxTcGVjdWxhciA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhcjtcXG5cXHQjaW5jbHVkZSA8dHJhbnNtaXNzaW9uX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHRvdGFsRGlmZnVzZSArIHRvdGFsU3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2lmZGVmIFVTRV9TSEVFTlxcblxcdFxcdGZsb2F0IHNoZWVuRW5lcmd5Q29tcCA9IDEuMCAtIDAuMTU3ICogbWF4MyggbWF0ZXJpYWwuc2hlZW5Db2xvciApO1xcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBvdXRnb2luZ0xpZ2h0ICogc2hlZW5FbmVyZ3lDb21wICsgc2hlZW5TcGVjdWxhcjtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgVVNFX0NMRUFSQ09BVFxcblxcdFxcdGZsb2F0IGRvdE5WY2MgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5jbGVhcmNvYXROb3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdFxcdHZlYzMgRmNjID0gRl9TY2hsaWNrKCBtYXRlcmlhbC5jbGVhcmNvYXRGMCwgbWF0ZXJpYWwuY2xlYXJjb2F0RjkwLCBkb3ROVmNjICk7XFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG91dGdvaW5nTGlnaHQgKiAoIDEuMCAtIG1hdGVyaWFsLmNsZWFyY29hdCAqIEZjYyApICsgY2xlYXJjb2F0U3BlY3VsYXIgKiBtYXRlcmlhbC5jbGVhcmNvYXQ7XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPG91dHB1dF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxkaXRoZXJpbmdfZnJhZ21lbnQ+XFxufVwiO1xudmFyIHZlcnRleCQ0ID0gXCIjZGVmaW5lIFRPT05cXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG5vcm1hbF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxmb2dfdmVydGV4Plxcbn1cIjtcbnZhciBmcmFnbWVudCQ0ID0gXCIjZGVmaW5lIFRPT05cXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhdGVzdF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzX2JlZ2luPlxcbiNpbmNsdWRlIDxub3JtYWxfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRzX3Rvb25fcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudF9iZWdpbj5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50X21hcHM+XFxuXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfdG9vbl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2JlZ2luPlxcblxcdCNpbmNsdWRlIDxsaWdodHNfZnJhZ21lbnRfbWFwcz5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX2ZyYWdtZW50X2VuZD5cXG5cXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXG59XCI7XG52YXIgdmVydGV4JDMgPSBcInVuaWZvcm0gZmxvYXQgc2l6ZTtcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdGdsX1BvaW50U2l6ZSA9IHNpemU7XFxuXFx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXG5cXHRcXHRib29sIGlzUGVyc3BlY3RpdmUgPSBpc1BlcnNwZWN0aXZlTWF0cml4KCBwcm9qZWN0aW9uTWF0cml4ICk7XFxuXFx0XFx0aWYgKCBpc1BlcnNwZWN0aXZlICkgZ2xfUG9pbnRTaXplICo9ICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXG59XCI7XG52YXIgZnJhZ21lbnQkMyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYXRlc3RfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdCNpbmNsdWRlIDxvdXRwdXRfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG59XCI7XG52YXIgdmVydGV4JDIgPSBcIiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xudmFyIGZyYWdtZW50JDIgPSBcInVuaWZvcm0gdmVjMyBjb2xvcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFyc19iZWdpbj5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIG9wYWNpdHkgKiAoIDEuMCAtIGdldFNoYWRvd01hc2soKSApICk7XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XCI7XG52YXIgdmVydGV4JDEgPSBcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XFxudW5pZm9ybSB2ZWMyIGNlbnRlcjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcblxcdHZlYzIgc2NhbGU7XFxuXFx0c2NhbGUueCA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDAgXS54LCBtb2RlbE1hdHJpeFsgMCBdLnksIG1vZGVsTWF0cml4WyAwIF0ueiApICk7XFxuXFx0c2NhbGUueSA9IGxlbmd0aCggdmVjMyggbW9kZWxNYXRyaXhbIDEgXS54LCBtb2RlbE1hdHJpeFsgMSBdLnksIG1vZGVsTWF0cml4WyAxIF0ueiApICk7XFxuXFx0I2lmbmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXFxuXFx0XFx0Ym9vbCBpc1BlcnNwZWN0aXZlID0gaXNQZXJzcGVjdGl2ZU1hdHJpeCggcHJvamVjdGlvbk1hdHJpeCApO1xcblxcdFxcdGlmICggaXNQZXJzcGVjdGl2ZSApIHNjYWxlICo9IC0gbXZQb3NpdGlvbi56O1xcblxcdCNlbmRpZlxcblxcdHZlYzIgYWxpZ25lZFBvc2l0aW9uID0gKCBwb3NpdGlvbi54eSAtICggY2VudGVyIC0gdmVjMiggMC41ICkgKSApICogc2NhbGU7XFxuXFx0dmVjMiByb3RhdGVkUG9zaXRpb247XFxuXFx0cm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcblxcdHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTtcXG5cXHRtdlBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjtcXG5cXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxufVwiO1xudmFyIGZyYWdtZW50JDEgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHQjaW5jbHVkZSA8b3V0cHV0X2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVwiO1xudmFyIFNoYWRlckNodW5rID0ge1xuICBhbHBoYW1hcF9mcmFnbWVudDogYWxwaGFtYXBfZnJhZ21lbnQsXG4gIGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ6IGFscGhhbWFwX3BhcnNfZnJhZ21lbnQsXG4gIGFscGhhdGVzdF9mcmFnbWVudDogYWxwaGF0ZXN0X2ZyYWdtZW50LFxuICBhbHBoYXRlc3RfcGFyc19mcmFnbWVudDogYWxwaGF0ZXN0X3BhcnNfZnJhZ21lbnQsXG4gIGFvbWFwX2ZyYWdtZW50OiBhb21hcF9mcmFnbWVudCxcbiAgYW9tYXBfcGFyc19mcmFnbWVudDogYW9tYXBfcGFyc19mcmFnbWVudCxcbiAgYmVnaW5fdmVydGV4OiBiZWdpbl92ZXJ0ZXgsXG4gIGJlZ2lubm9ybWFsX3ZlcnRleDogYmVnaW5ub3JtYWxfdmVydGV4LFxuICBic2RmczogYnNkZnMsXG4gIGlyaWRlc2NlbmNlX2ZyYWdtZW50OiBpcmlkZXNjZW5jZV9mcmFnbWVudCxcbiAgYnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBidW1wbWFwX3BhcnNfZnJhZ21lbnQsXG4gIGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50LFxuICBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQsXG4gIGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4LFxuICBjbGlwcGluZ19wbGFuZXNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfdmVydGV4LFxuICBjb2xvcl9mcmFnbWVudDogY29sb3JfZnJhZ21lbnQsXG4gIGNvbG9yX3BhcnNfZnJhZ21lbnQ6IGNvbG9yX3BhcnNfZnJhZ21lbnQsXG4gIGNvbG9yX3BhcnNfdmVydGV4OiBjb2xvcl9wYXJzX3ZlcnRleCxcbiAgY29sb3JfdmVydGV4OiBjb2xvcl92ZXJ0ZXgsXG4gIGNvbW1vbjogY29tbW9uLFxuICBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6IGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCxcbiAgZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6IGRlZmF1bHRub3JtYWxfdmVydGV4LFxuICBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCxcbiAgZGlzcGxhY2VtZW50bWFwX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3ZlcnRleCxcbiAgZW1pc3NpdmVtYXBfZnJhZ21lbnQ6IGVtaXNzaXZlbWFwX2ZyYWdtZW50LFxuICBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50LFxuICBlbmNvZGluZ3NfZnJhZ21lbnQ6IGVuY29kaW5nc19mcmFnbWVudCxcbiAgZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQ6IGVuY29kaW5nc19wYXJzX2ZyYWdtZW50LFxuICBlbnZtYXBfZnJhZ21lbnQ6IGVudm1hcF9mcmFnbWVudCxcbiAgZW52bWFwX2NvbW1vbl9wYXJzX2ZyYWdtZW50OiBlbnZtYXBfY29tbW9uX3BhcnNfZnJhZ21lbnQsXG4gIGVudm1hcF9wYXJzX2ZyYWdtZW50OiBlbnZtYXBfcGFyc19mcmFnbWVudCxcbiAgZW52bWFwX3BhcnNfdmVydGV4OiBlbnZtYXBfcGFyc192ZXJ0ZXgsXG4gIGVudm1hcF9waHlzaWNhbF9wYXJzX2ZyYWdtZW50OiBlbnZtYXBfcGh5c2ljYWxfcGFyc19mcmFnbWVudCxcbiAgZW52bWFwX3ZlcnRleDogZW52bWFwX3ZlcnRleCxcbiAgZm9nX3ZlcnRleDogZm9nX3ZlcnRleCxcbiAgZm9nX3BhcnNfdmVydGV4OiBmb2dfcGFyc192ZXJ0ZXgsXG4gIGZvZ19mcmFnbWVudDogZm9nX2ZyYWdtZW50LFxuICBmb2dfcGFyc19mcmFnbWVudDogZm9nX3BhcnNfZnJhZ21lbnQsXG4gIGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQ6IGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQsXG4gIGxpZ2h0bWFwX2ZyYWdtZW50OiBsaWdodG1hcF9mcmFnbWVudCxcbiAgbGlnaHRtYXBfcGFyc19mcmFnbWVudDogbGlnaHRtYXBfcGFyc19mcmFnbWVudCxcbiAgbGlnaHRzX2xhbWJlcnRfdmVydGV4OiBsaWdodHNfbGFtYmVydF92ZXJ0ZXgsXG4gIGxpZ2h0c19wYXJzX2JlZ2luOiBsaWdodHNfcGFyc19iZWdpbixcbiAgbGlnaHRzX3Rvb25fZnJhZ21lbnQ6IGxpZ2h0c190b29uX2ZyYWdtZW50LFxuICBsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50OiBsaWdodHNfdG9vbl9wYXJzX2ZyYWdtZW50LFxuICBsaWdodHNfcGhvbmdfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19mcmFnbWVudCxcbiAgbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuICBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCxcbiAgbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxuICBsaWdodHNfZnJhZ21lbnRfYmVnaW46IGxpZ2h0c19mcmFnbWVudF9iZWdpbixcbiAgbGlnaHRzX2ZyYWdtZW50X21hcHM6IGxpZ2h0c19mcmFnbWVudF9tYXBzLFxuICBsaWdodHNfZnJhZ21lbnRfZW5kOiBsaWdodHNfZnJhZ21lbnRfZW5kLFxuICBsb2dkZXB0aGJ1Zl9mcmFnbWVudDogbG9nZGVwdGhidWZfZnJhZ21lbnQsXG4gIGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG4gIGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OiBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcbiAgbG9nZGVwdGhidWZfdmVydGV4OiBsb2dkZXB0aGJ1Zl92ZXJ0ZXgsXG4gIG1hcF9mcmFnbWVudDogbWFwX2ZyYWdtZW50LFxuICBtYXBfcGFyc19mcmFnbWVudDogbWFwX3BhcnNfZnJhZ21lbnQsXG4gIG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogbWFwX3BhcnRpY2xlX2ZyYWdtZW50LFxuICBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDogbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQsXG4gIG1ldGFsbmVzc21hcF9mcmFnbWVudDogbWV0YWxuZXNzbWFwX2ZyYWdtZW50LFxuICBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG4gIG1vcnBoY29sb3JfdmVydGV4OiBtb3JwaGNvbG9yX3ZlcnRleCxcbiAgbW9ycGhub3JtYWxfdmVydGV4OiBtb3JwaG5vcm1hbF92ZXJ0ZXgsXG4gIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4OiBtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCxcbiAgbW9ycGh0YXJnZXRfdmVydGV4OiBtb3JwaHRhcmdldF92ZXJ0ZXgsXG4gIG5vcm1hbF9mcmFnbWVudF9iZWdpbjogbm9ybWFsX2ZyYWdtZW50X2JlZ2luLFxuICBub3JtYWxfZnJhZ21lbnRfbWFwczogbm9ybWFsX2ZyYWdtZW50X21hcHMsXG4gIG5vcm1hbF9wYXJzX2ZyYWdtZW50OiBub3JtYWxfcGFyc19mcmFnbWVudCxcbiAgbm9ybWFsX3BhcnNfdmVydGV4OiBub3JtYWxfcGFyc192ZXJ0ZXgsXG4gIG5vcm1hbF92ZXJ0ZXg6IG5vcm1hbF92ZXJ0ZXgsXG4gIG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50OiBub3JtYWxtYXBfcGFyc19mcmFnbWVudCxcbiAgY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbjogY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9iZWdpbixcbiAgY2xlYXJjb2F0X25vcm1hbF9mcmFnbWVudF9tYXBzOiBjbGVhcmNvYXRfbm9ybWFsX2ZyYWdtZW50X21hcHMsXG4gIGNsZWFyY29hdF9wYXJzX2ZyYWdtZW50OiBjbGVhcmNvYXRfcGFyc19mcmFnbWVudCxcbiAgaXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudDogaXJpZGVzY2VuY2VfcGFyc19mcmFnbWVudCxcbiAgb3V0cHV0X2ZyYWdtZW50OiBvdXRwdXRfZnJhZ21lbnQsXG4gIHBhY2tpbmc6IHBhY2tpbmcsXG4gIHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6IHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQsXG4gIHByb2plY3RfdmVydGV4OiBwcm9qZWN0X3ZlcnRleCxcbiAgZGl0aGVyaW5nX2ZyYWdtZW50OiBkaXRoZXJpbmdfZnJhZ21lbnQsXG4gIGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50OiBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCxcbiAgcm91Z2huZXNzbWFwX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfZnJhZ21lbnQsXG4gIHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCxcbiAgc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFxuICBzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6IHNoYWRvd21hcF9wYXJzX3ZlcnRleCxcbiAgc2hhZG93bWFwX3ZlcnRleDogc2hhZG93bWFwX3ZlcnRleCxcbiAgc2hhZG93bWFza19wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQsXG4gIHNraW5iYXNlX3ZlcnRleDogc2tpbmJhc2VfdmVydGV4LFxuICBza2lubmluZ19wYXJzX3ZlcnRleDogc2tpbm5pbmdfcGFyc192ZXJ0ZXgsXG4gIHNraW5uaW5nX3ZlcnRleDogc2tpbm5pbmdfdmVydGV4LFxuICBza2lubm9ybWFsX3ZlcnRleDogc2tpbm5vcm1hbF92ZXJ0ZXgsXG4gIHNwZWN1bGFybWFwX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9mcmFnbWVudCxcbiAgc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDogc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCxcbiAgdG9uZW1hcHBpbmdfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX2ZyYWdtZW50LFxuICB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50OiB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50LFxuICB0cmFuc21pc3Npb25fZnJhZ21lbnQ6IHRyYW5zbWlzc2lvbl9mcmFnbWVudCxcbiAgdHJhbnNtaXNzaW9uX3BhcnNfZnJhZ21lbnQ6IHRyYW5zbWlzc2lvbl9wYXJzX2ZyYWdtZW50LFxuICB1dl9wYXJzX2ZyYWdtZW50OiB1dl9wYXJzX2ZyYWdtZW50LFxuICB1dl9wYXJzX3ZlcnRleDogdXZfcGFyc192ZXJ0ZXgsXG4gIHV2X3ZlcnRleDogdXZfdmVydGV4LFxuICB1djJfcGFyc19mcmFnbWVudDogdXYyX3BhcnNfZnJhZ21lbnQsXG4gIHV2Ml9wYXJzX3ZlcnRleDogdXYyX3BhcnNfdmVydGV4LFxuICB1djJfdmVydGV4OiB1djJfdmVydGV4LFxuICB3b3JsZHBvc192ZXJ0ZXg6IHdvcmxkcG9zX3ZlcnRleCxcbiAgYmFja2dyb3VuZF92ZXJ0OiB2ZXJ0ZXgkZyxcbiAgYmFja2dyb3VuZF9mcmFnOiBmcmFnbWVudCRnLFxuICBjdWJlX3ZlcnQ6IHZlcnRleCRmLFxuICBjdWJlX2ZyYWc6IGZyYWdtZW50JGYsXG4gIGRlcHRoX3ZlcnQ6IHZlcnRleCRlLFxuICBkZXB0aF9mcmFnOiBmcmFnbWVudCRlLFxuICBkaXN0YW5jZVJHQkFfdmVydDogdmVydGV4JGQsXG4gIGRpc3RhbmNlUkdCQV9mcmFnOiBmcmFnbWVudCRkLFxuICBlcXVpcmVjdF92ZXJ0OiB2ZXJ0ZXgkYyxcbiAgZXF1aXJlY3RfZnJhZzogZnJhZ21lbnQkYyxcbiAgbGluZWRhc2hlZF92ZXJ0OiB2ZXJ0ZXgkYixcbiAgbGluZWRhc2hlZF9mcmFnOiBmcmFnbWVudCRiLFxuICBtZXNoYmFzaWNfdmVydDogdmVydGV4JGEsXG4gIG1lc2hiYXNpY19mcmFnOiBmcmFnbWVudCRhLFxuICBtZXNobGFtYmVydF92ZXJ0OiB2ZXJ0ZXgkOSxcbiAgbWVzaGxhbWJlcnRfZnJhZzogZnJhZ21lbnQkOSxcbiAgbWVzaG1hdGNhcF92ZXJ0OiB2ZXJ0ZXgkOCxcbiAgbWVzaG1hdGNhcF9mcmFnOiBmcmFnbWVudCQ4LFxuICBtZXNobm9ybWFsX3ZlcnQ6IHZlcnRleCQ3LFxuICBtZXNobm9ybWFsX2ZyYWc6IGZyYWdtZW50JDcsXG4gIG1lc2hwaG9uZ192ZXJ0OiB2ZXJ0ZXgkNixcbiAgbWVzaHBob25nX2ZyYWc6IGZyYWdtZW50JDYsXG4gIG1lc2hwaHlzaWNhbF92ZXJ0OiB2ZXJ0ZXgkNSxcbiAgbWVzaHBoeXNpY2FsX2ZyYWc6IGZyYWdtZW50JDUsXG4gIG1lc2h0b29uX3ZlcnQ6IHZlcnRleCQ0LFxuICBtZXNodG9vbl9mcmFnOiBmcmFnbWVudCQ0LFxuICBwb2ludHNfdmVydDogdmVydGV4JDMsXG4gIHBvaW50c19mcmFnOiBmcmFnbWVudCQzLFxuICBzaGFkb3dfdmVydDogdmVydGV4JDIsXG4gIHNoYWRvd19mcmFnOiBmcmFnbWVudCQyLFxuICBzcHJpdGVfdmVydDogdmVydGV4JDEsXG4gIHNwcml0ZV9mcmFnOiBmcmFnbWVudCQxXG59O1xuLyoqXG4gKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xuICovXG5cbnZhciBVbmlmb3Jtc0xpYiA9IHtcbiAgY29tbW9uOiB7XG4gICAgZGlmZnVzZToge1xuICAgICAgdmFsdWU6IG5ldyBDb2xvcigweGZmZmZmZilcbiAgICB9LFxuICAgIG9wYWNpdHk6IHtcbiAgICAgIHZhbHVlOiAxLjBcbiAgICB9LFxuICAgIG1hcDoge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIHV2VHJhbnNmb3JtOiB7XG4gICAgICB2YWx1ZTogbmV3IE1hdHJpeDMoKVxuICAgIH0sXG4gICAgdXYyVHJhbnNmb3JtOiB7XG4gICAgICB2YWx1ZTogbmV3IE1hdHJpeDMoKVxuICAgIH0sXG4gICAgYWxwaGFNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBhbHBoYVRlc3Q6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfVxuICB9LFxuICBzcGVjdWxhcm1hcDoge1xuICAgIHNwZWN1bGFyTWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH1cbiAgfSxcbiAgZW52bWFwOiB7XG4gICAgZW52TWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgZmxpcEVudk1hcDoge1xuICAgICAgdmFsdWU6IC0xXG4gICAgfSxcbiAgICByZWZsZWN0aXZpdHk6IHtcbiAgICAgIHZhbHVlOiAxLjBcbiAgICB9LFxuICAgIC8vIGJhc2ljLCBsYW1iZXJ0LCBwaG9uZ1xuICAgIGlvcjoge1xuICAgICAgdmFsdWU6IDEuNVxuICAgIH0sXG4gICAgLy8gcGh5c2ljYWxcbiAgICByZWZyYWN0aW9uUmF0aW86IHtcbiAgICAgIHZhbHVlOiAwLjk4XG4gICAgfSAvLyBiYXNpYywgbGFtYmVydCwgcGhvbmdcblxuICB9LFxuICBhb21hcDoge1xuICAgIGFvTWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgYW9NYXBJbnRlbnNpdHk6IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfVxuICB9LFxuICBsaWdodG1hcDoge1xuICAgIGxpZ2h0TWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgbGlnaHRNYXBJbnRlbnNpdHk6IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfVxuICB9LFxuICBlbWlzc2l2ZW1hcDoge1xuICAgIGVtaXNzaXZlTWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH1cbiAgfSxcbiAgYnVtcG1hcDoge1xuICAgIGJ1bXBNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBidW1wU2NhbGU6IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfVxuICB9LFxuICBub3JtYWxtYXA6IHtcbiAgICBub3JtYWxNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBub3JtYWxTY2FsZToge1xuICAgICAgdmFsdWU6IG5ldyBWZWN0b3IyKDEsIDEpXG4gICAgfVxuICB9LFxuICBkaXNwbGFjZW1lbnRtYXA6IHtcbiAgICBkaXNwbGFjZW1lbnRNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBkaXNwbGFjZW1lbnRTY2FsZToge1xuICAgICAgdmFsdWU6IDFcbiAgICB9LFxuICAgIGRpc3BsYWNlbWVudEJpYXM6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfVxuICB9LFxuICByb3VnaG5lc3NtYXA6IHtcbiAgICByb3VnaG5lc3NNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfVxuICB9LFxuICBtZXRhbG5lc3NtYXA6IHtcbiAgICBtZXRhbG5lc3NNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfVxuICB9LFxuICBncmFkaWVudG1hcDoge1xuICAgIGdyYWRpZW50TWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH1cbiAgfSxcbiAgZm9nOiB7XG4gICAgZm9nRGVuc2l0eToge1xuICAgICAgdmFsdWU6IDAuMDAwMjVcbiAgICB9LFxuICAgIGZvZ05lYXI6IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICBmb2dGYXI6IHtcbiAgICAgIHZhbHVlOiAyMDAwXG4gICAgfSxcbiAgICBmb2dDb2xvcjoge1xuICAgICAgdmFsdWU6IG5ldyBDb2xvcigweGZmZmZmZilcbiAgICB9XG4gIH0sXG4gIGxpZ2h0czoge1xuICAgIGFtYmllbnRMaWdodENvbG9yOiB7XG4gICAgICB2YWx1ZTogW11cbiAgICB9LFxuICAgIGxpZ2h0UHJvYmU6IHtcbiAgICAgIHZhbHVlOiBbXVxuICAgIH0sXG4gICAgZGlyZWN0aW9uYWxMaWdodHM6IHtcbiAgICAgIHZhbHVlOiBbXSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZGlyZWN0aW9uOiB7fSxcbiAgICAgICAgY29sb3I6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXJlY3Rpb25hbExpZ2h0U2hhZG93czoge1xuICAgICAgdmFsdWU6IFtdLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBzaGFkb3dCaWFzOiB7fSxcbiAgICAgICAgc2hhZG93Tm9ybWFsQmlhczoge30sXG4gICAgICAgIHNoYWRvd1JhZGl1czoge30sXG4gICAgICAgIHNoYWRvd01hcFNpemU6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXJlY3Rpb25hbFNoYWRvd01hcDoge1xuICAgICAgdmFsdWU6IFtdXG4gICAgfSxcbiAgICBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDoge1xuICAgICAgdmFsdWU6IFtdXG4gICAgfSxcbiAgICBzcG90TGlnaHRzOiB7XG4gICAgICB2YWx1ZTogW10sXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGNvbG9yOiB7fSxcbiAgICAgICAgcG9zaXRpb246IHt9LFxuICAgICAgICBkaXJlY3Rpb246IHt9LFxuICAgICAgICBkaXN0YW5jZToge30sXG4gICAgICAgIGNvbmVDb3M6IHt9LFxuICAgICAgICBwZW51bWJyYUNvczoge30sXG4gICAgICAgIGRlY2F5OiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgc3BvdExpZ2h0U2hhZG93czoge1xuICAgICAgdmFsdWU6IFtdLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBzaGFkb3dCaWFzOiB7fSxcbiAgICAgICAgc2hhZG93Tm9ybWFsQmlhczoge30sXG4gICAgICAgIHNoYWRvd1JhZGl1czoge30sXG4gICAgICAgIHNoYWRvd01hcFNpemU6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBzcG90U2hhZG93TWFwOiB7XG4gICAgICB2YWx1ZTogW11cbiAgICB9LFxuICAgIHNwb3RTaGFkb3dNYXRyaXg6IHtcbiAgICAgIHZhbHVlOiBbXVxuICAgIH0sXG4gICAgcG9pbnRMaWdodHM6IHtcbiAgICAgIHZhbHVlOiBbXSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgY29sb3I6IHt9LFxuICAgICAgICBwb3NpdGlvbjoge30sXG4gICAgICAgIGRlY2F5OiB7fSxcbiAgICAgICAgZGlzdGFuY2U6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBwb2ludExpZ2h0U2hhZG93czoge1xuICAgICAgdmFsdWU6IFtdLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBzaGFkb3dCaWFzOiB7fSxcbiAgICAgICAgc2hhZG93Tm9ybWFsQmlhczoge30sXG4gICAgICAgIHNoYWRvd1JhZGl1czoge30sXG4gICAgICAgIHNoYWRvd01hcFNpemU6IHt9LFxuICAgICAgICBzaGFkb3dDYW1lcmFOZWFyOiB7fSxcbiAgICAgICAgc2hhZG93Q2FtZXJhRmFyOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgcG9pbnRTaGFkb3dNYXA6IHtcbiAgICAgIHZhbHVlOiBbXVxuICAgIH0sXG4gICAgcG9pbnRTaGFkb3dNYXRyaXg6IHtcbiAgICAgIHZhbHVlOiBbXVxuICAgIH0sXG4gICAgaGVtaXNwaGVyZUxpZ2h0czoge1xuICAgICAgdmFsdWU6IFtdLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBkaXJlY3Rpb246IHt9LFxuICAgICAgICBza3lDb2xvcjoge30sXG4gICAgICAgIGdyb3VuZENvbG9yOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gVE9ETyAoYWJlbG5hdGlvbik6IFJlY3RBcmVhTGlnaHQgQlJERiBkYXRhIG5lZWRzIHRvIGJlIG1vdmVkIGZyb20gZXhhbXBsZSB0byBtYWluIHNyY1xuICAgIHJlY3RBcmVhTGlnaHRzOiB7XG4gICAgICB2YWx1ZTogW10sXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGNvbG9yOiB7fSxcbiAgICAgICAgcG9zaXRpb246IHt9LFxuICAgICAgICB3aWR0aDoge30sXG4gICAgICAgIGhlaWdodDoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIGx0Y18xOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgbHRjXzI6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfVxuICB9LFxuICBwb2ludHM6IHtcbiAgICBkaWZmdXNlOiB7XG4gICAgICB2YWx1ZTogbmV3IENvbG9yKDB4ZmZmZmZmKVxuICAgIH0sXG4gICAgb3BhY2l0eToge1xuICAgICAgdmFsdWU6IDEuMFxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgdmFsdWU6IDEuMFxuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgIHZhbHVlOiAxLjBcbiAgICB9LFxuICAgIG1hcDoge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGFscGhhTWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgYWxwaGFUZXN0OiB7XG4gICAgICB2YWx1ZTogMFxuICAgIH0sXG4gICAgdXZUcmFuc2Zvcm06IHtcbiAgICAgIHZhbHVlOiBuZXcgTWF0cml4MygpXG4gICAgfVxuICB9LFxuICBzcHJpdGU6IHtcbiAgICBkaWZmdXNlOiB7XG4gICAgICB2YWx1ZTogbmV3IENvbG9yKDB4ZmZmZmZmKVxuICAgIH0sXG4gICAgb3BhY2l0eToge1xuICAgICAgdmFsdWU6IDEuMFxuICAgIH0sXG4gICAgY2VudGVyOiB7XG4gICAgICB2YWx1ZTogbmV3IFZlY3RvcjIoMC41LCAwLjUpXG4gICAgfSxcbiAgICByb3RhdGlvbjoge1xuICAgICAgdmFsdWU6IDAuMFxuICAgIH0sXG4gICAgbWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgYWxwaGFNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBhbHBoYVRlc3Q6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB1dlRyYW5zZm9ybToge1xuICAgICAgdmFsdWU6IG5ldyBNYXRyaXgzKClcbiAgICB9XG4gIH1cbn07XG52YXIgU2hhZGVyTGliID0ge1xuICBiYXNpYzoge1xuICAgIHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLCBVbmlmb3Jtc0xpYi5lbnZtYXAsIFVuaWZvcm1zTGliLmFvbWFwLCBVbmlmb3Jtc0xpYi5saWdodG1hcCwgVW5pZm9ybXNMaWIuZm9nXSksXG4gICAgdmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX2ZyYWdcbiAgfSxcbiAgbGFtYmVydDoge1xuICAgIHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLCBVbmlmb3Jtc0xpYi5lbnZtYXAsIFVuaWZvcm1zTGliLmFvbWFwLCBVbmlmb3Jtc0xpYi5saWdodG1hcCwgVW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsIFVuaWZvcm1zTGliLmZvZywgVW5pZm9ybXNMaWIubGlnaHRzLCB7XG4gICAgICBlbWlzc2l2ZToge1xuICAgICAgICB2YWx1ZTogbmV3IENvbG9yKDB4MDAwMDAwKVxuICAgICAgfVxuICAgIH1dKSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hsYW1iZXJ0X3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hsYW1iZXJ0X2ZyYWdcbiAgfSxcbiAgcGhvbmc6IHtcbiAgICB1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCwgVW5pZm9ybXNMaWIuZW52bWFwLCBVbmlmb3Jtc0xpYi5hb21hcCwgVW5pZm9ybXNMaWIubGlnaHRtYXAsIFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIuZm9nLCBVbmlmb3Jtc0xpYi5saWdodHMsIHtcbiAgICAgIGVtaXNzaXZlOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgQ29sb3IoMHgwMDAwMDApXG4gICAgICB9LFxuICAgICAgc3BlY3VsYXI6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBDb2xvcigweDExMTExMSlcbiAgICAgIH0sXG4gICAgICBzaGluaW5lc3M6IHtcbiAgICAgICAgdmFsdWU6IDMwXG4gICAgICB9XG4gICAgfV0pLFxuICAgIHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ19mcmFnXG4gIH0sXG4gIHN0YW5kYXJkOiB7XG4gICAgdW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuZW52bWFwLCBVbmlmb3Jtc0xpYi5hb21hcCwgVW5pZm9ybXNMaWIubGlnaHRtYXAsIFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIucm91Z2huZXNzbWFwLCBVbmlmb3Jtc0xpYi5tZXRhbG5lc3NtYXAsIFVuaWZvcm1zTGliLmZvZywgVW5pZm9ybXNMaWIubGlnaHRzLCB7XG4gICAgICBlbWlzc2l2ZToge1xuICAgICAgICB2YWx1ZTogbmV3IENvbG9yKDB4MDAwMDAwKVxuICAgICAgfSxcbiAgICAgIHJvdWdobmVzczoge1xuICAgICAgICB2YWx1ZTogMS4wXG4gICAgICB9LFxuICAgICAgbWV0YWxuZXNzOiB7XG4gICAgICAgIHZhbHVlOiAwLjBcbiAgICAgIH0sXG4gICAgICBlbnZNYXBJbnRlbnNpdHk6IHtcbiAgICAgICAgdmFsdWU6IDFcbiAgICAgIH0gLy8gdGVtcG9yYXJ5XG5cbiAgICB9XSksXG4gICAgdmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcbiAgfSxcbiAgdG9vbjoge1xuICAgIHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLmFvbWFwLCBVbmlmb3Jtc0xpYi5saWdodG1hcCwgVW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsIFVuaWZvcm1zTGliLmJ1bXBtYXAsIFVuaWZvcm1zTGliLm5vcm1hbG1hcCwgVW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLCBVbmlmb3Jtc0xpYi5ncmFkaWVudG1hcCwgVW5pZm9ybXNMaWIuZm9nLCBVbmlmb3Jtc0xpYi5saWdodHMsIHtcbiAgICAgIGVtaXNzaXZlOiB7XG4gICAgICAgIHZhbHVlOiBuZXcgQ29sb3IoMHgwMDAwMDApXG4gICAgICB9XG4gICAgfV0pLFxuICAgIHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHRvb25fdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHRvb25fZnJhZ1xuICB9LFxuICBtYXRjYXA6IHtcbiAgICB1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwgVW5pZm9ybXNMaWIuZm9nLCB7XG4gICAgICBtYXRjYXA6IHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH1cbiAgICB9XSksXG4gICAgdmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobWF0Y2FwX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2htYXRjYXBfZnJhZ1xuICB9LFxuICBwb2ludHM6IHtcbiAgICB1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIucG9pbnRzLCBVbmlmb3Jtc0xpYi5mb2ddKSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c192ZXJ0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5wb2ludHNfZnJhZ1xuICB9LFxuICBkYXNoZWQ6IHtcbiAgICB1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5mb2csIHtcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHZhbHVlOiAxXG4gICAgICB9LFxuICAgICAgZGFzaFNpemU6IHtcbiAgICAgICAgdmFsdWU6IDFcbiAgICAgIH0sXG4gICAgICB0b3RhbFNpemU6IHtcbiAgICAgICAgdmFsdWU6IDJcbiAgICAgIH1cbiAgICB9XSksXG4gICAgdmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfZnJhZ1xuICB9LFxuICBkZXB0aDoge1xuICAgIHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5jb21tb24sIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcF0pLFxuICAgIHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfZnJhZ1xuICB9LFxuICBub3JtYWw6IHtcbiAgICB1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbVW5pZm9ybXNMaWIuY29tbW9uLCBVbmlmb3Jtc0xpYi5idW1wbWFwLCBVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsIFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCwge1xuICAgICAgb3BhY2l0eToge1xuICAgICAgICB2YWx1ZTogMS4wXG4gICAgICB9XG4gICAgfV0pLFxuICAgIHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaG5vcm1hbF92ZXJ0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobm9ybWFsX2ZyYWdcbiAgfSxcbiAgc3ByaXRlOiB7XG4gICAgdW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLnNwcml0ZSwgVW5pZm9ybXNMaWIuZm9nXSksXG4gICAgdmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5zcHJpdGVfdmVydCxcbiAgICBmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuc3ByaXRlX2ZyYWdcbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIHVuaWZvcm1zOiB7XG4gICAgICB1dlRyYW5zZm9ybToge1xuICAgICAgICB2YWx1ZTogbmV3IE1hdHJpeDMoKVxuICAgICAgfSxcbiAgICAgIHQyRDoge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgdmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5iYWNrZ3JvdW5kX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmJhY2tncm91bmRfZnJhZ1xuICB9LFxuXG4gIC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cdEN1YmUgbWFwIHNoYWRlclxuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuICBjdWJlOiB7XG4gICAgdW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmVudm1hcCwge1xuICAgICAgb3BhY2l0eToge1xuICAgICAgICB2YWx1ZTogMS4wXG4gICAgICB9XG4gICAgfV0pLFxuICAgIHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV92ZXJ0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX2ZyYWdcbiAgfSxcbiAgZXF1aXJlY3Q6IHtcbiAgICB1bmlmb3Jtczoge1xuICAgICAgdEVxdWlyZWN0OiB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcbiAgfSxcbiAgZGlzdGFuY2VSR0JBOiB7XG4gICAgdW5pZm9ybXM6IG1lcmdlVW5pZm9ybXMoW1VuaWZvcm1zTGliLmNvbW1vbiwgVW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLCB7XG4gICAgICByZWZlcmVuY2VQb3NpdGlvbjoge1xuICAgICAgICB2YWx1ZTogbmV3IFZlY3RvcjMoKVxuICAgICAgfSxcbiAgICAgIG5lYXJEaXN0YW5jZToge1xuICAgICAgICB2YWx1ZTogMVxuICAgICAgfSxcbiAgICAgIGZhckRpc3RhbmNlOiB7XG4gICAgICAgIHZhbHVlOiAxMDAwXG4gICAgICB9XG4gICAgfV0pLFxuICAgIHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX3ZlcnQsXG4gICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV9mcmFnXG4gIH0sXG4gIHNoYWRvdzoge1xuICAgIHVuaWZvcm1zOiBtZXJnZVVuaWZvcm1zKFtVbmlmb3Jtc0xpYi5saWdodHMsIFVuaWZvcm1zTGliLmZvZywge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBDb2xvcigweDAwMDAwKVxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgdmFsdWU6IDEuMFxuICAgICAgfVxuICAgIH1dKSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnNoYWRvd192ZXJ0LFxuICAgIGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfZnJhZ1xuICB9XG59O1xuU2hhZGVyTGliLnBoeXNpY2FsID0ge1xuICB1bmlmb3JtczogbWVyZ2VVbmlmb3JtcyhbU2hhZGVyTGliLnN0YW5kYXJkLnVuaWZvcm1zLCB7XG4gICAgY2xlYXJjb2F0OiB7XG4gICAgICB2YWx1ZTogMFxuICAgIH0sXG4gICAgY2xlYXJjb2F0TWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgY2xlYXJjb2F0Um91Z2huZXNzOiB7XG4gICAgICB2YWx1ZTogMFxuICAgIH0sXG4gICAgY2xlYXJjb2F0Um91Z2huZXNzTWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgY2xlYXJjb2F0Tm9ybWFsU2NhbGU6IHtcbiAgICAgIHZhbHVlOiBuZXcgVmVjdG9yMigxLCAxKVxuICAgIH0sXG4gICAgY2xlYXJjb2F0Tm9ybWFsTWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgaXJpZGVzY2VuY2U6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICBpcmlkZXNjZW5jZU1hcDoge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGlyaWRlc2NlbmNlSU9SOiB7XG4gICAgICB2YWx1ZTogMS4zXG4gICAgfSxcbiAgICBpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW06IHtcbiAgICAgIHZhbHVlOiAxMDBcbiAgICB9LFxuICAgIGlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bToge1xuICAgICAgdmFsdWU6IDQwMFxuICAgIH0sXG4gICAgaXJpZGVzY2VuY2VUaGlja25lc3NNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBzaGVlbjoge1xuICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIHNoZWVuQ29sb3I6IHtcbiAgICAgIHZhbHVlOiBuZXcgQ29sb3IoMHgwMDAwMDApXG4gICAgfSxcbiAgICBzaGVlbkNvbG9yTWFwOiB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgc2hlZW5Sb3VnaG5lc3M6IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICBzaGVlblJvdWdobmVzc01hcDoge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIHRyYW5zbWlzc2lvbjoge1xuICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIHRyYW5zbWlzc2lvbk1hcDoge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIHRyYW5zbWlzc2lvblNhbXBsZXJTaXplOiB7XG4gICAgICB2YWx1ZTogbmV3IFZlY3RvcjIoKVxuICAgIH0sXG4gICAgdHJhbnNtaXNzaW9uU2FtcGxlck1hcDoge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIHRoaWNrbmVzczoge1xuICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIHRoaWNrbmVzc01hcDoge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIGF0dGVudWF0aW9uRGlzdGFuY2U6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICBhdHRlbnVhdGlvbkNvbG9yOiB7XG4gICAgICB2YWx1ZTogbmV3IENvbG9yKDB4MDAwMDAwKVxuICAgIH0sXG4gICAgc3BlY3VsYXJJbnRlbnNpdHk6IHtcbiAgICAgIHZhbHVlOiAxXG4gICAgfSxcbiAgICBzcGVjdWxhckludGVuc2l0eU1hcDoge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9LFxuICAgIHNwZWN1bGFyQ29sb3I6IHtcbiAgICAgIHZhbHVlOiBuZXcgQ29sb3IoMSwgMSwgMSlcbiAgICB9LFxuICAgIHNwZWN1bGFyQ29sb3JNYXA6IHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfVxuICB9XSksXG4gIHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXG4gIGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xufTtcblxuZnVuY3Rpb24gV2ViR0xCYWNrZ3JvdW5kKHJlbmRlcmVyLCBjdWJlbWFwcywgc3RhdGUsIG9iamVjdHMsIGFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEpIHtcbiAgdmFyIGNsZWFyQ29sb3IgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICB2YXIgY2xlYXJBbHBoYSA9IGFscGhhID09PSB0cnVlID8gMCA6IDE7XG4gIHZhciBwbGFuZU1lc2g7XG4gIHZhciBib3hNZXNoO1xuICB2YXIgY3VycmVudEJhY2tncm91bmQgPSBudWxsO1xuICB2YXIgY3VycmVudEJhY2tncm91bmRWZXJzaW9uID0gMDtcbiAgdmFyIGN1cnJlbnRUb25lbWFwcGluZyA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVuZGVyKHJlbmRlckxpc3QsIHNjZW5lKSB7XG4gICAgdmFyIGZvcmNlQ2xlYXIgPSBmYWxzZTtcbiAgICB2YXIgYmFja2dyb3VuZCA9IHNjZW5lLmlzU2NlbmUgPT09IHRydWUgPyBzY2VuZS5iYWNrZ3JvdW5kIDogbnVsbDtcblxuICAgIGlmIChiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gY3ViZW1hcHMuZ2V0KGJhY2tncm91bmQpO1xuICAgIH0gLy8gSWdub3JlIGJhY2tncm91bmQgaW4gQVJcbiAgICAvLyBUT0RPOiBSZWNvbnNpZGVyIHRoaXMuXG5cblxuICAgIHZhciB4ciA9IHJlbmRlcmVyLnhyO1xuICAgIHZhciBzZXNzaW9uID0geHIuZ2V0U2Vzc2lvbiAmJiB4ci5nZXRTZXNzaW9uKCk7XG5cbiAgICBpZiAoc2Vzc2lvbiAmJiBzZXNzaW9uLmVudmlyb25tZW50QmxlbmRNb2RlID09PSAnYWRkaXRpdmUnKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYmFja2dyb3VuZCA9PT0gbnVsbCkge1xuICAgICAgc2V0Q2xlYXIoY2xlYXJDb2xvciwgY2xlYXJBbHBoYSk7XG4gICAgfSBlbHNlIGlmIChiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNDb2xvcikge1xuICAgICAgc2V0Q2xlYXIoYmFja2dyb3VuZCwgMSk7XG4gICAgICBmb3JjZUNsZWFyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVuZGVyZXIuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIpIHtcbiAgICAgIHJlbmRlcmVyLmNsZWFyKHJlbmRlcmVyLmF1dG9DbGVhckNvbG9yLCByZW5kZXJlci5hdXRvQ2xlYXJEZXB0aCwgcmVuZGVyZXIuYXV0b0NsZWFyU3RlbmNpbCk7XG4gICAgfVxuXG4gICAgaWYgKGJhY2tncm91bmQgJiYgKGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSB8fCBiYWNrZ3JvdW5kLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nKSkge1xuICAgICAgaWYgKGJveE1lc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBib3hNZXNoID0gbmV3IE1lc2gobmV3IEJveEdlb21ldHJ5KDEsIDEsIDEpLCBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgICAgIG5hbWU6ICdCYWNrZ3JvdW5kQ3ViZU1hdGVyaWFsJyxcbiAgICAgICAgICB1bmlmb3JtczogY2xvbmVVbmlmb3JtcyhTaGFkZXJMaWIuY3ViZS51bmlmb3JtcyksXG4gICAgICAgICAgdmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuY3ViZS52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckxpYi5jdWJlLmZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHNpZGU6IEJhY2tTaWRlLFxuICAgICAgICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgICAgZm9nOiBmYWxzZVxuICAgICAgICB9KSk7XG4gICAgICAgIGJveE1lc2guZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCdub3JtYWwnKTtcbiAgICAgICAgYm94TWVzaC5nZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoJ3V2Jyk7XG5cbiAgICAgICAgYm94TWVzaC5vbkJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSkge1xuICAgICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weVBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG4gICAgICAgIH07IC8vIGVuYWJsZSBjb2RlIGluamVjdGlvbiBmb3Igbm9uLWJ1aWx0LWluIG1hdGVyaWFsXG5cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYm94TWVzaC5tYXRlcmlhbCwgJ2Vudk1hcCcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLmVudk1hcC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvYmplY3RzLnVwZGF0ZShib3hNZXNoKTtcbiAgICAgIH1cblxuICAgICAgYm94TWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBiYWNrZ3JvdW5kO1xuICAgICAgYm94TWVzaC5tYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gYmFja2dyb3VuZC5pc0N1YmVUZXh0dXJlICYmIGJhY2tncm91bmQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSA/IC0xIDogMTtcblxuICAgICAgaWYgKGN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8IGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiAhPT0gYmFja2dyb3VuZC52ZXJzaW9uIHx8IGN1cnJlbnRUb25lbWFwcGluZyAhPT0gcmVuZGVyZXIudG9uZU1hcHBpbmcpIHtcbiAgICAgICAgYm94TWVzaC5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRCYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICAgICAgY3VycmVudEJhY2tncm91bmRWZXJzaW9uID0gYmFja2dyb3VuZC52ZXJzaW9uO1xuICAgICAgICBjdXJyZW50VG9uZW1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcbiAgICAgIH1cblxuICAgICAgYm94TWVzaC5sYXllcnMuZW5hYmxlQWxsKCk7IC8vIHB1c2ggdG8gdGhlIHByZS1zb3J0ZWQgb3BhcXVlIHJlbmRlciBsaXN0XG5cbiAgICAgIHJlbmRlckxpc3QudW5zaGlmdChib3hNZXNoLCBib3hNZXNoLmdlb21ldHJ5LCBib3hNZXNoLm1hdGVyaWFsLCAwLCAwLCBudWxsKTtcbiAgICB9IGVsc2UgaWYgKGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc1RleHR1cmUpIHtcbiAgICAgIGlmIChwbGFuZU1lc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwbGFuZU1lc2ggPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgyLCAyKSwgbmV3IFNoYWRlck1hdGVyaWFsKHtcbiAgICAgICAgICBuYW1lOiAnQmFja2dyb3VuZE1hdGVyaWFsJyxcbiAgICAgICAgICB1bmlmb3JtczogY2xvbmVVbmlmb3JtcyhTaGFkZXJMaWIuYmFja2dyb3VuZC51bmlmb3JtcyksXG4gICAgICAgICAgdmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuYmFja2dyb3VuZC52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IFNoYWRlckxpYi5iYWNrZ3JvdW5kLmZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgIHNpZGU6IEZyb250U2lkZSxcbiAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICAgIGZvZzogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgICAgICBwbGFuZU1lc2guZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCdub3JtYWwnKTsgLy8gZW5hYmxlIGNvZGUgaW5qZWN0aW9uIGZvciBub24tYnVpbHQtaW4gbWF0ZXJpYWxcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxhbmVNZXNoLm1hdGVyaWFsLCAnbWFwJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudDJELnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9iamVjdHMudXBkYXRlKHBsYW5lTWVzaCk7XG4gICAgICB9XG5cbiAgICAgIHBsYW5lTWVzaC5tYXRlcmlhbC51bmlmb3Jtcy50MkQudmFsdWUgPSBiYWNrZ3JvdW5kO1xuXG4gICAgICBpZiAoYmFja2dyb3VuZC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICAgIGJhY2tncm91bmQudXBkYXRlTWF0cml4KCk7XG4gICAgICB9XG5cbiAgICAgIHBsYW5lTWVzaC5tYXRlcmlhbC51bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KGJhY2tncm91bmQubWF0cml4KTtcblxuICAgICAgaWYgKGN1cnJlbnRCYWNrZ3JvdW5kICE9PSBiYWNrZ3JvdW5kIHx8IGN1cnJlbnRCYWNrZ3JvdW5kVmVyc2lvbiAhPT0gYmFja2dyb3VuZC52ZXJzaW9uIHx8IGN1cnJlbnRUb25lbWFwcGluZyAhPT0gcmVuZGVyZXIudG9uZU1hcHBpbmcpIHtcbiAgICAgICAgcGxhbmVNZXNoLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudEJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICAgICAgICBjdXJyZW50QmFja2dyb3VuZFZlcnNpb24gPSBiYWNrZ3JvdW5kLnZlcnNpb247XG4gICAgICAgIGN1cnJlbnRUb25lbWFwcGluZyA9IHJlbmRlcmVyLnRvbmVNYXBwaW5nO1xuICAgICAgfVxuXG4gICAgICBwbGFuZU1lc2gubGF5ZXJzLmVuYWJsZUFsbCgpOyAvLyBwdXNoIHRvIHRoZSBwcmUtc29ydGVkIG9wYXF1ZSByZW5kZXIgbGlzdFxuXG4gICAgICByZW5kZXJMaXN0LnVuc2hpZnQocGxhbmVNZXNoLCBwbGFuZU1lc2guZ2VvbWV0cnksIHBsYW5lTWVzaC5tYXRlcmlhbCwgMCwgMCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2xlYXIoY29sb3IsIGFscGhhKSB7XG4gICAgc3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhcihjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBhbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gZ2V0Q2xlYXJDb2xvcigpIHtcbiAgICAgIHJldHVybiBjbGVhckNvbG9yO1xuICAgIH0sXG4gICAgc2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gc2V0Q2xlYXJDb2xvcihjb2xvcikge1xuICAgICAgdmFyIGFscGhhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgY2xlYXJDb2xvci5zZXQoY29sb3IpO1xuICAgICAgY2xlYXJBbHBoYSA9IGFscGhhO1xuICAgICAgc2V0Q2xlYXIoY2xlYXJDb2xvciwgY2xlYXJBbHBoYSk7XG4gICAgfSxcbiAgICBnZXRDbGVhckFscGhhOiBmdW5jdGlvbiBnZXRDbGVhckFscGhhKCkge1xuICAgICAgcmV0dXJuIGNsZWFyQWxwaGE7XG4gICAgfSxcbiAgICBzZXRDbGVhckFscGhhOiBmdW5jdGlvbiBzZXRDbGVhckFscGhhKGFscGhhKSB7XG4gICAgICBjbGVhckFscGhhID0gYWxwaGE7XG4gICAgICBzZXRDbGVhcihjbGVhckNvbG9yLCBjbGVhckFscGhhKTtcbiAgICB9LFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG59XG5cbmZ1bmN0aW9uIFdlYkdMQmluZGluZ1N0YXRlcyhnbCwgZXh0ZW5zaW9ucywgYXR0cmlidXRlcywgY2FwYWJpbGl0aWVzKSB7XG4gIHZhciBtYXhWZXJ0ZXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKDM0OTIxKTtcbiAgdmFyIGV4dGVuc2lvbiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMiA/IG51bGwgOiBleHRlbnNpb25zLmdldCgnT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcbiAgdmFyIHZhb0F2YWlsYWJsZSA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMiB8fCBleHRlbnNpb24gIT09IG51bGw7XG4gIHZhciBiaW5kaW5nU3RhdGVzID0ge307XG4gIHZhciBkZWZhdWx0U3RhdGUgPSBjcmVhdGVCaW5kaW5nU3RhdGUobnVsbCk7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gIHZhciBmb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNldHVwKG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBpbmRleCkge1xuICAgIHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2U7XG5cbiAgICBpZiAodmFvQXZhaWxhYmxlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRCaW5kaW5nU3RhdGUoZ2VvbWV0cnksIHByb2dyYW0sIG1hdGVyaWFsKTtcblxuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gc3RhdGU7XG4gICAgICAgIGJpbmRWZXJ0ZXhBcnJheU9iamVjdChjdXJyZW50U3RhdGUub2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlQnVmZmVycyA9IG5lZWRzVXBkYXRlKG9iamVjdCwgZ2VvbWV0cnksIHByb2dyYW0sIGluZGV4KTtcbiAgICAgIGlmICh1cGRhdGVCdWZmZXJzKSBzYXZlQ2FjaGUob2JqZWN0LCBnZW9tZXRyeSwgcHJvZ3JhbSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgd2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlO1xuXG4gICAgICBpZiAoY3VycmVudFN0YXRlLmdlb21ldHJ5ICE9PSBnZW9tZXRyeS5pZCB8fCBjdXJyZW50U3RhdGUucHJvZ3JhbSAhPT0gcHJvZ3JhbS5pZCB8fCBjdXJyZW50U3RhdGUud2lyZWZyYW1lICE9PSB3aXJlZnJhbWUpIHtcbiAgICAgICAgY3VycmVudFN0YXRlLmdlb21ldHJ5ID0gZ2VvbWV0cnkuaWQ7XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5wcm9ncmFtID0gcHJvZ3JhbS5pZDtcbiAgICAgICAgY3VycmVudFN0YXRlLndpcmVmcmFtZSA9IHdpcmVmcmFtZTtcbiAgICAgICAgdXBkYXRlQnVmZmVycyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICBhdHRyaWJ1dGVzLnVwZGF0ZShpbmRleCwgMzQ5NjMpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGVCdWZmZXJzIHx8IGZvcmNlVXBkYXRlKSB7XG4gICAgICBmb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKG9iamVjdCwgbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5KTtcblxuICAgICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoMzQ5NjMsIGF0dHJpYnV0ZXMuZ2V0KGluZGV4KS5idWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVZlcnRleEFycmF5T2JqZWN0KCkge1xuICAgIGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHJldHVybiBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgIHJldHVybiBleHRlbnNpb24uY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmRWZXJ0ZXhBcnJheU9iamVjdCh2YW8pIHtcbiAgICBpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyKSByZXR1cm4gZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModmFvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KHZhbykge1xuICAgIGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHJldHVybiBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2YW8pO1xuICAgIHJldHVybiBleHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVModmFvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJpbmRpbmdTdGF0ZShnZW9tZXRyeSwgcHJvZ3JhbSwgbWF0ZXJpYWwpIHtcbiAgICB2YXIgd2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlO1xuICAgIHZhciBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1tnZW9tZXRyeS5pZF07XG5cbiAgICBpZiAocHJvZ3JhbU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9ncmFtTWFwID0ge307XG4gICAgICBiaW5kaW5nU3RhdGVzW2dlb21ldHJ5LmlkXSA9IHByb2dyYW1NYXA7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlTWFwID0gcHJvZ3JhbU1hcFtwcm9ncmFtLmlkXTtcblxuICAgIGlmIChzdGF0ZU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGF0ZU1hcCA9IHt9O1xuICAgICAgcHJvZ3JhbU1hcFtwcm9ncmFtLmlkXSA9IHN0YXRlTWFwO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHN0YXRlTWFwW3dpcmVmcmFtZV07XG5cbiAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhdGUgPSBjcmVhdGVCaW5kaW5nU3RhdGUoY3JlYXRlVmVydGV4QXJyYXlPYmplY3QoKSk7XG4gICAgICBzdGF0ZU1hcFt3aXJlZnJhbWVdID0gc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQmluZGluZ1N0YXRlKHZhbykge1xuICAgIHZhciBuZXdBdHRyaWJ1dGVzID0gW107XG4gICAgdmFyIGVuYWJsZWRBdHRyaWJ1dGVzID0gW107XG4gICAgdmFyIGF0dHJpYnV0ZURpdmlzb3JzID0gW107XG5cbiAgICBmb3IgKHZhciBfaTcyID0gMDsgX2k3MiA8IG1heFZlcnRleEF0dHJpYnV0ZXM7IF9pNzIrKykge1xuICAgICAgbmV3QXR0cmlidXRlc1tfaTcyXSA9IDA7XG4gICAgICBlbmFibGVkQXR0cmlidXRlc1tfaTcyXSA9IDA7XG4gICAgICBhdHRyaWJ1dGVEaXZpc29yc1tfaTcyXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9uIG5vbi1WQU8gc3VwcG9ydCBicm93c2VyXG4gICAgICBnZW9tZXRyeTogbnVsbCxcbiAgICAgIHByb2dyYW06IG51bGwsXG4gICAgICB3aXJlZnJhbWU6IGZhbHNlLFxuICAgICAgbmV3QXR0cmlidXRlczogbmV3QXR0cmlidXRlcyxcbiAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzOiBlbmFibGVkQXR0cmlidXRlcyxcbiAgICAgIGF0dHJpYnV0ZURpdmlzb3JzOiBhdHRyaWJ1dGVEaXZpc29ycyxcbiAgICAgIG9iamVjdDogdmFvLFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBpbmRleDogbnVsbFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBuZWVkc1VwZGF0ZShvYmplY3QsIGdlb21ldHJ5LCBwcm9ncmFtLCBpbmRleCkge1xuICAgIHZhciBjYWNoZWRBdHRyaWJ1dGVzID0gY3VycmVudFN0YXRlLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgdmFyIGF0dHJpYnV0ZXNOdW0gPSAwO1xuICAgIHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcykge1xuICAgICAgdmFyIHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gPj0gMCkge1xuICAgICAgICB2YXIgY2FjaGVkQXR0cmlidXRlID0gY2FjaGVkQXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICAgIGlmIChnZW9tZXRyeUF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICdpbnN0YW5jZU1hdHJpeCcgJiYgb2JqZWN0Lmluc3RhbmNlTWF0cml4KSBnZW9tZXRyeUF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZU1hdHJpeDtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2luc3RhbmNlQ29sb3InICYmIG9iamVjdC5pbnN0YW5jZUNvbG9yKSBnZW9tZXRyeUF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZUNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlZEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNhY2hlZEF0dHJpYnV0ZS5hdHRyaWJ1dGUgIT09IGdlb21ldHJ5QXR0cmlidXRlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGdlb21ldHJ5QXR0cmlidXRlICYmIGNhY2hlZEF0dHJpYnV0ZS5kYXRhICE9PSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgYXR0cmlidXRlc051bSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSAhPT0gYXR0cmlidXRlc051bSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGN1cnJlbnRTdGF0ZS5pbmRleCAhPT0gaW5kZXgpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhdmVDYWNoZShvYmplY3QsIGdlb21ldHJ5LCBwcm9ncmFtLCBpbmRleCkge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cmlidXRlc051bSA9IDA7XG4gICAgdmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHByb2dyYW1BdHRyaWJ1dGVzKSB7XG4gICAgICB2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiA+PSAwKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAnaW5zdGFuY2VNYXRyaXgnICYmIG9iamVjdC5pbnN0YW5jZU1hdHJpeCkgYXR0cmlidXRlID0gb2JqZWN0Lmluc3RhbmNlTWF0cml4O1xuICAgICAgICAgIGlmIChuYW1lID09PSAnaW5zdGFuY2VDb2xvcicgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IpIGF0dHJpYnV0ZSA9IG9iamVjdC5pbnN0YW5jZUNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgZGF0YS5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuZGF0YSkge1xuICAgICAgICAgIGRhdGEuZGF0YSA9IGF0dHJpYnV0ZS5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVbbmFtZV0gPSBkYXRhO1xuICAgICAgICBhdHRyaWJ1dGVzTnVtKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudFN0YXRlLmF0dHJpYnV0ZXMgPSBjYWNoZTtcbiAgICBjdXJyZW50U3RhdGUuYXR0cmlidXRlc051bSA9IGF0dHJpYnV0ZXNOdW07XG4gICAgY3VycmVudFN0YXRlLmluZGV4ID0gaW5kZXg7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0QXR0cmlidXRlcygpIHtcbiAgICB2YXIgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgX2k3MyA9IDAsIGlsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IF9pNzMgPCBpbDsgX2k3MysrKSB7XG4gICAgICBuZXdBdHRyaWJ1dGVzW19pNzNdID0gMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcihhdHRyaWJ1dGUsIDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcihhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUpIHtcbiAgICB2YXIgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xuICAgIHZhciBlbmFibGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5lbmFibGVkQXR0cmlidXRlcztcbiAgICB2YXIgYXR0cmlidXRlRGl2aXNvcnMgPSBjdXJyZW50U3RhdGUuYXR0cmlidXRlRGl2aXNvcnM7XG4gICAgbmV3QXR0cmlidXRlc1thdHRyaWJ1dGVdID0gMTtcblxuICAgIGlmIChlbmFibGVkQXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSAwKSB7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGUpO1xuICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZURpdmlzb3JzW2F0dHJpYnV0ZV0gIT09IG1lc2hQZXJBdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBfZXh0ZW5zaW9uID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyID8gZ2wgOiBleHRlbnNpb25zLmdldCgnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuXG4gICAgICBfZXh0ZW5zaW9uW2NhcGFiaWxpdGllcy5pc1dlYkdMMiA/ICd2ZXJ0ZXhBdHRyaWJEaXZpc29yJyA6ICd2ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUnXShhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUpO1xuXG4gICAgICBhdHRyaWJ1dGVEaXZpc29yc1thdHRyaWJ1dGVdID0gbWVzaFBlckF0dHJpYnV0ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpIHtcbiAgICB2YXIgbmV3QXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5uZXdBdHRyaWJ1dGVzO1xuICAgIHZhciBlbmFibGVkQXR0cmlidXRlcyA9IGN1cnJlbnRTdGF0ZS5lbmFibGVkQXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIF9pNzQgPSAwLCBpbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgX2k3NCA8IGlsOyBfaTc0KyspIHtcbiAgICAgIGlmIChlbmFibGVkQXR0cmlidXRlc1tfaTc0XSAhPT0gbmV3QXR0cmlidXRlc1tfaTc0XSkge1xuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoX2k3NCk7XG4gICAgICAgIGVuYWJsZWRBdHRyaWJ1dGVzW19pNzRdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldCkge1xuICAgIGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPT09IHRydWUgJiYgKHR5cGUgPT09IDUxMjQgfHwgdHlwZSA9PT0gNTEyNSkpIHtcbiAgICAgIGdsLnZlcnRleEF0dHJpYklQb2ludGVyKGluZGV4LCBzaXplLCB0eXBlLCBzdHJpZGUsIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSwgb2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMob2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnkpIHtcbiAgICBpZiAoY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSBmYWxzZSAmJiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCB8fCBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KSkge1xuICAgICAgaWYgKGV4dGVuc2lvbnMuZ2V0KCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJykgPT09IG51bGwpIHJldHVybjtcbiAgICB9XG5cbiAgICBpbml0QXR0cmlidXRlcygpO1xuICAgIHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuICAgIHZhciBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSBtYXRlcmlhbC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcykge1xuICAgICAgdmFyIHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24gPj0gMCkge1xuICAgICAgICB2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgICAgaWYgKGdlb21ldHJ5QXR0cmlidXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ2luc3RhbmNlTWF0cml4JyAmJiBvYmplY3QuaW5zdGFuY2VNYXRyaXgpIGdlb21ldHJ5QXR0cmlidXRlID0gb2JqZWN0Lmluc3RhbmNlTWF0cml4O1xuICAgICAgICAgIGlmIChuYW1lID09PSAnaW5zdGFuY2VDb2xvcicgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IpIGdlb21ldHJ5QXR0cmlidXRlID0gb2JqZWN0Lmluc3RhbmNlQ29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBub3JtYWxpemVkID0gZ2VvbWV0cnlBdHRyaWJ1dGUubm9ybWFsaXplZDtcbiAgICAgICAgICB2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldChnZW9tZXRyeUF0dHJpYnV0ZSk7IC8vIFRPRE8gQXR0cmlidXRlIG1heSBub3QgYmUgYXZhaWxhYmxlIG9uIGNvbnRleHQgcmVzdG9yZVxuXG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gYXR0cmlidXRlLmJ1ZmZlcjtcbiAgICAgICAgICB2YXIgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuICAgICAgICAgIHZhciBieXRlc1BlckVsZW1lbnQgPSBhdHRyaWJ1dGUuYnl0ZXNQZXJFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKGdlb21ldHJ5QXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5vZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2k3NSA9IDA7IF9pNzUgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgX2k3NSsrKSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgX2k3NSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChvYmplY3QuaXNJbnN0YW5jZWRNZXNoICE9PSB0cnVlICYmIGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pNzYgPSAwOyBfaTc2IDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IF9pNzYrKykge1xuICAgICAgICAgICAgICAgIGVuYWJsZUF0dHJpYnV0ZShwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgX2k3Nik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcigzNDk2MiwgYnVmZmVyKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2k3NyA9IDA7IF9pNzcgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgX2k3NysrKSB7XG4gICAgICAgICAgICAgIHZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIF9pNzcsIHNpemUgLyBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlICogYnl0ZXNQZXJFbGVtZW50LCAob2Zmc2V0ICsgc2l6ZSAvIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplICogX2k3NykgKiBieXRlc1BlckVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnlBdHRyaWJ1dGUuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2k3OCA9IDA7IF9pNzggPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgX2k3OCsrKSB7XG4gICAgICAgICAgICAgICAgZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgX2k3OCwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAhPT0gdHJ1ZSAmJiBnZW9tZXRyeS5fbWF4SW5zdGFuY2VDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pNzkgPSAwOyBfaTc5IDwgcHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvblNpemU7IF9pNzkrKykge1xuICAgICAgICAgICAgICAgIGVuYWJsZUF0dHJpYnV0ZShwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uICsgX2k3OSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcigzNDk2MiwgYnVmZmVyKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2k4MCA9IDA7IF9pODAgPCBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZTsgX2k4MCsrKSB7XG4gICAgICAgICAgICAgIHZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiArIF9pODAsIHNpemUgLyBwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uU2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc2l6ZSAqIGJ5dGVzUGVyRWxlbWVudCwgc2l6ZSAvIHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb25TaXplICogX2k4MCAqIGJ5dGVzUGVyRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF92YWx1ZTIgPSBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbbmFtZV07XG5cbiAgICAgICAgICBpZiAoX3ZhbHVlMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF92YWx1ZTIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIyZnYocHJvZ3JhbUF0dHJpYnV0ZS5sb2NhdGlvbiwgX3ZhbHVlMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYjNmdihwcm9ncmFtQXR0cmlidXRlLmxvY2F0aW9uLCBfdmFsdWUyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliNGZ2KHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIF92YWx1ZTIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliMWZ2KHByb2dyYW1BdHRyaWJ1dGUubG9jYXRpb24sIF92YWx1ZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHJlc2V0KCk7XG5cbiAgICBmb3IgKHZhciBnZW9tZXRyeUlkIGluIGJpbmRpbmdTdGF0ZXMpIHtcbiAgICAgIHZhciBwcm9ncmFtTWFwID0gYmluZGluZ1N0YXRlc1tnZW9tZXRyeUlkXTtcblxuICAgICAgZm9yICh2YXIgcHJvZ3JhbUlkIGluIHByb2dyYW1NYXApIHtcbiAgICAgICAgdmFyIHN0YXRlTWFwID0gcHJvZ3JhbU1hcFtwcm9ncmFtSWRdO1xuXG4gICAgICAgIGZvciAodmFyIHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCkge1xuICAgICAgICAgIGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KHN0YXRlTWFwW3dpcmVmcmFtZV0ub2JqZWN0KTtcbiAgICAgICAgICBkZWxldGUgc3RhdGVNYXBbd2lyZWZyYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBwcm9ncmFtTWFwW3Byb2dyYW1JZF07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBiaW5kaW5nU3RhdGVzW2dlb21ldHJ5SWRdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5KGdlb21ldHJ5KSB7XG4gICAgaWYgKGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICB2YXIgcHJvZ3JhbU1hcCA9IGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdO1xuXG4gICAgZm9yICh2YXIgcHJvZ3JhbUlkIGluIHByb2dyYW1NYXApIHtcbiAgICAgIHZhciBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbcHJvZ3JhbUlkXTtcblxuICAgICAgZm9yICh2YXIgd2lyZWZyYW1lIGluIHN0YXRlTWFwKSB7XG4gICAgICAgIGRlbGV0ZVZlcnRleEFycmF5T2JqZWN0KHN0YXRlTWFwW3dpcmVmcmFtZV0ub2JqZWN0KTtcbiAgICAgICAgZGVsZXRlIHN0YXRlTWFwW3dpcmVmcmFtZV07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBwcm9ncmFtTWFwW3Byb2dyYW1JZF07XG4gICAgfVxuXG4gICAgZGVsZXRlIGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnkuaWRdO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVsZWFzZVN0YXRlc09mUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgZm9yICh2YXIgZ2VvbWV0cnlJZCBpbiBiaW5kaW5nU3RhdGVzKSB7XG4gICAgICB2YXIgcHJvZ3JhbU1hcCA9IGJpbmRpbmdTdGF0ZXNbZ2VvbWV0cnlJZF07XG4gICAgICBpZiAocHJvZ3JhbU1hcFtwcm9ncmFtLmlkXSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgIHZhciBzdGF0ZU1hcCA9IHByb2dyYW1NYXBbcHJvZ3JhbS5pZF07XG5cbiAgICAgIGZvciAodmFyIHdpcmVmcmFtZSBpbiBzdGF0ZU1hcCkge1xuICAgICAgICBkZWxldGVWZXJ0ZXhBcnJheU9iamVjdChzdGF0ZU1hcFt3aXJlZnJhbWVdLm9iamVjdCk7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZU1hcFt3aXJlZnJhbWVdO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgcHJvZ3JhbU1hcFtwcm9ncmFtLmlkXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICByZXNldERlZmF1bHRTdGF0ZSgpO1xuICAgIGZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAoY3VycmVudFN0YXRlID09PSBkZWZhdWx0U3RhdGUpIHJldHVybjtcbiAgICBjdXJyZW50U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gICAgYmluZFZlcnRleEFycmF5T2JqZWN0KGN1cnJlbnRTdGF0ZS5vYmplY3QpO1xuICB9IC8vIGZvciBiYWNrd2FyZC1jb21wYXRpYmlsaXR5XG5cblxuICBmdW5jdGlvbiByZXNldERlZmF1bHRTdGF0ZSgpIHtcbiAgICBkZWZhdWx0U3RhdGUuZ2VvbWV0cnkgPSBudWxsO1xuICAgIGRlZmF1bHRTdGF0ZS5wcm9ncmFtID0gbnVsbDtcbiAgICBkZWZhdWx0U3RhdGUud2lyZWZyYW1lID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNldHVwOiBzZXR1cCxcbiAgICByZXNldDogcmVzZXQsXG4gICAgcmVzZXREZWZhdWx0U3RhdGU6IHJlc2V0RGVmYXVsdFN0YXRlLFxuICAgIGRpc3Bvc2U6IGRpc3Bvc2UsXG4gICAgcmVsZWFzZVN0YXRlc09mR2VvbWV0cnk6IHJlbGVhc2VTdGF0ZXNPZkdlb21ldHJ5LFxuICAgIHJlbGVhc2VTdGF0ZXNPZlByb2dyYW06IHJlbGVhc2VTdGF0ZXNPZlByb2dyYW0sXG4gICAgaW5pdEF0dHJpYnV0ZXM6IGluaXRBdHRyaWJ1dGVzLFxuICAgIGVuYWJsZUF0dHJpYnV0ZTogZW5hYmxlQXR0cmlidXRlLFxuICAgIGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzOiBkaXNhYmxlVW51c2VkQXR0cmlidXRlc1xuICB9O1xufVxuXG5mdW5jdGlvbiBXZWJHTEJ1ZmZlclJlbmRlcmVyKGdsLCBleHRlbnNpb25zLCBpbmZvLCBjYXBhYmlsaXRpZXMpIHtcbiAgdmFyIGlzV2ViR0wyID0gY2FwYWJpbGl0aWVzLmlzV2ViR0wyO1xuICB2YXIgbW9kZTtcblxuICBmdW5jdGlvbiBzZXRNb2RlKHZhbHVlKSB7XG4gICAgbW9kZSA9IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyKHN0YXJ0LCBjb3VudCkge1xuICAgIGdsLmRyYXdBcnJheXMobW9kZSwgc3RhcnQsIGNvdW50KTtcbiAgICBpbmZvLnVwZGF0ZShjb3VudCwgbW9kZSwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoc3RhcnQsIGNvdW50LCBwcmltY291bnQpIHtcbiAgICBpZiAocHJpbWNvdW50ID09PSAwKSByZXR1cm47XG4gICAgdmFyIGV4dGVuc2lvbiwgbWV0aG9kTmFtZTtcblxuICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgZXh0ZW5zaW9uID0gZ2w7XG4gICAgICBtZXRob2ROYW1lID0gJ2RyYXdBcnJheXNJbnN0YW5jZWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuICAgICAgbWV0aG9kTmFtZSA9ICdkcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUnO1xuXG4gICAgICBpZiAoZXh0ZW5zaW9uID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXh0ZW5zaW9uW21ldGhvZE5hbWVdKG1vZGUsIHN0YXJ0LCBjb3VudCwgcHJpbWNvdW50KTtcbiAgICBpbmZvLnVwZGF0ZShjb3VudCwgbW9kZSwgcHJpbWNvdW50KTtcbiAgfSAvL1xuXG5cbiAgdGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcbiAgdGhpcy5yZW5kZXIgPSByZW5kZXI7XG4gIHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xufVxuXG5mdW5jdGlvbiBXZWJHTENhcGFiaWxpdGllcyhnbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycykge1xuICB2YXIgbWF4QW5pc290cm9weTtcblxuICBmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xuICAgIGlmIChtYXhBbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQpIHJldHVybiBtYXhBbmlzb3Ryb3B5O1xuXG4gICAgaWYgKGV4dGVuc2lvbnMuaGFzKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKTtcbiAgICAgIG1heEFuaXNvdHJvcHkgPSBnbC5nZXRQYXJhbWV0ZXIoZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heEFuaXNvdHJvcHkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhBbmlzb3Ryb3B5O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKHByZWNpc2lvbikge1xuICAgIGlmIChwcmVjaXNpb24gPT09ICdoaWdocCcpIHtcbiAgICAgIGlmIChnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoMzU2MzMsIDM2MzM4KS5wcmVjaXNpb24gPiAwICYmIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCgzNTYzMiwgMzYzMzgpLnByZWNpc2lvbiA+IDApIHtcbiAgICAgICAgcmV0dXJuICdoaWdocCc7XG4gICAgICB9XG5cbiAgICAgIHByZWNpc2lvbiA9ICdtZWRpdW1wJztcbiAgICB9XG5cbiAgICBpZiAocHJlY2lzaW9uID09PSAnbWVkaXVtcCcpIHtcbiAgICAgIGlmIChnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoMzU2MzMsIDM2MzM3KS5wcmVjaXNpb24gPiAwICYmIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCgzNTYzMiwgMzYzMzcpLnByZWNpc2lvbiA+IDApIHtcbiAgICAgICAgcmV0dXJuICdtZWRpdW1wJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJ2xvd3AnO1xuICB9XG5cbiAgdmFyIGlzV2ViR0wyID0gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCB8fCB0eXBlb2YgV2ViR0wyQ29tcHV0ZVJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyQ29tcHV0ZVJlbmRlcmluZ0NvbnRleHQ7XG4gIHZhciBwcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnO1xuICB2YXIgbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKHByZWNpc2lvbik7XG5cbiAgaWYgKG1heFByZWNpc2lvbiAhPT0gcHJlY2lzaW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIHByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgbWF4UHJlY2lzaW9uLCAnaW5zdGVhZC4nKTtcbiAgICBwcmVjaXNpb24gPSBtYXhQcmVjaXNpb247XG4gIH1cblxuICB2YXIgZHJhd0J1ZmZlcnMgPSBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnV0VCR0xfZHJhd19idWZmZXJzJyk7XG4gIHZhciBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID09PSB0cnVlO1xuICB2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoMzQ5MzApO1xuICB2YXIgbWF4VmVydGV4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoMzU2NjApO1xuICB2YXIgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoMzM3OSk7XG4gIHZhciBtYXhDdWJlbWFwU2l6ZSA9IGdsLmdldFBhcmFtZXRlcigzNDA3Nik7XG4gIHZhciBtYXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKDM0OTIxKTtcbiAgdmFyIG1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKDM2MzQ3KTtcbiAgdmFyIG1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKDM2MzQ4KTtcbiAgdmFyIG1heEZyYWdtZW50VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoMzYzNDkpO1xuICB2YXIgdmVydGV4VGV4dHVyZXMgPSBtYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG4gIHZhciBmbG9hdEZyYWdtZW50VGV4dHVyZXMgPSBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgdmFyIGZsb2F0VmVydGV4VGV4dHVyZXMgPSB2ZXJ0ZXhUZXh0dXJlcyAmJiBmbG9hdEZyYWdtZW50VGV4dHVyZXM7XG4gIHZhciBtYXhTYW1wbGVzID0gaXNXZWJHTDIgPyBnbC5nZXRQYXJhbWV0ZXIoMzYxODMpIDogMDtcbiAgcmV0dXJuIHtcbiAgICBpc1dlYkdMMjogaXNXZWJHTDIsXG4gICAgZHJhd0J1ZmZlcnM6IGRyYXdCdWZmZXJzLFxuICAgIGdldE1heEFuaXNvdHJvcHk6IGdldE1heEFuaXNvdHJvcHksXG4gICAgZ2V0TWF4UHJlY2lzaW9uOiBnZXRNYXhQcmVjaXNpb24sXG4gICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcbiAgICBtYXhUZXh0dXJlczogbWF4VGV4dHVyZXMsXG4gICAgbWF4VmVydGV4VGV4dHVyZXM6IG1heFZlcnRleFRleHR1cmVzLFxuICAgIG1heFRleHR1cmVTaXplOiBtYXhUZXh0dXJlU2l6ZSxcbiAgICBtYXhDdWJlbWFwU2l6ZTogbWF4Q3ViZW1hcFNpemUsXG4gICAgbWF4QXR0cmlidXRlczogbWF4QXR0cmlidXRlcyxcbiAgICBtYXhWZXJ0ZXhVbmlmb3JtczogbWF4VmVydGV4VW5pZm9ybXMsXG4gICAgbWF4VmFyeWluZ3M6IG1heFZhcnlpbmdzLFxuICAgIG1heEZyYWdtZW50VW5pZm9ybXM6IG1heEZyYWdtZW50VW5pZm9ybXMsXG4gICAgdmVydGV4VGV4dHVyZXM6IHZlcnRleFRleHR1cmVzLFxuICAgIGZsb2F0RnJhZ21lbnRUZXh0dXJlczogZmxvYXRGcmFnbWVudFRleHR1cmVzLFxuICAgIGZsb2F0VmVydGV4VGV4dHVyZXM6IGZsb2F0VmVydGV4VGV4dHVyZXMsXG4gICAgbWF4U2FtcGxlczogbWF4U2FtcGxlc1xuICB9O1xufVxuXG5mdW5jdGlvbiBXZWJHTENsaXBwaW5nKHByb3BlcnRpZXMpIHtcbiAgdmFyIHNjb3BlID0gdGhpcztcbiAgdmFyIGdsb2JhbFN0YXRlID0gbnVsbCxcbiAgICAgIG51bUdsb2JhbFBsYW5lcyA9IDAsXG4gICAgICBsb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlLFxuICAgICAgcmVuZGVyaW5nU2hhZG93cyA9IGZhbHNlO1xuICB2YXIgcGxhbmUgPSBuZXcgUGxhbmUoKSxcbiAgICAgIHZpZXdOb3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLFxuICAgICAgdW5pZm9ybSA9IHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICBuZWVkc1VwZGF0ZTogZmFsc2VcbiAgfTtcbiAgdGhpcy51bmlmb3JtID0gdW5pZm9ybTtcbiAgdGhpcy5udW1QbGFuZXMgPSAwO1xuICB0aGlzLm51bUludGVyc2VjdGlvbiA9IDA7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKHBsYW5lcywgZW5hYmxlTG9jYWxDbGlwcGluZywgY2FtZXJhKSB7XG4gICAgdmFyIGVuYWJsZWQgPSBwbGFuZXMubGVuZ3RoICE9PSAwIHx8IGVuYWJsZUxvY2FsQ2xpcHBpbmcgfHwgLy8gZW5hYmxlIHN0YXRlIG9mIHByZXZpb3VzIGZyYW1lIC0gdGhlIGNsaXBwaW5nIGNvZGUgaGFzIHRvXG4gICAgLy8gcnVuIGFub3RoZXIgZnJhbWUgaW4gb3JkZXIgdG8gcmVzZXQgdGhlIHN0YXRlOlxuICAgIG51bUdsb2JhbFBsYW5lcyAhPT0gMCB8fCBsb2NhbENsaXBwaW5nRW5hYmxlZDtcbiAgICBsb2NhbENsaXBwaW5nRW5hYmxlZCA9IGVuYWJsZUxvY2FsQ2xpcHBpbmc7XG4gICAgZ2xvYmFsU3RhdGUgPSBwcm9qZWN0UGxhbmVzKHBsYW5lcywgY2FtZXJhLCAwKTtcbiAgICBudW1HbG9iYWxQbGFuZXMgPSBwbGFuZXMubGVuZ3RoO1xuICAgIHJldHVybiBlbmFibGVkO1xuICB9O1xuXG4gIHRoaXMuYmVnaW5TaGFkb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIHJlbmRlcmluZ1NoYWRvd3MgPSB0cnVlO1xuICAgIHByb2plY3RQbGFuZXMobnVsbCk7XG4gIH07XG5cbiAgdGhpcy5lbmRTaGFkb3dzID0gZnVuY3Rpb24gKCkge1xuICAgIHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZTtcbiAgICByZXNldEdsb2JhbFN0YXRlKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChtYXRlcmlhbCwgY2FtZXJhLCB1c2VDYWNoZSkge1xuICAgIHZhciBwbGFuZXMgPSBtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcyxcbiAgICAgICAgY2xpcEludGVyc2VjdGlvbiA9IG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb24sXG4gICAgICAgIGNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XG4gICAgdmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcblxuICAgIGlmICghbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHwgcGxhbmVzID09PSBudWxsIHx8IHBsYW5lcy5sZW5ndGggPT09IDAgfHwgcmVuZGVyaW5nU2hhZG93cyAmJiAhY2xpcFNoYWRvd3MpIHtcbiAgICAgIC8vIHRoZXJlJ3Mgbm8gbG9jYWwgY2xpcHBpbmdcbiAgICAgIGlmIChyZW5kZXJpbmdTaGFkb3dzKSB7XG4gICAgICAgIC8vIHRoZXJlJ3Mgbm8gZ2xvYmFsIGNsaXBwaW5nXG4gICAgICAgIHByb2plY3RQbGFuZXMobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEdsb2JhbFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuR2xvYmFsID0gcmVuZGVyaW5nU2hhZG93cyA/IDAgOiBudW1HbG9iYWxQbGFuZXMsXG4gICAgICAgICAgbEdsb2JhbCA9IG5HbG9iYWwgKiA0O1xuICAgICAgdmFyIGRzdEFycmF5ID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmNsaXBwaW5nU3RhdGUgfHwgbnVsbDtcbiAgICAgIHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTsgLy8gZW5zdXJlIHVuaXF1ZSBzdGF0ZVxuXG4gICAgICBkc3RBcnJheSA9IHByb2plY3RQbGFuZXMocGxhbmVzLCBjYW1lcmEsIGxHbG9iYWwsIHVzZUNhY2hlKTtcblxuICAgICAgZm9yICh2YXIgX2k4MSA9IDA7IF9pODEgIT09IGxHbG9iYWw7ICsrX2k4MSkge1xuICAgICAgICBkc3RBcnJheVtfaTgxXSA9IGdsb2JhbFN0YXRlW19pODFdO1xuICAgICAgfVxuXG4gICAgICBtYXRlcmlhbFByb3BlcnRpZXMuY2xpcHBpbmdTdGF0ZSA9IGRzdEFycmF5O1xuICAgICAgdGhpcy5udW1JbnRlcnNlY3Rpb24gPSBjbGlwSW50ZXJzZWN0aW9uID8gdGhpcy5udW1QbGFuZXMgOiAwO1xuICAgICAgdGhpcy5udW1QbGFuZXMgKz0gbkdsb2JhbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcbiAgICBpZiAodW5pZm9ybS52YWx1ZSAhPT0gZ2xvYmFsU3RhdGUpIHtcbiAgICAgIHVuaWZvcm0udmFsdWUgPSBnbG9iYWxTdGF0ZTtcbiAgICAgIHVuaWZvcm0ubmVlZHNVcGRhdGUgPSBudW1HbG9iYWxQbGFuZXMgPiAwO1xuICAgIH1cblxuICAgIHNjb3BlLm51bVBsYW5lcyA9IG51bUdsb2JhbFBsYW5lcztcbiAgICBzY29wZS5udW1JbnRlcnNlY3Rpb24gPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvamVjdFBsYW5lcyhwbGFuZXMsIGNhbWVyYSwgZHN0T2Zmc2V0LCBza2lwVHJhbnNmb3JtKSB7XG4gICAgdmFyIG5QbGFuZXMgPSBwbGFuZXMgIT09IG51bGwgPyBwbGFuZXMubGVuZ3RoIDogMDtcbiAgICB2YXIgZHN0QXJyYXkgPSBudWxsO1xuXG4gICAgaWYgKG5QbGFuZXMgIT09IDApIHtcbiAgICAgIGRzdEFycmF5ID0gdW5pZm9ybS52YWx1ZTtcblxuICAgICAgaWYgKHNraXBUcmFuc2Zvcm0gIT09IHRydWUgfHwgZHN0QXJyYXkgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGZsYXRTaXplID0gZHN0T2Zmc2V0ICsgblBsYW5lcyAqIDQsXG4gICAgICAgICAgICB2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcbiAgICAgICAgdmlld05vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgodmlld01hdHJpeCk7XG5cbiAgICAgICAgaWYgKGRzdEFycmF5ID09PSBudWxsIHx8IGRzdEFycmF5Lmxlbmd0aCA8IGZsYXRTaXplKSB7XG4gICAgICAgICAgZHN0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXRTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pODIgPSAwLCBpNCA9IGRzdE9mZnNldDsgX2k4MiAhPT0gblBsYW5lczsgKytfaTgyLCBpNCArPSA0KSB7XG4gICAgICAgICAgcGxhbmUuY29weShwbGFuZXNbX2k4Ml0pLmFwcGx5TWF0cml4NCh2aWV3TWF0cml4LCB2aWV3Tm9ybWFsTWF0cml4KTtcbiAgICAgICAgICBwbGFuZS5ub3JtYWwudG9BcnJheShkc3RBcnJheSwgaTQpO1xuICAgICAgICAgIGRzdEFycmF5W2k0ICsgM10gPSBwbGFuZS5jb25zdGFudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7XG4gICAgICB1bmlmb3JtLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xuICAgIHNjb3BlLm51bUludGVyc2VjdGlvbiA9IDA7XG4gICAgcmV0dXJuIGRzdEFycmF5O1xuICB9XG59XG5cbmZ1bmN0aW9uIFdlYkdMQ3ViZU1hcHMocmVuZGVyZXIpIHtcbiAgdmFyIGN1YmVtYXBzID0gbmV3IFdlYWtNYXAoKTtcblxuICBmdW5jdGlvbiBtYXBUZXh0dXJlTWFwcGluZyh0ZXh0dXJlLCBtYXBwaW5nKSB7XG4gICAgaWYgKG1hcHBpbmcgPT09IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nKSB7XG4gICAgICB0ZXh0dXJlLm1hcHBpbmcgPSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG4gICAgfSBlbHNlIGlmIChtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZykge1xuICAgICAgdGV4dHVyZS5tYXBwaW5nID0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KHRleHR1cmUpIHtcbiAgICBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzVGV4dHVyZSAmJiB0ZXh0dXJlLmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGV4dHVyZS5tYXBwaW5nO1xuXG4gICAgICBpZiAobWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcpIHtcbiAgICAgICAgaWYgKGN1YmVtYXBzLmhhcyh0ZXh0dXJlKSkge1xuICAgICAgICAgIHZhciBjdWJlbWFwID0gY3ViZW1hcHMuZ2V0KHRleHR1cmUpLnRleHR1cmU7XG4gICAgICAgICAgcmV0dXJuIG1hcFRleHR1cmVNYXBwaW5nKGN1YmVtYXAsIHRleHR1cmUubWFwcGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuICAgICAgICAgIGlmIChpbWFnZSAmJiBpbWFnZS5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMQ3ViZVJlbmRlclRhcmdldChpbWFnZS5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldC5mcm9tRXF1aXJlY3Rhbmd1bGFyVGV4dHVyZShyZW5kZXJlciwgdGV4dHVyZSk7XG4gICAgICAgICAgICBjdWJlbWFwcy5zZXQodGV4dHVyZSwgcmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICAgIHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcFRleHR1cmVNYXBwaW5nKHJlbmRlclRhcmdldC50ZXh0dXJlLCB0ZXh0dXJlLm1hcHBpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbWFnZSBub3QgeWV0IHJlYWR5LiB0cnkgdGhlIGNvbnZlcnNpb24gbmV4dCBmcmFtZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICBmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKGV2ZW50KSB7XG4gICAgdmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG4gICAgdGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG4gICAgdmFyIGN1YmVtYXAgPSBjdWJlbWFwcy5nZXQodGV4dHVyZSk7XG5cbiAgICBpZiAoY3ViZW1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdWJlbWFwcy5kZWxldGUodGV4dHVyZSk7XG4gICAgICBjdWJlbWFwLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGN1YmVtYXBzID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXQsXG4gICAgZGlzcG9zZTogZGlzcG9zZVxuICB9O1xufVxuXG52YXIgT3J0aG9ncmFwaGljQ2FtZXJhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2FtZXJhMikge1xuICBfaW5oZXJpdHMoT3J0aG9ncmFwaGljQ2FtZXJhLCBfQ2FtZXJhMik7XG5cbiAgdmFyIF9zdXBlcjMxID0gX2NyZWF0ZVN1cGVyKE9ydGhvZ3JhcGhpY0NhbWVyYSk7XG5cbiAgZnVuY3Rpb24gT3J0aG9ncmFwaGljQ2FtZXJhKCkge1xuICAgIHZhciBfdGhpczIzO1xuXG4gICAgdmFyIGxlZnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IC0xO1xuICAgIHZhciByaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICB2YXIgdG9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgIHZhciBib3R0b20gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IC0xO1xuICAgIHZhciBuZWFyID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwLjE7XG4gICAgdmFyIGZhciA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMjAwMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcnRob2dyYXBoaWNDYW1lcmEpO1xuXG4gICAgX3RoaXMyMyA9IF9zdXBlcjMxLmNhbGwodGhpcyk7XG4gICAgX3RoaXMyMy5pc09ydGhvZ3JhcGhpY0NhbWVyYSA9IHRydWU7XG4gICAgX3RoaXMyMy50eXBlID0gJ09ydGhvZ3JhcGhpY0NhbWVyYSc7XG4gICAgX3RoaXMyMy56b29tID0gMTtcbiAgICBfdGhpczIzLnZpZXcgPSBudWxsO1xuICAgIF90aGlzMjMubGVmdCA9IGxlZnQ7XG4gICAgX3RoaXMyMy5yaWdodCA9IHJpZ2h0O1xuICAgIF90aGlzMjMudG9wID0gdG9wO1xuICAgIF90aGlzMjMuYm90dG9tID0gYm90dG9tO1xuICAgIF90aGlzMjMubmVhciA9IG5lYXI7XG4gICAgX3RoaXMyMy5mYXIgPSBmYXI7XG5cbiAgICBfdGhpczIzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIHJldHVybiBfdGhpczIzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9ydGhvZ3JhcGhpY0NhbWVyYSwgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihPcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlLCByZWN1cnNpdmUpO1xuXG4gICAgICB0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSBzb3VyY2UucmlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHNvdXJjZS50b3A7XG4gICAgICB0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XG4gICAgICB0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcbiAgICAgIHRoaXMuZmFyID0gc291cmNlLmZhcjtcbiAgICAgIHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuICAgICAgdGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLnZpZXcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFZpZXdPZmZzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Vmlld09mZnNldChmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy52aWV3ID0ge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgZnVsbFdpZHRoOiAxLFxuICAgICAgICAgIGZ1bGxIZWlnaHQ6IDEsXG4gICAgICAgICAgb2Zmc2V0WDogMCxcbiAgICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xuICAgICAgdGhpcy52aWV3LmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xuICAgICAgdGhpcy52aWV3Lm9mZnNldFggPSB4O1xuICAgICAgdGhpcy52aWV3Lm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy52aWV3LndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyVmlld09mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclZpZXdPZmZzZXQoKSB7XG4gICAgICBpZiAodGhpcy52aWV3ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudmlldy5lbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKSB7XG4gICAgICB2YXIgZHggPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCkgLyAoMiAqIHRoaXMuem9vbSk7XG4gICAgICB2YXIgZHkgPSAodGhpcy50b3AgLSB0aGlzLmJvdHRvbSkgLyAoMiAqIHRoaXMuem9vbSk7XG4gICAgICB2YXIgY3ggPSAodGhpcy5yaWdodCArIHRoaXMubGVmdCkgLyAyO1xuICAgICAgdmFyIGN5ID0gKHRoaXMudG9wICsgdGhpcy5ib3R0b20pIC8gMjtcbiAgICAgIHZhciBsZWZ0ID0gY3ggLSBkeDtcbiAgICAgIHZhciByaWdodCA9IGN4ICsgZHg7XG4gICAgICB2YXIgdG9wID0gY3kgKyBkeTtcbiAgICAgIHZhciBib3R0b20gPSBjeSAtIGR5O1xuXG4gICAgICBpZiAodGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkKSB7XG4gICAgICAgIHZhciBzY2FsZVcgPSAodGhpcy5yaWdodCAtIHRoaXMubGVmdCkgLyB0aGlzLnZpZXcuZnVsbFdpZHRoIC8gdGhpcy56b29tO1xuICAgICAgICB2YXIgc2NhbGVIID0gKHRoaXMudG9wIC0gdGhpcy5ib3R0b20pIC8gdGhpcy52aWV3LmZ1bGxIZWlnaHQgLyB0aGlzLnpvb207XG4gICAgICAgIGxlZnQgKz0gc2NhbGVXICogdGhpcy52aWV3Lm9mZnNldFg7XG4gICAgICAgIHJpZ2h0ID0gbGVmdCArIHNjYWxlVyAqIHRoaXMudmlldy53aWR0aDtcbiAgICAgICAgdG9wIC09IHNjYWxlSCAqIHRoaXMudmlldy5vZmZzZXRZO1xuICAgICAgICBib3R0b20gPSB0b3AgLSBzY2FsZUggKiB0aGlzLnZpZXcuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyhsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRoaXMubmVhciwgdGhpcy5mYXIpO1xuICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMucHJvamVjdGlvbk1hdHJpeCkuaW52ZXJ0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04obWV0YSkge1xuICAgICAgdmFyIGRhdGEgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihPcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlKSwgXCJ0b0pTT05cIiwgdGhpcykuY2FsbCh0aGlzLCBtZXRhKTtcblxuICAgICAgZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcbiAgICAgIGRhdGEub2JqZWN0LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICBkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG4gICAgICBkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIGRhdGEub2JqZWN0LmJvdHRvbSA9IHRoaXMuYm90dG9tO1xuICAgICAgZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcbiAgICAgIGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuICAgICAgaWYgKHRoaXMudmlldyAhPT0gbnVsbCkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudmlldyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT3J0aG9ncmFwaGljQ2FtZXJhO1xufShDYW1lcmEpO1xuXG52YXIgTE9EX01JTiA9IDQ7IC8vIFRoZSBzdGFuZGFyZCBkZXZpYXRpb25zIChyYWRpYW5zKSBhc3NvY2lhdGVkIHdpdGggdGhlIGV4dHJhIG1pcHMuIFRoZXNlIGFyZVxuLy8gY2hvc2VuIHRvIGFwcHJveGltYXRlIGEgVHJvd2JyaWRnZS1SZWl0eiBkaXN0cmlidXRpb24gZnVuY3Rpb24gdGltZXMgdGhlXG4vLyBnZW9tZXRyaWMgc2hhZG93aW5nIGZ1bmN0aW9uLiBUaGVzZSBzaWdtYSB2YWx1ZXMgc3F1YXJlZCBtdXN0IG1hdGNoIHRoZVxuLy8gdmFyaWFuY2UgI2RlZmluZXMgaW4gY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50Lmdsc2wuanMuXG5cbnZhciBFWFRSQV9MT0RfU0lHTUEgPSBbMC4xMjUsIDAuMjE1LCAwLjM1LCAwLjQ0NiwgMC41MjYsIDAuNTgyXTsgLy8gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBibHVyIGZvciBsb29wLiBTbWFsbGVyIHNpZ21hcyB3aWxsIHVzZSBmZXdlclxuLy8gc2FtcGxlcyBhbmQgZXhpdCBlYXJseSwgYnV0IG5vdCByZWNvbXBpbGUgdGhlIHNoYWRlci5cblxudmFyIE1BWF9TQU1QTEVTID0gMjA7XG5cbnZhciBfZmxhdENhbWVyYSA9IC8qQF9fUFVSRV9fKi9uZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCk7XG5cbnZhciBfY2xlYXJDb2xvciA9IC8qQF9fUFVSRV9fKi9uZXcgQ29sb3IoKTtcblxudmFyIF9vbGRUYXJnZXQgPSBudWxsOyAvLyBHb2xkZW4gUmF0aW9cblxudmFyIFBISSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG52YXIgSU5WX1BISSA9IDEgLyBQSEk7IC8vIFZlcnRpY2VzIG9mIGEgZG9kZWNhaGVkcm9uIChleGNlcHQgdGhlIG9wcG9zaXRlcywgd2hpY2ggcmVwcmVzZW50IHRoZVxuLy8gc2FtZSBheGlzKSwgdXNlZCBhcyBheGlzIGRpcmVjdGlvbnMgZXZlbmx5IHNwcmVhZCBvbiBhIHNwaGVyZS5cblxudmFyIF9heGlzRGlyZWN0aW9ucyA9IFsvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMSwgMSwgMSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygtMSwgMSwgMSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygxLCAxLCAtMSksIC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygtMSwgMSwgLTEpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoMCwgUEhJLCBJTlZfUEhJKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKDAsIFBISSwgLUlOVl9QSEkpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoSU5WX1BISSwgMCwgUEhJKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKC1JTlZfUEhJLCAwLCBQSEkpLCAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoUEhJLCBJTlZfUEhJLCAwKSwgLypAX19QVVJFX18qL25ldyBWZWN0b3IzKC1QSEksIElOVl9QSEksIDApXTtcbi8qKlxuICogVGhpcyBjbGFzcyBnZW5lcmF0ZXMgYSBQcmVmaWx0ZXJlZCwgTWlwbWFwcGVkIFJhZGlhbmNlIEVudmlyb25tZW50IE1hcFxuICogKFBNUkVNKSBmcm9tIGEgY3ViZU1hcCBlbnZpcm9ubWVudCB0ZXh0dXJlLiBUaGlzIGFsbG93cyBkaWZmZXJlbnQgbGV2ZWxzIG9mXG4gKiBibHVyIHRvIGJlIHF1aWNrbHkgYWNjZXNzZWQgYmFzZWQgb24gbWF0ZXJpYWwgcm91Z2huZXNzLiBJdCBpcyBwYWNrZWQgaW50byBhXG4gKiBzcGVjaWFsIEN1YmVVViBmb3JtYXQgdGhhdCBhbGxvd3MgdXMgdG8gcGVyZm9ybSBjdXN0b20gaW50ZXJwb2xhdGlvbiBzbyB0aGF0XG4gKiB3ZSBjYW4gc3VwcG9ydCBub25saW5lYXIgZm9ybWF0cyBzdWNoIGFzIFJHQkUuIFVubGlrZSBhIHRyYWRpdGlvbmFsIG1pcG1hcFxuICogY2hhaW4sIGl0IG9ubHkgZ29lcyBkb3duIHRvIHRoZSBMT0RfTUlOIGxldmVsIChhYm92ZSksIGFuZCB0aGVuIGNyZWF0ZXMgZXh0cmFcbiAqIGV2ZW4gbW9yZSBmaWx0ZXJlZCAnbWlwcycgYXQgdGhlIHNhbWUgTE9EX01JTiByZXNvbHV0aW9uLCBhc3NvY2lhdGVkIHdpdGhcbiAqIGhpZ2hlciByb3VnaG5lc3MgbGV2ZWxzLiBJbiB0aGlzIHdheSB3ZSBtYWludGFpbiByZXNvbHV0aW9uIHRvIHNtb290aGx5XG4gKiBpbnRlcnBvbGF0ZSBkaWZmdXNlIGxpZ2h0aW5nIHdoaWxlIGxpbWl0aW5nIHNhbXBsaW5nIGNvbXB1dGF0aW9uLlxuICpcbiAqIFBhcGVyOiBGYXN0LCBBY2N1cmF0ZSBJbWFnZS1CYXNlZCBMaWdodGluZ1xuICogaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8xNXk4cl9VcEtsVTlTdlY0SUxiMEMzcUNQZWNTOHB2THovdmlld1xuKi9cblxudmFyIFBNUkVNR2VuZXJhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUE1SRU1HZW5lcmF0b3IocmVuZGVyZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUE1SRU1HZW5lcmF0b3IpO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fbG9kTWF4ID0gMDtcbiAgICB0aGlzLl9jdWJlU2l6ZSA9IDA7XG4gICAgdGhpcy5fbG9kUGxhbmVzID0gW107XG4gICAgdGhpcy5fc2l6ZUxvZHMgPSBbXTtcbiAgICB0aGlzLl9zaWdtYXMgPSBbXTtcbiAgICB0aGlzLl9ibHVyTWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy5fZXF1aXJlY3RNYXRlcmlhbCA9IG51bGw7XG5cbiAgICB0aGlzLl9jb21waWxlTWF0ZXJpYWwodGhpcy5fYmx1ck1hdGVyaWFsKTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgUE1SRU0gZnJvbSBhIHN1cHBsaWVkIFNjZW5lLCB3aGljaCBjYW4gYmUgZmFzdGVyIHRoYW4gdXNpbmcgYW5cbiAgICogaW1hZ2UgaWYgbmV0d29ya2luZyBiYW5kd2lkdGggaXMgbG93LiBPcHRpb25hbCBzaWdtYSBzcGVjaWZpZXMgYSBibHVyIHJhZGl1c1xuICAgKiBpbiByYWRpYW5zIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNjZW5lIGJlZm9yZSBQTVJFTSBnZW5lcmF0aW9uLiBPcHRpb25hbCBuZWFyXG4gICAqIGFuZCBmYXIgcGxhbmVzIGVuc3VyZSB0aGUgc2NlbmUgaXMgcmVuZGVyZWQgaW4gaXRzIGVudGlyZXR5ICh0aGUgY3ViZUNhbWVyYVxuICAgKiBpcyBwbGFjZWQgYXQgdGhlIG9yaWdpbikuXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFBNUkVNR2VuZXJhdG9yLCBbe1xuICAgIGtleTogXCJmcm9tU2NlbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVNjZW5lKHNjZW5lKSB7XG4gICAgICB2YXIgc2lnbWEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgbmVhciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMC4xO1xuICAgICAgdmFyIGZhciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTAwO1xuICAgICAgX29sZFRhcmdldCA9IHRoaXMuX3JlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuXG4gICAgICB0aGlzLl9zZXRTaXplKDI1Nik7XG5cbiAgICAgIHZhciBjdWJlVVZSZW5kZXJUYXJnZXQgPSB0aGlzLl9hbGxvY2F0ZVRhcmdldHMoKTtcblxuICAgICAgY3ViZVVWUmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fc2NlbmVUb0N1YmVVVihzY2VuZSwgbmVhciwgZmFyLCBjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG4gICAgICBpZiAoc2lnbWEgPiAwKSB7XG4gICAgICAgIHRoaXMuX2JsdXIoY3ViZVVWUmVuZGVyVGFyZ2V0LCAwLCAwLCBzaWdtYSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FwcGx5UE1SRU0oY3ViZVVWUmVuZGVyVGFyZ2V0KTtcblxuICAgICAgdGhpcy5fY2xlYW51cChjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG4gICAgICByZXR1cm4gY3ViZVVWUmVuZGVyVGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGVxdWlyZWN0YW5ndWxhciB0ZXh0dXJlLCB3aGljaCBjYW4gYmUgZWl0aGVyIExEUlxuICAgICAqIG9yIEhEUi4gVGhlIGlkZWFsIGlucHV0IGltYWdlIHNpemUgaXMgMWsgKDEwMjQgeCA1MTIpLFxuICAgICAqIGFzIHRoaXMgbWF0Y2hlcyBiZXN0IHdpdGggdGhlIDI1NiB4IDI1NiBjdWJlbWFwIG91dHB1dC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZyb21FcXVpcmVjdGFuZ3VsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUVxdWlyZWN0YW5ndWxhcihlcXVpcmVjdGFuZ3VsYXIpIHtcbiAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoZXF1aXJlY3Rhbmd1bGFyLCByZW5kZXJUYXJnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBQTVJFTSBmcm9tIGFuIGN1YmVtYXAgdGV4dHVyZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBMRFJcbiAgICAgKiBvciBIRFIuIFRoZSBpZGVhbCBpbnB1dCBjdWJlIHNpemUgaXMgMjU2IHggMjU2LFxuICAgICAqIGFzIHRoaXMgbWF0Y2hlcyBiZXN0IHdpdGggdGhlIDI1NiB4IDI1NiBjdWJlbWFwIG91dHB1dC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZyb21DdWJlbWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21DdWJlbWFwKGN1YmVtYXApIHtcbiAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fZnJvbVRleHR1cmUoY3ViZW1hcCwgcmVuZGVyVGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlLWNvbXBpbGVzIHRoZSBjdWJlbWFwIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xuICAgICAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbXBpbGVDdWJlbWFwU2hhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGVDdWJlbWFwU2hhZGVyKCkge1xuICAgICAgaWYgKHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jdWJlbWFwTWF0ZXJpYWwgPSBfZ2V0Q3ViZW1hcE1hdGVyaWFsKCk7XG5cbiAgICAgICAgdGhpcy5fY29tcGlsZU1hdGVyaWFsKHRoaXMuX2N1YmVtYXBNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZS1jb21waWxlcyB0aGUgZXF1aXJlY3Rhbmd1bGFyIHNoYWRlci4gWW91IGNhbiBnZXQgZmFzdGVyIHN0YXJ0LXVwIGJ5IGludm9raW5nIHRoaXMgbWV0aG9kIGR1cmluZ1xuICAgICAqIHlvdXIgdGV4dHVyZSdzIG5ldHdvcmsgZmV0Y2ggZm9yIGluY3JlYXNlZCBjb25jdXJyZW5jeS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbXBpbGVFcXVpcmVjdGFuZ3VsYXJTaGFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZUVxdWlyZWN0YW5ndWxhclNoYWRlcigpIHtcbiAgICAgIGlmICh0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPSBfZ2V0RXF1aXJlY3RNYXRlcmlhbCgpO1xuXG4gICAgICAgIHRoaXMuX2NvbXBpbGVNYXRlcmlhbCh0aGlzLl9lcXVpcmVjdE1hdGVyaWFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgb2YgdGhlIFBNUkVNR2VuZXJhdG9yJ3MgaW50ZXJuYWwgbWVtb3J5LiBOb3RlIHRoYXQgUE1SRU1HZW5lcmF0b3IgaXMgYSBzdGF0aWMgY2xhc3MsXG4gICAgICogc28geW91IHNob3VsZCBub3QgbmVlZCBtb3JlIHRoYW4gb25lIFBNUkVNR2VuZXJhdG9yIG9iamVjdC4gSWYgeW91IGRvLCBjYWxsaW5nIGRpc3Bvc2UoKSBvblxuICAgICAqIG9uZSBvZiB0aGVtIHdpbGwgY2F1c2UgYW55IG90aGVycyB0byBhbHNvIGJlY29tZSB1bnVzYWJsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2UoKTtcblxuICAgICAgaWYgKHRoaXMuX2N1YmVtYXBNYXRlcmlhbCAhPT0gbnVsbCkgdGhpcy5fY3ViZW1hcE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgIGlmICh0aGlzLl9lcXVpcmVjdE1hdGVyaWFsICE9PSBudWxsKSB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB9IC8vIHByaXZhdGUgaW50ZXJmYWNlXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2l6ZShjdWJlU2l6ZSkge1xuICAgICAgdGhpcy5fbG9kTWF4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoY3ViZVNpemUpKTtcbiAgICAgIHRoaXMuX2N1YmVTaXplID0gTWF0aC5wb3coMiwgdGhpcy5fbG9kTWF4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3Bvc2UoKSB7XG4gICAgICBpZiAodGhpcy5fYmx1ck1hdGVyaWFsICE9PSBudWxsKSB0aGlzLl9ibHVyTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgaWYgKHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ICE9PSBudWxsKSB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldC5kaXNwb3NlKCk7XG5cbiAgICAgIGZvciAodmFyIF9pODMgPSAwOyBfaTgzIDwgdGhpcy5fbG9kUGxhbmVzLmxlbmd0aDsgX2k4MysrKSB7XG4gICAgICAgIHRoaXMuX2xvZFBsYW5lc1tfaTgzXS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwKG91dHB1dFRhcmdldCkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KF9vbGRUYXJnZXQpO1xuXG4gICAgICBvdXRwdXRUYXJnZXQuc2Npc3NvclRlc3QgPSBmYWxzZTtcblxuICAgICAgX3NldFZpZXdwb3J0KG91dHB1dFRhcmdldCwgMCwgMCwgb3V0cHV0VGFyZ2V0LndpZHRoLCBvdXRwdXRUYXJnZXQuaGVpZ2h0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Zyb21UZXh0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mcm9tVGV4dHVyZSh0ZXh0dXJlLCByZW5kZXJUYXJnZXQpIHtcbiAgICAgIGlmICh0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB8fCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZyYWN0aW9uTWFwcGluZykge1xuICAgICAgICB0aGlzLl9zZXRTaXplKHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSAwID8gMTYgOiB0ZXh0dXJlLmltYWdlWzBdLndpZHRoIHx8IHRleHR1cmUuaW1hZ2VbMF0uaW1hZ2Uud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXF1aXJlY3Rhbmd1bGFyXG4gICAgICAgIHRoaXMuX3NldFNpemUodGV4dHVyZS5pbWFnZS53aWR0aCAvIDQpO1xuICAgICAgfVxuXG4gICAgICBfb2xkVGFyZ2V0ID0gdGhpcy5fcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cbiAgICAgIHZhciBjdWJlVVZSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQgfHwgdGhpcy5fYWxsb2NhdGVUYXJnZXRzKCk7XG5cbiAgICAgIHRoaXMuX3RleHR1cmVUb0N1YmVVVih0ZXh0dXJlLCBjdWJlVVZSZW5kZXJUYXJnZXQpO1xuXG4gICAgICB0aGlzLl9hcHBseVBNUkVNKGN1YmVVVlJlbmRlclRhcmdldCk7XG5cbiAgICAgIHRoaXMuX2NsZWFudXAoY3ViZVVWUmVuZGVyVGFyZ2V0KTtcblxuICAgICAgcmV0dXJuIGN1YmVVVlJlbmRlclRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FsbG9jYXRlVGFyZ2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWxsb2NhdGVUYXJnZXRzKCkge1xuICAgICAgdmFyIHdpZHRoID0gMyAqIE1hdGgubWF4KHRoaXMuX2N1YmVTaXplLCAxNiAqIDcpO1xuICAgICAgdmFyIGhlaWdodCA9IDQgKiB0aGlzLl9jdWJlU2l6ZTtcbiAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIG1hZ0ZpbHRlcjogTGluZWFyRmlsdGVyLFxuICAgICAgICBtaW5GaWx0ZXI6IExpbmVhckZpbHRlcixcbiAgICAgICAgZ2VuZXJhdGVNaXBtYXBzOiBmYWxzZSxcbiAgICAgICAgdHlwZTogSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgZm9ybWF0OiBSR0JBRm9ybWF0LFxuICAgICAgICBlbmNvZGluZzogTGluZWFyRW5jb2RpbmcsXG4gICAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgdmFyIGN1YmVVVlJlbmRlclRhcmdldCA9IF9jcmVhdGVSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgcGFyYW1zKTtcblxuICAgICAgaWYgKHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0ID09PSBudWxsIHx8IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0LndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICBpZiAodGhpcy5fcGluZ1BvbmdSZW5kZXJUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9waW5nUG9uZ1JlbmRlclRhcmdldCA9IF9jcmVhdGVSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgcGFyYW1zKTtcbiAgICAgICAgdmFyIF9sb2RNYXggPSB0aGlzLl9sb2RNYXg7XG5cbiAgICAgICAgdmFyIF9jcmVhdGVQbGFuZXMyID0gX2NyZWF0ZVBsYW5lcyhfbG9kTWF4KTtcblxuICAgICAgICB0aGlzLl9zaXplTG9kcyA9IF9jcmVhdGVQbGFuZXMyLnNpemVMb2RzO1xuICAgICAgICB0aGlzLl9sb2RQbGFuZXMgPSBfY3JlYXRlUGxhbmVzMi5sb2RQbGFuZXM7XG4gICAgICAgIHRoaXMuX3NpZ21hcyA9IF9jcmVhdGVQbGFuZXMyLnNpZ21hcztcbiAgICAgICAgdGhpcy5fYmx1ck1hdGVyaWFsID0gX2dldEJsdXJTaGFkZXIoX2xvZE1heCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb21waWxlTWF0ZXJpYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBpbGVNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgICAgdmFyIHRtcE1lc2ggPSBuZXcgTWVzaCh0aGlzLl9sb2RQbGFuZXNbMF0sIG1hdGVyaWFsKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZXIuY29tcGlsZSh0bXBNZXNoLCBfZmxhdENhbWVyYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zY2VuZVRvQ3ViZVVWXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY2VuZVRvQ3ViZVVWKHNjZW5lLCBuZWFyLCBmYXIsIGN1YmVVVlJlbmRlclRhcmdldCkge1xuICAgICAgdmFyIGZvdiA9IDkwO1xuICAgICAgdmFyIGFzcGVjdCA9IDE7XG4gICAgICB2YXIgY3ViZUNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShmb3YsIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgICAgIHZhciB1cFNpZ24gPSBbMSwgLTEsIDEsIDEsIDEsIDFdO1xuICAgICAgdmFyIGZvcndhcmRTaWduID0gWzEsIDEsIDEsIC0xLCAtMSwgLTFdO1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgICB2YXIgb3JpZ2luYWxBdXRvQ2xlYXIgPSByZW5kZXJlci5hdXRvQ2xlYXI7XG4gICAgICB2YXIgdG9uZU1hcHBpbmcgPSByZW5kZXJlci50b25lTWFwcGluZztcbiAgICAgIHJlbmRlcmVyLmdldENsZWFyQ29sb3IoX2NsZWFyQ29sb3IpO1xuICAgICAgcmVuZGVyZXIudG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuICAgICAgcmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XG4gICAgICB2YXIgYmFja2dyb3VuZE1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgbmFtZTogJ1BNUkVNLkJhY2tncm91bmQnLFxuICAgICAgICBzaWRlOiBCYWNrU2lkZSxcbiAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgIGRlcHRoVGVzdDogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdmFyIGJhY2tncm91bmRCb3ggPSBuZXcgTWVzaChuZXcgQm94R2VvbWV0cnkoKSwgYmFja2dyb3VuZE1hdGVyaWFsKTtcbiAgICAgIHZhciB1c2VTb2xpZENvbG9yID0gZmFsc2U7XG4gICAgICB2YXIgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG5cbiAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kLmlzQ29sb3IpIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kTWF0ZXJpYWwuY29sb3IuY29weShiYWNrZ3JvdW5kKTtcbiAgICAgICAgICBzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICB1c2VTb2xpZENvbG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFja2dyb3VuZE1hdGVyaWFsLmNvbG9yLmNvcHkoX2NsZWFyQ29sb3IpO1xuICAgICAgICB1c2VTb2xpZENvbG9yID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2k4NCA9IDA7IF9pODQgPCA2OyBfaTg0KyspIHtcbiAgICAgICAgdmFyIGNvbCA9IF9pODQgJSAzO1xuXG4gICAgICAgIGlmIChjb2wgPT09IDApIHtcbiAgICAgICAgICBjdWJlQ2FtZXJhLnVwLnNldCgwLCB1cFNpZ25bX2k4NF0sIDApO1xuICAgICAgICAgIGN1YmVDYW1lcmEubG9va0F0KGZvcndhcmRTaWduW19pODRdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2wgPT09IDEpIHtcbiAgICAgICAgICBjdWJlQ2FtZXJhLnVwLnNldCgwLCAwLCB1cFNpZ25bX2k4NF0pO1xuICAgICAgICAgIGN1YmVDYW1lcmEubG9va0F0KDAsIGZvcndhcmRTaWduW19pODRdLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWJlQ2FtZXJhLnVwLnNldCgwLCB1cFNpZ25bX2k4NF0sIDApO1xuICAgICAgICAgIGN1YmVDYW1lcmEubG9va0F0KDAsIDAsIGZvcndhcmRTaWduW19pODRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaXplID0gdGhpcy5fY3ViZVNpemU7XG5cbiAgICAgICAgX3NldFZpZXdwb3J0KGN1YmVVVlJlbmRlclRhcmdldCwgY29sICogc2l6ZSwgX2k4NCA+IDIgPyBzaXplIDogMCwgc2l6ZSwgc2l6ZSk7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KGN1YmVVVlJlbmRlclRhcmdldCk7XG5cbiAgICAgICAgaWYgKHVzZVNvbGlkQ29sb3IpIHtcbiAgICAgICAgICByZW5kZXJlci5yZW5kZXIoYmFja2dyb3VuZEJveCwgY3ViZUNhbWVyYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGN1YmVDYW1lcmEpO1xuICAgICAgfVxuXG4gICAgICBiYWNrZ3JvdW5kQm94Lmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIGJhY2tncm91bmRCb3gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgcmVuZGVyZXIudG9uZU1hcHBpbmcgPSB0b25lTWFwcGluZztcbiAgICAgIHJlbmRlcmVyLmF1dG9DbGVhciA9IG9yaWdpbmFsQXV0b0NsZWFyO1xuICAgICAgc2NlbmUuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90ZXh0dXJlVG9DdWJlVVZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RleHR1cmVUb0N1YmVVVih0ZXh0dXJlLCBjdWJlVVZSZW5kZXJUYXJnZXQpIHtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgICAgdmFyIGlzQ3ViZVRleHR1cmUgPSB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZsZWN0aW9uTWFwcGluZyB8fCB0ZXh0dXJlLm1hcHBpbmcgPT09IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcblxuICAgICAgaWYgKGlzQ3ViZVRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX2N1YmVtYXBNYXRlcmlhbCA9IF9nZXRDdWJlbWFwTWF0ZXJpYWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1YmVtYXBNYXRlcmlhbC51bmlmb3Jtcy5mbGlwRW52TWFwLnZhbHVlID0gdGV4dHVyZS5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlID8gLTEgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2VxdWlyZWN0TWF0ZXJpYWwgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9lcXVpcmVjdE1hdGVyaWFsID0gX2dldEVxdWlyZWN0TWF0ZXJpYWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF0ZXJpYWwgPSBpc0N1YmVUZXh0dXJlID8gdGhpcy5fY3ViZW1hcE1hdGVyaWFsIDogdGhpcy5fZXF1aXJlY3RNYXRlcmlhbDtcbiAgICAgIHZhciBtZXNoID0gbmV3IE1lc2godGhpcy5fbG9kUGxhbmVzWzBdLCBtYXRlcmlhbCk7XG4gICAgICB2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbC51bmlmb3JtcztcbiAgICAgIHVuaWZvcm1zWydlbnZNYXAnXS52YWx1ZSA9IHRleHR1cmU7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX2N1YmVTaXplO1xuXG4gICAgICBfc2V0Vmlld3BvcnQoY3ViZVVWUmVuZGVyVGFyZ2V0LCAwLCAwLCAzICogc2l6ZSwgMiAqIHNpemUpO1xuXG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoY3ViZVVWUmVuZGVyVGFyZ2V0KTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihtZXNoLCBfZmxhdENhbWVyYSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseVBNUkVNXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseVBNUkVNKGN1YmVVVlJlbmRlclRhcmdldCkge1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgICB2YXIgYXV0b0NsZWFyID0gcmVuZGVyZXIuYXV0b0NsZWFyO1xuICAgICAgcmVuZGVyZXIuYXV0b0NsZWFyID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIF9pODUgPSAxOyBfaTg1IDwgdGhpcy5fbG9kUGxhbmVzLmxlbmd0aDsgX2k4NSsrKSB7XG4gICAgICAgIHZhciBzaWdtYSA9IE1hdGguc3FydCh0aGlzLl9zaWdtYXNbX2k4NV0gKiB0aGlzLl9zaWdtYXNbX2k4NV0gLSB0aGlzLl9zaWdtYXNbX2k4NSAtIDFdICogdGhpcy5fc2lnbWFzW19pODUgLSAxXSk7XG4gICAgICAgIHZhciBwb2xlQXhpcyA9IF9heGlzRGlyZWN0aW9uc1soX2k4NSAtIDEpICUgX2F4aXNEaXJlY3Rpb25zLmxlbmd0aF07XG5cbiAgICAgICAgdGhpcy5fYmx1cihjdWJlVVZSZW5kZXJUYXJnZXQsIF9pODUgLSAxLCBfaTg1LCBzaWdtYSwgcG9sZUF4aXMpO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5hdXRvQ2xlYXIgPSBhdXRvQ2xlYXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSB0d28tcGFzcyBHYXVzc2lhbiBibHVyIGZvciBhIGN1YmVtYXAuIE5vcm1hbGx5IHRoaXMgaXMgZG9uZVxuICAgICAqIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSwgYnV0IHRoaXMgYnJlYWtzIGRvd24gb24gYSBjdWJlLiBIZXJlIHdlIGFwcGx5XG4gICAgICogdGhlIGJsdXIgbGF0aXR1ZGluYWxseSAoYXJvdW5kIHRoZSBwb2xlcyksIGFuZCB0aGVuIGxvbmdpdHVkaW5hbGx5ICh0b3dhcmRzXG4gICAgICogdGhlIHBvbGVzKSB0byBhcHByb3hpbWF0ZSB0aGUgb3J0aG9nb25hbGx5LXNlcGFyYWJsZSBibHVyLiBJdCBpcyBsZWFzdFxuICAgICAqIGFjY3VyYXRlIGF0IHRoZSBwb2xlcywgYnV0IHN0aWxsIGRvZXMgYSBkZWNlbnQgam9iLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JsdXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JsdXIoY3ViZVVWUmVuZGVyVGFyZ2V0LCBsb2RJbiwgbG9kT3V0LCBzaWdtYSwgcG9sZUF4aXMpIHtcbiAgICAgIHZhciBwaW5nUG9uZ1JlbmRlclRhcmdldCA9IHRoaXMuX3BpbmdQb25nUmVuZGVyVGFyZ2V0O1xuXG4gICAgICB0aGlzLl9oYWxmQmx1cihjdWJlVVZSZW5kZXJUYXJnZXQsIHBpbmdQb25nUmVuZGVyVGFyZ2V0LCBsb2RJbiwgbG9kT3V0LCBzaWdtYSwgJ2xhdGl0dWRpbmFsJywgcG9sZUF4aXMpO1xuXG4gICAgICB0aGlzLl9oYWxmQmx1cihwaW5nUG9uZ1JlbmRlclRhcmdldCwgY3ViZVVWUmVuZGVyVGFyZ2V0LCBsb2RPdXQsIGxvZE91dCwgc2lnbWEsICdsb25naXR1ZGluYWwnLCBwb2xlQXhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYWxmQmx1clwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFsZkJsdXIodGFyZ2V0SW4sIHRhcmdldE91dCwgbG9kSW4sIGxvZE91dCwgc2lnbWFSYWRpYW5zLCBkaXJlY3Rpb24sIHBvbGVBeGlzKSB7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICAgIHZhciBibHVyTWF0ZXJpYWwgPSB0aGlzLl9ibHVyTWF0ZXJpYWw7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gIT09ICdsYXRpdHVkaW5hbCcgJiYgZGlyZWN0aW9uICE9PSAnbG9uZ2l0dWRpbmFsJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdibHVyIGRpcmVjdGlvbiBtdXN0IGJlIGVpdGhlciBsYXRpdHVkaW5hbCBvciBsb25naXR1ZGluYWwhJyk7XG4gICAgICB9IC8vIE51bWJlciBvZiBzdGFuZGFyZCBkZXZpYXRpb25zIGF0IHdoaWNoIHRvIGN1dCBvZmYgdGhlIGRpc2NyZXRlIGFwcHJveGltYXRpb24uXG5cblxuICAgICAgdmFyIFNUQU5EQVJEX0RFVklBVElPTlMgPSAzO1xuICAgICAgdmFyIGJsdXJNZXNoID0gbmV3IE1lc2godGhpcy5fbG9kUGxhbmVzW2xvZE91dF0sIGJsdXJNYXRlcmlhbCk7XG4gICAgICB2YXIgYmx1clVuaWZvcm1zID0gYmx1ck1hdGVyaWFsLnVuaWZvcm1zO1xuICAgICAgdmFyIHBpeGVscyA9IHRoaXMuX3NpemVMb2RzW2xvZEluXSAtIDE7XG4gICAgICB2YXIgcmFkaWFuc1BlclBpeGVsID0gaXNGaW5pdGUoc2lnbWFSYWRpYW5zKSA/IE1hdGguUEkgLyAoMiAqIHBpeGVscykgOiAyICogTWF0aC5QSSAvICgyICogTUFYX1NBTVBMRVMgLSAxKTtcbiAgICAgIHZhciBzaWdtYVBpeGVscyA9IHNpZ21hUmFkaWFucyAvIHJhZGlhbnNQZXJQaXhlbDtcbiAgICAgIHZhciBzYW1wbGVzID0gaXNGaW5pdGUoc2lnbWFSYWRpYW5zKSA/IDEgKyBNYXRoLmZsb29yKFNUQU5EQVJEX0RFVklBVElPTlMgKiBzaWdtYVBpeGVscykgOiBNQVhfU0FNUExFUztcblxuICAgICAgaWYgKHNhbXBsZXMgPiBNQVhfU0FNUExFUykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJzaWdtYVJhZGlhbnMsIFwiLmNvbmNhdChzaWdtYVJhZGlhbnMsIFwiLCBpcyB0b28gbGFyZ2UgYW5kIHdpbGwgY2xpcCwgYXMgaXQgcmVxdWVzdGVkIFwiKS5jb25jYXQoc2FtcGxlcywgXCIgc2FtcGxlcyB3aGVuIHRoZSBtYXhpbXVtIGlzIHNldCB0byBcIikuY29uY2F0KE1BWF9TQU1QTEVTKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB3ZWlnaHRzID0gW107XG4gICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgX2k4NiA9IDA7IF9pODYgPCBNQVhfU0FNUExFUzsgKytfaTg2KSB7XG4gICAgICAgIHZhciBfeDIgPSBfaTg2IC8gc2lnbWFQaXhlbHM7XG5cbiAgICAgICAgdmFyIHdlaWdodCA9IE1hdGguZXhwKC1feDIgKiBfeDIgLyAyKTtcbiAgICAgICAgd2VpZ2h0cy5wdXNoKHdlaWdodCk7XG5cbiAgICAgICAgaWYgKF9pODYgPT09IDApIHtcbiAgICAgICAgICBzdW0gKz0gd2VpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKF9pODYgPCBzYW1wbGVzKSB7XG4gICAgICAgICAgc3VtICs9IDIgKiB3ZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2k4NyA9IDA7IF9pODcgPCB3ZWlnaHRzLmxlbmd0aDsgX2k4NysrKSB7XG4gICAgICAgIHdlaWdodHNbX2k4N10gPSB3ZWlnaHRzW19pODddIC8gc3VtO1xuICAgICAgfVxuXG4gICAgICBibHVyVW5pZm9ybXNbJ2Vudk1hcCddLnZhbHVlID0gdGFyZ2V0SW4udGV4dHVyZTtcbiAgICAgIGJsdXJVbmlmb3Jtc1snc2FtcGxlcyddLnZhbHVlID0gc2FtcGxlcztcbiAgICAgIGJsdXJVbmlmb3Jtc1snd2VpZ2h0cyddLnZhbHVlID0gd2VpZ2h0cztcbiAgICAgIGJsdXJVbmlmb3Jtc1snbGF0aXR1ZGluYWwnXS52YWx1ZSA9IGRpcmVjdGlvbiA9PT0gJ2xhdGl0dWRpbmFsJztcblxuICAgICAgaWYgKHBvbGVBeGlzKSB7XG4gICAgICAgIGJsdXJVbmlmb3Jtc1sncG9sZUF4aXMnXS52YWx1ZSA9IHBvbGVBeGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2xvZE1heCA9IHRoaXMuX2xvZE1heDtcbiAgICAgIGJsdXJVbmlmb3Jtc1snZFRoZXRhJ10udmFsdWUgPSByYWRpYW5zUGVyUGl4ZWw7XG4gICAgICBibHVyVW5pZm9ybXNbJ21pcEludCddLnZhbHVlID0gX2xvZE1heCAtIGxvZEluO1xuICAgICAgdmFyIG91dHB1dFNpemUgPSB0aGlzLl9zaXplTG9kc1tsb2RPdXRdO1xuICAgICAgdmFyIHggPSAzICogb3V0cHV0U2l6ZSAqIChsb2RPdXQgPiBfbG9kTWF4IC0gTE9EX01JTiA/IGxvZE91dCAtIF9sb2RNYXggKyBMT0RfTUlOIDogMCk7XG4gICAgICB2YXIgeSA9IDQgKiAodGhpcy5fY3ViZVNpemUgLSBvdXRwdXRTaXplKTtcblxuICAgICAgX3NldFZpZXdwb3J0KHRhcmdldE91dCwgeCwgeSwgMyAqIG91dHB1dFNpemUsIDIgKiBvdXRwdXRTaXplKTtcblxuICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRhcmdldE91dCk7XG4gICAgICByZW5kZXJlci5yZW5kZXIoYmx1ck1lc2gsIF9mbGF0Q2FtZXJhKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUE1SRU1HZW5lcmF0b3I7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVQbGFuZXMobG9kTWF4KSB7XG4gIHZhciBsb2RQbGFuZXMgPSBbXTtcbiAgdmFyIHNpemVMb2RzID0gW107XG4gIHZhciBzaWdtYXMgPSBbXTtcbiAgdmFyIGxvZCA9IGxvZE1heDtcbiAgdmFyIHRvdGFsTG9kcyA9IGxvZE1heCAtIExPRF9NSU4gKyAxICsgRVhUUkFfTE9EX1NJR01BLmxlbmd0aDtcblxuICBmb3IgKHZhciBfaTg4ID0gMDsgX2k4OCA8IHRvdGFsTG9kczsgX2k4OCsrKSB7XG4gICAgdmFyIHNpemVMb2QgPSBNYXRoLnBvdygyLCBsb2QpO1xuICAgIHNpemVMb2RzLnB1c2goc2l6ZUxvZCk7XG4gICAgdmFyIHNpZ21hID0gMS4wIC8gc2l6ZUxvZDtcblxuICAgIGlmIChfaTg4ID4gbG9kTWF4IC0gTE9EX01JTikge1xuICAgICAgc2lnbWEgPSBFWFRSQV9MT0RfU0lHTUFbX2k4OCAtIGxvZE1heCArIExPRF9NSU4gLSAxXTtcbiAgICB9IGVsc2UgaWYgKF9pODggPT09IDApIHtcbiAgICAgIHNpZ21hID0gMDtcbiAgICB9XG5cbiAgICBzaWdtYXMucHVzaChzaWdtYSk7XG4gICAgdmFyIHRleGVsU2l6ZSA9IDEuMCAvIChzaXplTG9kIC0gMik7XG4gICAgdmFyIG1pbiA9IC10ZXhlbFNpemU7XG4gICAgdmFyIG1heCA9IDEgKyB0ZXhlbFNpemU7XG4gICAgdmFyIHV2MSA9IFttaW4sIG1pbiwgbWF4LCBtaW4sIG1heCwgbWF4LCBtaW4sIG1pbiwgbWF4LCBtYXgsIG1pbiwgbWF4XTtcbiAgICB2YXIgY3ViZUZhY2VzID0gNjtcbiAgICB2YXIgdmVydGljZXMgPSA2O1xuICAgIHZhciBwb3NpdGlvblNpemUgPSAzO1xuICAgIHZhciB1dlNpemUgPSAyO1xuICAgIHZhciBmYWNlSW5kZXhTaXplID0gMTtcbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uU2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzKTtcbiAgICB2YXIgdXYgPSBuZXcgRmxvYXQzMkFycmF5KHV2U2l6ZSAqIHZlcnRpY2VzICogY3ViZUZhY2VzKTtcbiAgICB2YXIgZmFjZUluZGV4ID0gbmV3IEZsb2F0MzJBcnJheShmYWNlSW5kZXhTaXplICogdmVydGljZXMgKiBjdWJlRmFjZXMpO1xuXG4gICAgZm9yICh2YXIgZmFjZSA9IDA7IGZhY2UgPCBjdWJlRmFjZXM7IGZhY2UrKykge1xuICAgICAgdmFyIHggPSBmYWNlICUgMyAqIDIgLyAzIC0gMTtcbiAgICAgIHZhciB5ID0gZmFjZSA+IDIgPyAwIDogLTE7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBbeCwgeSwgMCwgeCArIDIgLyAzLCB5LCAwLCB4ICsgMiAvIDMsIHkgKyAxLCAwLCB4LCB5LCAwLCB4ICsgMiAvIDMsIHkgKyAxLCAwLCB4LCB5ICsgMSwgMF07XG4gICAgICBwb3NpdGlvbi5zZXQoY29vcmRpbmF0ZXMsIHBvc2l0aW9uU2l6ZSAqIHZlcnRpY2VzICogZmFjZSk7XG4gICAgICB1di5zZXQodXYxLCB1dlNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UpO1xuICAgICAgdmFyIGZpbGwgPSBbZmFjZSwgZmFjZSwgZmFjZSwgZmFjZSwgZmFjZSwgZmFjZV07XG4gICAgICBmYWNlSW5kZXguc2V0KGZpbGwsIGZhY2VJbmRleFNpemUgKiB2ZXJ0aWNlcyAqIGZhY2UpO1xuICAgIH1cblxuICAgIHZhciBwbGFuZXMgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBwbGFuZXMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIHBvc2l0aW9uU2l6ZSkpO1xuICAgIHBsYW5lcy5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSh1diwgdXZTaXplKSk7XG4gICAgcGxhbmVzLnNldEF0dHJpYnV0ZSgnZmFjZUluZGV4JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShmYWNlSW5kZXgsIGZhY2VJbmRleFNpemUpKTtcbiAgICBsb2RQbGFuZXMucHVzaChwbGFuZXMpO1xuXG4gICAgaWYgKGxvZCA+IExPRF9NSU4pIHtcbiAgICAgIGxvZC0tO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9kUGxhbmVzOiBsb2RQbGFuZXMsXG4gICAgc2l6ZUxvZHM6IHNpemVMb2RzLFxuICAgIHNpZ21hczogc2lnbWFzXG4gIH07XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgcGFyYW1zKSB7XG4gIHZhciBjdWJlVVZSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgcGFyYW1zKTtcbiAgY3ViZVVWUmVuZGVyVGFyZ2V0LnRleHR1cmUubWFwcGluZyA9IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nO1xuICBjdWJlVVZSZW5kZXJUYXJnZXQudGV4dHVyZS5uYW1lID0gJ1BNUkVNLmN1YmVVdic7XG4gIGN1YmVVVlJlbmRlclRhcmdldC5zY2lzc29yVGVzdCA9IHRydWU7XG4gIHJldHVybiBjdWJlVVZSZW5kZXJUYXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9zZXRWaWV3cG9ydCh0YXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdGFyZ2V0LnZpZXdwb3J0LnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgdGFyZ2V0LnNjaXNzb3Iuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBfZ2V0Qmx1clNoYWRlcihsb2RNYXgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHdlaWdodHMgPSBuZXcgRmxvYXQzMkFycmF5KE1BWF9TQU1QTEVTKTtcbiAgdmFyIHBvbGVBeGlzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gIHZhciBzaGFkZXJNYXRlcmlhbCA9IG5ldyBTaGFkZXJNYXRlcmlhbCh7XG4gICAgbmFtZTogJ1NwaGVyaWNhbEdhdXNzaWFuQmx1cicsXG4gICAgZGVmaW5lczoge1xuICAgICAgJ24nOiBNQVhfU0FNUExFUyxcbiAgICAgICdDVUJFVVZfVEVYRUxfV0lEVEgnOiAxLjAgLyB3aWR0aCxcbiAgICAgICdDVUJFVVZfVEVYRUxfSEVJR0hUJzogMS4wIC8gaGVpZ2h0LFxuICAgICAgJ0NVQkVVVl9NQVhfTUlQJzogXCJcIi5jb25jYXQobG9kTWF4LCBcIi4wXCIpXG4gICAgfSxcbiAgICB1bmlmb3Jtczoge1xuICAgICAgJ2Vudk1hcCc6IHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sXG4gICAgICAnc2FtcGxlcyc6IHtcbiAgICAgICAgdmFsdWU6IDFcbiAgICAgIH0sXG4gICAgICAnd2VpZ2h0cyc6IHtcbiAgICAgICAgdmFsdWU6IHdlaWdodHNcbiAgICAgIH0sXG4gICAgICAnbGF0aXR1ZGluYWwnOiB7XG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgICdkVGhldGEnOiB7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9LFxuICAgICAgJ21pcEludCc6IHtcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0sXG4gICAgICAncG9sZUF4aXMnOiB7XG4gICAgICAgIHZhbHVlOiBwb2xlQXhpc1xuICAgICAgfVxuICAgIH0sXG4gICAgdmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG4gICAgZnJhZ21lbnRTaGFkZXI6XG4gICAgLyogZ2xzbCAqL1xuICAgIFwiXFxuXFxuXFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xcblxcblxcdFxcdFxcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXHRcXHRcXHR1bmlmb3JtIGludCBzYW1wbGVzO1xcblxcdFxcdFxcdHVuaWZvcm0gZmxvYXQgd2VpZ2h0c1sgbiBdO1xcblxcdFxcdFxcdHVuaWZvcm0gYm9vbCBsYXRpdHVkaW5hbDtcXG5cXHRcXHRcXHR1bmlmb3JtIGZsb2F0IGRUaGV0YTtcXG5cXHRcXHRcXHR1bmlmb3JtIGZsb2F0IG1pcEludDtcXG5cXHRcXHRcXHR1bmlmb3JtIHZlYzMgcG9sZUF4aXM7XFxuXFxuXFx0XFx0XFx0I2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuXFx0XFx0XFx0I2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG5cXG5cXHRcXHRcXHR2ZWMzIGdldFNhbXBsZSggZmxvYXQgdGhldGEsIHZlYzMgYXhpcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBjb3NUaGV0YSA9IGNvcyggdGhldGEgKTtcXG5cXHRcXHRcXHRcXHQvLyBSb2RyaWd1ZXMnIGF4aXMtYW5nbGUgcm90YXRpb25cXG5cXHRcXHRcXHRcXHR2ZWMzIHNhbXBsZURpcmVjdGlvbiA9IHZPdXRwdXREaXJlY3Rpb24gKiBjb3NUaGV0YVxcblxcdFxcdFxcdFxcdFxcdCsgY3Jvc3MoIGF4aXMsIHZPdXRwdXREaXJlY3Rpb24gKSAqIHNpbiggdGhldGEgKVxcblxcdFxcdFxcdFxcdFxcdCsgYXhpcyAqIGRvdCggYXhpcywgdk91dHB1dERpcmVjdGlvbiApICogKCAxLjAgLSBjb3NUaGV0YSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBiaWxpbmVhckN1YmVVViggZW52TWFwLCBzYW1wbGVEaXJlY3Rpb24sIG1pcEludCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2b2lkIG1haW4oKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBheGlzID0gbGF0aXR1ZGluYWwgPyBwb2xlQXhpcyA6IGNyb3NzKCBwb2xlQXhpcywgdk91dHB1dERpcmVjdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggYWxsKCBlcXVhbCggYXhpcywgdmVjMyggMC4wICkgKSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGF4aXMgPSB2ZWMzKCB2T3V0cHV0RGlyZWN0aW9uLnosIDAuMCwgLSB2T3V0cHV0RGlyZWN0aW9uLnggKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0YXhpcyA9IG5vcm1hbGl6ZSggYXhpcyApO1xcblxcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xcblxcdFxcdFxcdFxcdGdsX0ZyYWdDb2xvci5yZ2IgKz0gd2VpZ2h0c1sgMCBdICogZ2V0U2FtcGxlKCAwLjAsIGF4aXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpbnQgaSA9IDE7IGkgPCBuOyBpKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpID49IHNhbXBsZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGZsb2F0IHRoZXRhID0gZFRoZXRhICogZmxvYXQoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRnbF9GcmFnQ29sb3IucmdiICs9IHdlaWdodHNbIGkgXSAqIGdldFNhbXBsZSggLTEuMCAqIHRoZXRhLCBheGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0Z2xfRnJhZ0NvbG9yLnJnYiArPSB3ZWlnaHRzWyBpIF0gKiBnZXRTYW1wbGUoIHRoZXRhLCBheGlzICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIixcbiAgICBibGVuZGluZzogTm9CbGVuZGluZyxcbiAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgIGRlcHRoV3JpdGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gc2hhZGVyTWF0ZXJpYWw7XG59XG5cbmZ1bmN0aW9uIF9nZXRFcXVpcmVjdE1hdGVyaWFsKCkge1xuICByZXR1cm4gbmV3IFNoYWRlck1hdGVyaWFsKHtcbiAgICBuYW1lOiAnRXF1aXJlY3Rhbmd1bGFyVG9DdWJlVVYnLFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICAnZW52TWFwJzoge1xuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgdmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG4gICAgZnJhZ21lbnRTaGFkZXI6XG4gICAgLyogZ2xzbCAqL1xuICAgIFwiXFxuXFxuXFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xcblxcblxcdFxcdFxcdHZhcnlpbmcgdmVjMyB2T3V0cHV0RGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXG5cXHRcXHRcXHQjaW5jbHVkZSA8Y29tbW9uPlxcblxcblxcdFxcdFxcdHZvaWQgbWFpbigpIHtcXG5cXG5cXHRcXHRcXHRcXHR2ZWMzIG91dHB1dERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdk91dHB1dERpcmVjdGlvbiApO1xcblxcdFxcdFxcdFxcdHZlYzIgdXYgPSBlcXVpcmVjdFV2KCBvdXRwdXREaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQgKCBlbnZNYXAsIHV2ICkucmdiLCAxLjAgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCIsXG4gICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcsXG4gICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICBkZXB0aFdyaXRlOiBmYWxzZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gX2dldEN1YmVtYXBNYXRlcmlhbCgpIHtcbiAgcmV0dXJuIG5ldyBTaGFkZXJNYXRlcmlhbCh7XG4gICAgbmFtZTogJ0N1YmVtYXBUb0N1YmVVVicsXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgICdlbnZNYXAnOiB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuICAgICAgJ2ZsaXBFbnZNYXAnOiB7XG4gICAgICAgIHZhbHVlOiAtMVxuICAgICAgfVxuICAgIH0sXG4gICAgdmVydGV4U2hhZGVyOiBfZ2V0Q29tbW9uVmVydGV4U2hhZGVyKCksXG4gICAgZnJhZ21lbnRTaGFkZXI6XG4gICAgLyogZ2xzbCAqL1xuICAgIFwiXFxuXFxuXFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFx0XFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xcblxcblxcdFxcdFxcdHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcXG5cXG5cXHRcXHRcXHR2YXJ5aW5nIHZlYzMgdk91dHB1dERpcmVjdGlvbjtcXG5cXG5cXHRcXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cXG5cXHRcXHRcXHR2b2lkIG1haW4oKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgdmVjMyggZmxpcEVudk1hcCAqIHZPdXRwdXREaXJlY3Rpb24ueCwgdk91dHB1dERpcmVjdGlvbi55eiApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiLFxuICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuICAgIGRlcHRoVGVzdDogZmFsc2UsXG4gICAgZGVwdGhXcml0ZTogZmFsc2VcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRDb21tb25WZXJ0ZXhTaGFkZXIoKSB7XG4gIHJldHVybiAoXG4gICAgLyogZ2xzbCAqL1xuICAgIFwiXFxuXFxuXFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFx0XFx0cHJlY2lzaW9uIG1lZGl1bXAgaW50O1xcblxcblxcdFxcdGF0dHJpYnV0ZSBmbG9hdCBmYWNlSW5kZXg7XFxuXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZPdXRwdXREaXJlY3Rpb247XFxuXFxuXFx0XFx0Ly8gUkggY29vcmRpbmF0ZSBzeXN0ZW07IFBNUkVNIGZhY2UtaW5kZXhpbmcgY29udmVudGlvblxcblxcdFxcdHZlYzMgZ2V0RGlyZWN0aW9uKCB2ZWMyIHV2LCBmbG9hdCBmYWNlICkge1xcblxcblxcdFxcdFxcdHV2ID0gMi4wICogdXYgLSAxLjA7XFxuXFxuXFx0XFx0XFx0dmVjMyBkaXJlY3Rpb24gPSB2ZWMzKCB1diwgMS4wICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBmYWNlID09IDAuMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4OyAvLyAoIDEsIHYsIHUgKSBwb3MgeFxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gMS4wICkge1xcblxcblxcdFxcdFxcdFxcdGRpcmVjdGlvbiA9IGRpcmVjdGlvbi54enk7XFxuXFx0XFx0XFx0XFx0ZGlyZWN0aW9uLnh6ICo9IC0xLjA7IC8vICggLXUsIDEsIC12ICkgcG9zIHlcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDIuMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb24ueCAqPSAtMS4wOyAvLyAoIC11LCB2LCAxICkgcG9zIHpcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBmYWNlID09IDMuMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb24gPSBkaXJlY3Rpb24uenl4O1xcblxcdFxcdFxcdFxcdGRpcmVjdGlvbi54eiAqPSAtMS4wOyAvLyAoIC0xLCB2LCAtdSApIG5lZyB4XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZmFjZSA9PSA0LjAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGlyZWN0aW9uID0gZGlyZWN0aW9uLnh6eTtcXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb24ueHkgKj0gLTEuMDsgLy8gKCAtdSwgLTEsIHYgKSBuZWcgeVxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGZhY2UgPT0gNS4wICkge1xcblxcblxcdFxcdFxcdFxcdGRpcmVjdGlvbi56ICo9IC0xLjA7IC8vICggdSwgdiwgLTEgKSBuZWcgelxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGlyZWN0aW9uO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2b2lkIG1haW4oKSB7XFxuXFxuXFx0XFx0XFx0dk91dHB1dERpcmVjdGlvbiA9IGdldERpcmVjdGlvbiggdXYsIGZhY2VJbmRleCApO1xcblxcdFxcdFxcdGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcblxcdFxcdH1cXG5cXHRcIlxuICApO1xufVxuXG5mdW5jdGlvbiBXZWJHTEN1YmVVVk1hcHMocmVuZGVyZXIpIHtcbiAgdmFyIGN1YmVVVm1hcHMgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgcG1yZW1HZW5lcmF0b3IgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGdldCh0ZXh0dXJlKSB7XG4gICAgaWYgKHRleHR1cmUgJiYgdGV4dHVyZS5pc1RleHR1cmUpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGV4dHVyZS5tYXBwaW5nO1xuICAgICAgdmFyIGlzRXF1aXJlY3RNYXAgPSBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyB8fCBtYXBwaW5nID09PSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZztcbiAgICAgIHZhciBpc0N1YmVNYXAgPSBtYXBwaW5nID09PSBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgfHwgbWFwcGluZyA9PT0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOyAvLyBlcXVpcmVjdC9jdWJlIG1hcCB0byBjdWJlVVYgY29udmVyc2lvblxuXG4gICAgICBpZiAoaXNFcXVpcmVjdE1hcCB8fCBpc0N1YmVNYXApIHtcbiAgICAgICAgaWYgKHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICYmIHRleHR1cmUubmVlZHNQTVJFTVVwZGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRleHR1cmUubmVlZHNQTVJFTVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBjdWJlVVZtYXBzLmdldCh0ZXh0dXJlKTtcbiAgICAgICAgICBpZiAocG1yZW1HZW5lcmF0b3IgPT09IG51bGwpIHBtcmVtR2VuZXJhdG9yID0gbmV3IFBNUkVNR2VuZXJhdG9yKHJlbmRlcmVyKTtcbiAgICAgICAgICByZW5kZXJUYXJnZXQgPSBpc0VxdWlyZWN0TWFwID8gcG1yZW1HZW5lcmF0b3IuZnJvbUVxdWlyZWN0YW5ndWxhcih0ZXh0dXJlLCByZW5kZXJUYXJnZXQpIDogcG1yZW1HZW5lcmF0b3IuZnJvbUN1YmVtYXAodGV4dHVyZSwgcmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICBjdWJlVVZtYXBzLnNldCh0ZXh0dXJlLCByZW5kZXJUYXJnZXQpO1xuICAgICAgICAgIHJldHVybiByZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3ViZVVWbWFwcy5oYXModGV4dHVyZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjdWJlVVZtYXBzLmdldCh0ZXh0dXJlKS50ZXh0dXJlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG4gICAgICAgICAgICBpZiAoaXNFcXVpcmVjdE1hcCAmJiBpbWFnZSAmJiBpbWFnZS5oZWlnaHQgPiAwIHx8IGlzQ3ViZU1hcCAmJiBpbWFnZSAmJiBpc0N1YmVUZXh0dXJlQ29tcGxldGUoaW1hZ2UpKSB7XG4gICAgICAgICAgICAgIGlmIChwbXJlbUdlbmVyYXRvciA9PT0gbnVsbCkgcG1yZW1HZW5lcmF0b3IgPSBuZXcgUE1SRU1HZW5lcmF0b3IocmVuZGVyZXIpO1xuXG4gICAgICAgICAgICAgIHZhciBfcmVuZGVyVGFyZ2V0ID0gaXNFcXVpcmVjdE1hcCA/IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIodGV4dHVyZSkgOiBwbXJlbUdlbmVyYXRvci5mcm9tQ3ViZW1hcCh0ZXh0dXJlKTtcblxuICAgICAgICAgICAgICBjdWJlVVZtYXBzLnNldCh0ZXh0dXJlLCBfcmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICAgICAgdGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpbWFnZSBub3QgeWV0IHJlYWR5LiB0cnkgdGhlIGNvbnZlcnNpb24gbmV4dCBmcmFtZVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ3ViZVRleHR1cmVDb21wbGV0ZShpbWFnZSkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IDY7XG5cbiAgICBmb3IgKHZhciBfaTg5ID0gMDsgX2k4OSA8IGxlbmd0aDsgX2k4OSsrKSB7XG4gICAgICBpZiAoaW1hZ2VbX2k4OV0gIT09IHVuZGVmaW5lZCkgY291bnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gY291bnQgPT09IGxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoZXZlbnQpIHtcbiAgICB2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcbiAgICB0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlKTtcbiAgICB2YXIgY3ViZW1hcFVWID0gY3ViZVVWbWFwcy5nZXQodGV4dHVyZSk7XG5cbiAgICBpZiAoY3ViZW1hcFVWICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1YmVVVm1hcHMuZGVsZXRlKHRleHR1cmUpO1xuICAgICAgY3ViZW1hcFVWLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGN1YmVVVm1hcHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgaWYgKHBtcmVtR2VuZXJhdG9yICE9PSBudWxsKSB7XG4gICAgICBwbXJlbUdlbmVyYXRvci5kaXNwb3NlKCk7XG4gICAgICBwbXJlbUdlbmVyYXRvciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGdldCxcbiAgICBkaXNwb3NlOiBkaXNwb3NlXG4gIH07XG59XG5cbmZ1bmN0aW9uIFdlYkdMRXh0ZW5zaW9ucyhnbCkge1xuICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldEV4dGVuc2lvbihuYW1lKSB7XG4gICAgaWYgKGV4dGVuc2lvbnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuXG4gICAgdmFyIGV4dGVuc2lvbjtcblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnV0VCR0xfZGVwdGhfdGV4dHVyZSc6XG4gICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVwdGhfdGV4dHVyZScpIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxuICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpIHx8IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxuICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJykgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcbiAgICAgICAgZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKSB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbihuYW1lKTtcbiAgICB9XG5cbiAgICBleHRlbnNpb25zW25hbWVdID0gZXh0ZW5zaW9uO1xuICAgIHJldHVybiBleHRlbnNpb247XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIHJldHVybiBnZXRFeHRlbnNpb24obmFtZSkgIT09IG51bGw7XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGNhcGFiaWxpdGllcykge1xuICAgICAgaWYgKGNhcGFiaWxpdGllcy5pc1dlYkdMMikge1xuICAgICAgICBnZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldEV4dGVuc2lvbignV0VCR0xfZGVwdGhfdGV4dHVyZScpO1xuICAgICAgICBnZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0Jyk7XG4gICAgICAgIGdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcpO1xuICAgICAgICBnZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyk7XG4gICAgICAgIGdldEV4dGVuc2lvbignT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyk7XG4gICAgICAgIGdldEV4dGVuc2lvbignT0VTX2VsZW1lbnRfaW5kZXhfdWludCcpO1xuICAgICAgICBnZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XG4gICAgICAgIGdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuICAgICAgfVxuXG4gICAgICBnZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpO1xuICAgICAgZ2V0RXh0ZW5zaW9uKCdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnKTtcbiAgICAgIGdldEV4dGVuc2lvbignV0VCR0xfbXVsdGlzYW1wbGVkX3JlbmRlcl90b190ZXh0dXJlJyk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICB2YXIgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uKG5hbWUpO1xuXG4gICAgICBpZiAoZXh0ZW5zaW9uID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gV2ViR0xHZW9tZXRyaWVzKGdsLCBhdHRyaWJ1dGVzLCBpbmZvLCBiaW5kaW5nU3RhdGVzKSB7XG4gIHZhciBnZW9tZXRyaWVzID0ge307XG4gIHZhciB3aXJlZnJhbWVBdHRyaWJ1dGVzID0gbmV3IFdlYWtNYXAoKTtcblxuICBmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZShldmVudCkge1xuICAgIHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmIChnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCkge1xuICAgICAgYXR0cmlidXRlcy5yZW1vdmUoZ2VvbWV0cnkuaW5kZXgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgICAgYXR0cmlidXRlcy5yZW1vdmUoZ2VvbWV0cnkuYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgZ2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlKTtcbiAgICBkZWxldGUgZ2VvbWV0cmllc1tnZW9tZXRyeS5pZF07XG4gICAgdmFyIGF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXMuZ2V0KGdlb21ldHJ5KTtcblxuICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgIGF0dHJpYnV0ZXMucmVtb3ZlKGF0dHJpYnV0ZSk7XG4gICAgICB3aXJlZnJhbWVBdHRyaWJ1dGVzLmRlbGV0ZShnZW9tZXRyeSk7XG4gICAgfVxuXG4gICAgYmluZGluZ1N0YXRlcy5yZWxlYXNlU3RhdGVzT2ZHZW9tZXRyeShnZW9tZXRyeSk7XG5cbiAgICBpZiAoZ2VvbWV0cnkuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9PT0gdHJ1ZSkge1xuICAgICAgZGVsZXRlIGdlb21ldHJ5Ll9tYXhJbnN0YW5jZUNvdW50O1xuICAgIH0gLy9cblxuXG4gICAgaW5mby5tZW1vcnkuZ2VvbWV0cmllcy0tO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgZ2VvbWV0cnkpIHtcbiAgICBpZiAoZ2VvbWV0cmllc1tnZW9tZXRyeS5pZF0gPT09IHRydWUpIHJldHVybiBnZW9tZXRyeTtcbiAgICBnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UpO1xuICAgIGdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdID0gdHJ1ZTtcbiAgICBpbmZvLm1lbW9yeS5nZW9tZXRyaWVzKys7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGdlb21ldHJ5KSB7XG4gICAgdmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7IC8vIFVwZGF0aW5nIGluZGV4IGJ1ZmZlciBpbiBWQU8gbm93LiBTZWUgV2ViR0xCaW5kaW5nU3RhdGVzLlxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBnZW9tZXRyeUF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMudXBkYXRlKGdlb21ldHJ5QXR0cmlidXRlc1tuYW1lXSwgMzQ5NjIpO1xuICAgIH0gLy8gbW9ycGggdGFyZ2V0c1xuXG5cbiAgICB2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgX25hbWUzIGluIG1vcnBoQXR0cmlidXRlcykge1xuICAgICAgdmFyIGFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzW19uYW1lM107XG5cbiAgICAgIGZvciAodmFyIF9pOTAgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBfaTkwIDwgbDsgX2k5MCsrKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMudXBkYXRlKGFycmF5W19pOTBdLCAzNDk2Mik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlV2lyZWZyYW1lQXR0cmlidXRlKGdlb21ldHJ5KSB7XG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgZ2VvbWV0cnlJbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgIHZhciBnZW9tZXRyeVBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICB2YXIgdmVyc2lvbiA9IDA7XG5cbiAgICBpZiAoZ2VvbWV0cnlJbmRleCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGFycmF5ID0gZ2VvbWV0cnlJbmRleC5hcnJheTtcbiAgICAgIHZlcnNpb24gPSBnZW9tZXRyeUluZGV4LnZlcnNpb247XG5cbiAgICAgIGZvciAodmFyIF9pOTEgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBfaTkxIDwgbDsgX2k5MSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gYXJyYXlbX2k5MSArIDBdO1xuICAgICAgICB2YXIgYiA9IGFycmF5W19pOTEgKyAxXTtcbiAgICAgICAgdmFyIGMgPSBhcnJheVtfaTkxICsgMl07XG4gICAgICAgIGluZGljZXMucHVzaChhLCBiLCBiLCBjLCBjLCBhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9hcnJheSA9IGdlb21ldHJ5UG9zaXRpb24uYXJyYXk7XG4gICAgICB2ZXJzaW9uID0gZ2VvbWV0cnlQb3NpdGlvbi52ZXJzaW9uO1xuXG4gICAgICBmb3IgKHZhciBfaTkyID0gMCwgX2w1ID0gX2FycmF5Lmxlbmd0aCAvIDMgLSAxOyBfaTkyIDwgX2w1OyBfaTkyICs9IDMpIHtcbiAgICAgICAgdmFyIF9hNCA9IF9pOTIgKyAwO1xuXG4gICAgICAgIHZhciBfYjQgPSBfaTkyICsgMTtcblxuICAgICAgICB2YXIgX2M0ID0gX2k5MiArIDI7XG5cbiAgICAgICAgaW5kaWNlcy5wdXNoKF9hNCwgX2I0LCBfYjQsIF9jNCwgX2M0LCBfYTQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGUgPSBuZXcgKGFycmF5TmVlZHNVaW50MzIoaW5kaWNlcykgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUpKGluZGljZXMsIDEpO1xuICAgIGF0dHJpYnV0ZS52ZXJzaW9uID0gdmVyc2lvbjsgLy8gVXBkYXRpbmcgaW5kZXggYnVmZmVyIGluIFZBTyBub3cuIFNlZSBXZWJHTEJpbmRpbmdTdGF0ZXNcbiAgICAvL1xuXG4gICAgdmFyIHByZXZpb3VzQXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlcy5nZXQoZ2VvbWV0cnkpO1xuICAgIGlmIChwcmV2aW91c0F0dHJpYnV0ZSkgYXR0cmlidXRlcy5yZW1vdmUocHJldmlvdXNBdHRyaWJ1dGUpOyAvL1xuXG4gICAgd2lyZWZyYW1lQXR0cmlidXRlcy5zZXQoZ2VvbWV0cnksIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUoZ2VvbWV0cnkpIHtcbiAgICB2YXIgY3VycmVudEF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXMuZ2V0KGdlb21ldHJ5KTtcblxuICAgIGlmIChjdXJyZW50QXR0cmlidXRlKSB7XG4gICAgICB2YXIgZ2VvbWV0cnlJbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXG4gICAgICBpZiAoZ2VvbWV0cnlJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGlzIG9ic29sZXRlLCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlLnZlcnNpb24gPCBnZW9tZXRyeUluZGV4LnZlcnNpb24pIHtcbiAgICAgICAgICB1cGRhdGVXaXJlZnJhbWVBdHRyaWJ1dGUoZ2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZVdpcmVmcmFtZUF0dHJpYnV0ZShnZW9tZXRyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpcmVmcmFtZUF0dHJpYnV0ZXMuZ2V0KGdlb21ldHJ5KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXQsXG4gICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgZ2V0V2lyZWZyYW1lQXR0cmlidXRlOiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIoZ2wsIGV4dGVuc2lvbnMsIGluZm8sIGNhcGFiaWxpdGllcykge1xuICB2YXIgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG4gIHZhciBtb2RlO1xuXG4gIGZ1bmN0aW9uIHNldE1vZGUodmFsdWUpIHtcbiAgICBtb2RlID0gdmFsdWU7XG4gIH1cblxuICB2YXIgdHlwZSwgYnl0ZXNQZXJFbGVtZW50O1xuXG4gIGZ1bmN0aW9uIHNldEluZGV4KHZhbHVlKSB7XG4gICAgdHlwZSA9IHZhbHVlLnR5cGU7XG4gICAgYnl0ZXNQZXJFbGVtZW50ID0gdmFsdWUuYnl0ZXNQZXJFbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyKHN0YXJ0LCBjb3VudCkge1xuICAgIGdsLmRyYXdFbGVtZW50cyhtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBieXRlc1BlckVsZW1lbnQpO1xuICAgIGluZm8udXBkYXRlKGNvdW50LCBtb2RlLCAxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyhzdGFydCwgY291bnQsIHByaW1jb3VudCkge1xuICAgIGlmIChwcmltY291bnQgPT09IDApIHJldHVybjtcbiAgICB2YXIgZXh0ZW5zaW9uLCBtZXRob2ROYW1lO1xuXG4gICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICBleHRlbnNpb24gPSBnbDtcbiAgICAgIG1ldGhvZE5hbWUgPSAnZHJhd0VsZW1lbnRzSW5zdGFuY2VkJztcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgIG1ldGhvZE5hbWUgPSAnZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUnO1xuXG4gICAgICBpZiAoZXh0ZW5zaW9uID09PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4dGVuc2lvblttZXRob2ROYW1lXShtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBieXRlc1BlckVsZW1lbnQsIHByaW1jb3VudCk7XG4gICAgaW5mby51cGRhdGUoY291bnQsIG1vZGUsIHByaW1jb3VudCk7XG4gIH0gLy9cblxuXG4gIHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG4gIHRoaXMuc2V0SW5kZXggPSBzZXRJbmRleDtcbiAgdGhpcy5yZW5kZXIgPSByZW5kZXI7XG4gIHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xufVxuXG5mdW5jdGlvbiBXZWJHTEluZm8oZ2wpIHtcbiAgdmFyIG1lbW9yeSA9IHtcbiAgICBnZW9tZXRyaWVzOiAwLFxuICAgIHRleHR1cmVzOiAwXG4gIH07XG4gIHZhciByZW5kZXIgPSB7XG4gICAgZnJhbWU6IDAsXG4gICAgY2FsbHM6IDAsXG4gICAgdHJpYW5nbGVzOiAwLFxuICAgIHBvaW50czogMCxcbiAgICBsaW5lczogMFxuICB9O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZShjb3VudCwgbW9kZSwgaW5zdGFuY2VDb3VudCkge1xuICAgIHJlbmRlci5jYWxscysrO1xuXG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJlbmRlci50cmlhbmdsZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAvIDMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOlxuICAgICAgICByZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICByZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIChjb3VudCAtIDEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZW5kZXIubGluZXMgKz0gaW5zdGFuY2VDb3VudCAqIGNvdW50O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAwOlxuICAgICAgICByZW5kZXIucG9pbnRzICs9IGluc3RhbmNlQ291bnQgKiBjb3VudDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMSW5mbzogVW5rbm93biBkcmF3IG1vZGU6JywgbW9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHJlbmRlci5mcmFtZSsrO1xuICAgIHJlbmRlci5jYWxscyA9IDA7XG4gICAgcmVuZGVyLnRyaWFuZ2xlcyA9IDA7XG4gICAgcmVuZGVyLnBvaW50cyA9IDA7XG4gICAgcmVuZGVyLmxpbmVzID0gMDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVtb3J5OiBtZW1vcnksXG4gICAgcmVuZGVyOiByZW5kZXIsXG4gICAgcHJvZ3JhbXM6IG51bGwsXG4gICAgYXV0b1Jlc2V0OiB0cnVlLFxuICAgIHJlc2V0OiByZXNldCxcbiAgICB1cGRhdGU6IHVwZGF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBudW1lcmljYWxTb3J0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdO1xufVxuXG5mdW5jdGlvbiBhYnNOdW1lcmljYWxTb3J0KGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGJbMV0pIC0gTWF0aC5hYnMoYVsxXSk7XG59XG5cbmZ1bmN0aW9uIGRlbm9ybWFsaXplKG1vcnBoLCBhdHRyaWJ1dGUpIHtcbiAgdmFyIGRlbm9taW5hdG9yID0gMTtcbiAgdmFyIGFycmF5ID0gYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPyBhdHRyaWJ1dGUuZGF0YS5hcnJheSA6IGF0dHJpYnV0ZS5hcnJheTtcbiAgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5KSBkZW5vbWluYXRvciA9IDEyNztlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDE2QXJyYXkpIGRlbm9taW5hdG9yID0gMzI3Njc7ZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSBkZW5vbWluYXRvciA9IDIxNDc0ODM2NDc7ZWxzZSBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTE1vcnBodGFyZ2V0czogVW5zdXBwb3J0ZWQgbW9ycGggYXR0cmlidXRlIGRhdGEgdHlwZTogJywgYXJyYXkpO1xuICBtb3JwaC5kaXZpZGVTY2FsYXIoZGVub21pbmF0b3IpO1xufVxuXG5mdW5jdGlvbiBXZWJHTE1vcnBodGFyZ2V0cyhnbCwgY2FwYWJpbGl0aWVzLCB0ZXh0dXJlcykge1xuICB2YXIgaW5mbHVlbmNlc0xpc3QgPSB7fTtcbiAgdmFyIG1vcnBoSW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gIHZhciBtb3JwaFRleHR1cmVzID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIG1vcnBoID0gbmV3IFZlY3RvcjQoKTtcbiAgdmFyIHdvcmtJbmZsdWVuY2VzID0gW107XG5cbiAgZm9yICh2YXIgX2k5MyA9IDA7IF9pOTMgPCA4OyBfaTkzKyspIHtcbiAgICB3b3JrSW5mbHVlbmNlc1tfaTkzXSA9IFtfaTkzLCAwXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcHJvZ3JhbSkge1xuICAgIHZhciBvYmplY3RJbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgIGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIgPT09IHRydWUpIHtcbiAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgYXR0cmlidXRlcywgdGhlIFdlYkdMIDIgY29kZSBwYXRoIGVuY29kZXMgbW9ycGggdGFyZ2V0c1xuICAgICAgLy8gaW50byBhbiBhcnJheSBvZiBkYXRhIHRleHR1cmVzLiBFYWNoIGxheWVyIHJlcHJlc2VudHMgYSBzaW5nbGUgbW9ycGggdGFyZ2V0LlxuICAgICAgdmFyIG1vcnBoQXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgdmFyIG1vcnBoVGFyZ2V0c0NvdW50ID0gbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCA/IG1vcnBoQXR0cmlidXRlLmxlbmd0aCA6IDA7XG4gICAgICB2YXIgZW50cnkgPSBtb3JwaFRleHR1cmVzLmdldChnZW9tZXRyeSk7XG5cbiAgICAgIGlmIChlbnRyeSA9PT0gdW5kZWZpbmVkIHx8IGVudHJ5LmNvdW50ICE9PSBtb3JwaFRhcmdldHNDb3VudCkge1xuICAgICAgICB2YXIgZGlzcG9zZVRleHR1cmUgPSBmdW5jdGlvbiBkaXNwb3NlVGV4dHVyZSgpIHtcbiAgICAgICAgICB0ZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgICBtb3JwaFRleHR1cmVzLmRlbGV0ZShnZW9tZXRyeSk7XG4gICAgICAgICAgZ2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGRpc3Bvc2VUZXh0dXJlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZW50cnkgIT09IHVuZGVmaW5lZCkgZW50cnkudGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICAgIHZhciBoYXNNb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBoYXNNb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBoYXNNb3JwaENvbG9ycyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uIHx8IFtdO1xuICAgICAgICB2YXIgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBbXTtcbiAgICAgICAgdmFyIG1vcnBoQ29sb3JzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yIHx8IFtdO1xuICAgICAgICB2YXIgdmVydGV4RGF0YUNvdW50ID0gMDtcbiAgICAgICAgaWYgKGhhc01vcnBoUG9zaXRpb24gPT09IHRydWUpIHZlcnRleERhdGFDb3VudCA9IDE7XG4gICAgICAgIGlmIChoYXNNb3JwaE5vcm1hbHMgPT09IHRydWUpIHZlcnRleERhdGFDb3VudCA9IDI7XG4gICAgICAgIGlmIChoYXNNb3JwaENvbG9ycyA9PT0gdHJ1ZSkgdmVydGV4RGF0YUNvdW50ID0gMztcbiAgICAgICAgdmFyIHdpZHRoID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCAqIHZlcnRleERhdGFDb3VudDtcbiAgICAgICAgdmFyIGhlaWdodCA9IDE7XG5cbiAgICAgICAgaWYgKHdpZHRoID4gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplKSB7XG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKHdpZHRoIC8gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplKTtcbiAgICAgICAgICB3aWR0aCA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCAqIG1vcnBoVGFyZ2V0c0NvdW50KTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBuZXcgRGF0YUFycmF5VGV4dHVyZShidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG1vcnBoVGFyZ2V0c0NvdW50KTtcbiAgICAgICAgdGV4dHVyZS50eXBlID0gRmxvYXRUeXBlO1xuICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gZmlsbCBidWZmZXJcblxuICAgICAgICB2YXIgdmVydGV4RGF0YVN0cmlkZSA9IHZlcnRleERhdGFDb3VudCAqIDQ7XG5cbiAgICAgICAgZm9yICh2YXIgX2k5NCA9IDA7IF9pOTQgPCBtb3JwaFRhcmdldHNDb3VudDsgX2k5NCsrKSB7XG4gICAgICAgICAgdmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzW19pOTRdO1xuICAgICAgICAgIHZhciBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1tfaTk0XTtcbiAgICAgICAgICB2YXIgbW9ycGhDb2xvciA9IG1vcnBoQ29sb3JzW19pOTRdO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSB3aWR0aCAqIGhlaWdodCAqIDQgKiBfaTk0O1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldC5jb3VudDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gaiAqIHZlcnRleERhdGFTdHJpZGU7XG5cbiAgICAgICAgICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIG1vcnBoLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGhUYXJnZXQsIGopO1xuICAgICAgICAgICAgICBpZiAobW9ycGhUYXJnZXQubm9ybWFsaXplZCA9PT0gdHJ1ZSkgZGVub3JtYWxpemUobW9ycGgsIG1vcnBoVGFyZ2V0KTtcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIHN0cmlkZSArIDBdID0gbW9ycGgueDtcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIHN0cmlkZSArIDFdID0gbW9ycGgueTtcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIHN0cmlkZSArIDJdID0gbW9ycGguejtcbiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIHN0cmlkZSArIDNdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc01vcnBoTm9ybWFscyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBtb3JwaC5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoTm9ybWFsLCBqKTtcbiAgICAgICAgICAgICAgaWYgKG1vcnBoTm9ybWFsLm5vcm1hbGl6ZWQgPT09IHRydWUpIGRlbm9ybWFsaXplKG1vcnBoLCBtb3JwaE5vcm1hbCk7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA0XSA9IG1vcnBoLng7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA1XSA9IG1vcnBoLnk7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA2XSA9IG1vcnBoLno7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA3XSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNNb3JwaENvbG9ycyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBtb3JwaC5mcm9tQnVmZmVyQXR0cmlidXRlKG1vcnBoQ29sb3IsIGopO1xuICAgICAgICAgICAgICBpZiAobW9ycGhDb2xvci5ub3JtYWxpemVkID09PSB0cnVlKSBkZW5vcm1hbGl6ZShtb3JwaCwgbW9ycGhDb2xvcik7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA4XSA9IG1vcnBoLng7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyA5XSA9IG1vcnBoLnk7XG4gICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzdHJpZGUgKyAxMF0gPSBtb3JwaC56O1xuICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgc3RyaWRlICsgMTFdID0gbW9ycGhDb2xvci5pdGVtU2l6ZSA9PT0gNCA/IG1vcnBoLncgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgIGNvdW50OiBtb3JwaFRhcmdldHNDb3VudCxcbiAgICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxuICAgICAgICAgIHNpemU6IG5ldyBWZWN0b3IyKHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIH07XG4gICAgICAgIG1vcnBoVGV4dHVyZXMuc2V0KGdlb21ldHJ5LCBlbnRyeSk7XG4gICAgICAgIGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBkaXNwb3NlVGV4dHVyZSk7XG4gICAgICB9IC8vXG5cblxuICAgICAgdmFyIG1vcnBoSW5mbHVlbmNlc1N1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pOTUgPSAwOyBfaTk1IDwgb2JqZWN0SW5mbHVlbmNlcy5sZW5ndGg7IF9pOTUrKykge1xuICAgICAgICBtb3JwaEluZmx1ZW5jZXNTdW0gKz0gb2JqZWN0SW5mbHVlbmNlc1tfaTk1XTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vcnBoQmFzZUluZmx1ZW5jZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID8gMSA6IDEgLSBtb3JwaEluZmx1ZW5jZXNTdW07XG4gICAgICBwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoZ2wsICdtb3JwaFRhcmdldEJhc2VJbmZsdWVuY2UnLCBtb3JwaEJhc2VJbmZsdWVuY2UpO1xuICAgICAgcHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGdsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgb2JqZWN0SW5mbHVlbmNlcyk7XG4gICAgICBwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoZ2wsICdtb3JwaFRhcmdldHNUZXh0dXJlJywgZW50cnkudGV4dHVyZSwgdGV4dHVyZXMpO1xuICAgICAgcHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGdsLCAnbW9ycGhUYXJnZXRzVGV4dHVyZVNpemUnLCBlbnRyeS5zaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2hlbiBvYmplY3QgZG9lc24ndCBoYXZlIG1vcnBoIHRhcmdldCBpbmZsdWVuY2VzIGRlZmluZWQsIHdlIHRyZWF0IGl0IGFzIGEgMC1sZW5ndGggYXJyYXlcbiAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIG1ha2Ugc3VyZSB3ZSBzZXQgdXAgbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlIC8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzXG4gICAgICB2YXIgbGVuZ3RoID0gb2JqZWN0SW5mbHVlbmNlcyA9PT0gdW5kZWZpbmVkID8gMCA6IG9iamVjdEluZmx1ZW5jZXMubGVuZ3RoO1xuICAgICAgdmFyIGluZmx1ZW5jZXMgPSBpbmZsdWVuY2VzTGlzdFtnZW9tZXRyeS5pZF07XG5cbiAgICAgIGlmIChpbmZsdWVuY2VzID09PSB1bmRlZmluZWQgfHwgaW5mbHVlbmNlcy5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAvLyBpbml0aWFsaXNlIGxpc3RcbiAgICAgICAgaW5mbHVlbmNlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pOTYgPSAwOyBfaTk2IDwgbGVuZ3RoOyBfaTk2KyspIHtcbiAgICAgICAgICBpbmZsdWVuY2VzW19pOTZdID0gW19pOTYsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5mbHVlbmNlc0xpc3RbZ2VvbWV0cnkuaWRdID0gaW5mbHVlbmNlcztcbiAgICAgIH0gLy8gQ29sbGVjdCBpbmZsdWVuY2VzXG5cblxuICAgICAgZm9yICh2YXIgX2k5NyA9IDA7IF9pOTcgPCBsZW5ndGg7IF9pOTcrKykge1xuICAgICAgICB2YXIgaW5mbHVlbmNlID0gaW5mbHVlbmNlc1tfaTk3XTtcbiAgICAgICAgaW5mbHVlbmNlWzBdID0gX2k5NztcbiAgICAgICAgaW5mbHVlbmNlWzFdID0gb2JqZWN0SW5mbHVlbmNlc1tfaTk3XTtcbiAgICAgIH1cblxuICAgICAgaW5mbHVlbmNlcy5zb3J0KGFic051bWVyaWNhbFNvcnQpO1xuXG4gICAgICBmb3IgKHZhciBfaTk4ID0gMDsgX2k5OCA8IDg7IF9pOTgrKykge1xuICAgICAgICBpZiAoX2k5OCA8IGxlbmd0aCAmJiBpbmZsdWVuY2VzW19pOThdWzFdKSB7XG4gICAgICAgICAgd29ya0luZmx1ZW5jZXNbX2k5OF1bMF0gPSBpbmZsdWVuY2VzW19pOThdWzBdO1xuICAgICAgICAgIHdvcmtJbmZsdWVuY2VzW19pOThdWzFdID0gaW5mbHVlbmNlc1tfaTk4XVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3b3JrSW5mbHVlbmNlc1tfaTk4XVswXSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgIHdvcmtJbmZsdWVuY2VzW19pOThdWzFdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3b3JrSW5mbHVlbmNlcy5zb3J0KG51bWVyaWNhbFNvcnQpO1xuICAgICAgdmFyIF9tb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICB2YXIgX21vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICB2YXIgX21vcnBoSW5mbHVlbmNlc1N1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pOTkgPSAwOyBfaTk5IDwgODsgX2k5OSsrKSB7XG4gICAgICAgIHZhciBfaW5mbHVlbmNlID0gd29ya0luZmx1ZW5jZXNbX2k5OV07XG4gICAgICAgIHZhciBpbmRleCA9IF9pbmZsdWVuY2VbMF07XG4gICAgICAgIHZhciBfdmFsdWUzID0gX2luZmx1ZW5jZVsxXTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIF92YWx1ZTMpIHtcbiAgICAgICAgICBpZiAoX21vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ21vcnBoVGFyZ2V0JyArIF9pOTkpICE9PSBfbW9ycGhUYXJnZXRzW2luZGV4XSkge1xuICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdtb3JwaFRhcmdldCcgKyBfaTk5LCBfbW9ycGhUYXJnZXRzW2luZGV4XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9tb3JwaE5vcm1hbHMgJiYgZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdtb3JwaE5vcm1hbCcgKyBfaTk5KSAhPT0gX21vcnBoTm9ybWFsc1tpbmRleF0pIHtcbiAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbW9ycGhOb3JtYWwnICsgX2k5OSwgX21vcnBoTm9ybWFsc1tpbmRleF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vcnBoSW5mbHVlbmNlc1tfaTk5XSA9IF92YWx1ZTM7XG4gICAgICAgICAgX21vcnBoSW5mbHVlbmNlc1N1bSArPSBfdmFsdWUzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfbW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5Lmhhc0F0dHJpYnV0ZSgnbW9ycGhUYXJnZXQnICsgX2k5OSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5LmRlbGV0ZUF0dHJpYnV0ZSgnbW9ycGhUYXJnZXQnICsgX2k5OSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9tb3JwaE5vcm1hbHMgJiYgZ2VvbWV0cnkuaGFzQXR0cmlidXRlKCdtb3JwaE5vcm1hbCcgKyBfaTk5KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgZ2VvbWV0cnkuZGVsZXRlQXR0cmlidXRlKCdtb3JwaE5vcm1hbCcgKyBfaTk5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtb3JwaEluZmx1ZW5jZXNbX2k5OV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdMU0wgc2hhZGVyIHVzZXMgZm9ybXVsYSBiYXNlaW5mbHVlbmNlICogYmFzZSArIHN1bSh0YXJnZXQgKiBpbmZsdWVuY2UpXG4gICAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBzd2l0Y2ggYmV0d2VlbiBhYnNvbHV0ZSBtb3JwaHMgYW5kIHJlbGF0aXZlIG1vcnBocyB3aXRob3V0IGNoYW5naW5nIHNoYWRlciBjb2RlXG4gICAgICAvLyBXaGVuIGJhc2VpbmZsdWVuY2UgPSAxIC0gc3VtKGluZmx1ZW5jZSksIHRoZSBhYm92ZSBpcyBlcXVpdmFsZW50IHRvIHN1bSgodGFyZ2V0IC0gYmFzZSkgKiBpbmZsdWVuY2UpXG5cblxuICAgICAgdmFyIF9tb3JwaEJhc2VJbmZsdWVuY2UgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA/IDEgOiAxIC0gX21vcnBoSW5mbHVlbmNlc1N1bTtcblxuICAgICAgcHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKGdsLCAnbW9ycGhUYXJnZXRCYXNlSW5mbHVlbmNlJywgX21vcnBoQmFzZUluZmx1ZW5jZSk7XG4gICAgICBwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoZ2wsICdtb3JwaFRhcmdldEluZmx1ZW5jZXMnLCBtb3JwaEluZmx1ZW5jZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiB1cGRhdGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gV2ViR0xPYmplY3RzKGdsLCBnZW9tZXRyaWVzLCBhdHRyaWJ1dGVzLCBpbmZvKSB7XG4gIHZhciB1cGRhdGVNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QpIHtcbiAgICB2YXIgZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG4gICAgdmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQob2JqZWN0LCBnZW9tZXRyeSk7IC8vIFVwZGF0ZSBvbmNlIHBlciBmcmFtZVxuXG4gICAgaWYgKHVwZGF0ZU1hcC5nZXQoYnVmZmVyZ2VvbWV0cnkpICE9PSBmcmFtZSkge1xuICAgICAgZ2VvbWV0cmllcy51cGRhdGUoYnVmZmVyZ2VvbWV0cnkpO1xuICAgICAgdXBkYXRlTWFwLnNldChidWZmZXJnZW9tZXRyeSwgZnJhbWUpO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuaXNJbnN0YW5jZWRNZXNoKSB7XG4gICAgICBpZiAob2JqZWN0Lmhhc0V2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlKTtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlcy51cGRhdGUob2JqZWN0Lmluc3RhbmNlTWF0cml4LCAzNDk2Mik7XG5cbiAgICAgIGlmIChvYmplY3QuaW5zdGFuY2VDb2xvciAhPT0gbnVsbCkge1xuICAgICAgICBhdHRyaWJ1dGVzLnVwZGF0ZShvYmplY3QuaW5zdGFuY2VDb2xvciwgMzQ5NjIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJnZW9tZXRyeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgdXBkYXRlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSW5zdGFuY2VkTWVzaERpc3Bvc2UoZXZlbnQpIHtcbiAgICB2YXIgaW5zdGFuY2VkTWVzaCA9IGV2ZW50LnRhcmdldDtcbiAgICBpbnN0YW5jZWRNZXNoLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkluc3RhbmNlZE1lc2hEaXNwb3NlKTtcbiAgICBhdHRyaWJ1dGVzLnJlbW92ZShpbnN0YW5jZWRNZXNoLmluc3RhbmNlTWF0cml4KTtcbiAgICBpZiAoaW5zdGFuY2VkTWVzaC5pbnN0YW5jZUNvbG9yICE9PSBudWxsKSBhdHRyaWJ1dGVzLnJlbW92ZShpbnN0YW5jZWRNZXNoLmluc3RhbmNlQ29sb3IpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBkaXNwb3NlOiBkaXNwb3NlXG4gIH07XG59XG4vKipcbiAqIFVuaWZvcm1zIG9mIGEgcHJvZ3JhbS5cbiAqIFRob3NlIGZvcm0gYSB0cmVlIHN0cnVjdHVyZSB3aXRoIGEgc3BlY2lhbCB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciB0aGUgcm9vdCxcbiAqIHdoaWNoIHlvdSBnZXQgYnkgY2FsbGluZyAnbmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtICknLlxuICpcbiAqXG4gKiBQcm9wZXJ0aWVzIG9mIGlubmVyIG5vZGVzIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcbiAqXG4gKiAuc2VxIC0gYXJyYXkgb2YgbmVzdGVkIHVuaWZvcm1zXG4gKiAubWFwIC0gbmVzdGVkIHVuaWZvcm1zIGJ5IG5hbWVcbiAqXG4gKlxuICogTWV0aG9kcyBvZiBhbGwgbm9kZXMgZXhjZXB0IHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxuICpcbiAqIC5zZXRWYWx1ZSggZ2wsIHZhbHVlLCBbdGV4dHVyZXNdIClcbiAqXG4gKiBcdFx0dXBsb2FkcyBhIHVuaWZvcm0gdmFsdWUocylcbiAqICBcdHRoZSAndGV4dHVyZXMnIHBhcmFtZXRlciBpcyBuZWVkZWQgZm9yIHNhbXBsZXIgdW5pZm9ybXNcbiAqXG4gKlxuICogU3RhdGljIG1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHRleHR1cmVzIGZhY3Rvcml6YXRpb25zKTpcbiAqXG4gKiAudXBsb2FkKCBnbCwgc2VxLCB2YWx1ZXMsIHRleHR1cmVzIClcbiAqXG4gKiBcdFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcbiAqXG4gKiAuc2VxV2l0aFZhbHVlKCBzZXEsIHZhbHVlcyApIDogZmlsdGVyZWRTZXFcbiAqXG4gKiBcdFx0ZmlsdGVycyAnc2VxJyBlbnRyaWVzIHdpdGggY29ycmVzcG9uZGluZyBlbnRyeSBpbiB2YWx1ZXNcbiAqXG4gKlxuICogTWV0aG9kcyBvZiB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciAodGV4dHVyZXMgZmFjdG9yaXphdGlvbnMpOlxuICpcbiAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlLCB0ZXh0dXJlcyApXG4gKlxuICogXHRcdHNldHMgdW5pZm9ybSB3aXRoICBuYW1lICduYW1lJyB0byAndmFsdWUnXG4gKlxuICogLnNldE9wdGlvbmFsKCBnbCwgb2JqLCBwcm9wIClcbiAqXG4gKiBcdFx0bGlrZSAuc2V0IGZvciBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XG4gKlxuICovXG5cblxudmFyIGVtcHR5VGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG52YXIgZW1wdHlBcnJheVRleHR1cmUgPSBuZXcgRGF0YUFycmF5VGV4dHVyZSgpO1xudmFyIGVtcHR5M2RUZXh0dXJlID0gbmV3IERhdGEzRFRleHR1cmUoKTtcbnZhciBlbXB0eUN1YmVUZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7IC8vIC0tLSBVdGlsaXRpZXMgLS0tXG4vLyBBcnJheSBDYWNoZXMgKHByb3ZpZGUgdHlwZWQgYXJyYXlzIGZvciB0ZW1wb3JhcnkgYnkgc2l6ZSlcblxudmFyIGFycmF5Q2FjaGVGMzIgPSBbXTtcbnZhciBhcnJheUNhY2hlSTMyID0gW107IC8vIEZsb2F0MzJBcnJheSBjYWNoZXMgdXNlZCBmb3IgdXBsb2FkaW5nIE1hdHJpeCB1bmlmb3Jtc1xuXG52YXIgbWF0NGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG52YXIgbWF0M2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbnZhciBtYXQyYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDQpOyAvLyBGbGF0dGVuaW5nIGZvciBhcnJheXMgb2YgdmVjdG9ycyBhbmQgbWF0cmljZXNcblxuZnVuY3Rpb24gZmxhdHRlbihhcnJheSwgbkJsb2NrcywgYmxvY2tTaXplKSB7XG4gIHZhciBmaXJzdEVsZW0gPSBhcnJheVswXTtcbiAgaWYgKGZpcnN0RWxlbSA8PSAwIHx8IGZpcnN0RWxlbSA+IDApIHJldHVybiBhcnJheTsgLy8gdW5vcHRpbWl6ZWQ6ICEgaXNOYU4oIGZpcnN0RWxlbSApXG4gIC8vIHNlZSBodHRwOi8vamFja3NvbmR1bnN0YW4uY29tL2FydGljbGVzLzk4M1xuXG4gIHZhciBuID0gbkJsb2NrcyAqIGJsb2NrU2l6ZTtcbiAgdmFyIHIgPSBhcnJheUNhY2hlRjMyW25dO1xuXG4gIGlmIChyID09PSB1bmRlZmluZWQpIHtcbiAgICByID0gbmV3IEZsb2F0MzJBcnJheShuKTtcbiAgICBhcnJheUNhY2hlRjMyW25dID0gcjtcbiAgfVxuXG4gIGlmIChuQmxvY2tzICE9PSAwKSB7XG4gICAgZmlyc3RFbGVtLnRvQXJyYXkociwgMCk7XG5cbiAgICBmb3IgKHZhciBfaTEwMCA9IDEsIG9mZnNldCA9IDA7IF9pMTAwICE9PSBuQmxvY2tzOyArK19pMTAwKSB7XG4gICAgICBvZmZzZXQgKz0gYmxvY2tTaXplO1xuXG4gICAgICBhcnJheVtfaTEwMF0udG9BcnJheShyLCBvZmZzZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBhcnJheXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBfaTEwMSA9IDAsIGwgPSBhLmxlbmd0aDsgX2kxMDEgPCBsOyBfaTEwMSsrKSB7XG4gICAgaWYgKGFbX2kxMDFdICE9PSBiW19pMTAxXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvcHlBcnJheShhLCBiKSB7XG4gIGZvciAodmFyIF9pMTAyID0gMCwgbCA9IGIubGVuZ3RoOyBfaTEwMiA8IGw7IF9pMTAyKyspIHtcbiAgICBhW19pMTAyXSA9IGJbX2kxMDJdO1xuICB9XG59IC8vIFRleHR1cmUgdW5pdCBhbGxvY2F0aW9uXG5cblxuZnVuY3Rpb24gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbikge1xuICB2YXIgciA9IGFycmF5Q2FjaGVJMzJbbl07XG5cbiAgaWYgKHIgPT09IHVuZGVmaW5lZCkge1xuICAgIHIgPSBuZXcgSW50MzJBcnJheShuKTtcbiAgICBhcnJheUNhY2hlSTMyW25dID0gcjtcbiAgfVxuXG4gIGZvciAodmFyIF9pMTAzID0gMDsgX2kxMDMgIT09IG47ICsrX2kxMDMpIHtcbiAgICByW19pMTAzXSA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcbiAgfVxuXG4gIHJldHVybiByO1xufSAvLyAtLS0gU2V0dGVycyAtLS1cbi8vIE5vdGU6IERlZmluaW5nIHRoZXNlIG1ldGhvZHMgZXh0ZXJuYWxseSwgYmVjYXVzZSB0aGV5IGNvbWUgaW4gYSBidW5jaFxuLy8gYW5kIHRoaXMgd2F5IHRoZWlyIG5hbWVzIG1pbmlmeS5cbi8vIFNpbmdsZSBzY2FsYXJcblxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYxZihnbCwgdikge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICBpZiAoY2FjaGVbMF0gPT09IHYpIHJldHVybjtcbiAgZ2wudW5pZm9ybTFmKHRoaXMuYWRkciwgdik7XG4gIGNhY2hlWzBdID0gdjtcbn0gLy8gU2luZ2xlIGZsb2F0IHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXG5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMmYoZ2wsIHYpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICBpZiAodi54ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoY2FjaGVbMF0gIT09IHYueCB8fCBjYWNoZVsxXSAhPT0gdi55KSB7XG4gICAgICBnbC51bmlmb3JtMmYodGhpcy5hZGRyLCB2LngsIHYueSk7XG4gICAgICBjYWNoZVswXSA9IHYueDtcbiAgICAgIGNhY2hlWzFdID0gdi55O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG4gICAgZ2wudW5pZm9ybTJmdih0aGlzLmFkZHIsIHYpO1xuICAgIGNvcHlBcnJheShjYWNoZSwgdik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWM2YoZ2wsIHYpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICBpZiAodi54ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoY2FjaGVbMF0gIT09IHYueCB8fCBjYWNoZVsxXSAhPT0gdi55IHx8IGNhY2hlWzJdICE9PSB2LnopIHtcbiAgICAgIGdsLnVuaWZvcm0zZih0aGlzLmFkZHIsIHYueCwgdi55LCB2LnopO1xuICAgICAgY2FjaGVbMF0gPSB2Lng7XG4gICAgICBjYWNoZVsxXSA9IHYueTtcbiAgICAgIGNhY2hlWzJdID0gdi56O1xuICAgIH1cbiAgfSBlbHNlIGlmICh2LnIgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChjYWNoZVswXSAhPT0gdi5yIHx8IGNhY2hlWzFdICE9PSB2LmcgfHwgY2FjaGVbMl0gIT09IHYuYikge1xuICAgICAgZ2wudW5pZm9ybTNmKHRoaXMuYWRkciwgdi5yLCB2LmcsIHYuYik7XG4gICAgICBjYWNoZVswXSA9IHYucjtcbiAgICAgIGNhY2hlWzFdID0gdi5nO1xuICAgICAgY2FjaGVbMl0gPSB2LmI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcbiAgICBnbC51bmlmb3JtM2Z2KHRoaXMuYWRkciwgdik7XG4gICAgY29weUFycmF5KGNhY2hlLCB2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0ZihnbCwgdikge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuXG4gIGlmICh2LnggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChjYWNoZVswXSAhPT0gdi54IHx8IGNhY2hlWzFdICE9PSB2LnkgfHwgY2FjaGVbMl0gIT09IHYueiB8fCBjYWNoZVszXSAhPT0gdi53KSB7XG4gICAgICBnbC51bmlmb3JtNGYodGhpcy5hZGRyLCB2LngsIHYueSwgdi56LCB2LncpO1xuICAgICAgY2FjaGVbMF0gPSB2Lng7XG4gICAgICBjYWNoZVsxXSA9IHYueTtcbiAgICAgIGNhY2hlWzJdID0gdi56O1xuICAgICAgY2FjaGVbM10gPSB2Lnc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcbiAgICBnbC51bmlmb3JtNGZ2KHRoaXMuYWRkciwgdik7XG4gICAgY29weUFycmF5KGNhY2hlLCB2KTtcbiAgfVxufSAvLyBTaW5nbGUgbWF0cml4IChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuTWF0cml4TilcblxuXG5mdW5jdGlvbiBzZXRWYWx1ZU0yKGdsLCB2KSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gIHZhciBlbGVtZW50cyA9IHYuZWxlbWVudHM7XG5cbiAgaWYgKGVsZW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG4gICAgZ2wudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsIGZhbHNlLCB2KTtcbiAgICBjb3B5QXJyYXkoY2FjaGUsIHYpO1xuICB9IGVsc2Uge1xuICAgIGlmIChhcnJheXNFcXVhbChjYWNoZSwgZWxlbWVudHMpKSByZXR1cm47XG4gICAgbWF0MmFycmF5LnNldChlbGVtZW50cyk7XG4gICAgZ2wudW5pZm9ybU1hdHJpeDJmdih0aGlzLmFkZHIsIGZhbHNlLCBtYXQyYXJyYXkpO1xuICAgIGNvcHlBcnJheShjYWNoZSwgZWxlbWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlTTMoZ2wsIHYpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgdmFyIGVsZW1lbnRzID0gdi5lbGVtZW50cztcblxuICBpZiAoZWxlbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwgZmFsc2UsIHYpO1xuICAgIGNvcHlBcnJheShjYWNoZSwgdik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFycmF5c0VxdWFsKGNhY2hlLCBlbGVtZW50cykpIHJldHVybjtcbiAgICBtYXQzYXJyYXkuc2V0KGVsZW1lbnRzKTtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHRoaXMuYWRkciwgZmFsc2UsIG1hdDNhcnJheSk7XG4gICAgY29weUFycmF5KGNhY2hlLCBlbGVtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVNNChnbCwgdikge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICB2YXIgZWxlbWVudHMgPSB2LmVsZW1lbnRzO1xuXG4gIGlmIChlbGVtZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCBmYWxzZSwgdik7XG4gICAgY29weUFycmF5KGNhY2hlLCB2KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIGVsZW1lbnRzKSkgcmV0dXJuO1xuICAgIG1hdDRhcnJheS5zZXQoZWxlbWVudHMpO1xuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy5hZGRyLCBmYWxzZSwgbWF0NGFycmF5KTtcbiAgICBjb3B5QXJyYXkoY2FjaGUsIGVsZW1lbnRzKTtcbiAgfVxufSAvLyBTaW5nbGUgaW50ZWdlciAvIGJvb2xlYW5cblxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYxaShnbCwgdikge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICBpZiAoY2FjaGVbMF0gPT09IHYpIHJldHVybjtcbiAgZ2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdik7XG4gIGNhY2hlWzBdID0gdjtcbn0gLy8gU2luZ2xlIGludGVnZXIgLyBib29sZWFuIHZlY3RvciAoZnJvbSBmbGF0IGFycmF5KVxuXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJpKGdsLCB2KSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gIGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcbiAgZ2wudW5pZm9ybTJpdih0aGlzLmFkZHIsIHYpO1xuICBjb3B5QXJyYXkoY2FjaGUsIHYpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYzaShnbCwgdikge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICBpZiAoYXJyYXlzRXF1YWwoY2FjaGUsIHYpKSByZXR1cm47XG4gIGdsLnVuaWZvcm0zaXYodGhpcy5hZGRyLCB2KTtcbiAgY29weUFycmF5KGNhY2hlLCB2KTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWNGkoZ2wsIHYpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgaWYgKGFycmF5c0VxdWFsKGNhY2hlLCB2KSkgcmV0dXJuO1xuICBnbC51bmlmb3JtNGl2KHRoaXMuYWRkciwgdik7XG4gIGNvcHlBcnJheShjYWNoZSwgdik7XG59IC8vIFNpbmdsZSB1bnNpZ25lZCBpbnRlZ2VyXG5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMXVpKGdsLCB2KSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gIGlmIChjYWNoZVswXSA9PT0gdikgcmV0dXJuO1xuICBnbC51bmlmb3JtMXVpKHRoaXMuYWRkciwgdik7XG4gIGNhY2hlWzBdID0gdjtcbn0gLy8gU2luZ2xlIHVuc2lnbmVkIGludGVnZXIgdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkpXG5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMnVpKGdsLCB2KSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gIGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcbiAgZ2wudW5pZm9ybTJ1aXYodGhpcy5hZGRyLCB2KTtcbiAgY29weUFycmF5KGNhY2hlLCB2KTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWM3VpKGdsLCB2KSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gIGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcbiAgZ2wudW5pZm9ybTN1aXYodGhpcy5hZGRyLCB2KTtcbiAgY29weUFycmF5KGNhY2hlLCB2KTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWNHVpKGdsLCB2KSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gIGlmIChhcnJheXNFcXVhbChjYWNoZSwgdikpIHJldHVybjtcbiAgZ2wudW5pZm9ybTR1aXYodGhpcy5hZGRyLCB2KTtcbiAgY29weUFycmF5KGNhY2hlLCB2KTtcbn0gLy8gU2luZ2xlIHRleHR1cmUgKDJEIC8gQ3ViZSlcblxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQxKGdsLCB2LCB0ZXh0dXJlcykge1xuICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICB2YXIgdW5pdCA9IHRleHR1cmVzLmFsbG9jYXRlVGV4dHVyZVVuaXQoKTtcblxuICBpZiAoY2FjaGVbMF0gIT09IHVuaXQpIHtcbiAgICBnbC51bmlmb3JtMWkodGhpcy5hZGRyLCB1bml0KTtcbiAgICBjYWNoZVswXSA9IHVuaXQ7XG4gIH1cblxuICB0ZXh0dXJlcy5zZXRUZXh0dXJlMkQodiB8fCBlbXB0eVRleHR1cmUsIHVuaXQpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQzRDEoZ2wsIHYsIHRleHR1cmVzKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gIHZhciB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG4gIGlmIChjYWNoZVswXSAhPT0gdW5pdCkge1xuICAgIGdsLnVuaWZvcm0xaSh0aGlzLmFkZHIsIHVuaXQpO1xuICAgIGNhY2hlWzBdID0gdW5pdDtcbiAgfVxuXG4gIHRleHR1cmVzLnNldFRleHR1cmUzRCh2IHx8IGVtcHR5M2RUZXh0dXJlLCB1bml0KTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVUNihnbCwgdiwgdGV4dHVyZXMpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgdmFyIHVuaXQgPSB0ZXh0dXJlcy5hbGxvY2F0ZVRleHR1cmVVbml0KCk7XG5cbiAgaWYgKGNhY2hlWzBdICE9PSB1bml0KSB7XG4gICAgZ2wudW5pZm9ybTFpKHRoaXMuYWRkciwgdW5pdCk7XG4gICAgY2FjaGVbMF0gPSB1bml0O1xuICB9XG5cbiAgdGV4dHVyZXMuc2V0VGV4dHVyZUN1YmUodiB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0KTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVUMkRBcnJheTEoZ2wsIHYsIHRleHR1cmVzKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gIHZhciB1bml0ID0gdGV4dHVyZXMuYWxsb2NhdGVUZXh0dXJlVW5pdCgpO1xuXG4gIGlmIChjYWNoZVswXSAhPT0gdW5pdCkge1xuICAgIGdsLnVuaWZvcm0xaSh0aGlzLmFkZHIsIHVuaXQpO1xuICAgIGNhY2hlWzBdID0gdW5pdDtcbiAgfVxuXG4gIHRleHR1cmVzLnNldFRleHR1cmUyREFycmF5KHYgfHwgZW1wdHlBcnJheVRleHR1cmUsIHVuaXQpO1xufSAvLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciB0aGUgc2luZ3VsYXIgY2FzZVxuXG5cbmZ1bmN0aW9uIGdldFNpbmd1bGFyU2V0dGVyKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAweDE0MDY6XG4gICAgICByZXR1cm4gc2V0VmFsdWVWMWY7XG4gICAgLy8gRkxPQVRcblxuICAgIGNhc2UgMHg4YjUwOlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjJmO1xuICAgIC8vIF9WRUMyXG5cbiAgICBjYXNlIDB4OGI1MTpcbiAgICAgIHJldHVybiBzZXRWYWx1ZVYzZjtcbiAgICAvLyBfVkVDM1xuXG4gICAgY2FzZSAweDhiNTI6XG4gICAgICByZXR1cm4gc2V0VmFsdWVWNGY7XG4gICAgLy8gX1ZFQzRcblxuICAgIGNhc2UgMHg4YjVhOlxuICAgICAgcmV0dXJuIHNldFZhbHVlTTI7XG4gICAgLy8gX01BVDJcblxuICAgIGNhc2UgMHg4YjViOlxuICAgICAgcmV0dXJuIHNldFZhbHVlTTM7XG4gICAgLy8gX01BVDNcblxuICAgIGNhc2UgMHg4YjVjOlxuICAgICAgcmV0dXJuIHNldFZhbHVlTTQ7XG4gICAgLy8gX01BVDRcblxuICAgIGNhc2UgMHgxNDA0OlxuICAgIGNhc2UgMHg4YjU2OlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjFpO1xuICAgIC8vIElOVCwgQk9PTFxuXG4gICAgY2FzZSAweDhiNTM6XG4gICAgY2FzZSAweDhiNTc6XG4gICAgICByZXR1cm4gc2V0VmFsdWVWMmk7XG4gICAgLy8gX1ZFQzJcblxuICAgIGNhc2UgMHg4YjU0OlxuICAgIGNhc2UgMHg4YjU4OlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjNpO1xuICAgIC8vIF9WRUMzXG5cbiAgICBjYXNlIDB4OGI1NTpcbiAgICBjYXNlIDB4OGI1OTpcbiAgICAgIHJldHVybiBzZXRWYWx1ZVY0aTtcbiAgICAvLyBfVkVDNFxuXG4gICAgY2FzZSAweDE0MDU6XG4gICAgICByZXR1cm4gc2V0VmFsdWVWMXVpO1xuICAgIC8vIFVJTlRcblxuICAgIGNhc2UgMHg4ZGM2OlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjJ1aTtcbiAgICAvLyBfVkVDMlxuXG4gICAgY2FzZSAweDhkYzc6XG4gICAgICByZXR1cm4gc2V0VmFsdWVWM3VpO1xuICAgIC8vIF9WRUMzXG5cbiAgICBjYXNlIDB4OGRjODpcbiAgICAgIHJldHVybiBzZXRWYWx1ZVY0dWk7XG4gICAgLy8gX1ZFQzRcblxuICAgIGNhc2UgMHg4YjVlOiAvLyBTQU1QTEVSXzJEXG5cbiAgICBjYXNlIDB4OGQ2NjogLy8gU0FNUExFUl9FWFRFUk5BTF9PRVNcblxuICAgIGNhc2UgMHg4ZGNhOiAvLyBJTlRfU0FNUExFUl8yRFxuXG4gICAgY2FzZSAweDhkZDI6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSXzJEXG5cbiAgICBjYXNlIDB4OGI2MjpcbiAgICAgIC8vIFNBTVBMRVJfMkRfU0hBRE9XXG4gICAgICByZXR1cm4gc2V0VmFsdWVUMTtcblxuICAgIGNhc2UgMHg4YjVmOiAvLyBTQU1QTEVSXzNEXG5cbiAgICBjYXNlIDB4OGRjYjogLy8gSU5UX1NBTVBMRVJfM0RcblxuICAgIGNhc2UgMHg4ZGQzOlxuICAgICAgLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfM0RcbiAgICAgIHJldHVybiBzZXRWYWx1ZVQzRDE7XG5cbiAgICBjYXNlIDB4OGI2MDogLy8gU0FNUExFUl9DVUJFXG5cbiAgICBjYXNlIDB4OGRjYzogLy8gSU5UX1NBTVBMRVJfQ1VCRVxuXG4gICAgY2FzZSAweDhkZDQ6IC8vIFVOU0lHTkVEX0lOVF9TQU1QTEVSX0NVQkVcblxuICAgIGNhc2UgMHg4ZGM1OlxuICAgICAgLy8gU0FNUExFUl9DVUJFX1NIQURPV1xuICAgICAgcmV0dXJuIHNldFZhbHVlVDY7XG5cbiAgICBjYXNlIDB4OGRjMTogLy8gU0FNUExFUl8yRF9BUlJBWVxuXG4gICAgY2FzZSAweDhkY2Y6IC8vIElOVF9TQU1QTEVSXzJEX0FSUkFZXG5cbiAgICBjYXNlIDB4OGRkNzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVlcblxuICAgIGNhc2UgMHg4ZGM0OlxuICAgICAgLy8gU0FNUExFUl8yRF9BUlJBWV9TSEFET1dcbiAgICAgIHJldHVybiBzZXRWYWx1ZVQyREFycmF5MTtcbiAgfVxufSAvLyBBcnJheSBvZiBzY2FsYXJzXG5cblxuZnVuY3Rpb24gc2V0VmFsdWVWMWZBcnJheShnbCwgdikge1xuICBnbC51bmlmb3JtMWZ2KHRoaXMuYWRkciwgdik7XG59IC8vIEFycmF5IG9mIHZlY3RvcnMgKGZyb20gZmxhdCBhcnJheSBvciBhcnJheSBvZiBUSFJFRS5WZWN0b3JOKVxuXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJmQXJyYXkoZ2wsIHYpIHtcbiAgdmFyIGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgMik7XG4gIGdsLnVuaWZvcm0yZnYodGhpcy5hZGRyLCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWM2ZBcnJheShnbCwgdikge1xuICB2YXIgZGF0YSA9IGZsYXR0ZW4odiwgdGhpcy5zaXplLCAzKTtcbiAgZ2wudW5pZm9ybTNmdih0aGlzLmFkZHIsIGRhdGEpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0ZkFycmF5KGdsLCB2KSB7XG4gIHZhciBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDQpO1xuICBnbC51bmlmb3JtNGZ2KHRoaXMuYWRkciwgZGF0YSk7XG59IC8vIEFycmF5IG9mIG1hdHJpY2VzIChmcm9tIGZsYXQgYXJyYXkgb3IgYXJyYXkgb2YgVEhSRUUuTWF0cml4TilcblxuXG5mdW5jdGlvbiBzZXRWYWx1ZU0yQXJyYXkoZ2wsIHYpIHtcbiAgdmFyIGRhdGEgPSBmbGF0dGVuKHYsIHRoaXMuc2l6ZSwgNCk7XG4gIGdsLnVuaWZvcm1NYXRyaXgyZnYodGhpcy5hZGRyLCBmYWxzZSwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlTTNBcnJheShnbCwgdikge1xuICB2YXIgZGF0YSA9IGZsYXR0ZW4odiwgdGhpcy5zaXplLCA5KTtcbiAgZ2wudW5pZm9ybU1hdHJpeDNmdih0aGlzLmFkZHIsIGZhbHNlLCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVNNEFycmF5KGdsLCB2KSB7XG4gIHZhciBkYXRhID0gZmxhdHRlbih2LCB0aGlzLnNpemUsIDE2KTtcbiAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLmFkZHIsIGZhbHNlLCBkYXRhKTtcbn0gLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW5cblxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYxaUFycmF5KGdsLCB2KSB7XG4gIGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB2KTtcbn0gLy8gQXJyYXkgb2YgaW50ZWdlciAvIGJvb2xlYW4gdmVjdG9ycyAoZnJvbSBmbGF0IGFycmF5KVxuXG5cbmZ1bmN0aW9uIHNldFZhbHVlVjJpQXJyYXkoZ2wsIHYpIHtcbiAgZ2wudW5pZm9ybTJpdih0aGlzLmFkZHIsIHYpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYzaUFycmF5KGdsLCB2KSB7XG4gIGdsLnVuaWZvcm0zaXYodGhpcy5hZGRyLCB2KTtcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVWNGlBcnJheShnbCwgdikge1xuICBnbC51bmlmb3JtNGl2KHRoaXMuYWRkciwgdik7XG59IC8vIEFycmF5IG9mIHVuc2lnbmVkIGludGVnZXJcblxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYxdWlBcnJheShnbCwgdikge1xuICBnbC51bmlmb3JtMXVpdih0aGlzLmFkZHIsIHYpO1xufSAvLyBBcnJheSBvZiB1bnNpZ25lZCBpbnRlZ2VyIHZlY3RvcnMgKGZyb20gZmxhdCBhcnJheSlcblxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYydWlBcnJheShnbCwgdikge1xuICBnbC51bmlmb3JtMnVpdih0aGlzLmFkZHIsIHYpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVYzdWlBcnJheShnbCwgdikge1xuICBnbC51bmlmb3JtM3Vpdih0aGlzLmFkZHIsIHYpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVY0dWlBcnJheShnbCwgdikge1xuICBnbC51bmlmb3JtNHVpdih0aGlzLmFkZHIsIHYpO1xufSAvLyBBcnJheSBvZiB0ZXh0dXJlcyAoMkQgLyAzRCAvIEN1YmUgLyAyREFycmF5KVxuXG5cbmZ1bmN0aW9uIHNldFZhbHVlVDFBcnJheShnbCwgdiwgdGV4dHVyZXMpIHtcbiAgdmFyIG4gPSB2Lmxlbmd0aDtcbiAgdmFyIHVuaXRzID0gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbik7XG4gIGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cbiAgZm9yICh2YXIgX2kxMDQgPSAwOyBfaTEwNCAhPT0gbjsgKytfaTEwNCkge1xuICAgIHRleHR1cmVzLnNldFRleHR1cmUyRCh2W19pMTA0XSB8fCBlbXB0eVRleHR1cmUsIHVuaXRzW19pMTA0XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVUM0RBcnJheShnbCwgdiwgdGV4dHVyZXMpIHtcbiAgdmFyIG4gPSB2Lmxlbmd0aDtcbiAgdmFyIHVuaXRzID0gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbik7XG4gIGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cbiAgZm9yICh2YXIgX2kxMDUgPSAwOyBfaTEwNSAhPT0gbjsgKytfaTEwNSkge1xuICAgIHRleHR1cmVzLnNldFRleHR1cmUzRCh2W19pMTA1XSB8fCBlbXB0eTNkVGV4dHVyZSwgdW5pdHNbX2kxMDVdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZVQ2QXJyYXkoZ2wsIHYsIHRleHR1cmVzKSB7XG4gIHZhciBuID0gdi5sZW5ndGg7XG4gIHZhciB1bml0cyA9IGFsbG9jVGV4VW5pdHModGV4dHVyZXMsIG4pO1xuICBnbC51bmlmb3JtMWl2KHRoaXMuYWRkciwgdW5pdHMpO1xuXG4gIGZvciAodmFyIF9pMTA2ID0gMDsgX2kxMDYgIT09IG47ICsrX2kxMDYpIHtcbiAgICB0ZXh0dXJlcy5zZXRUZXh0dXJlQ3ViZSh2W19pMTA2XSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1tfaTEwNl0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlVDJEQXJyYXlBcnJheShnbCwgdiwgdGV4dHVyZXMpIHtcbiAgdmFyIG4gPSB2Lmxlbmd0aDtcbiAgdmFyIHVuaXRzID0gYWxsb2NUZXhVbml0cyh0ZXh0dXJlcywgbik7XG4gIGdsLnVuaWZvcm0xaXYodGhpcy5hZGRyLCB1bml0cyk7XG5cbiAgZm9yICh2YXIgX2kxMDcgPSAwOyBfaTEwNyAhPT0gbjsgKytfaTEwNykge1xuICAgIHRleHR1cmVzLnNldFRleHR1cmUyREFycmF5KHZbX2kxMDddIHx8IGVtcHR5QXJyYXlUZXh0dXJlLCB1bml0c1tfaTEwN10pO1xuICB9XG59IC8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIGEgcHVyZSAoYm90dG9tLWxldmVsKSBhcnJheVxuXG5cbmZ1bmN0aW9uIGdldFB1cmVBcnJheVNldHRlcih0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgMHgxNDA2OlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjFmQXJyYXk7XG4gICAgLy8gRkxPQVRcblxuICAgIGNhc2UgMHg4YjUwOlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjJmQXJyYXk7XG4gICAgLy8gX1ZFQzJcblxuICAgIGNhc2UgMHg4YjUxOlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjNmQXJyYXk7XG4gICAgLy8gX1ZFQzNcblxuICAgIGNhc2UgMHg4YjUyOlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjRmQXJyYXk7XG4gICAgLy8gX1ZFQzRcblxuICAgIGNhc2UgMHg4YjVhOlxuICAgICAgcmV0dXJuIHNldFZhbHVlTTJBcnJheTtcbiAgICAvLyBfTUFUMlxuXG4gICAgY2FzZSAweDhiNWI6XG4gICAgICByZXR1cm4gc2V0VmFsdWVNM0FycmF5O1xuICAgIC8vIF9NQVQzXG5cbiAgICBjYXNlIDB4OGI1YzpcbiAgICAgIHJldHVybiBzZXRWYWx1ZU00QXJyYXk7XG4gICAgLy8gX01BVDRcblxuICAgIGNhc2UgMHgxNDA0OlxuICAgIGNhc2UgMHg4YjU2OlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjFpQXJyYXk7XG4gICAgLy8gSU5ULCBCT09MXG5cbiAgICBjYXNlIDB4OGI1MzpcbiAgICBjYXNlIDB4OGI1NzpcbiAgICAgIHJldHVybiBzZXRWYWx1ZVYyaUFycmF5O1xuICAgIC8vIF9WRUMyXG5cbiAgICBjYXNlIDB4OGI1NDpcbiAgICBjYXNlIDB4OGI1ODpcbiAgICAgIHJldHVybiBzZXRWYWx1ZVYzaUFycmF5O1xuICAgIC8vIF9WRUMzXG5cbiAgICBjYXNlIDB4OGI1NTpcbiAgICBjYXNlIDB4OGI1OTpcbiAgICAgIHJldHVybiBzZXRWYWx1ZVY0aUFycmF5O1xuICAgIC8vIF9WRUM0XG5cbiAgICBjYXNlIDB4MTQwNTpcbiAgICAgIHJldHVybiBzZXRWYWx1ZVYxdWlBcnJheTtcbiAgICAvLyBVSU5UXG5cbiAgICBjYXNlIDB4OGRjNjpcbiAgICAgIHJldHVybiBzZXRWYWx1ZVYydWlBcnJheTtcbiAgICAvLyBfVkVDMlxuXG4gICAgY2FzZSAweDhkYzc6XG4gICAgICByZXR1cm4gc2V0VmFsdWVWM3VpQXJyYXk7XG4gICAgLy8gX1ZFQzNcblxuICAgIGNhc2UgMHg4ZGM4OlxuICAgICAgcmV0dXJuIHNldFZhbHVlVjR1aUFycmF5O1xuICAgIC8vIF9WRUM0XG5cbiAgICBjYXNlIDB4OGI1ZTogLy8gU0FNUExFUl8yRFxuXG4gICAgY2FzZSAweDhkNjY6IC8vIFNBTVBMRVJfRVhURVJOQUxfT0VTXG5cbiAgICBjYXNlIDB4OGRjYTogLy8gSU5UX1NBTVBMRVJfMkRcblxuICAgIGNhc2UgMHg4ZGQyOiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl8yRFxuXG4gICAgY2FzZSAweDhiNjI6XG4gICAgICAvLyBTQU1QTEVSXzJEX1NIQURPV1xuICAgICAgcmV0dXJuIHNldFZhbHVlVDFBcnJheTtcblxuICAgIGNhc2UgMHg4YjVmOiAvLyBTQU1QTEVSXzNEXG5cbiAgICBjYXNlIDB4OGRjYjogLy8gSU5UX1NBTVBMRVJfM0RcblxuICAgIGNhc2UgMHg4ZGQzOlxuICAgICAgLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfM0RcbiAgICAgIHJldHVybiBzZXRWYWx1ZVQzREFycmF5O1xuXG4gICAgY2FzZSAweDhiNjA6IC8vIFNBTVBMRVJfQ1VCRVxuXG4gICAgY2FzZSAweDhkY2M6IC8vIElOVF9TQU1QTEVSX0NVQkVcblxuICAgIGNhc2UgMHg4ZGQ0OiAvLyBVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFXG5cbiAgICBjYXNlIDB4OGRjNTpcbiAgICAgIC8vIFNBTVBMRVJfQ1VCRV9TSEFET1dcbiAgICAgIHJldHVybiBzZXRWYWx1ZVQ2QXJyYXk7XG5cbiAgICBjYXNlIDB4OGRjMTogLy8gU0FNUExFUl8yRF9BUlJBWVxuXG4gICAgY2FzZSAweDhkY2Y6IC8vIElOVF9TQU1QTEVSXzJEX0FSUkFZXG5cbiAgICBjYXNlIDB4OGRkNzogLy8gVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVlcblxuICAgIGNhc2UgMHg4ZGM0OlxuICAgICAgLy8gU0FNUExFUl8yRF9BUlJBWV9TSEFET1dcbiAgICAgIHJldHVybiBzZXRWYWx1ZVQyREFycmF5QXJyYXk7XG4gIH1cbn0gLy8gLS0tIFVuaWZvcm0gQ2xhc3NlcyAtLS1cblxuXG52YXIgU2luZ2xlVW5pZm9ybSA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gU2luZ2xlVW5pZm9ybShpZCwgYWN0aXZlSW5mbywgYWRkcikge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2luZ2xlVW5pZm9ybSk7XG5cbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLmFkZHIgPSBhZGRyO1xuICB0aGlzLmNhY2hlID0gW107XG4gIHRoaXMuc2V0VmFsdWUgPSBnZXRTaW5ndWxhclNldHRlcihhY3RpdmVJbmZvLnR5cGUpOyAvLyB0aGlzLnBhdGggPSBhY3RpdmVJbmZvLm5hbWU7IC8vIERFQlVHXG59KTtcblxudmFyIFB1cmVBcnJheVVuaWZvcm0gPSAvKiNfX1BVUkVfXyovX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIFB1cmVBcnJheVVuaWZvcm0oaWQsIGFjdGl2ZUluZm8sIGFkZHIpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1cmVBcnJheVVuaWZvcm0pO1xuXG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5hZGRyID0gYWRkcjtcbiAgdGhpcy5jYWNoZSA9IFtdO1xuICB0aGlzLnNpemUgPSBhY3RpdmVJbmZvLnNpemU7XG4gIHRoaXMuc2V0VmFsdWUgPSBnZXRQdXJlQXJyYXlTZXR0ZXIoYWN0aXZlSW5mby50eXBlKTsgLy8gdGhpcy5wYXRoID0gYWN0aXZlSW5mby5uYW1lOyAvLyBERUJVR1xufSk7XG5cbnZhciBTdHJ1Y3R1cmVkVW5pZm9ybSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0cnVjdHVyZWRVbmlmb3JtKGlkKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cnVjdHVyZWRVbmlmb3JtKTtcblxuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnNlcSA9IFtdO1xuICAgIHRoaXMubWFwID0ge307XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3RydWN0dXJlZFVuaWZvcm0sIFt7XG4gICAga2V5OiBcInNldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKGdsLCB2YWx1ZSwgdGV4dHVyZXMpIHtcbiAgICAgIHZhciBzZXEgPSB0aGlzLnNlcTtcblxuICAgICAgZm9yICh2YXIgX2kxMDggPSAwLCBuID0gc2VxLmxlbmd0aDsgX2kxMDggIT09IG47ICsrX2kxMDgpIHtcbiAgICAgICAgdmFyIHUgPSBzZXFbX2kxMDhdO1xuICAgICAgICB1LnNldFZhbHVlKGdsLCB2YWx1ZVt1LmlkXSwgdGV4dHVyZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHJ1Y3R1cmVkVW5pZm9ybTtcbn0oKTsgLy8gLS0tIFRvcC1sZXZlbCAtLS1cbi8vIFBhcnNlciAtIGJ1aWxkcyB1cCB0aGUgcHJvcGVydHkgdHJlZSBmcm9tIHRoZSBwYXRoIHN0cmluZ3NcblxuXG52YXIgUmVQYXRoUGFydCA9IC8oXFx3KykoXFxdKT8oXFxbfFxcLik/L2c7IC8vIGV4dHJhY3RzXG4vLyBcdC0gdGhlIGlkZW50aWZpZXIgKG1lbWJlciBuYW1lIG9yIGFycmF5IGluZGV4KVxuLy8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgcmlnaHQgYnJhY2tldCAoZm91bmQgd2hlbiBhcnJheSBpbmRleClcbi8vICAtIGZvbGxvd2VkIGJ5IGFuIG9wdGlvbmFsIGxlZnQgYnJhY2tldCBvciBkb3QgKHR5cGUgb2Ygc3Vic2NyaXB0KVxuLy9cbi8vIE5vdGU6IFRoZXNlIHBvcnRpb25zIGNhbiBiZSByZWFkIGluIGEgbm9uLW92ZXJsYXBwaW5nIGZhc2hpb24gYW5kXG4vLyBhbGxvdyBzdHJhaWdodGZvcndhcmQgcGFyc2luZyBvZiB0aGUgaGllcmFyY2h5IHRoYXQgV2ViR0wgZW5jb2Rlc1xuLy8gaW4gdGhlIHVuaWZvcm0gbmFtZXMuXG5cbmZ1bmN0aW9uIGFkZFVuaWZvcm0oY29udGFpbmVyLCB1bmlmb3JtT2JqZWN0KSB7XG4gIGNvbnRhaW5lci5zZXEucHVzaCh1bmlmb3JtT2JqZWN0KTtcbiAgY29udGFpbmVyLm1hcFt1bmlmb3JtT2JqZWN0LmlkXSA9IHVuaWZvcm1PYmplY3Q7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5pZm9ybShhY3RpdmVJbmZvLCBhZGRyLCBjb250YWluZXIpIHtcbiAgdmFyIHBhdGggPSBhY3RpdmVJbmZvLm5hbWUsXG4gICAgICBwYXRoTGVuZ3RoID0gcGF0aC5sZW5ndGg7IC8vIHJlc2V0IFJlZ0V4cCBvYmplY3QsIGJlY2F1c2Ugb2YgdGhlIGVhcmx5IGV4aXQgb2YgYSBwcmV2aW91cyBydW5cblxuICBSZVBhdGhQYXJ0Lmxhc3RJbmRleCA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBSZVBhdGhQYXJ0LmV4ZWMocGF0aCksXG4gICAgICAgIG1hdGNoRW5kID0gUmVQYXRoUGFydC5sYXN0SW5kZXg7XG4gICAgdmFyIGlkID0gbWF0Y2hbMV07XG4gICAgdmFyIGlkSXNJbmRleCA9IG1hdGNoWzJdID09PSAnXScsXG4gICAgICAgIHN1YnNjcmlwdCA9IG1hdGNoWzNdO1xuICAgIGlmIChpZElzSW5kZXgpIGlkID0gaWQgfCAwOyAvLyBjb252ZXJ0IHRvIGludGVnZXJcblxuICAgIGlmIChzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCB8fCBzdWJzY3JpcHQgPT09ICdbJyAmJiBtYXRjaEVuZCArIDIgPT09IHBhdGhMZW5ndGgpIHtcbiAgICAgIC8vIGJhcmUgbmFtZSBvciBcInB1cmVcIiBib3R0b20tbGV2ZWwgYXJyYXkgXCJbMF1cIiBzdWZmaXhcbiAgICAgIGFkZFVuaWZvcm0oY29udGFpbmVyLCBzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCA/IG5ldyBTaW5nbGVVbmlmb3JtKGlkLCBhY3RpdmVJbmZvLCBhZGRyKSA6IG5ldyBQdXJlQXJyYXlVbmlmb3JtKGlkLCBhY3RpdmVJbmZvLCBhZGRyKSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RlcCBpbnRvIGlubmVyIG5vZGUgLyBjcmVhdGUgaXQgaW4gY2FzZSBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICB2YXIgbWFwID0gY29udGFpbmVyLm1hcDtcbiAgICAgIHZhciBuZXh0ID0gbWFwW2lkXTtcblxuICAgICAgaWYgKG5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXh0ID0gbmV3IFN0cnVjdHVyZWRVbmlmb3JtKGlkKTtcbiAgICAgICAgYWRkVW5pZm9ybShjb250YWluZXIsIG5leHQpO1xuICAgICAgfVxuXG4gICAgICBjb250YWluZXIgPSBuZXh0O1xuICAgIH1cbiAgfVxufSAvLyBSb290IENvbnRhaW5lclxuXG5cbnZhciBXZWJHTFVuaWZvcm1zID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2ViR0xVbmlmb3JtcyhnbCwgcHJvZ3JhbSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTFVuaWZvcm1zKTtcblxuICAgIHRoaXMuc2VxID0gW107XG4gICAgdGhpcy5tYXAgPSB7fTtcbiAgICB2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgMzU3MTgpO1xuXG4gICAgZm9yICh2YXIgX2kxMDkgPSAwOyBfaTEwOSA8IG47ICsrX2kxMDkpIHtcbiAgICAgIHZhciBpbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBfaTEwOSksXG4gICAgICAgICAgYWRkciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBpbmZvLm5hbWUpO1xuICAgICAgcGFyc2VVbmlmb3JtKGluZm8sIGFkZHIsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJHTFVuaWZvcm1zLCBbe1xuICAgIGtleTogXCJzZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShnbCwgbmFtZSwgdmFsdWUsIHRleHR1cmVzKSB7XG4gICAgICB2YXIgdSA9IHRoaXMubWFwW25hbWVdO1xuICAgICAgaWYgKHUgIT09IHVuZGVmaW5lZCkgdS5zZXRWYWx1ZShnbCwgdmFsdWUsIHRleHR1cmVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9uYWwoZ2wsIG9iamVjdCwgbmFtZSkge1xuICAgICAgdmFyIHYgPSBvYmplY3RbbmFtZV07XG4gICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB0aGlzLnNldFZhbHVlKGdsLCBuYW1lLCB2KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ1cGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBsb2FkKGdsLCBzZXEsIHZhbHVlcywgdGV4dHVyZXMpIHtcbiAgICAgIGZvciAodmFyIF9pMTEwID0gMCwgbiA9IHNlcS5sZW5ndGg7IF9pMTEwICE9PSBuOyArK19pMTEwKSB7XG4gICAgICAgIHZhciB1ID0gc2VxW19pMTEwXSxcbiAgICAgICAgICAgIHYgPSB2YWx1ZXNbdS5pZF07XG5cbiAgICAgICAgaWYgKHYubmVlZHNVcGRhdGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gbm90ZTogYWx3YXlzIHVwZGF0aW5nIHdoZW4gLm5lZWRzVXBkYXRlIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIHUuc2V0VmFsdWUoZ2wsIHYudmFsdWUsIHRleHR1cmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXFXaXRoVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VxV2l0aFZhbHVlKHNlcSwgdmFsdWVzKSB7XG4gICAgICB2YXIgciA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTExMSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBfaTExMSAhPT0gbjsgKytfaTExMSkge1xuICAgICAgICB2YXIgdSA9IHNlcVtfaTExMV07XG4gICAgICAgIGlmICh1LmlkIGluIHZhbHVlcykgci5wdXNoKHUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViR0xVbmlmb3Jtcztcbn0oKTtcblxuZnVuY3Rpb24gV2ViR0xTaGFkZXIoZ2wsIHR5cGUsIHN0cmluZykge1xuICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzdHJpbmcpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIHJldHVybiBzaGFkZXI7XG59XG5cbnZhciBwcm9ncmFtSWRDb3VudCA9IDA7XG5cbmZ1bmN0aW9uIGhhbmRsZVNvdXJjZShzdHJpbmcsIGVycm9yTGluZSkge1xuICB2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoJ1xcbicpO1xuICB2YXIgbGluZXMyID0gW107XG4gIHZhciBmcm9tID0gTWF0aC5tYXgoZXJyb3JMaW5lIC0gNiwgMCk7XG4gIHZhciB0byA9IE1hdGgubWluKGVycm9yTGluZSArIDYsIGxpbmVzLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgX2kxMTIgPSBmcm9tOyBfaTExMiA8IHRvOyBfaTExMisrKSB7XG4gICAgdmFyIGxpbmUgPSBfaTExMiArIDE7XG4gICAgbGluZXMyLnB1c2goXCJcIi5jb25jYXQobGluZSA9PT0gZXJyb3JMaW5lID8gJz4nIDogJyAnLCBcIiBcIikuY29uY2F0KGxpbmUsIFwiOiBcIikuY29uY2F0KGxpbmVzW19pMTEyXSkpO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVzMi5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RW5jb2RpbmdDb21wb25lbnRzKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlIExpbmVhckVuY29kaW5nOlxuICAgICAgcmV0dXJuIFsnTGluZWFyJywgJyggdmFsdWUgKSddO1xuXG4gICAgY2FzZSBzUkdCRW5jb2Rpbmc6XG4gICAgICByZXR1cm4gWydzUkdCJywgJyggdmFsdWUgKSddO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xQcm9ncmFtOiBVbnN1cHBvcnRlZCBlbmNvZGluZzonLCBlbmNvZGluZyk7XG4gICAgICByZXR1cm4gWydMaW5lYXInLCAnKCB2YWx1ZSApJ107XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2hhZGVyRXJyb3JzKGdsLCBzaGFkZXIsIHR5cGUpIHtcbiAgdmFyIHN0YXR1cyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIDM1NzEzKTtcbiAgdmFyIGVycm9ycyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKS50cmltKCk7XG4gIGlmIChzdGF0dXMgJiYgZXJyb3JzID09PSAnJykgcmV0dXJuICcnO1xuICB2YXIgZXJyb3JNYXRjaGVzID0gL0VSUk9SOiAwOihcXGQrKS8uZXhlYyhlcnJvcnMpO1xuXG4gIGlmIChlcnJvck1hdGNoZXMpIHtcbiAgICAvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxuICAgIC8vIGNvbnNvbGUubG9nKCAnKionICsgdHlwZSArICcqKicsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggc2hhZGVyICkgKTtcbiAgICB2YXIgZXJyb3JMaW5lID0gcGFyc2VJbnQoZXJyb3JNYXRjaGVzWzFdKTtcbiAgICByZXR1cm4gdHlwZS50b1VwcGVyQ2FzZSgpICsgJ1xcblxcbicgKyBlcnJvcnMgKyAnXFxuXFxuJyArIGhhbmRsZVNvdXJjZShnbC5nZXRTaGFkZXJTb3VyY2Uoc2hhZGVyKSwgZXJyb3JMaW5lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRleGVsRW5jb2RpbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGVuY29kaW5nKSB7XG4gIHZhciBjb21wb25lbnRzID0gZ2V0RW5jb2RpbmdDb21wb25lbnRzKGVuY29kaW5nKTtcbiAgcmV0dXJuICd2ZWM0ICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gTGluZWFyVG8nICsgY29tcG9uZW50c1swXSArIGNvbXBvbmVudHNbMV0gKyAnOyB9Jztcbn1cblxuZnVuY3Rpb24gZ2V0VG9uZU1hcHBpbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHRvbmVNYXBwaW5nKSB7XG4gIHZhciB0b25lTWFwcGluZ05hbWU7XG5cbiAgc3dpdGNoICh0b25lTWFwcGluZykge1xuICAgIGNhc2UgTGluZWFyVG9uZU1hcHBpbmc6XG4gICAgICB0b25lTWFwcGluZ05hbWUgPSAnTGluZWFyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSZWluaGFyZFRvbmVNYXBwaW5nOlxuICAgICAgdG9uZU1hcHBpbmdOYW1lID0gJ1JlaW5oYXJkJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDaW5lb25Ub25lTWFwcGluZzpcbiAgICAgIHRvbmVNYXBwaW5nTmFtZSA9ICdPcHRpbWl6ZWRDaW5lb24nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFDRVNGaWxtaWNUb25lTWFwcGluZzpcbiAgICAgIHRvbmVNYXBwaW5nTmFtZSA9ICdBQ0VTRmlsbWljJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDdXN0b21Ub25lTWFwcGluZzpcbiAgICAgIHRvbmVNYXBwaW5nTmFtZSA9ICdDdXN0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW06IFVuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOicsIHRvbmVNYXBwaW5nKTtcbiAgICAgIHRvbmVNYXBwaW5nTmFtZSA9ICdMaW5lYXInO1xuICB9XG5cbiAgcmV0dXJuICd2ZWMzICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gJyArIHRvbmVNYXBwaW5nTmFtZSArICdUb25lTWFwcGluZyggY29sb3IgKTsgfSc7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRXh0ZW5zaW9ucyhwYXJhbWV0ZXJzKSB7XG4gIHZhciBjaHVua3MgPSBbcGFyYW1ldGVycy5leHRlbnNpb25EZXJpdmF0aXZlcyB8fCAhIXBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWSGVpZ2h0IHx8IHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLnRhbmdlbnRTcGFjZU5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nIHx8IHBhcmFtZXRlcnMuc2hhZGVySUQgPT09ICdwaHlzaWNhbCcgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsIChwYXJhbWV0ZXJzLmV4dGVuc2lvbkZyYWdEZXB0aCB8fCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIpICYmIHBhcmFtZXRlcnMucmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGggPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJywgcGFyYW1ldGVycy5leHRlbnNpb25EcmF3QnVmZmVycyAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uRHJhd0J1ZmZlcnMgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZScgOiAnJywgKHBhcmFtZXRlcnMuZXh0ZW5zaW9uU2hhZGVyVGV4dHVyZUxPRCB8fCBwYXJhbWV0ZXJzLmVudk1hcCB8fCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbikgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvblNoYWRlclRleHR1cmVMb2QgPyAnI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlJyA6ICcnXTtcbiAgcmV0dXJuIGNodW5rcy5maWx0ZXIoZmlsdGVyRW1wdHlMaW5lKS5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbmVzKGRlZmluZXMpIHtcbiAgdmFyIGNodW5rcyA9IFtdO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gZGVmaW5lcykge1xuICAgIHZhciBfdmFsdWU0ID0gZGVmaW5lc1tuYW1lXTtcbiAgICBpZiAoX3ZhbHVlNCA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgIGNodW5rcy5wdXNoKCcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgX3ZhbHVlNCk7XG4gIH1cblxuICByZXR1cm4gY2h1bmtzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSkge1xuICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICB2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgMzU3MjEpO1xuXG4gIGZvciAodmFyIF9pMTEzID0gMDsgX2kxMTMgPCBuOyBfaTExMysrKSB7XG4gICAgdmFyIGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgX2kxMTMpO1xuICAgIHZhciBuYW1lID0gaW5mby5uYW1lO1xuICAgIHZhciBsb2NhdGlvblNpemUgPSAxO1xuICAgIGlmIChpbmZvLnR5cGUgPT09IDM1Njc0KSBsb2NhdGlvblNpemUgPSAyO1xuICAgIGlmIChpbmZvLnR5cGUgPT09IDM1Njc1KSBsb2NhdGlvblNpemUgPSAzO1xuICAgIGlmIChpbmZvLnR5cGUgPT09IDM1Njc2KSBsb2NhdGlvblNpemUgPSA0OyAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6JywgbmFtZSwgaSApO1xuXG4gICAgYXR0cmlidXRlc1tuYW1lXSA9IHtcbiAgICAgIHR5cGU6IGluZm8udHlwZSxcbiAgICAgIGxvY2F0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcbiAgICAgIGxvY2F0aW9uU2l6ZTogbG9jYXRpb25TaXplXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBhdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcgIT09ICcnO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlTGlnaHROdW1zKHN0cmluZywgcGFyYW1ldGVycykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL05VTV9ESVJfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRzKS5yZXBsYWNlKC9OVU1fU1BPVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1TcG90TGlnaHRzKS5yZXBsYWNlKC9OVU1fUkVDVF9BUkVBX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVJlY3RBcmVhTGlnaHRzKS5yZXBsYWNlKC9OVU1fUE9JTlRfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodHMpLnJlcGxhY2UoL05VTV9IRU1JX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bUhlbWlMaWdodHMpLnJlcGxhY2UoL05VTV9ESVJfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bURpckxpZ2h0U2hhZG93cykucmVwbGFjZSgvTlVNX1NQT1RfTElHSFRfU0hBRE9XUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MpLnJlcGxhY2UoL05VTV9QT0lOVF9MSUdIVF9TSEFET1dTL2csIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodFNoYWRvd3MpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXMoc3RyaW5nLCBwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvTlVNX0NMSVBQSU5HX1BMQU5FUy9nLCBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzKS5yZXBsYWNlKC9VTklPTl9DTElQUElOR19QTEFORVMvZywgcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyAtIHBhcmFtZXRlcnMubnVtQ2xpcEludGVyc2VjdGlvbik7XG59IC8vIFJlc29sdmUgSW5jbHVkZXNcblxuXG52YXIgaW5jbHVkZVBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLi9dKyk+L2dtO1xuXG5mdW5jdGlvbiByZXNvbHZlSW5jbHVkZXMoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShpbmNsdWRlUGF0dGVybiwgaW5jbHVkZVJlcGxhY2VyKTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZVJlcGxhY2VyKG1hdGNoLCBpbmNsdWRlKSB7XG4gIHZhciBzdHJpbmcgPSBTaGFkZXJDaHVua1tpbmNsdWRlXTtcblxuICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8JyArIGluY2x1ZGUgKyAnPicpO1xuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVJbmNsdWRlcyhzdHJpbmcpO1xufSAvLyBVbnJvbGwgTG9vcHNcblxuXG52YXIgZGVwcmVjYXRlZFVucm9sbExvb3BQYXR0ZXJuID0gLyNwcmFnbWEgdW5yb2xsX2xvb3BbXFxzXSs/Zm9yIFxcKCBpbnQgaSBcXD0gKFxcZCspXFw7IGkgPCAoXFxkKylcXDsgaSBcXCtcXCsgXFwpIFxceyhbXFxzXFxTXSs/KSg/PVxcfSlcXH0vZztcbnZhciB1bnJvbGxMb29wUGF0dGVybiA9IC8jcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxzK2ZvclxccypcXChcXHMqaW50XFxzK2lcXHMqPVxccyooXFxkKylcXHMqO1xccyppXFxzKjxcXHMqKFxcZCspXFxzKjtcXHMqaVxccypcXCtcXCtcXHMqXFwpXFxzKnsoW1xcc1xcU10rPyl9XFxzKyNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kL2c7XG5cbmZ1bmN0aW9uIHVucm9sbExvb3BzKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UodW5yb2xsTG9vcFBhdHRlcm4sIGxvb3BSZXBsYWNlcikucmVwbGFjZShkZXByZWNhdGVkVW5yb2xsTG9vcFBhdHRlcm4sIGRlcHJlY2F0ZWRMb29wUmVwbGFjZXIpO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkTG9vcFJlcGxhY2VyKG1hdGNoLCBzdGFydCwgZW5kLCBzbmlwcGV0KSB7XG4gIGNvbnNvbGUud2FybignV2ViR0xQcm9ncmFtOiAjcHJhZ21hIHVucm9sbF9sb29wIHNoYWRlciBzeW50YXggaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0IHN5bnRheCBpbnN0ZWFkLicpO1xuICByZXR1cm4gbG9vcFJlcGxhY2VyKG1hdGNoLCBzdGFydCwgZW5kLCBzbmlwcGV0KTtcbn1cblxuZnVuY3Rpb24gbG9vcFJlcGxhY2VyKG1hdGNoLCBzdGFydCwgZW5kLCBzbmlwcGV0KSB7XG4gIHZhciBzdHJpbmcgPSAnJztcblxuICBmb3IgKHZhciBfaTExNCA9IHBhcnNlSW50KHN0YXJ0KTsgX2kxMTQgPCBwYXJzZUludChlbmQpOyBfaTExNCsrKSB7XG4gICAgc3RyaW5nICs9IHNuaXBwZXQucmVwbGFjZSgvXFxbXFxzKmlcXHMqXFxdL2csICdbICcgKyBfaTExNCArICcgXScpLnJlcGxhY2UoL1VOUk9MTEVEX0xPT1BfSU5ERVgvZywgX2kxMTQpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn0gLy9cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZVByZWNpc2lvbihwYXJhbWV0ZXJzKSB7XG4gIHZhciBwcmVjaXNpb25zdHJpbmcgPSAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7XFxucHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50Oyc7XG5cbiAgaWYgKHBhcmFtZXRlcnMucHJlY2lzaW9uID09PSAnaGlnaHAnKSB7XG4gICAgcHJlY2lzaW9uc3RyaW5nICs9ICdcXG4jZGVmaW5lIEhJR0hfUFJFQ0lTSU9OJztcbiAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLnByZWNpc2lvbiA9PT0gJ21lZGl1bXAnKSB7XG4gICAgcHJlY2lzaW9uc3RyaW5nICs9ICdcXG4jZGVmaW5lIE1FRElVTV9QUkVDSVNJT04nO1xuICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMucHJlY2lzaW9uID09PSAnbG93cCcpIHtcbiAgICBwcmVjaXNpb25zdHJpbmcgKz0gJ1xcbiNkZWZpbmUgTE9XX1BSRUNJU0lPTic7XG4gIH1cblxuICByZXR1cm4gcHJlY2lzaW9uc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNoYWRvd01hcFR5cGVEZWZpbmUocGFyYW1ldGVycykge1xuICB2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cbiAgaWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU2hhZG93TWFwKSB7XG4gICAgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xuICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU29mdFNoYWRvd01hcCkge1xuICAgIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xuICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVlNNU2hhZG93TWFwKSB7XG4gICAgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9WU00nO1xuICB9XG5cbiAgcmV0dXJuIHNoYWRvd01hcFR5cGVEZWZpbmU7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwVHlwZURlZmluZShwYXJhbWV0ZXJzKSB7XG4gIHZhciBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuXG4gIGlmIChwYXJhbWV0ZXJzLmVudk1hcCkge1xuICAgIHN3aXRjaCAocGFyYW1ldGVycy5lbnZNYXBNb2RlKSB7XG4gICAgICBjYXNlIEN1YmVSZWZsZWN0aW9uTWFwcGluZzpcbiAgICAgIGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzpcbiAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFX1VWJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVudk1hcFR5cGVEZWZpbmU7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwTW9kZURlZmluZShwYXJhbWV0ZXJzKSB7XG4gIHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xuXG4gIGlmIChwYXJhbWV0ZXJzLmVudk1hcCkge1xuICAgIHN3aXRjaCAocGFyYW1ldGVycy5lbnZNYXBNb2RlKSB7XG4gICAgICBjYXNlIEN1YmVSZWZyYWN0aW9uTWFwcGluZzpcbiAgICAgICAgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZSQUNUSU9OJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVudk1hcE1vZGVEZWZpbmU7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRW52TWFwQmxlbmRpbmdEZWZpbmUocGFyYW1ldGVycykge1xuICB2YXIgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX05PTkUnO1xuXG4gIGlmIChwYXJhbWV0ZXJzLmVudk1hcCkge1xuICAgIHN3aXRjaCAocGFyYW1ldGVycy5jb21iaW5lKSB7XG4gICAgICBjYXNlIE11bHRpcGx5T3BlcmF0aW9uOlxuICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBNaXhPcGVyYXRpb246XG4gICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NSVgnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBBZGRPcGVyYXRpb246XG4gICAgICAgIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19BREQnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW52TWFwQmxlbmRpbmdEZWZpbmU7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ3ViZVVWU2l6ZShwYXJhbWV0ZXJzKSB7XG4gIHZhciBpbWFnZUhlaWdodCA9IHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWSGVpZ2h0O1xuICBpZiAoaW1hZ2VIZWlnaHQgPT09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgbWF4TWlwID0gTWF0aC5sb2cyKGltYWdlSGVpZ2h0KSAtIDI7XG4gIHZhciB0ZXhlbEhlaWdodCA9IDEuMCAvIGltYWdlSGVpZ2h0O1xuICB2YXIgdGV4ZWxXaWR0aCA9IDEuMCAvICgzICogTWF0aC5tYXgoTWF0aC5wb3coMiwgbWF4TWlwKSwgNyAqIDE2KSk7XG4gIHJldHVybiB7XG4gICAgdGV4ZWxXaWR0aDogdGV4ZWxXaWR0aCxcbiAgICB0ZXhlbEhlaWdodDogdGV4ZWxIZWlnaHQsXG4gICAgbWF4TWlwOiBtYXhNaXBcbiAgfTtcbn1cblxuZnVuY3Rpb24gV2ViR0xQcm9ncmFtKHJlbmRlcmVyLCBjYWNoZUtleSwgcGFyYW1ldGVycywgYmluZGluZ1N0YXRlcykge1xuICAvLyBUT0RPIFNlbmQgdGhpcyBldmVudCB0byBUaHJlZS5qcyBEZXZUb29sc1xuICAvLyBjb25zb2xlLmxvZyggJ1dlYkdMUHJvZ3JhbScsIGNhY2hlS2V5ICk7XG4gIHZhciBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcbiAgdmFyIGRlZmluZXMgPSBwYXJhbWV0ZXJzLmRlZmluZXM7XG4gIHZhciB2ZXJ0ZXhTaGFkZXIgPSBwYXJhbWV0ZXJzLnZlcnRleFNoYWRlcjtcbiAgdmFyIGZyYWdtZW50U2hhZGVyID0gcGFyYW1ldGVycy5mcmFnbWVudFNoYWRlcjtcbiAgdmFyIHNoYWRvd01hcFR5cGVEZWZpbmUgPSBnZW5lcmF0ZVNoYWRvd01hcFR5cGVEZWZpbmUocGFyYW1ldGVycyk7XG4gIHZhciBlbnZNYXBUeXBlRGVmaW5lID0gZ2VuZXJhdGVFbnZNYXBUeXBlRGVmaW5lKHBhcmFtZXRlcnMpO1xuICB2YXIgZW52TWFwTW9kZURlZmluZSA9IGdlbmVyYXRlRW52TWFwTW9kZURlZmluZShwYXJhbWV0ZXJzKTtcbiAgdmFyIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gZ2VuZXJhdGVFbnZNYXBCbGVuZGluZ0RlZmluZShwYXJhbWV0ZXJzKTtcbiAgdmFyIGVudk1hcEN1YmVVVlNpemUgPSBnZW5lcmF0ZUN1YmVVVlNpemUocGFyYW1ldGVycyk7XG4gIHZhciBjdXN0b21FeHRlbnNpb25zID0gcGFyYW1ldGVycy5pc1dlYkdMMiA/ICcnIDogZ2VuZXJhdGVFeHRlbnNpb25zKHBhcmFtZXRlcnMpO1xuICB2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyhkZWZpbmVzKTtcbiAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIHZhciBwcmVmaXhWZXJ0ZXgsIHByZWZpeEZyYWdtZW50O1xuICB2YXIgdmVyc2lvblN0cmluZyA9IHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPyAnI3ZlcnNpb24gJyArIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gKyAnXFxuJyA6ICcnO1xuXG4gIGlmIChwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwpIHtcbiAgICBwcmVmaXhWZXJ0ZXggPSBbY3VzdG9tRGVmaW5lc10uZmlsdGVyKGZpbHRlckVtcHR5TGluZSkuam9pbignXFxuJyk7XG5cbiAgICBpZiAocHJlZml4VmVydGV4Lmxlbmd0aCA+IDApIHtcbiAgICAgIHByZWZpeFZlcnRleCArPSAnXFxuJztcbiAgICB9XG5cbiAgICBwcmVmaXhGcmFnbWVudCA9IFtjdXN0b21FeHRlbnNpb25zLCBjdXN0b21EZWZpbmVzXS5maWx0ZXIoZmlsdGVyRW1wdHlMaW5lKS5qb2luKCdcXG4nKTtcblxuICAgIGlmIChwcmVmaXhGcmFnbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICBwcmVmaXhGcmFnbWVudCArPSAnXFxuJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJlZml4VmVydGV4ID0gW2dlbmVyYXRlUHJlY2lzaW9uKHBhcmFtZXRlcnMpLCAnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgcGFyYW1ldGVycy5zaGFkZXJOYW1lLCBjdXN0b21EZWZpbmVzLCBwYXJhbWV0ZXJzLmluc3RhbmNpbmcgPyAnI2RlZmluZSBVU0VfSU5TVEFOQ0lORycgOiAnJywgcGFyYW1ldGVycy5pbnN0YW5jaW5nQ29sb3IgPyAnI2RlZmluZSBVU0VfSU5TVEFOQ0lOR19DT0xPUicgOiAnJywgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVkVSVEVYX1RFWFRVUkVTJyA6ICcnLCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwMiA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLCBwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJywgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJywgcGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCAmJiBwYXJhbWV0ZXJzLm9iamVjdFNwYWNlTm9ybWFsTWFwID8gJyNkZWZpbmUgT0JKRUNUU1BBQ0VfTk9STUFMTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCAmJiBwYXJhbWV0ZXJzLnRhbmdlbnRTcGFjZU5vcm1hbE1hcCA/ICcjZGVmaW5lIFRBTkdFTlRTUEFDRV9OT1JNQUxNQVAnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0TWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcCA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCcgOiAnJywgcGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJDb2xvck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUkNPTE9STUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJywgcGFyYW1ldGVycy50cmFuc21pc3Npb24gPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OJyA6ICcnLCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcCA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVAnIDogJycsIHBhcmFtZXRlcnMudGhpY2tuZXNzTWFwID8gJyNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5zaGVlbkNvbG9yTWFwID8gJyNkZWZpbmUgVVNFX1NIRUVOQ09MT1JNQVAnIDogJycsIHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMgPyAnI2RlZmluZSBVU0VfVEFOR0VOVCcgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsIHBhcmFtZXRlcnMudmVydGV4QWxwaGFzID8gJyNkZWZpbmUgVVNFX0NPTE9SX0FMUEhBJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleFV2cyA/ICcjZGVmaW5lIFVTRV9VVicgOiAnJywgcGFyYW1ldGVycy51dnNWZXJ0ZXhPbmx5ID8gJyNkZWZpbmUgVVZTX1ZFUlRFWF9PTkxZJyA6ICcnLCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsIHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJywgcGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLCBwYXJhbWV0ZXJzLm1vcnBoQ29sb3JzICYmIHBhcmFtZXRlcnMuaXNXZWJHTDIgPyAnI2RlZmluZSBVU0VfTU9SUEhDT0xPUlMnIDogJycsIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzQ291bnQgPiAwICYmIHBhcmFtZXRlcnMuaXNXZWJHTDIgPyAnI2RlZmluZSBNT1JQSFRBUkdFVFNfVEVYVFVSRScgOiAnJywgcGFyYW1ldGVycy5tb3JwaFRhcmdldHNDb3VudCA+IDAgJiYgcGFyYW1ldGVycy5pc1dlYkdMMiA/ICcjZGVmaW5lIE1PUlBIVEFSR0VUU19URVhUVVJFX1NUUklERSAnICsgcGFyYW1ldGVycy5tb3JwaFRleHR1cmVTdHJpZGUgOiAnJywgcGFyYW1ldGVycy5tb3JwaFRhcmdldHNDb3VudCA+IDAgJiYgcGFyYW1ldGVycy5pc1dlYkdMMiA/ICcjZGVmaW5lIE1PUlBIVEFSR0VUU19DT1VOVCAnICsgcGFyYW1ldGVycy5tb3JwaFRhcmdldHNDb3VudCA6ICcnLCBwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLCBwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsIHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJywgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcGFyYW1ldGVycy5yZW5kZXJlckV4dGVuc2lvbkZyYWdEZXB0aCA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsICd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JywgJ3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JywgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsICd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLCAndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLCAndW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uOycsICd1bmlmb3JtIGJvb2wgaXNPcnRob2dyYXBoaWM7JywgJyNpZmRlZiBVU0VfSU5TVEFOQ0lORycsICdcdGF0dHJpYnV0ZSBtYXQ0IGluc3RhbmNlTWF0cml4OycsICcjZW5kaWYnLCAnI2lmZGVmIFVTRV9JTlNUQU5DSU5HX0NPTE9SJywgJ1x0YXR0cmlidXRlIHZlYzMgaW5zdGFuY2VDb2xvcjsnLCAnI2VuZGlmJywgJ2F0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uOycsICdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JywgJ2F0dHJpYnV0ZSB2ZWMyIHV2OycsICcjaWZkZWYgVVNFX1RBTkdFTlQnLCAnXHRhdHRyaWJ1dGUgdmVjNCB0YW5nZW50OycsICcjZW5kaWYnLCAnI2lmIGRlZmluZWQoIFVTRV9DT0xPUl9BTFBIQSApJywgJ1x0YXR0cmlidXRlIHZlYzQgY29sb3I7JywgJyNlbGlmIGRlZmluZWQoIFVTRV9DT0xPUiApJywgJ1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JywgJyNlbmRpZicsICcjaWYgKCBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTICkgJiYgISBkZWZpbmVkKCBNT1JQSFRBUkdFVFNfVEVYVFVSRSApICknLCAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7JywgJ1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQxOycsICdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLCAnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7JywgJ1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMjsnLCAnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLCAnXHQjZWxzZScsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsICdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsICdcdCNlbmRpZicsICcjZW5kaWYnLCAnI2lmZGVmIFVTRV9TS0lOTklORycsICdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLCAnXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsICcjZW5kaWYnLCAnXFxuJ10uZmlsdGVyKGZpbHRlckVtcHR5TGluZSkuam9pbignXFxuJyk7XG4gICAgcHJlZml4RnJhZ21lbnQgPSBbY3VzdG9tRXh0ZW5zaW9ucywgZ2VuZXJhdGVQcmVjaXNpb24ocGFyYW1ldGVycyksICcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBwYXJhbWV0ZXJzLnNoYWRlck5hbWUsIGN1c3RvbURlZmluZXMsIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJywgcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAyID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsIHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJywgcGFyYW1ldGVycy5tYXRjYXAgPyAnI2RlZmluZSBVU0VfTUFUQ0FQJyA6ICcnLCBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJywgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBCbGVuZGluZ0RlZmluZSA6ICcnLCBlbnZNYXBDdWJlVVZTaXplID8gJyNkZWZpbmUgQ1VCRVVWX1RFWEVMX1dJRFRIICcgKyBlbnZNYXBDdWJlVVZTaXplLnRleGVsV2lkdGggOiAnJywgZW52TWFwQ3ViZVVWU2l6ZSA/ICcjZGVmaW5lIENVQkVVVl9URVhFTF9IRUlHSFQgJyArIGVudk1hcEN1YmVVVlNpemUudGV4ZWxIZWlnaHQgOiAnJywgZW52TWFwQ3ViZVVWU2l6ZSA/ICcjZGVmaW5lIENVQkVVVl9NQVhfTUlQICcgKyBlbnZNYXBDdWJlVVZTaXplLm1heE1pcCArICcuMCcgOiAnJywgcGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJywgcGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJywgcGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsIHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5ub3JtYWxNYXAgJiYgcGFyYW1ldGVycy5vYmplY3RTcGFjZU5vcm1hbE1hcCA/ICcjZGVmaW5lIE9CSkVDVFNQQUNFX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5ub3JtYWxNYXAgJiYgcGFyYW1ldGVycy50YW5nZW50U3BhY2VOb3JtYWxNYXAgPyAnI2RlZmluZSBUQU5HRU5UU1BBQ0VfTk9STUFMTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLmNsZWFyY29hdCA/ICcjZGVmaW5lIFVTRV9DTEVBUkNPQVQnIDogJycsIHBhcmFtZXRlcnMuY2xlYXJjb2F0TWFwID8gJyNkZWZpbmUgVVNFX0NMRUFSQ09BVE1BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX1JPVUdITkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5jbGVhcmNvYXROb3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfQ0xFQVJDT0FUX05PUk1BTE1BUCcgOiAnJywgcGFyYW1ldGVycy5pcmlkZXNjZW5jZSA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRScgOiAnJywgcGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcCA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRU1BUCcgOiAnJywgcGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9JUklERVNDRU5DRV9USElDS05FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJJTlRFTlNJVFlNQVAnIDogJycsIHBhcmFtZXRlcnMuc3BlY3VsYXJDb2xvck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUkNPTE9STUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsIHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJywgcGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBVU0VfQUxQSEFURVNUJyA6ICcnLCBwYXJhbWV0ZXJzLnNoZWVuID8gJyNkZWZpbmUgVVNFX1NIRUVOJyA6ICcnLCBwYXJhbWV0ZXJzLnNoZWVuQ29sb3JNYXAgPyAnI2RlZmluZSBVU0VfU0hFRU5DT0xPUk1BUCcgOiAnJywgcGFyYW1ldGVycy5zaGVlblJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9TSEVFTlJPVUdITkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy50cmFuc21pc3Npb24gPyAnI2RlZmluZSBVU0VfVFJBTlNNSVNTSU9OJyA6ICcnLCBwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbk1hcCA/ICcjZGVmaW5lIFVTRV9UUkFOU01JU1NJT05NQVAnIDogJycsIHBhcmFtZXRlcnMudGhpY2tuZXNzTWFwID8gJyNkZWZpbmUgVVNFX1RISUNLTkVTU01BUCcgOiAnJywgcGFyYW1ldGVycy5kZWNvZGVWaWRlb1RleHR1cmUgPyAnI2RlZmluZSBERUNPREVfVklERU9fVEVYVFVSRScgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhUYW5nZW50cyA/ICcjZGVmaW5lIFVTRV9UQU5HRU5UJyA6ICcnLCBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyB8fCBwYXJhbWV0ZXJzLmluc3RhbmNpbmdDb2xvciA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJywgcGFyYW1ldGVycy52ZXJ0ZXhBbHBoYXMgPyAnI2RlZmluZSBVU0VfQ09MT1JfQUxQSEEnIDogJycsIHBhcmFtZXRlcnMudmVydGV4VXZzID8gJyNkZWZpbmUgVVNFX1VWJyA6ICcnLCBwYXJhbWV0ZXJzLnV2c1ZlcnRleE9ubHkgPyAnI2RlZmluZSBVVlNfVkVSVEVYX09OTFknIDogJycsIHBhcmFtZXRlcnMuZ3JhZGllbnRNYXAgPyAnI2RlZmluZSBVU0VfR1JBRElFTlRNQVAnIDogJycsIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJywgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJywgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLCBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLCBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA/ICcjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEEnIDogJycsIHBhcmFtZXRlcnMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPyAnI2RlZmluZSBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTJyA6ICcnLCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiBwYXJhbWV0ZXJzLnJlbmRlcmVyRXh0ZW5zaW9uRnJhZ0RlcHRoID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJywgJ3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsICd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JywgJ3VuaWZvcm0gYm9vbCBpc09ydGhvZ3JhcGhpYzsnLCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nID8gJyNkZWZpbmUgVE9ORV9NQVBQSU5HJyA6ICcnLCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nID8gU2hhZGVyQ2h1bmtbJ3RvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQnXSA6ICcnLCAvLyB0aGlzIGNvZGUgaXMgcmVxdWlyZWQgaGVyZSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgdGhlIHRvbmVNYXBwaW5nKCkgZnVuY3Rpb24gZGVmaW5lZCBiZWxvd1xuICAgIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgPyBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCd0b25lTWFwcGluZycsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcpIDogJycsIHBhcmFtZXRlcnMuZGl0aGVyaW5nID8gJyNkZWZpbmUgRElUSEVSSU5HJyA6ICcnLCBwYXJhbWV0ZXJzLm9wYXF1ZSA/ICcjZGVmaW5lIE9QQVFVRScgOiAnJywgU2hhZGVyQ2h1bmtbJ2VuY29kaW5nc19wYXJzX2ZyYWdtZW50J10sIC8vIHRoaXMgY29kZSBpcyByZXF1aXJlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdXNlZCBieSB0aGUgdmFyaW91cyBlbmNvZGluZy9kZWNvZGluZyBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XG4gICAgZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCdsaW5lYXJUb091dHB1dFRleGVsJywgcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyksIHBhcmFtZXRlcnMudXNlRGVwdGhQYWNraW5nID8gJyNkZWZpbmUgREVQVEhfUEFDS0lORyAnICsgcGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgOiAnJywgJ1xcbiddLmZpbHRlcihmaWx0ZXJFbXB0eUxpbmUpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgdmVydGV4U2hhZGVyID0gcmVzb2x2ZUluY2x1ZGVzKHZlcnRleFNoYWRlcik7XG4gIHZlcnRleFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXModmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzKTtcbiAgdmVydGV4U2hhZGVyID0gcmVwbGFjZUNsaXBwaW5nUGxhbmVOdW1zKHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyk7XG4gIGZyYWdtZW50U2hhZGVyID0gcmVzb2x2ZUluY2x1ZGVzKGZyYWdtZW50U2hhZGVyKTtcbiAgZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlTGlnaHROdW1zKGZyYWdtZW50U2hhZGVyLCBwYXJhbWV0ZXJzKTtcbiAgZnJhZ21lbnRTaGFkZXIgPSByZXBsYWNlQ2xpcHBpbmdQbGFuZU51bXMoZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMpO1xuICB2ZXJ0ZXhTaGFkZXIgPSB1bnJvbGxMb29wcyh2ZXJ0ZXhTaGFkZXIpO1xuICBmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKGZyYWdtZW50U2hhZGVyKTtcblxuICBpZiAocGFyYW1ldGVycy5pc1dlYkdMMiAmJiBwYXJhbWV0ZXJzLmlzUmF3U2hhZGVyTWF0ZXJpYWwgIT09IHRydWUpIHtcbiAgICAvLyBHTFNMIDMuMCBjb252ZXJzaW9uIGZvciBidWlsdC1pbiBtYXRlcmlhbHMgYW5kIFNoYWRlck1hdGVyaWFsXG4gICAgdmVyc2lvblN0cmluZyA9ICcjdmVyc2lvbiAzMDAgZXNcXG4nO1xuICAgIHByZWZpeFZlcnRleCA9IFsncHJlY2lzaW9uIG1lZGl1bXAgc2FtcGxlcjJEQXJyYXk7JywgJyNkZWZpbmUgYXR0cmlidXRlIGluJywgJyNkZWZpbmUgdmFyeWluZyBvdXQnLCAnI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZSddLmpvaW4oJ1xcbicpICsgJ1xcbicgKyBwcmVmaXhWZXJ0ZXg7XG4gICAgcHJlZml4RnJhZ21lbnQgPSBbJyNkZWZpbmUgdmFyeWluZyBpbicsIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPT09IEdMU0wzID8gJycgOiAnbGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IGhpZ2hwIHZlYzQgcGNfZnJhZ0NvbG9yOycsIHBhcmFtZXRlcnMuZ2xzbFZlcnNpb24gPT09IEdMU0wzID8gJycgOiAnI2RlZmluZSBnbF9GcmFnQ29sb3IgcGNfZnJhZ0NvbG9yJywgJyNkZWZpbmUgZ2xfRnJhZ0RlcHRoRVhUIGdsX0ZyYWdEZXB0aCcsICcjZGVmaW5lIHRleHR1cmUyRCB0ZXh0dXJlJywgJyNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZScsICcjZGVmaW5lIHRleHR1cmUyRFByb2ogdGV4dHVyZVByb2onLCAnI2RlZmluZSB0ZXh0dXJlMkRMb2RFWFQgdGV4dHVyZUxvZCcsICcjZGVmaW5lIHRleHR1cmUyRFByb2pMb2RFWFQgdGV4dHVyZVByb2pMb2QnLCAnI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZEVYVCB0ZXh0dXJlTG9kJywgJyNkZWZpbmUgdGV4dHVyZTJER3JhZEVYVCB0ZXh0dXJlR3JhZCcsICcjZGVmaW5lIHRleHR1cmUyRFByb2pHcmFkRVhUIHRleHR1cmVQcm9qR3JhZCcsICcjZGVmaW5lIHRleHR1cmVDdWJlR3JhZEVYVCB0ZXh0dXJlR3JhZCddLmpvaW4oJ1xcbicpICsgJ1xcbicgKyBwcmVmaXhGcmFnbWVudDtcbiAgfVxuXG4gIHZhciB2ZXJ0ZXhHbHNsID0gdmVyc2lvblN0cmluZyArIHByZWZpeFZlcnRleCArIHZlcnRleFNoYWRlcjtcbiAgdmFyIGZyYWdtZW50R2xzbCA9IHZlcnNpb25TdHJpbmcgKyBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyOyAvLyBjb25zb2xlLmxvZyggJypWRVJURVgqJywgdmVydGV4R2xzbCApO1xuICAvLyBjb25zb2xlLmxvZyggJypGUkFHTUVOVConLCBmcmFnbWVudEdsc2wgKTtcblxuICB2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBXZWJHTFNoYWRlcihnbCwgMzU2MzMsIHZlcnRleEdsc2wpO1xuICB2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFdlYkdMU2hhZGVyKGdsLCAzNTYzMiwgZnJhZ21lbnRHbHNsKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsVmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIpOyAvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXG5cbiAgaWYgKHBhcmFtZXRlcnMuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIDAsIHBhcmFtZXRlcnMuaW5kZXgwQXR0cmlidXRlTmFtZSk7XG4gIH0gZWxzZSBpZiAocGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPT09IHRydWUpIHtcbiAgICAvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcbiAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyk7XG4gIH1cblxuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsgLy8gY2hlY2sgZm9yIGxpbmsgZXJyb3JzXG5cbiAgaWYgKHJlbmRlcmVyLmRlYnVnLmNoZWNrU2hhZGVyRXJyb3JzKSB7XG4gICAgdmFyIHByb2dyYW1Mb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKS50cmltKCk7XG4gICAgdmFyIHZlcnRleExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coZ2xWZXJ0ZXhTaGFkZXIpLnRyaW0oKTtcbiAgICB2YXIgZnJhZ21lbnRMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKGdsRnJhZ21lbnRTaGFkZXIpLnRyaW0oKTtcbiAgICB2YXIgcnVubmFibGUgPSB0cnVlO1xuICAgIHZhciBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xuXG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgMzU3MTQpID09PSBmYWxzZSkge1xuICAgICAgcnVubmFibGUgPSBmYWxzZTtcbiAgICAgIHZhciB2ZXJ0ZXhFcnJvcnMgPSBnZXRTaGFkZXJFcnJvcnMoZ2wsIGdsVmVydGV4U2hhZGVyLCAndmVydGV4Jyk7XG4gICAgICB2YXIgZnJhZ21lbnRFcnJvcnMgPSBnZXRTaGFkZXJFcnJvcnMoZ2wsIGdsRnJhZ21lbnRTaGFkZXIsICdmcmFnbWVudCcpO1xuICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xQcm9ncmFtOiBTaGFkZXIgRXJyb3IgJyArIGdsLmdldEVycm9yKCkgKyAnIC0gJyArICdWQUxJREFURV9TVEFUVVMgJyArIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgMzU3MTUpICsgJ1xcblxcbicgKyAnUHJvZ3JhbSBJbmZvIExvZzogJyArIHByb2dyYW1Mb2cgKyAnXFxuJyArIHZlcnRleEVycm9ycyArICdcXG4nICsgZnJhZ21lbnRFcnJvcnMpO1xuICAgIH0gZWxzZSBpZiAocHJvZ3JhbUxvZyAhPT0gJycpIHtcbiAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xQcm9ncmFtOiBQcm9ncmFtIEluZm8gTG9nOicsIHByb2dyYW1Mb2cpO1xuICAgIH0gZWxzZSBpZiAodmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycpIHtcbiAgICAgIGhhdmVEaWFnbm9zdGljcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChoYXZlRGlhZ25vc3RpY3MpIHtcbiAgICAgIHRoaXMuZGlhZ25vc3RpY3MgPSB7XG4gICAgICAgIHJ1bm5hYmxlOiBydW5uYWJsZSxcbiAgICAgICAgcHJvZ3JhbUxvZzogcHJvZ3JhbUxvZyxcbiAgICAgICAgdmVydGV4U2hhZGVyOiB7XG4gICAgICAgICAgbG9nOiB2ZXJ0ZXhMb2csXG4gICAgICAgICAgcHJlZml4OiBwcmVmaXhWZXJ0ZXhcbiAgICAgICAgfSxcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IHtcbiAgICAgICAgICBsb2c6IGZyYWdtZW50TG9nLFxuICAgICAgICAgIHByZWZpeDogcHJlZml4RnJhZ21lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0gLy8gQ2xlYW4gdXBcbiAgLy8gQ3Jhc2hlcyBpbiBpT1M5IGFuZCBpT1MxMC4gIzE4NDAyXG4gIC8vIGdsLmRldGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcbiAgLy8gZ2wuZGV0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XG5cblxuICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIoZ2xGcmFnbWVudFNoYWRlcik7IC8vIHNldCB1cCBjYWNoaW5nIGZvciB1bmlmb3JtIGxvY2F0aW9uc1xuXG4gIHZhciBjYWNoZWRVbmlmb3JtcztcblxuICB0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWNoZWRVbmlmb3JtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYWNoZWRVbmlmb3JtcyA9IG5ldyBXZWJHTFVuaWZvcm1zKGdsLCBwcm9ncmFtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVkVW5pZm9ybXM7XG4gIH07IC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXG5cblxuICB2YXIgY2FjaGVkQXR0cmlidXRlcztcblxuICB0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKGdsLCBwcm9ncmFtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVkQXR0cmlidXRlcztcbiAgfTsgLy8gZnJlZSByZXNvdXJjZVxuXG5cbiAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGJpbmRpbmdTdGF0ZXMucmVsZWFzZVN0YXRlc09mUHJvZ3JhbSh0aGlzKTtcbiAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgIHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcbiAgfTsgLy9cblxuXG4gIHRoaXMubmFtZSA9IHBhcmFtZXRlcnMuc2hhZGVyTmFtZTtcbiAgdGhpcy5pZCA9IHByb2dyYW1JZENvdW50Kys7XG4gIHRoaXMuY2FjaGVLZXkgPSBjYWNoZUtleTtcbiAgdGhpcy51c2VkVGltZXMgPSAxO1xuICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICB0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xuICB0aGlzLmZyYWdtZW50U2hhZGVyID0gZ2xGcmFnbWVudFNoYWRlcjtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfaWQgPSAwO1xuXG52YXIgV2ViR0xTaGFkZXJDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdlYkdMU2hhZGVyQ2FjaGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMU2hhZGVyQ2FjaGUpO1xuXG4gICAgdGhpcy5zaGFkZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm1hdGVyaWFsQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViR0xTaGFkZXJDYWNoZSwgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShtYXRlcmlhbCkge1xuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLnZlcnRleFNoYWRlcjtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyO1xuXG4gICAgICB2YXIgdmVydGV4U2hhZGVyU3RhZ2UgPSB0aGlzLl9nZXRTaGFkZXJTdGFnZSh2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXJTdGFnZSA9IHRoaXMuX2dldFNoYWRlclN0YWdlKGZyYWdtZW50U2hhZGVyKTtcblxuICAgICAgdmFyIG1hdGVyaWFsU2hhZGVycyA9IHRoaXMuX2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwobWF0ZXJpYWwpO1xuXG4gICAgICBpZiAobWF0ZXJpYWxTaGFkZXJzLmhhcyh2ZXJ0ZXhTaGFkZXJTdGFnZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIG1hdGVyaWFsU2hhZGVycy5hZGQodmVydGV4U2hhZGVyU3RhZ2UpO1xuICAgICAgICB2ZXJ0ZXhTaGFkZXJTdGFnZS51c2VkVGltZXMrKztcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGVyaWFsU2hhZGVycy5oYXMoZnJhZ21lbnRTaGFkZXJTdGFnZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIG1hdGVyaWFsU2hhZGVycy5hZGQoZnJhZ21lbnRTaGFkZXJTdGFnZSk7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyU3RhZ2UudXNlZFRpbWVzKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKG1hdGVyaWFsKSB7XG4gICAgICB2YXIgbWF0ZXJpYWxTaGFkZXJzID0gdGhpcy5tYXRlcmlhbENhY2hlLmdldChtYXRlcmlhbCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihtYXRlcmlhbFNoYWRlcnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzaGFkZXJTdGFnZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHNoYWRlclN0YWdlLnVzZWRUaW1lcy0tO1xuICAgICAgICAgIGlmIChzaGFkZXJTdGFnZS51c2VkVGltZXMgPT09IDApIHRoaXMuc2hhZGVyQ2FjaGUuZGVsZXRlKHNoYWRlclN0YWdlLmNvZGUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWF0ZXJpYWxDYWNoZS5kZWxldGUobWF0ZXJpYWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZlcnRleFNoYWRlcklEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZlcnRleFNoYWRlcklEKG1hdGVyaWFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UobWF0ZXJpYWwudmVydGV4U2hhZGVyKS5pZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnJhZ21lbnRTaGFkZXJJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGcmFnbWVudFNoYWRlcklEKG1hdGVyaWFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2hhZGVyU3RhZ2UobWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIpLmlkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLnNoYWRlckNhY2hlLmNsZWFyKCk7XG4gICAgICB0aGlzLm1hdGVyaWFsQ2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNoYWRlckNhY2hlRm9yTWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMubWF0ZXJpYWxDYWNoZTtcblxuICAgICAgaWYgKGNhY2hlLmhhcyhtYXRlcmlhbCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGNhY2hlLnNldChtYXRlcmlhbCwgbmV3IFNldCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlLmdldChtYXRlcmlhbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTaGFkZXJTdGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2hhZGVyU3RhZ2UoY29kZSkge1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5zaGFkZXJDYWNoZTtcblxuICAgICAgaWYgKGNhY2hlLmhhcyhjb2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIHN0YWdlID0gbmV3IFdlYkdMU2hhZGVyU3RhZ2UoY29kZSk7XG4gICAgICAgIGNhY2hlLnNldChjb2RlLCBzdGFnZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZS5nZXQoY29kZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYkdMU2hhZGVyQ2FjaGU7XG59KCk7XG5cbnZhciBXZWJHTFNoYWRlclN0YWdlID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhmdW5jdGlvbiBXZWJHTFNoYWRlclN0YWdlKGNvZGUpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMU2hhZGVyU3RhZ2UpO1xuXG4gIHRoaXMuaWQgPSBfaWQrKztcbiAgdGhpcy5jb2RlID0gY29kZTtcbiAgdGhpcy51c2VkVGltZXMgPSAwO1xufSk7XG5cbmZ1bmN0aW9uIFdlYkdMUHJvZ3JhbXMocmVuZGVyZXIsIGN1YmVtYXBzLCBjdWJldXZtYXBzLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMsIGJpbmRpbmdTdGF0ZXMsIGNsaXBwaW5nKSB7XG4gIHZhciBfcHJvZ3JhbUxheWVycyA9IG5ldyBMYXllcnMoKTtcblxuICB2YXIgX2N1c3RvbVNoYWRlcnMgPSBuZXcgV2ViR0xTaGFkZXJDYWNoZSgpO1xuXG4gIHZhciBwcm9ncmFtcyA9IFtdO1xuICB2YXIgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG4gIHZhciBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXI7XG4gIHZhciB2ZXJ0ZXhUZXh0dXJlcyA9IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcztcbiAgdmFyIHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5wcmVjaXNpb247XG4gIHZhciBzaGFkZXJJRHMgPSB7XG4gICAgTWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXG4gICAgTWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuICAgIE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXG4gICAgTWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICAgIE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxuICAgIE1lc2hUb29uTWF0ZXJpYWw6ICd0b29uJyxcbiAgICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBNZXNoTWF0Y2FwTWF0ZXJpYWw6ICdtYXRjYXAnLFxuICAgIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICAgIExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gICAgUG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxuICAgIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgICBTcHJpdGVNYXRlcmlhbDogJ3Nwcml0ZSdcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKG1hdGVyaWFsLCBsaWdodHMsIHNoYWRvd3MsIHNjZW5lLCBvYmplY3QpIHtcbiAgICB2YXIgZm9nID0gc2NlbmUuZm9nO1xuICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgICB2YXIgZW52aXJvbm1lbnQgPSBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID8gc2NlbmUuZW52aXJvbm1lbnQgOiBudWxsO1xuICAgIHZhciBlbnZNYXAgPSAobWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcykuZ2V0KG1hdGVyaWFsLmVudk1hcCB8fCBlbnZpcm9ubWVudCk7XG4gICAgdmFyIGVudk1hcEN1YmVVVkhlaWdodCA9ICEhZW52TWFwICYmIGVudk1hcC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA/IGVudk1hcC5pbWFnZS5oZWlnaHQgOiBudWxsO1xuICAgIHZhciBzaGFkZXJJRCA9IHNoYWRlcklEc1ttYXRlcmlhbC50eXBlXTsgLy8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcbiAgICAvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxuXG4gICAgaWYgKG1hdGVyaWFsLnByZWNpc2lvbiAhPT0gbnVsbCkge1xuICAgICAgcHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbihtYXRlcmlhbC5wcmVjaXNpb24pO1xuXG4gICAgICBpZiAocHJlY2lzaW9uICE9PSBtYXRlcmlhbC5wcmVjaXNpb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyk7XG4gICAgICB9XG4gICAgfSAvL1xuXG5cbiAgICB2YXIgbW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XG4gICAgdmFyIG1vcnBoVGFyZ2V0c0NvdW50ID0gbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCA/IG1vcnBoQXR0cmlidXRlLmxlbmd0aCA6IDA7XG4gICAgdmFyIG1vcnBoVGV4dHVyZVN0cmlkZSA9IDA7XG4gICAgaWYgKGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSBtb3JwaFRleHR1cmVTdHJpZGUgPSAxO1xuICAgIGlmIChnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQpIG1vcnBoVGV4dHVyZVN0cmlkZSA9IDI7XG4gICAgaWYgKGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkKSBtb3JwaFRleHR1cmVTdHJpZGUgPSAzOyAvL1xuXG4gICAgdmFyIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXI7XG4gICAgdmFyIGN1c3RvbVZlcnRleFNoYWRlcklELCBjdXN0b21GcmFnbWVudFNoYWRlcklEO1xuXG4gICAgaWYgKHNoYWRlcklEKSB7XG4gICAgICB2YXIgc2hhZGVyID0gU2hhZGVyTGliW3NoYWRlcklEXTtcbiAgICAgIHZlcnRleFNoYWRlciA9IHNoYWRlci52ZXJ0ZXhTaGFkZXI7XG4gICAgICBmcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVydGV4U2hhZGVyID0gbWF0ZXJpYWwudmVydGV4U2hhZGVyO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlcjtcblxuICAgICAgX2N1c3RvbVNoYWRlcnMudXBkYXRlKG1hdGVyaWFsKTtcblxuICAgICAgY3VzdG9tVmVydGV4U2hhZGVySUQgPSBfY3VzdG9tU2hhZGVycy5nZXRWZXJ0ZXhTaGFkZXJJRChtYXRlcmlhbCk7XG4gICAgICBjdXN0b21GcmFnbWVudFNoYWRlcklEID0gX2N1c3RvbVNoYWRlcnMuZ2V0RnJhZ21lbnRTaGFkZXJJRChtYXRlcmlhbCk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcbiAgICB2YXIgdXNlQWxwaGFUZXN0ID0gbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMDtcbiAgICB2YXIgdXNlQ2xlYXJjb2F0ID0gbWF0ZXJpYWwuY2xlYXJjb2F0ID4gMDtcbiAgICB2YXIgdXNlSXJpZGVzY2VuY2UgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDA7XG4gICAgdmFyIHBhcmFtZXRlcnMgPSB7XG4gICAgICBpc1dlYkdMMjogaXNXZWJHTDIsXG4gICAgICBzaGFkZXJJRDogc2hhZGVySUQsXG4gICAgICBzaGFkZXJOYW1lOiBtYXRlcmlhbC50eXBlLFxuICAgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsXG4gICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRTaGFkZXIsXG4gICAgICBkZWZpbmVzOiBtYXRlcmlhbC5kZWZpbmVzLFxuICAgICAgY3VzdG9tVmVydGV4U2hhZGVySUQ6IGN1c3RvbVZlcnRleFNoYWRlcklELFxuICAgICAgY3VzdG9tRnJhZ21lbnRTaGFkZXJJRDogY3VzdG9tRnJhZ21lbnRTaGFkZXJJRCxcbiAgICAgIGlzUmF3U2hhZGVyTWF0ZXJpYWw6IG1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPT09IHRydWUsXG4gICAgICBnbHNsVmVyc2lvbjogbWF0ZXJpYWwuZ2xzbFZlcnNpb24sXG4gICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgIGluc3RhbmNpbmc6IG9iamVjdC5pc0luc3RhbmNlZE1lc2ggPT09IHRydWUsXG4gICAgICBpbnN0YW5jaW5nQ29sb3I6IG9iamVjdC5pc0luc3RhbmNlZE1lc2ggPT09IHRydWUgJiYgb2JqZWN0Lmluc3RhbmNlQ29sb3IgIT09IG51bGwsXG4gICAgICBzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiB2ZXJ0ZXhUZXh0dXJlcyxcbiAgICAgIG91dHB1dEVuY29kaW5nOiBjdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gcmVuZGVyZXIub3V0cHV0RW5jb2RpbmcgOiBjdXJyZW50UmVuZGVyVGFyZ2V0LmlzWFJSZW5kZXJUYXJnZXQgPT09IHRydWUgPyBjdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuZW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZyxcbiAgICAgIG1hcDogISFtYXRlcmlhbC5tYXAsXG4gICAgICBtYXRjYXA6ICEhbWF0ZXJpYWwubWF0Y2FwLFxuICAgICAgZW52TWFwOiAhIWVudk1hcCxcbiAgICAgIGVudk1hcE1vZGU6IGVudk1hcCAmJiBlbnZNYXAubWFwcGluZyxcbiAgICAgIGVudk1hcEN1YmVVVkhlaWdodDogZW52TWFwQ3ViZVVWSGVpZ2h0LFxuICAgICAgbGlnaHRNYXA6ICEhbWF0ZXJpYWwubGlnaHRNYXAsXG4gICAgICBhb01hcDogISFtYXRlcmlhbC5hb01hcCxcbiAgICAgIGVtaXNzaXZlTWFwOiAhIW1hdGVyaWFsLmVtaXNzaXZlTWFwLFxuICAgICAgYnVtcE1hcDogISFtYXRlcmlhbC5idW1wTWFwLFxuICAgICAgbm9ybWFsTWFwOiAhIW1hdGVyaWFsLm5vcm1hbE1hcCxcbiAgICAgIG9iamVjdFNwYWNlTm9ybWFsTWFwOiBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID09PSBPYmplY3RTcGFjZU5vcm1hbE1hcCxcbiAgICAgIHRhbmdlbnRTcGFjZU5vcm1hbE1hcDogbWF0ZXJpYWwubm9ybWFsTWFwVHlwZSA9PT0gVGFuZ2VudFNwYWNlTm9ybWFsTWFwLFxuICAgICAgZGVjb2RlVmlkZW9UZXh0dXJlOiAhIW1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuaXNWaWRlb1RleHR1cmUgPT09IHRydWUgJiYgbWF0ZXJpYWwubWFwLmVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcsXG4gICAgICBjbGVhcmNvYXQ6IHVzZUNsZWFyY29hdCxcbiAgICAgIGNsZWFyY29hdE1hcDogdXNlQ2xlYXJjb2F0ICYmICEhbWF0ZXJpYWwuY2xlYXJjb2F0TWFwLFxuICAgICAgY2xlYXJjb2F0Um91Z2huZXNzTWFwOiB1c2VDbGVhcmNvYXQgJiYgISFtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAsXG4gICAgICBjbGVhcmNvYXROb3JtYWxNYXA6IHVzZUNsZWFyY29hdCAmJiAhIW1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCxcbiAgICAgIGlyaWRlc2NlbmNlOiB1c2VJcmlkZXNjZW5jZSxcbiAgICAgIGlyaWRlc2NlbmNlTWFwOiB1c2VJcmlkZXNjZW5jZSAmJiAhIW1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwLFxuICAgICAgaXJpZGVzY2VuY2VUaGlja25lc3NNYXA6IHVzZUlyaWRlc2NlbmNlICYmICEhbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAsXG4gICAgICBkaXNwbGFjZW1lbnRNYXA6ICEhbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxuICAgICAgcm91Z2huZXNzTWFwOiAhIW1hdGVyaWFsLnJvdWdobmVzc01hcCxcbiAgICAgIG1ldGFsbmVzc01hcDogISFtYXRlcmlhbC5tZXRhbG5lc3NNYXAsXG4gICAgICBzcGVjdWxhck1hcDogISFtYXRlcmlhbC5zcGVjdWxhck1hcCxcbiAgICAgIHNwZWN1bGFySW50ZW5zaXR5TWFwOiAhIW1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwLFxuICAgICAgc3BlY3VsYXJDb2xvck1hcDogISFtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwLFxuICAgICAgb3BhcXVlOiBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gZmFsc2UgJiYgbWF0ZXJpYWwuYmxlbmRpbmcgPT09IE5vcm1hbEJsZW5kaW5nLFxuICAgICAgYWxwaGFNYXA6ICEhbWF0ZXJpYWwuYWxwaGFNYXAsXG4gICAgICBhbHBoYVRlc3Q6IHVzZUFscGhhVGVzdCxcbiAgICAgIGdyYWRpZW50TWFwOiAhIW1hdGVyaWFsLmdyYWRpZW50TWFwLFxuICAgICAgc2hlZW46IG1hdGVyaWFsLnNoZWVuID4gMCxcbiAgICAgIHNoZWVuQ29sb3JNYXA6ICEhbWF0ZXJpYWwuc2hlZW5Db2xvck1hcCxcbiAgICAgIHNoZWVuUm91Z2huZXNzTWFwOiAhIW1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwLFxuICAgICAgdHJhbnNtaXNzaW9uOiBtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwLFxuICAgICAgdHJhbnNtaXNzaW9uTWFwOiAhIW1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCxcbiAgICAgIHRoaWNrbmVzc01hcDogISFtYXRlcmlhbC50aGlja25lc3NNYXAsXG4gICAgICBjb21iaW5lOiBtYXRlcmlhbC5jb21iaW5lLFxuICAgICAgdmVydGV4VGFuZ2VudHM6ICEhbWF0ZXJpYWwubm9ybWFsTWFwICYmICEhZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50LFxuICAgICAgdmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG4gICAgICB2ZXJ0ZXhBbHBoYXM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyA9PT0gdHJ1ZSAmJiAhIWdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgJiYgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5pdGVtU2l6ZSA9PT0gNCxcbiAgICAgIHZlcnRleFV2czogISFtYXRlcmlhbC5tYXAgfHwgISFtYXRlcmlhbC5idW1wTWFwIHx8ICEhbWF0ZXJpYWwubm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJNYXAgfHwgISFtYXRlcmlhbC5hbHBoYU1hcCB8fCAhIW1hdGVyaWFsLmVtaXNzaXZlTWFwIHx8ICEhbWF0ZXJpYWwucm91Z2huZXNzTWFwIHx8ICEhbWF0ZXJpYWwubWV0YWxuZXNzTWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0TWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzTWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgfHwgISFtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCB8fCAhIW1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCB8fCAhIW1hdGVyaWFsLnRyYW5zbWlzc2lvbk1hcCB8fCAhIW1hdGVyaWFsLnRoaWNrbmVzc01hcCB8fCAhIW1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5TWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCB8fCAhIW1hdGVyaWFsLnNoZWVuQ29sb3JNYXAgfHwgISFtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCxcbiAgICAgIHV2c1ZlcnRleE9ubHk6ICEoISFtYXRlcmlhbC5tYXAgfHwgISFtYXRlcmlhbC5idW1wTWFwIHx8ICEhbWF0ZXJpYWwubm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJNYXAgfHwgISFtYXRlcmlhbC5hbHBoYU1hcCB8fCAhIW1hdGVyaWFsLmVtaXNzaXZlTWFwIHx8ICEhbWF0ZXJpYWwucm91Z2huZXNzTWFwIHx8ICEhbWF0ZXJpYWwubWV0YWxuZXNzTWFwIHx8ICEhbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsTWFwIHx8ICEhbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXAgfHwgISFtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCB8fCBtYXRlcmlhbC50cmFuc21pc3Npb24gPiAwIHx8ICEhbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwIHx8ICEhbWF0ZXJpYWwudGhpY2tuZXNzTWFwIHx8ICEhbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAgfHwgISFtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwIHx8IG1hdGVyaWFsLnNoZWVuID4gMCB8fCAhIW1hdGVyaWFsLnNoZWVuQ29sb3JNYXAgfHwgISFtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCkgJiYgISFtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXG4gICAgICBmb2c6ICEhZm9nLFxuICAgICAgdXNlRm9nOiBtYXRlcmlhbC5mb2cgPT09IHRydWUsXG4gICAgICBmb2dFeHAyOiBmb2cgJiYgZm9nLmlzRm9nRXhwMixcbiAgICAgIGZsYXRTaGFkaW5nOiAhIW1hdGVyaWFsLmZsYXRTaGFkaW5nLFxuICAgICAgc2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXG4gICAgICBsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuICAgICAgc2tpbm5pbmc6IG9iamVjdC5pc1NraW5uZWRNZXNoID09PSB0cnVlLFxuICAgICAgbW9ycGhUYXJnZXRzOiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCxcbiAgICAgIG1vcnBoTm9ybWFsczogZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkLFxuICAgICAgbW9ycGhDb2xvcnM6IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkLFxuICAgICAgbW9ycGhUYXJnZXRzQ291bnQ6IG1vcnBoVGFyZ2V0c0NvdW50LFxuICAgICAgbW9ycGhUZXh0dXJlU3RyaWRlOiBtb3JwaFRleHR1cmVTdHJpZGUsXG4gICAgICBudW1EaXJMaWdodHM6IGxpZ2h0cy5kaXJlY3Rpb25hbC5sZW5ndGgsXG4gICAgICBudW1Qb2ludExpZ2h0czogbGlnaHRzLnBvaW50Lmxlbmd0aCxcbiAgICAgIG51bVNwb3RMaWdodHM6IGxpZ2h0cy5zcG90Lmxlbmd0aCxcbiAgICAgIG51bVJlY3RBcmVhTGlnaHRzOiBsaWdodHMucmVjdEFyZWEubGVuZ3RoLFxuICAgICAgbnVtSGVtaUxpZ2h0czogbGlnaHRzLmhlbWkubGVuZ3RoLFxuICAgICAgbnVtRGlyTGlnaHRTaGFkb3dzOiBsaWdodHMuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoLFxuICAgICAgbnVtUG9pbnRMaWdodFNoYWRvd3M6IGxpZ2h0cy5wb2ludFNoYWRvd01hcC5sZW5ndGgsXG4gICAgICBudW1TcG90TGlnaHRTaGFkb3dzOiBsaWdodHMuc3BvdFNoYWRvd01hcC5sZW5ndGgsXG4gICAgICBudW1DbGlwcGluZ1BsYW5lczogY2xpcHBpbmcubnVtUGxhbmVzLFxuICAgICAgbnVtQ2xpcEludGVyc2VjdGlvbjogY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uLFxuICAgICAgZGl0aGVyaW5nOiBtYXRlcmlhbC5kaXRoZXJpbmcsXG4gICAgICBzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBzaGFkb3dzLmxlbmd0aCA+IDAsXG4gICAgICBzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcbiAgICAgIHRvbmVNYXBwaW5nOiBtYXRlcmlhbC50b25lTWFwcGVkID8gcmVuZGVyZXIudG9uZU1hcHBpbmcgOiBOb1RvbmVNYXBwaW5nLFxuICAgICAgcGh5c2ljYWxseUNvcnJlY3RMaWdodHM6IHJlbmRlcmVyLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzLFxuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEsXG4gICAgICBkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSxcbiAgICAgIGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUsXG4gICAgICB1c2VEZXB0aFBhY2tpbmc6ICEhbWF0ZXJpYWwuZGVwdGhQYWNraW5nLFxuICAgICAgZGVwdGhQYWNraW5nOiBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgfHwgMCxcbiAgICAgIGluZGV4MEF0dHJpYnV0ZU5hbWU6IG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUsXG4gICAgICBleHRlbnNpb25EZXJpdmF0aXZlczogbWF0ZXJpYWwuZXh0ZW5zaW9ucyAmJiBtYXRlcmlhbC5leHRlbnNpb25zLmRlcml2YXRpdmVzLFxuICAgICAgZXh0ZW5zaW9uRnJhZ0RlcHRoOiBtYXRlcmlhbC5leHRlbnNpb25zICYmIG1hdGVyaWFsLmV4dGVuc2lvbnMuZnJhZ0RlcHRoLFxuICAgICAgZXh0ZW5zaW9uRHJhd0J1ZmZlcnM6IG1hdGVyaWFsLmV4dGVuc2lvbnMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5kcmF3QnVmZmVycyxcbiAgICAgIGV4dGVuc2lvblNoYWRlclRleHR1cmVMT0Q6IG1hdGVyaWFsLmV4dGVuc2lvbnMgJiYgbWF0ZXJpYWwuZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9ELFxuICAgICAgcmVuZGVyZXJFeHRlbnNpb25GcmFnRGVwdGg6IGlzV2ViR0wyIHx8IGV4dGVuc2lvbnMuaGFzKCdFWFRfZnJhZ19kZXB0aCcpLFxuICAgICAgcmVuZGVyZXJFeHRlbnNpb25EcmF3QnVmZmVyczogaXNXZWJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxuICAgICAgcmVuZGVyZXJFeHRlbnNpb25TaGFkZXJUZXh0dXJlTG9kOiBpc1dlYkdMMiB8fCBleHRlbnNpb25zLmhhcygnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcpLFxuICAgICAgY3VzdG9tUHJvZ3JhbUNhY2hlS2V5OiBtYXRlcmlhbC5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKVxuICAgIH07XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9ncmFtQ2FjaGVLZXkocGFyYW1ldGVycykge1xuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgaWYgKHBhcmFtZXRlcnMuc2hhZGVySUQpIHtcbiAgICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5zaGFkZXJJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5jdXN0b21WZXJ0ZXhTaGFkZXJJRCk7XG4gICAgICBhcnJheS5wdXNoKHBhcmFtZXRlcnMuY3VzdG9tRnJhZ21lbnRTaGFkZXJJRCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtZXRlcnMuZGVmaW5lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHBhcmFtZXRlcnMuZGVmaW5lcykge1xuICAgICAgICBhcnJheS5wdXNoKG5hbWUpO1xuICAgICAgICBhcnJheS5wdXNoKHBhcmFtZXRlcnMuZGVmaW5lc1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtZXRlcnMuaXNSYXdTaGFkZXJNYXRlcmlhbCA9PT0gZmFsc2UpIHtcbiAgICAgIGdldFByb2dyYW1DYWNoZUtleVBhcmFtZXRlcnMoYXJyYXksIHBhcmFtZXRlcnMpO1xuICAgICAgZ2V0UHJvZ3JhbUNhY2hlS2V5Qm9vbGVhbnMoYXJyYXksIHBhcmFtZXRlcnMpO1xuICAgICAgYXJyYXkucHVzaChyZW5kZXJlci5vdXRwdXRFbmNvZGluZyk7XG4gICAgfVxuXG4gICAgYXJyYXkucHVzaChwYXJhbWV0ZXJzLmN1c3RvbVByb2dyYW1DYWNoZUtleSk7XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByb2dyYW1DYWNoZUtleVBhcmFtZXRlcnMoYXJyYXksIHBhcmFtZXRlcnMpIHtcbiAgICBhcnJheS5wdXNoKHBhcmFtZXRlcnMucHJlY2lzaW9uKTtcbiAgICBhcnJheS5wdXNoKHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5lbnZNYXBNb2RlKTtcbiAgICBhcnJheS5wdXNoKHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWSGVpZ2h0KTtcbiAgICBhcnJheS5wdXNoKHBhcmFtZXRlcnMuY29tYmluZSk7XG4gICAgYXJyYXkucHVzaChwYXJhbWV0ZXJzLnZlcnRleFV2cyk7XG4gICAgYXJyYXkucHVzaChwYXJhbWV0ZXJzLmZvZ0V4cDIpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24pO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5tb3JwaFRhcmdldHNDb3VudCk7XG4gICAgYXJyYXkucHVzaChwYXJhbWV0ZXJzLm1vcnBoQXR0cmlidXRlQ291bnQpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1EaXJMaWdodHMpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1Qb2ludExpZ2h0cyk7XG4gICAgYXJyYXkucHVzaChwYXJhbWV0ZXJzLm51bVNwb3RMaWdodHMpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1IZW1pTGlnaHRzKTtcbiAgICBhcnJheS5wdXNoKHBhcmFtZXRlcnMubnVtUmVjdEFyZWFMaWdodHMpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1EaXJMaWdodFNoYWRvd3MpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1Qb2ludExpZ2h0U2hhZG93cyk7XG4gICAgYXJyYXkucHVzaChwYXJhbWV0ZXJzLm51bVNwb3RMaWdodFNoYWRvd3MpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlKTtcbiAgICBhcnJheS5wdXNoKHBhcmFtZXRlcnMudG9uZU1hcHBpbmcpO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyk7XG4gICAgYXJyYXkucHVzaChwYXJhbWV0ZXJzLm51bUNsaXBJbnRlcnNlY3Rpb24pO1xuICAgIGFycmF5LnB1c2gocGFyYW1ldGVycy5kZXB0aFBhY2tpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJvZ3JhbUNhY2hlS2V5Qm9vbGVhbnMoYXJyYXksIHBhcmFtZXRlcnMpIHtcbiAgICBfcHJvZ3JhbUxheWVycy5kaXNhYmxlQWxsKCk7XG5cbiAgICBpZiAocGFyYW1ldGVycy5pc1dlYkdMMikgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDApO1xuICAgIGlmIChwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxKTtcbiAgICBpZiAocGFyYW1ldGVycy5pbnN0YW5jaW5nKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMik7XG4gICAgaWYgKHBhcmFtZXRlcnMuaW5zdGFuY2luZ0NvbG9yKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMyk7XG4gICAgaWYgKHBhcmFtZXRlcnMubWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNCk7XG4gICAgaWYgKHBhcmFtZXRlcnMubWF0Y2FwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNSk7XG4gICAgaWYgKHBhcmFtZXRlcnMuZW52TWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNik7XG4gICAgaWYgKHBhcmFtZXRlcnMubGlnaHRNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSg3KTtcbiAgICBpZiAocGFyYW1ldGVycy5hb01hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDgpO1xuICAgIGlmIChwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoOSk7XG4gICAgaWYgKHBhcmFtZXRlcnMuYnVtcE1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDEwKTtcbiAgICBpZiAocGFyYW1ldGVycy5ub3JtYWxNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxMSk7XG4gICAgaWYgKHBhcmFtZXRlcnMub2JqZWN0U3BhY2VOb3JtYWxNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxMik7XG4gICAgaWYgKHBhcmFtZXRlcnMudGFuZ2VudFNwYWNlTm9ybWFsTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTMpO1xuICAgIGlmIChwYXJhbWV0ZXJzLmNsZWFyY29hdCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE0KTtcbiAgICBpZiAocGFyYW1ldGVycy5jbGVhcmNvYXRNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxNSk7XG4gICAgaWYgKHBhcmFtZXRlcnMuY2xlYXJjb2F0Um91Z2huZXNzTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTYpO1xuICAgIGlmIChwYXJhbWV0ZXJzLmNsZWFyY29hdE5vcm1hbE1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE3KTtcbiAgICBpZiAocGFyYW1ldGVycy5pcmlkZXNjZW5jZSkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE4KTtcbiAgICBpZiAocGFyYW1ldGVycy5pcmlkZXNjZW5jZU1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE5KTtcbiAgICBpZiAocGFyYW1ldGVycy5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDIwKTtcbiAgICBpZiAocGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyMSk7XG4gICAgaWYgKHBhcmFtZXRlcnMuc3BlY3VsYXJNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyMik7XG4gICAgaWYgKHBhcmFtZXRlcnMucm91Z2huZXNzTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMjMpO1xuICAgIGlmIChwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDI0KTtcbiAgICBpZiAocGFyYW1ldGVycy5ncmFkaWVudE1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDI1KTtcbiAgICBpZiAocGFyYW1ldGVycy5hbHBoYU1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDI2KTtcbiAgICBpZiAocGFyYW1ldGVycy5hbHBoYVRlc3QpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyNyk7XG4gICAgaWYgKHBhcmFtZXRlcnMudmVydGV4Q29sb3JzKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMjgpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnZlcnRleEFscGhhcykgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDI5KTtcbiAgICBpZiAocGFyYW1ldGVycy52ZXJ0ZXhVdnMpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgzMCk7XG4gICAgaWYgKHBhcmFtZXRlcnMudmVydGV4VGFuZ2VudHMpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgzMSk7XG4gICAgaWYgKHBhcmFtZXRlcnMudXZzVmVydGV4T25seSkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDMyKTtcbiAgICBpZiAocGFyYW1ldGVycy5mb2cpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgzMyk7XG4gICAgYXJyYXkucHVzaChfcHJvZ3JhbUxheWVycy5tYXNrKTtcblxuICAgIF9wcm9ncmFtTGF5ZXJzLmRpc2FibGVBbGwoKTtcblxuICAgIGlmIChwYXJhbWV0ZXJzLnVzZUZvZykgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDApO1xuICAgIGlmIChwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMSk7XG4gICAgaWYgKHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcikgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDIpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnNraW5uaW5nKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMyk7XG4gICAgaWYgKHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNCk7XG4gICAgaWYgKHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoNSk7XG4gICAgaWYgKHBhcmFtZXRlcnMubW9ycGhDb2xvcnMpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSg2KTtcbiAgICBpZiAocGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSg3KTtcbiAgICBpZiAocGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoOCk7XG4gICAgaWYgKHBhcmFtZXRlcnMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSg5KTtcbiAgICBpZiAocGFyYW1ldGVycy5kb3VibGVTaWRlZCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDEwKTtcbiAgICBpZiAocGFyYW1ldGVycy5mbGlwU2lkZWQpIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxMSk7XG4gICAgaWYgKHBhcmFtZXRlcnMudXNlRGVwdGhQYWNraW5nKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTIpO1xuICAgIGlmIChwYXJhbWV0ZXJzLmRpdGhlcmluZykgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDEzKTtcbiAgICBpZiAocGFyYW1ldGVycy5zcGVjdWxhckludGVuc2l0eU1hcCkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE0KTtcbiAgICBpZiAocGFyYW1ldGVycy5zcGVjdWxhckNvbG9yTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTUpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnRyYW5zbWlzc2lvbikgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDE2KTtcbiAgICBpZiAocGFyYW1ldGVycy50cmFuc21pc3Npb25NYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgxNyk7XG4gICAgaWYgKHBhcmFtZXRlcnMudGhpY2tuZXNzTWFwKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTgpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnNoZWVuKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMTkpO1xuICAgIGlmIChwYXJhbWV0ZXJzLnNoZWVuQ29sb3JNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyMCk7XG4gICAgaWYgKHBhcmFtZXRlcnMuc2hlZW5Sb3VnaG5lc3NNYXApIF9wcm9ncmFtTGF5ZXJzLmVuYWJsZSgyMSk7XG4gICAgaWYgKHBhcmFtZXRlcnMuZGVjb2RlVmlkZW9UZXh0dXJlKSBfcHJvZ3JhbUxheWVycy5lbmFibGUoMjIpO1xuICAgIGlmIChwYXJhbWV0ZXJzLm9wYXF1ZSkgX3Byb2dyYW1MYXllcnMuZW5hYmxlKDIzKTtcbiAgICBhcnJheS5wdXNoKF9wcm9ncmFtTGF5ZXJzLm1hc2spO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VW5pZm9ybXMobWF0ZXJpYWwpIHtcbiAgICB2YXIgc2hhZGVySUQgPSBzaGFkZXJJRHNbbWF0ZXJpYWwudHlwZV07XG4gICAgdmFyIHVuaWZvcm1zO1xuXG4gICAgaWYgKHNoYWRlcklEKSB7XG4gICAgICB2YXIgc2hhZGVyID0gU2hhZGVyTGliW3NoYWRlcklEXTtcbiAgICAgIHVuaWZvcm1zID0gVW5pZm9ybXNVdGlscy5jbG9uZShzaGFkZXIudW5pZm9ybXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuICAgIH1cblxuICAgIHJldHVybiB1bmlmb3JtcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjcXVpcmVQcm9ncmFtKHBhcmFtZXRlcnMsIGNhY2hlS2V5KSB7XG4gICAgdmFyIHByb2dyYW07IC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxuXG4gICAgZm9yICh2YXIgcCA9IDAsIHBsID0gcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHArKykge1xuICAgICAgdmFyIHByZWV4aXN0aW5nUHJvZ3JhbSA9IHByb2dyYW1zW3BdO1xuXG4gICAgICBpZiAocHJlZXhpc3RpbmdQcm9ncmFtLmNhY2hlS2V5ID09PSBjYWNoZUtleSkge1xuICAgICAgICBwcm9ncmFtID0gcHJlZXhpc3RpbmdQcm9ncmFtO1xuICAgICAgICArK3Byb2dyYW0udXNlZFRpbWVzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvZ3JhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9ncmFtID0gbmV3IFdlYkdMUHJvZ3JhbShyZW5kZXJlciwgY2FjaGVLZXksIHBhcmFtZXRlcnMsIGJpbmRpbmdTdGF0ZXMpO1xuICAgICAgcHJvZ3JhbXMucHVzaChwcm9ncmFtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbGVhc2VQcm9ncmFtKHByb2dyYW0pIHtcbiAgICBpZiAoLS1wcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxuICAgICAgdmFyIF9pMTE1ID0gcHJvZ3JhbXMuaW5kZXhPZihwcm9ncmFtKTtcblxuICAgICAgcHJvZ3JhbXNbX2kxMTVdID0gcHJvZ3JhbXNbcHJvZ3JhbXMubGVuZ3RoIC0gMV07XG4gICAgICBwcm9ncmFtcy5wb3AoKTsgLy8gRnJlZSBXZWJHTCByZXNvdXJjZXNcblxuICAgICAgcHJvZ3JhbS5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVsZWFzZVNoYWRlckNhY2hlKG1hdGVyaWFsKSB7XG4gICAgX2N1c3RvbVNoYWRlcnMucmVtb3ZlKG1hdGVyaWFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgX2N1c3RvbVNoYWRlcnMuZGlzcG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRQYXJhbWV0ZXJzOiBnZXRQYXJhbWV0ZXJzLFxuICAgIGdldFByb2dyYW1DYWNoZUtleTogZ2V0UHJvZ3JhbUNhY2hlS2V5LFxuICAgIGdldFVuaWZvcm1zOiBnZXRVbmlmb3JtcyxcbiAgICBhY3F1aXJlUHJvZ3JhbTogYWNxdWlyZVByb2dyYW0sXG4gICAgcmVsZWFzZVByb2dyYW06IHJlbGVhc2VQcm9ncmFtLFxuICAgIHJlbGVhc2VTaGFkZXJDYWNoZTogcmVsZWFzZVNoYWRlckNhY2hlLFxuICAgIC8vIEV4cG9zZWQgZm9yIHJlc291cmNlIG1vbml0b3JpbmcgJiBlcnJvciBmZWVkYmFjayB2aWEgcmVuZGVyZXIuaW5mbzpcbiAgICBwcm9ncmFtczogcHJvZ3JhbXMsXG4gICAgZGlzcG9zZTogZGlzcG9zZVxuICB9O1xufVxuXG5mdW5jdGlvbiBXZWJHTFByb3BlcnRpZXMoKSB7XG4gIHZhciBwcm9wZXJ0aWVzID0gbmV3IFdlYWtNYXAoKTtcblxuICBmdW5jdGlvbiBnZXQob2JqZWN0KSB7XG4gICAgdmFyIG1hcCA9IHByb3BlcnRpZXMuZ2V0KG9iamVjdCk7XG5cbiAgICBpZiAobWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1hcCA9IHt9O1xuICAgICAgcHJvcGVydGllcy5zZXQob2JqZWN0LCBtYXApO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG4gICAgcHJvcGVydGllcy5kZWxldGUob2JqZWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICBwcm9wZXJ0aWVzLmdldChvYmplY3QpW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgcHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldDogZ2V0LFxuICAgIHJlbW92ZTogcmVtb3ZlLFxuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIGRpc3Bvc2U6IGRpc3Bvc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoYSwgYikge1xuICBpZiAoYS5ncm91cE9yZGVyICE9PSBiLmdyb3VwT3JkZXIpIHtcbiAgICByZXR1cm4gYS5ncm91cE9yZGVyIC0gYi5ncm91cE9yZGVyO1xuICB9IGVsc2UgaWYgKGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIpIHtcbiAgICByZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XG4gIH0gZWxzZSBpZiAoYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCkge1xuICAgIHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcbiAgfSBlbHNlIGlmIChhLnogIT09IGIueikge1xuICAgIHJldHVybiBhLnogLSBiLno7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZShhLCBiKSB7XG4gIGlmIChhLmdyb3VwT3JkZXIgIT09IGIuZ3JvdXBPcmRlcikge1xuICAgIHJldHVybiBhLmdyb3VwT3JkZXIgLSBiLmdyb3VwT3JkZXI7XG4gIH0gZWxzZSBpZiAoYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlcikge1xuICAgIHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcbiAgfSBlbHNlIGlmIChhLnogIT09IGIueikge1xuICAgIHJldHVybiBiLnogLSBhLno7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdlYkdMUmVuZGVyTGlzdCgpIHtcbiAgdmFyIHJlbmRlckl0ZW1zID0gW107XG4gIHZhciByZW5kZXJJdGVtc0luZGV4ID0gMDtcbiAgdmFyIG9wYXF1ZSA9IFtdO1xuICB2YXIgdHJhbnNtaXNzaXZlID0gW107XG4gIHZhciB0cmFuc3BhcmVudCA9IFtdO1xuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgcmVuZGVySXRlbXNJbmRleCA9IDA7XG4gICAgb3BhcXVlLmxlbmd0aCA9IDA7XG4gICAgdHJhbnNtaXNzaXZlLmxlbmd0aCA9IDA7XG4gICAgdHJhbnNwYXJlbnQubGVuZ3RoID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5leHRSZW5kZXJJdGVtKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCkge1xuICAgIHZhciByZW5kZXJJdGVtID0gcmVuZGVySXRlbXNbcmVuZGVySXRlbXNJbmRleF07XG5cbiAgICBpZiAocmVuZGVySXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJJdGVtID0ge1xuICAgICAgICBpZDogb2JqZWN0LmlkLFxuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICBtYXRlcmlhbDogbWF0ZXJpYWwsXG4gICAgICAgIGdyb3VwT3JkZXI6IGdyb3VwT3JkZXIsXG4gICAgICAgIHJlbmRlck9yZGVyOiBvYmplY3QucmVuZGVyT3JkZXIsXG4gICAgICAgIHo6IHosXG4gICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgfTtcbiAgICAgIHJlbmRlckl0ZW1zW3JlbmRlckl0ZW1zSW5kZXhdID0gcmVuZGVySXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVySXRlbS5pZCA9IG9iamVjdC5pZDtcbiAgICAgIHJlbmRlckl0ZW0ub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgcmVuZGVySXRlbS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgcmVuZGVySXRlbS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgcmVuZGVySXRlbS5ncm91cE9yZGVyID0gZ3JvdXBPcmRlcjtcbiAgICAgIHJlbmRlckl0ZW0ucmVuZGVyT3JkZXIgPSBvYmplY3QucmVuZGVyT3JkZXI7XG4gICAgICByZW5kZXJJdGVtLnogPSB6O1xuICAgICAgcmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xuICAgIH1cblxuICAgIHJlbmRlckl0ZW1zSW5kZXgrKztcbiAgICByZXR1cm4gcmVuZGVySXRlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gob2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwT3JkZXIsIHosIGdyb3VwKSB7XG4gICAgdmFyIHJlbmRlckl0ZW0gPSBnZXROZXh0UmVuZGVySXRlbShvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXApO1xuXG4gICAgaWYgKG1hdGVyaWFsLnRyYW5zbWlzc2lvbiA+IDAuMCkge1xuICAgICAgdHJhbnNtaXNzaXZlLnB1c2gocmVuZGVySXRlbSk7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSkge1xuICAgICAgdHJhbnNwYXJlbnQucHVzaChyZW5kZXJJdGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3BhcXVlLnB1c2gocmVuZGVySXRlbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW5zaGlmdChvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgeiwgZ3JvdXApIHtcbiAgICB2YXIgcmVuZGVySXRlbSA9IGdldE5leHRSZW5kZXJJdGVtKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cE9yZGVyLCB6LCBncm91cCk7XG5cbiAgICBpZiAobWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMC4wKSB7XG4gICAgICB0cmFuc21pc3NpdmUudW5zaGlmdChyZW5kZXJJdGVtKTtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlKSB7XG4gICAgICB0cmFuc3BhcmVudC51bnNoaWZ0KHJlbmRlckl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGFxdWUudW5zaGlmdChyZW5kZXJJdGVtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzb3J0KGN1c3RvbU9wYXF1ZVNvcnQsIGN1c3RvbVRyYW5zcGFyZW50U29ydCkge1xuICAgIGlmIChvcGFxdWUubGVuZ3RoID4gMSkgb3BhcXVlLnNvcnQoY3VzdG9tT3BhcXVlU29ydCB8fCBwYWludGVyU29ydFN0YWJsZSk7XG4gICAgaWYgKHRyYW5zbWlzc2l2ZS5sZW5ndGggPiAxKSB0cmFuc21pc3NpdmUuc29ydChjdXN0b21UcmFuc3BhcmVudFNvcnQgfHwgcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKTtcbiAgICBpZiAodHJhbnNwYXJlbnQubGVuZ3RoID4gMSkgdHJhbnNwYXJlbnQuc29ydChjdXN0b21UcmFuc3BhcmVudFNvcnQgfHwgcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAvLyBDbGVhciByZWZlcmVuY2VzIGZyb20gaW5hY3RpdmUgcmVuZGVySXRlbXMgaW4gdGhlIGxpc3RcbiAgICBmb3IgKHZhciBfaTExNiA9IHJlbmRlckl0ZW1zSW5kZXgsIGlsID0gcmVuZGVySXRlbXMubGVuZ3RoOyBfaTExNiA8IGlsOyBfaTExNisrKSB7XG4gICAgICB2YXIgcmVuZGVySXRlbSA9IHJlbmRlckl0ZW1zW19pMTE2XTtcbiAgICAgIGlmIChyZW5kZXJJdGVtLmlkID09PSBudWxsKSBicmVhaztcbiAgICAgIHJlbmRlckl0ZW0uaWQgPSBudWxsO1xuICAgICAgcmVuZGVySXRlbS5vYmplY3QgPSBudWxsO1xuICAgICAgcmVuZGVySXRlbS5nZW9tZXRyeSA9IG51bGw7XG4gICAgICByZW5kZXJJdGVtLm1hdGVyaWFsID0gbnVsbDtcbiAgICAgIHJlbmRlckl0ZW0uZ3JvdXAgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3BhcXVlOiBvcGFxdWUsXG4gICAgdHJhbnNtaXNzaXZlOiB0cmFuc21pc3NpdmUsXG4gICAgdHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50LFxuICAgIGluaXQ6IGluaXQsXG4gICAgcHVzaDogcHVzaCxcbiAgICB1bnNoaWZ0OiB1bnNoaWZ0LFxuICAgIGZpbmlzaDogZmluaXNoLFxuICAgIHNvcnQ6IHNvcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gV2ViR0xSZW5kZXJMaXN0cygpIHtcbiAgdmFyIGxpc3RzID0gbmV3IFdlYWtNYXAoKTtcblxuICBmdW5jdGlvbiBnZXQoc2NlbmUsIHJlbmRlckNhbGxEZXB0aCkge1xuICAgIHZhciBsaXN0O1xuXG4gICAgaWYgKGxpc3RzLmhhcyhzY2VuZSkgPT09IGZhbHNlKSB7XG4gICAgICBsaXN0ID0gbmV3IFdlYkdMUmVuZGVyTGlzdCgpO1xuICAgICAgbGlzdHMuc2V0KHNjZW5lLCBbbGlzdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyQ2FsbERlcHRoID49IGxpc3RzLmdldChzY2VuZSkubGVuZ3RoKSB7XG4gICAgICAgIGxpc3QgPSBuZXcgV2ViR0xSZW5kZXJMaXN0KCk7XG4gICAgICAgIGxpc3RzLmdldChzY2VuZSkucHVzaChsaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QgPSBsaXN0cy5nZXQoc2NlbmUpW3JlbmRlckNhbGxEZXB0aF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGxpc3RzID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXQsXG4gICAgZGlzcG9zZTogZGlzcG9zZVxuICB9O1xufVxuXG5mdW5jdGlvbiBVbmlmb3Jtc0NhY2hlKCkge1xuICB2YXIgbGlnaHRzID0ge307XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQobGlnaHQpIHtcbiAgICAgIGlmIChsaWdodHNbbGlnaHQuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxpZ2h0c1tsaWdodC5pZF07XG4gICAgICB9XG5cbiAgICAgIHZhciB1bmlmb3JtcztcblxuICAgICAgc3dpdGNoIChsaWdodC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuICAgICAgICAgIHVuaWZvcm1zID0ge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxuICAgICAgICAgICAgY29sb3I6IG5ldyBDb2xvcigpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTcG90TGlnaHQnOlxuICAgICAgICAgIHVuaWZvcm1zID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgICBkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG4gICAgICAgICAgICBjb2xvcjogbmV3IENvbG9yKCksXG4gICAgICAgICAgICBkaXN0YW5jZTogMCxcbiAgICAgICAgICAgIGNvbmVDb3M6IDAsXG4gICAgICAgICAgICBwZW51bWJyYUNvczogMCxcbiAgICAgICAgICAgIGRlY2F5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQb2ludExpZ2h0JzpcbiAgICAgICAgICB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxuICAgICAgICAgICAgY29sb3I6IG5ldyBDb2xvcigpLFxuICAgICAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgICAgICBkZWNheTogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcbiAgICAgICAgICB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICAgICAgICAgIHNreUNvbG9yOiBuZXcgQ29sb3IoKSxcbiAgICAgICAgICAgIGdyb3VuZENvbG9yOiBuZXcgQ29sb3IoKVxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUmVjdEFyZWFMaWdodCc6XG4gICAgICAgICAgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgICBjb2xvcjogbmV3IENvbG9yKCksXG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICAgICAgICAgIGhhbGZXaWR0aDogbmV3IFZlY3RvcjMoKSxcbiAgICAgICAgICAgIGhhbGZIZWlnaHQ6IG5ldyBWZWN0b3IzKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsaWdodHNbbGlnaHQuaWRdID0gdW5pZm9ybXM7XG4gICAgICByZXR1cm4gdW5pZm9ybXM7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBTaGFkb3dVbmlmb3Jtc0NhY2hlKCkge1xuICB2YXIgbGlnaHRzID0ge307XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQobGlnaHQpIHtcbiAgICAgIGlmIChsaWdodHNbbGlnaHQuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxpZ2h0c1tsaWdodC5pZF07XG4gICAgICB9XG5cbiAgICAgIHZhciB1bmlmb3JtcztcblxuICAgICAgc3dpdGNoIChsaWdodC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuICAgICAgICAgIHVuaWZvcm1zID0ge1xuICAgICAgICAgICAgc2hhZG93QmlhczogMCxcbiAgICAgICAgICAgIHNoYWRvd05vcm1hbEJpYXM6IDAsXG4gICAgICAgICAgICBzaGFkb3dSYWRpdXM6IDEsXG4gICAgICAgICAgICBzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTcG90TGlnaHQnOlxuICAgICAgICAgIHVuaWZvcm1zID0ge1xuICAgICAgICAgICAgc2hhZG93QmlhczogMCxcbiAgICAgICAgICAgIHNoYWRvd05vcm1hbEJpYXM6IDAsXG4gICAgICAgICAgICBzaGFkb3dSYWRpdXM6IDEsXG4gICAgICAgICAgICBzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQb2ludExpZ2h0JzpcbiAgICAgICAgICB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIHNoYWRvd0JpYXM6IDAsXG4gICAgICAgICAgICBzaGFkb3dOb3JtYWxCaWFzOiAwLFxuICAgICAgICAgICAgc2hhZG93UmFkaXVzOiAxLFxuICAgICAgICAgICAgc2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKSxcbiAgICAgICAgICAgIHNoYWRvd0NhbWVyYU5lYXI6IDEsXG4gICAgICAgICAgICBzaGFkb3dDYW1lcmFGYXI6IDEwMDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBUT0RPIChhYmVsbmF0aW9uKTogc2V0IFJlY3RBcmVhTGlnaHQgc2hhZG93IHVuaWZvcm1zXG4gICAgICB9XG5cbiAgICAgIGxpZ2h0c1tsaWdodC5pZF0gPSB1bmlmb3JtcztcbiAgICAgIHJldHVybiB1bmlmb3JtcztcbiAgICB9XG4gIH07XG59XG5cbnZhciBuZXh0VmVyc2lvbiA9IDA7XG5cbmZ1bmN0aW9uIHNoYWRvd0Nhc3RpbmdMaWdodHNGaXJzdChsaWdodEEsIGxpZ2h0Qikge1xuICByZXR1cm4gKGxpZ2h0Qi5jYXN0U2hhZG93ID8gMSA6IDApIC0gKGxpZ2h0QS5jYXN0U2hhZG93ID8gMSA6IDApO1xufVxuXG5mdW5jdGlvbiBXZWJHTExpZ2h0cyhleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpIHtcbiAgdmFyIGNhY2hlID0gbmV3IFVuaWZvcm1zQ2FjaGUoKTtcbiAgdmFyIHNoYWRvd0NhY2hlID0gU2hhZG93VW5pZm9ybXNDYWNoZSgpO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgdmVyc2lvbjogMCxcbiAgICBoYXNoOiB7XG4gICAgICBkaXJlY3Rpb25hbExlbmd0aDogLTEsXG4gICAgICBwb2ludExlbmd0aDogLTEsXG4gICAgICBzcG90TGVuZ3RoOiAtMSxcbiAgICAgIHJlY3RBcmVhTGVuZ3RoOiAtMSxcbiAgICAgIGhlbWlMZW5ndGg6IC0xLFxuICAgICAgbnVtRGlyZWN0aW9uYWxTaGFkb3dzOiAtMSxcbiAgICAgIG51bVBvaW50U2hhZG93czogLTEsXG4gICAgICBudW1TcG90U2hhZG93czogLTFcbiAgICB9LFxuICAgIGFtYmllbnQ6IFswLCAwLCAwXSxcbiAgICBwcm9iZTogW10sXG4gICAgZGlyZWN0aW9uYWw6IFtdLFxuICAgIGRpcmVjdGlvbmFsU2hhZG93OiBbXSxcbiAgICBkaXJlY3Rpb25hbFNoYWRvd01hcDogW10sXG4gICAgZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IFtdLFxuICAgIHNwb3Q6IFtdLFxuICAgIHNwb3RTaGFkb3c6IFtdLFxuICAgIHNwb3RTaGFkb3dNYXA6IFtdLFxuICAgIHNwb3RTaGFkb3dNYXRyaXg6IFtdLFxuICAgIHJlY3RBcmVhOiBbXSxcbiAgICByZWN0QXJlYUxUQzE6IG51bGwsXG4gICAgcmVjdEFyZWFMVEMyOiBudWxsLFxuICAgIHBvaW50OiBbXSxcbiAgICBwb2ludFNoYWRvdzogW10sXG4gICAgcG9pbnRTaGFkb3dNYXA6IFtdLFxuICAgIHBvaW50U2hhZG93TWF0cml4OiBbXSxcbiAgICBoZW1pOiBbXVxuICB9O1xuXG4gIGZvciAodmFyIF9pMTE3ID0gMDsgX2kxMTcgPCA5OyBfaTExNysrKSB7XG4gICAgc3RhdGUucHJvYmUucHVzaChuZXcgVmVjdG9yMygpKTtcbiAgfVxuXG4gIHZhciB2ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcbiAgdmFyIG1hdHJpeDQgPSBuZXcgTWF0cml4NCgpO1xuICB2YXIgbWF0cml4NDIgPSBuZXcgTWF0cml4NCgpO1xuXG4gIGZ1bmN0aW9uIHNldHVwKGxpZ2h0cywgcGh5c2ljYWxseUNvcnJlY3RMaWdodHMpIHtcbiAgICB2YXIgciA9IDAsXG4gICAgICAgIGcgPSAwLFxuICAgICAgICBiID0gMDtcblxuICAgIGZvciAodmFyIF9pMTE4ID0gMDsgX2kxMTggPCA5OyBfaTExOCsrKSB7XG4gICAgICBzdGF0ZS5wcm9iZVtfaTExOF0uc2V0KDAsIDAsIDApO1xuICAgIH1cblxuICAgIHZhciBkaXJlY3Rpb25hbExlbmd0aCA9IDA7XG4gICAgdmFyIHBvaW50TGVuZ3RoID0gMDtcbiAgICB2YXIgc3BvdExlbmd0aCA9IDA7XG4gICAgdmFyIHJlY3RBcmVhTGVuZ3RoID0gMDtcbiAgICB2YXIgaGVtaUxlbmd0aCA9IDA7XG4gICAgdmFyIG51bURpcmVjdGlvbmFsU2hhZG93cyA9IDA7XG4gICAgdmFyIG51bVBvaW50U2hhZG93cyA9IDA7XG4gICAgdmFyIG51bVNwb3RTaGFkb3dzID0gMDtcbiAgICBsaWdodHMuc29ydChzaGFkb3dDYXN0aW5nTGlnaHRzRmlyc3QpOyAvLyBhcnRpc3QtZnJpZW5kbHkgbGlnaHQgaW50ZW5zaXR5IHNjYWxpbmcgZmFjdG9yXG5cbiAgICB2YXIgc2NhbGVGYWN0b3IgPSBwaHlzaWNhbGx5Q29ycmVjdExpZ2h0cyAhPT0gdHJ1ZSA/IE1hdGguUEkgOiAxO1xuXG4gICAgZm9yICh2YXIgX2kxMTkgPSAwLCBsID0gbGlnaHRzLmxlbmd0aDsgX2kxMTkgPCBsOyBfaTExOSsrKSB7XG4gICAgICB2YXIgbGlnaHQgPSBsaWdodHNbX2kxMTldO1xuICAgICAgdmFyIGNvbG9yID0gbGlnaHQuY29sb3I7XG4gICAgICB2YXIgaW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xuICAgICAgdmFyIGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XG4gICAgICB2YXIgc2hhZG93TWFwID0gbGlnaHQuc2hhZG93ICYmIGxpZ2h0LnNoYWRvdy5tYXAgPyBsaWdodC5zaGFkb3cubWFwLnRleHR1cmUgOiBudWxsO1xuXG4gICAgICBpZiAobGlnaHQuaXNBbWJpZW50TGlnaHQpIHtcbiAgICAgICAgciArPSBjb2xvci5yICogaW50ZW5zaXR5ICogc2NhbGVGYWN0b3I7XG4gICAgICAgIGcgKz0gY29sb3IuZyAqIGludGVuc2l0eSAqIHNjYWxlRmFjdG9yO1xuICAgICAgICBiICs9IGNvbG9yLmIgKiBpbnRlbnNpdHkgKiBzY2FsZUZhY3RvcjtcbiAgICAgIH0gZWxzZSBpZiAobGlnaHQuaXNMaWdodFByb2JlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgOTsgaisrKSB7XG4gICAgICAgICAgc3RhdGUucHJvYmVbal0uYWRkU2NhbGVkVmVjdG9yKGxpZ2h0LnNoLmNvZWZmaWNpZW50c1tqXSwgaW50ZW5zaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQpIHtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KGxpZ2h0KTtcbiAgICAgICAgdW5pZm9ybXMuY29sb3IuY29weShsaWdodC5jb2xvcikubXVsdGlwbHlTY2FsYXIobGlnaHQuaW50ZW5zaXR5ICogc2NhbGVGYWN0b3IpO1xuXG4gICAgICAgIGlmIChsaWdodC5jYXN0U2hhZG93KSB7XG4gICAgICAgICAgdmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcbiAgICAgICAgICB2YXIgc2hhZG93VW5pZm9ybXMgPSBzaGFkb3dDYWNoZS5nZXQobGlnaHQpO1xuICAgICAgICAgIHNoYWRvd1VuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcbiAgICAgICAgICBzaGFkb3dVbmlmb3Jtcy5zaGFkb3dOb3JtYWxCaWFzID0gc2hhZG93Lm5vcm1hbEJpYXM7XG4gICAgICAgICAgc2hhZG93VW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcbiAgICAgICAgICBzaGFkb3dVbmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG4gICAgICAgICAgc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dbZGlyZWN0aW9uYWxMZW5ndGhdID0gc2hhZG93VW5pZm9ybXM7XG4gICAgICAgICAgc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXBbZGlyZWN0aW9uYWxMZW5ndGhdID0gc2hhZG93TWFwO1xuICAgICAgICAgIHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4W2RpcmVjdGlvbmFsTGVuZ3RoXSA9IGxpZ2h0LnNoYWRvdy5tYXRyaXg7XG4gICAgICAgICAgbnVtRGlyZWN0aW9uYWxTaGFkb3dzKys7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXJlY3Rpb25hbFtkaXJlY3Rpb25hbExlbmd0aF0gPSB1bmlmb3JtcztcbiAgICAgICAgZGlyZWN0aW9uYWxMZW5ndGgrKztcbiAgICAgIH0gZWxzZSBpZiAobGlnaHQuaXNTcG90TGlnaHQpIHtcbiAgICAgICAgdmFyIF91bmlmb3JtcyA9IGNhY2hlLmdldChsaWdodCk7XG5cbiAgICAgICAgX3VuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cbiAgICAgICAgX3VuaWZvcm1zLmNvbG9yLmNvcHkoY29sb3IpLm11bHRpcGx5U2NhbGFyKGludGVuc2l0eSAqIHNjYWxlRmFjdG9yKTtcblxuICAgICAgICBfdW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgX3VuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyhsaWdodC5hbmdsZSk7XG4gICAgICAgIF91bmlmb3Jtcy5wZW51bWJyYUNvcyA9IE1hdGguY29zKGxpZ2h0LmFuZ2xlICogKDEgLSBsaWdodC5wZW51bWJyYSkpO1xuICAgICAgICBfdW5pZm9ybXMuZGVjYXkgPSBsaWdodC5kZWNheTtcblxuICAgICAgICBpZiAobGlnaHQuY2FzdFNoYWRvdykge1xuICAgICAgICAgIHZhciBfc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXG4gICAgICAgICAgdmFyIF9zaGFkb3dVbmlmb3JtcyA9IHNoYWRvd0NhY2hlLmdldChsaWdodCk7XG5cbiAgICAgICAgICBfc2hhZG93VW5pZm9ybXMuc2hhZG93QmlhcyA9IF9zaGFkb3cuYmlhcztcbiAgICAgICAgICBfc2hhZG93VW5pZm9ybXMuc2hhZG93Tm9ybWFsQmlhcyA9IF9zaGFkb3cubm9ybWFsQmlhcztcbiAgICAgICAgICBfc2hhZG93VW5pZm9ybXMuc2hhZG93UmFkaXVzID0gX3NoYWRvdy5yYWRpdXM7XG4gICAgICAgICAgX3NoYWRvd1VuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBfc2hhZG93Lm1hcFNpemU7XG4gICAgICAgICAgc3RhdGUuc3BvdFNoYWRvd1tzcG90TGVuZ3RoXSA9IF9zaGFkb3dVbmlmb3JtcztcbiAgICAgICAgICBzdGF0ZS5zcG90U2hhZG93TWFwW3Nwb3RMZW5ndGhdID0gc2hhZG93TWFwO1xuICAgICAgICAgIHN0YXRlLnNwb3RTaGFkb3dNYXRyaXhbc3BvdExlbmd0aF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xuICAgICAgICAgIG51bVNwb3RTaGFkb3dzKys7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5zcG90W3Nwb3RMZW5ndGhdID0gX3VuaWZvcm1zO1xuICAgICAgICBzcG90TGVuZ3RoKys7XG4gICAgICB9IGVsc2UgaWYgKGxpZ2h0LmlzUmVjdEFyZWFMaWdodCkge1xuICAgICAgICB2YXIgX3VuaWZvcm1zMiA9IGNhY2hlLmdldChsaWdodCk7IC8vIChhKSBpbnRlbnNpdHkgaXMgdGhlIHRvdGFsIHZpc2libGUgbGlnaHQgZW1pdHRlZFxuICAgICAgICAvL3VuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSAvICggbGlnaHQud2lkdGggKiBsaWdodC5oZWlnaHQgKiBNYXRoLlBJICkgKTtcbiAgICAgICAgLy8gKGIpIGludGVuc2l0eSBpcyB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgbGlnaHRcblxuXG4gICAgICAgIF91bmlmb3JtczIuY29sb3IuY29weShjb2xvcikubXVsdGlwbHlTY2FsYXIoaW50ZW5zaXR5KTtcblxuICAgICAgICBfdW5pZm9ybXMyLmhhbGZXaWR0aC5zZXQobGlnaHQud2lkdGggKiAwLjUsIDAuMCwgMC4wKTtcblxuICAgICAgICBfdW5pZm9ybXMyLmhhbGZIZWlnaHQuc2V0KDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjApO1xuXG4gICAgICAgIHN0YXRlLnJlY3RBcmVhW3JlY3RBcmVhTGVuZ3RoXSA9IF91bmlmb3JtczI7XG4gICAgICAgIHJlY3RBcmVhTGVuZ3RoKys7XG4gICAgICB9IGVsc2UgaWYgKGxpZ2h0LmlzUG9pbnRMaWdodCkge1xuICAgICAgICB2YXIgX3VuaWZvcm1zMyA9IGNhY2hlLmdldChsaWdodCk7XG5cbiAgICAgICAgX3VuaWZvcm1zMy5jb2xvci5jb3B5KGxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcihsaWdodC5pbnRlbnNpdHkgKiBzY2FsZUZhY3Rvcik7XG5cbiAgICAgICAgX3VuaWZvcm1zMy5kaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuICAgICAgICBfdW5pZm9ybXMzLmRlY2F5ID0gbGlnaHQuZGVjYXk7XG5cbiAgICAgICAgaWYgKGxpZ2h0LmNhc3RTaGFkb3cpIHtcbiAgICAgICAgICB2YXIgX3NoYWRvdzIgPSBsaWdodC5zaGFkb3c7XG5cbiAgICAgICAgICB2YXIgX3NoYWRvd1VuaWZvcm1zMiA9IHNoYWRvd0NhY2hlLmdldChsaWdodCk7XG5cbiAgICAgICAgICBfc2hhZG93VW5pZm9ybXMyLnNoYWRvd0JpYXMgPSBfc2hhZG93Mi5iaWFzO1xuICAgICAgICAgIF9zaGFkb3dVbmlmb3JtczIuc2hhZG93Tm9ybWFsQmlhcyA9IF9zaGFkb3cyLm5vcm1hbEJpYXM7XG4gICAgICAgICAgX3NoYWRvd1VuaWZvcm1zMi5zaGFkb3dSYWRpdXMgPSBfc2hhZG93Mi5yYWRpdXM7XG4gICAgICAgICAgX3NoYWRvd1VuaWZvcm1zMi5zaGFkb3dNYXBTaXplID0gX3NoYWRvdzIubWFwU2l6ZTtcbiAgICAgICAgICBfc2hhZG93VW5pZm9ybXMyLnNoYWRvd0NhbWVyYU5lYXIgPSBfc2hhZG93Mi5jYW1lcmEubmVhcjtcbiAgICAgICAgICBfc2hhZG93VW5pZm9ybXMyLnNoYWRvd0NhbWVyYUZhciA9IF9zaGFkb3cyLmNhbWVyYS5mYXI7XG4gICAgICAgICAgc3RhdGUucG9pbnRTaGFkb3dbcG9pbnRMZW5ndGhdID0gX3NoYWRvd1VuaWZvcm1zMjtcbiAgICAgICAgICBzdGF0ZS5wb2ludFNoYWRvd01hcFtwb2ludExlbmd0aF0gPSBzaGFkb3dNYXA7XG4gICAgICAgICAgc3RhdGUucG9pbnRTaGFkb3dNYXRyaXhbcG9pbnRMZW5ndGhdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcbiAgICAgICAgICBudW1Qb2ludFNoYWRvd3MrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLnBvaW50W3BvaW50TGVuZ3RoXSA9IF91bmlmb3JtczM7XG4gICAgICAgIHBvaW50TGVuZ3RoKys7XG4gICAgICB9IGVsc2UgaWYgKGxpZ2h0LmlzSGVtaXNwaGVyZUxpZ2h0KSB7XG4gICAgICAgIHZhciBfdW5pZm9ybXM0ID0gY2FjaGUuZ2V0KGxpZ2h0KTtcblxuICAgICAgICBfdW5pZm9ybXM0LnNreUNvbG9yLmNvcHkobGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKGludGVuc2l0eSAqIHNjYWxlRmFjdG9yKTtcblxuICAgICAgICBfdW5pZm9ybXM0Lmdyb3VuZENvbG9yLmNvcHkobGlnaHQuZ3JvdW5kQ29sb3IpLm11bHRpcGx5U2NhbGFyKGludGVuc2l0eSAqIHNjYWxlRmFjdG9yKTtcblxuICAgICAgICBzdGF0ZS5oZW1pW2hlbWlMZW5ndGhdID0gX3VuaWZvcm1zNDtcbiAgICAgICAgaGVtaUxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWN0QXJlYUxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIpIHtcbiAgICAgICAgLy8gV2ViR0wgMlxuICAgICAgICBzdGF0ZS5yZWN0QXJlYUxUQzEgPSBVbmlmb3Jtc0xpYi5MVENfRkxPQVRfMTtcbiAgICAgICAgc3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0ZMT0FUXzI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZWJHTCAxXG4gICAgICAgIGlmIChleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykgPT09IHRydWUpIHtcbiAgICAgICAgICBzdGF0ZS5yZWN0QXJlYUxUQzEgPSBVbmlmb3Jtc0xpYi5MVENfRkxPQVRfMTtcbiAgICAgICAgICBzdGF0ZS5yZWN0QXJlYUxUQzIgPSBVbmlmb3Jtc0xpYi5MVENfRkxPQVRfMjtcbiAgICAgICAgfSBlbHNlIGlmIChleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHN0YXRlLnJlY3RBcmVhTFRDMSA9IFVuaWZvcm1zTGliLkxUQ19IQUxGXzE7XG4gICAgICAgICAgc3RhdGUucmVjdEFyZWFMVEMyID0gVW5pZm9ybXNMaWIuTFRDX0hBTEZfMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbmFibGUgdG8gdXNlIFJlY3RBcmVhTGlnaHQuIE1pc3NpbmcgV2ViR0wgZXh0ZW5zaW9ucy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmFtYmllbnRbMF0gPSByO1xuICAgIHN0YXRlLmFtYmllbnRbMV0gPSBnO1xuICAgIHN0YXRlLmFtYmllbnRbMl0gPSBiO1xuICAgIHZhciBoYXNoID0gc3RhdGUuaGFzaDtcblxuICAgIGlmIChoYXNoLmRpcmVjdGlvbmFsTGVuZ3RoICE9PSBkaXJlY3Rpb25hbExlbmd0aCB8fCBoYXNoLnBvaW50TGVuZ3RoICE9PSBwb2ludExlbmd0aCB8fCBoYXNoLnNwb3RMZW5ndGggIT09IHNwb3RMZW5ndGggfHwgaGFzaC5yZWN0QXJlYUxlbmd0aCAhPT0gcmVjdEFyZWFMZW5ndGggfHwgaGFzaC5oZW1pTGVuZ3RoICE9PSBoZW1pTGVuZ3RoIHx8IGhhc2gubnVtRGlyZWN0aW9uYWxTaGFkb3dzICE9PSBudW1EaXJlY3Rpb25hbFNoYWRvd3MgfHwgaGFzaC5udW1Qb2ludFNoYWRvd3MgIT09IG51bVBvaW50U2hhZG93cyB8fCBoYXNoLm51bVNwb3RTaGFkb3dzICE9PSBudW1TcG90U2hhZG93cykge1xuICAgICAgc3RhdGUuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XG4gICAgICBzdGF0ZS5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG4gICAgICBzdGF0ZS5yZWN0QXJlYS5sZW5ndGggPSByZWN0QXJlYUxlbmd0aDtcbiAgICAgIHN0YXRlLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xuICAgICAgc3RhdGUuaGVtaS5sZW5ndGggPSBoZW1pTGVuZ3RoO1xuICAgICAgc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3cubGVuZ3RoID0gbnVtRGlyZWN0aW9uYWxTaGFkb3dzO1xuICAgICAgc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXAubGVuZ3RoID0gbnVtRGlyZWN0aW9uYWxTaGFkb3dzO1xuICAgICAgc3RhdGUucG9pbnRTaGFkb3cubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xuICAgICAgc3RhdGUucG9pbnRTaGFkb3dNYXAubGVuZ3RoID0gbnVtUG9pbnRTaGFkb3dzO1xuICAgICAgc3RhdGUuc3BvdFNoYWRvdy5sZW5ndGggPSBudW1TcG90U2hhZG93cztcbiAgICAgIHN0YXRlLnNwb3RTaGFkb3dNYXAubGVuZ3RoID0gbnVtU3BvdFNoYWRvd3M7XG4gICAgICBzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC5sZW5ndGggPSBudW1EaXJlY3Rpb25hbFNoYWRvd3M7XG4gICAgICBzdGF0ZS5wb2ludFNoYWRvd01hdHJpeC5sZW5ndGggPSBudW1Qb2ludFNoYWRvd3M7XG4gICAgICBzdGF0ZS5zcG90U2hhZG93TWF0cml4Lmxlbmd0aCA9IG51bVNwb3RTaGFkb3dzO1xuICAgICAgaGFzaC5kaXJlY3Rpb25hbExlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xuICAgICAgaGFzaC5wb2ludExlbmd0aCA9IHBvaW50TGVuZ3RoO1xuICAgICAgaGFzaC5zcG90TGVuZ3RoID0gc3BvdExlbmd0aDtcbiAgICAgIGhhc2gucmVjdEFyZWFMZW5ndGggPSByZWN0QXJlYUxlbmd0aDtcbiAgICAgIGhhc2guaGVtaUxlbmd0aCA9IGhlbWlMZW5ndGg7XG4gICAgICBoYXNoLm51bURpcmVjdGlvbmFsU2hhZG93cyA9IG51bURpcmVjdGlvbmFsU2hhZG93cztcbiAgICAgIGhhc2gubnVtUG9pbnRTaGFkb3dzID0gbnVtUG9pbnRTaGFkb3dzO1xuICAgICAgaGFzaC5udW1TcG90U2hhZG93cyA9IG51bVNwb3RTaGFkb3dzO1xuICAgICAgc3RhdGUudmVyc2lvbiA9IG5leHRWZXJzaW9uKys7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXBWaWV3KGxpZ2h0cywgY2FtZXJhKSB7XG4gICAgdmFyIGRpcmVjdGlvbmFsTGVuZ3RoID0gMDtcbiAgICB2YXIgcG9pbnRMZW5ndGggPSAwO1xuICAgIHZhciBzcG90TGVuZ3RoID0gMDtcbiAgICB2YXIgcmVjdEFyZWFMZW5ndGggPSAwO1xuICAgIHZhciBoZW1pTGVuZ3RoID0gMDtcbiAgICB2YXIgdmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XG5cbiAgICBmb3IgKHZhciBfaTEyMCA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBfaTEyMCA8IGw7IF9pMTIwKyspIHtcbiAgICAgIHZhciBsaWdodCA9IGxpZ2h0c1tfaTEyMF07XG5cbiAgICAgIGlmIChsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQpIHtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0gc3RhdGUuZGlyZWN0aW9uYWxbZGlyZWN0aW9uYWxMZW5ndGhdO1xuICAgICAgICB1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcbiAgICAgICAgdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uLnN1Yih2ZWN0b3IzKTtcbiAgICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih2aWV3TWF0cml4KTtcbiAgICAgICAgZGlyZWN0aW9uYWxMZW5ndGgrKztcbiAgICAgIH0gZWxzZSBpZiAobGlnaHQuaXNTcG90TGlnaHQpIHtcbiAgICAgICAgdmFyIF91bmlmb3JtczUgPSBzdGF0ZS5zcG90W3Nwb3RMZW5ndGhdO1xuXG4gICAgICAgIF91bmlmb3JtczUucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblxuICAgICAgICBfdW5pZm9ybXM1LnBvc2l0aW9uLmFwcGx5TWF0cml4NCh2aWV3TWF0cml4KTtcblxuICAgICAgICBfdW5pZm9ybXM1LmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQubWF0cml4V29ybGQpO1xuXG4gICAgICAgIHZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCk7XG5cbiAgICAgICAgX3VuaWZvcm1zNS5kaXJlY3Rpb24uc3ViKHZlY3RvcjMpO1xuXG4gICAgICAgIF91bmlmb3JtczUuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbih2aWV3TWF0cml4KTtcblxuICAgICAgICBzcG90TGVuZ3RoKys7XG4gICAgICB9IGVsc2UgaWYgKGxpZ2h0LmlzUmVjdEFyZWFMaWdodCkge1xuICAgICAgICB2YXIgX3VuaWZvcm1zNiA9IHN0YXRlLnJlY3RBcmVhW3JlY3RBcmVhTGVuZ3RoXTtcblxuICAgICAgICBfdW5pZm9ybXM2LnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbihsaWdodC5tYXRyaXhXb3JsZCk7XG5cbiAgICAgICAgX3VuaWZvcm1zNi5wb3NpdGlvbi5hcHBseU1hdHJpeDQodmlld01hdHJpeCk7IC8vIGV4dHJhY3QgbG9jYWwgcm90YXRpb24gb2YgbGlnaHQgdG8gZGVyaXZlIHdpZHRoL2hlaWdodCBoYWxmIHZlY3RvcnNcblxuXG4gICAgICAgIG1hdHJpeDQyLmlkZW50aXR5KCk7XG4gICAgICAgIG1hdHJpeDQuY29weShsaWdodC5tYXRyaXhXb3JsZCk7XG4gICAgICAgIG1hdHJpeDQucHJlbXVsdGlwbHkodmlld01hdHJpeCk7XG4gICAgICAgIG1hdHJpeDQyLmV4dHJhY3RSb3RhdGlvbihtYXRyaXg0KTtcblxuICAgICAgICBfdW5pZm9ybXM2LmhhbGZXaWR0aC5zZXQobGlnaHQud2lkdGggKiAwLjUsIDAuMCwgMC4wKTtcblxuICAgICAgICBfdW5pZm9ybXM2LmhhbGZIZWlnaHQuc2V0KDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjApO1xuXG4gICAgICAgIF91bmlmb3JtczYuaGFsZldpZHRoLmFwcGx5TWF0cml4NChtYXRyaXg0Mik7XG5cbiAgICAgICAgX3VuaWZvcm1zNi5oYWxmSGVpZ2h0LmFwcGx5TWF0cml4NChtYXRyaXg0Mik7XG5cbiAgICAgICAgcmVjdEFyZWFMZW5ndGgrKztcbiAgICAgIH0gZWxzZSBpZiAobGlnaHQuaXNQb2ludExpZ2h0KSB7XG4gICAgICAgIHZhciBfdW5pZm9ybXM3ID0gc3RhdGUucG9pbnRbcG9pbnRMZW5ndGhdO1xuXG4gICAgICAgIF91bmlmb3JtczcucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblxuICAgICAgICBfdW5pZm9ybXM3LnBvc2l0aW9uLmFwcGx5TWF0cml4NCh2aWV3TWF0cml4KTtcblxuICAgICAgICBwb2ludExlbmd0aCsrO1xuICAgICAgfSBlbHNlIGlmIChsaWdodC5pc0hlbWlzcGhlcmVMaWdodCkge1xuICAgICAgICB2YXIgX3VuaWZvcm1zOCA9IHN0YXRlLmhlbWlbaGVtaUxlbmd0aF07XG5cbiAgICAgICAgX3VuaWZvcm1zOC5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblxuICAgICAgICBfdW5pZm9ybXM4LmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odmlld01hdHJpeCk7XG5cbiAgICAgICAgaGVtaUxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2V0dXA6IHNldHVwLFxuICAgIHNldHVwVmlldzogc2V0dXBWaWV3LFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBXZWJHTFJlbmRlclN0YXRlKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcykge1xuICB2YXIgbGlnaHRzID0gbmV3IFdlYkdMTGlnaHRzKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyk7XG4gIHZhciBsaWdodHNBcnJheSA9IFtdO1xuICB2YXIgc2hhZG93c0FycmF5ID0gW107XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBsaWdodHNBcnJheS5sZW5ndGggPSAwO1xuICAgIHNoYWRvd3NBcnJheS5sZW5ndGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaExpZ2h0KGxpZ2h0KSB7XG4gICAgbGlnaHRzQXJyYXkucHVzaChsaWdodCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoU2hhZG93KHNoYWRvd0xpZ2h0KSB7XG4gICAgc2hhZG93c0FycmF5LnB1c2goc2hhZG93TGlnaHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXBMaWdodHMocGh5c2ljYWxseUNvcnJlY3RMaWdodHMpIHtcbiAgICBsaWdodHMuc2V0dXAobGlnaHRzQXJyYXksIHBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwTGlnaHRzVmlldyhjYW1lcmEpIHtcbiAgICBsaWdodHMuc2V0dXBWaWV3KGxpZ2h0c0FycmF5LCBjYW1lcmEpO1xuICB9XG5cbiAgdmFyIHN0YXRlID0ge1xuICAgIGxpZ2h0c0FycmF5OiBsaWdodHNBcnJheSxcbiAgICBzaGFkb3dzQXJyYXk6IHNoYWRvd3NBcnJheSxcbiAgICBsaWdodHM6IGxpZ2h0c1xuICB9O1xuICByZXR1cm4ge1xuICAgIGluaXQ6IGluaXQsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIHNldHVwTGlnaHRzOiBzZXR1cExpZ2h0cyxcbiAgICBzZXR1cExpZ2h0c1ZpZXc6IHNldHVwTGlnaHRzVmlldyxcbiAgICBwdXNoTGlnaHQ6IHB1c2hMaWdodCxcbiAgICBwdXNoU2hhZG93OiBwdXNoU2hhZG93XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdlYkdMUmVuZGVyU3RhdGVzKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcykge1xuICB2YXIgcmVuZGVyU3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcblxuICBmdW5jdGlvbiBnZXQoc2NlbmUpIHtcbiAgICB2YXIgcmVuZGVyQ2FsbERlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciByZW5kZXJTdGF0ZTtcblxuICAgIGlmIChyZW5kZXJTdGF0ZXMuaGFzKHNjZW5lKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJlbmRlclN0YXRlID0gbmV3IFdlYkdMUmVuZGVyU3RhdGUoZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcbiAgICAgIHJlbmRlclN0YXRlcy5zZXQoc2NlbmUsIFtyZW5kZXJTdGF0ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyQ2FsbERlcHRoID49IHJlbmRlclN0YXRlcy5nZXQoc2NlbmUpLmxlbmd0aCkge1xuICAgICAgICByZW5kZXJTdGF0ZSA9IG5ldyBXZWJHTFJlbmRlclN0YXRlKGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyk7XG4gICAgICAgIHJlbmRlclN0YXRlcy5nZXQoc2NlbmUpLnB1c2gocmVuZGVyU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZXMuZ2V0KHNjZW5lKVtyZW5kZXJDYWxsRGVwdGhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgcmVuZGVyU3RhdGVzID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0OiBnZXQsXG4gICAgZGlzcG9zZTogZGlzcG9zZVxuICB9O1xufVxuXG52YXIgTWVzaERlcHRoTWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NYXRlcmlhbDMpIHtcbiAgX2luaGVyaXRzKE1lc2hEZXB0aE1hdGVyaWFsLCBfTWF0ZXJpYWwzKTtcblxuICB2YXIgX3N1cGVyMzIgPSBfY3JlYXRlU3VwZXIoTWVzaERlcHRoTWF0ZXJpYWwpO1xuXG4gIGZ1bmN0aW9uIE1lc2hEZXB0aE1hdGVyaWFsKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgX3RoaXMyNDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZXNoRGVwdGhNYXRlcmlhbCk7XG5cbiAgICBfdGhpczI0ID0gX3N1cGVyMzIuY2FsbCh0aGlzKTtcbiAgICBfdGhpczI0LmlzTWVzaERlcHRoTWF0ZXJpYWwgPSB0cnVlO1xuICAgIF90aGlzMjQudHlwZSA9ICdNZXNoRGVwdGhNYXRlcmlhbCc7XG4gICAgX3RoaXMyNC5kZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcbiAgICBfdGhpczI0Lm1hcCA9IG51bGw7XG4gICAgX3RoaXMyNC5hbHBoYU1hcCA9IG51bGw7XG4gICAgX3RoaXMyNC5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuICAgIF90aGlzMjQuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuICAgIF90aGlzMjQuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG4gICAgX3RoaXMyNC53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBfdGhpczI0LndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgICBfdGhpczI0LnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblxuICAgIHJldHVybiBfdGhpczI0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1lc2hEZXB0aE1hdGVyaWFsLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLmRlcHRoUGFja2luZyA9IHNvdXJjZS5kZXB0aFBhY2tpbmc7XG4gICAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG4gICAgICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuICAgICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lc2hEZXB0aE1hdGVyaWFsO1xufShNYXRlcmlhbCk7XG5cbnZhciBNZXNoRGlzdGFuY2VNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01hdGVyaWFsNCkge1xuICBfaW5oZXJpdHMoTWVzaERpc3RhbmNlTWF0ZXJpYWwsIF9NYXRlcmlhbDQpO1xuXG4gIHZhciBfc3VwZXIzMyA9IF9jcmVhdGVTdXBlcihNZXNoRGlzdGFuY2VNYXRlcmlhbCk7XG5cbiAgZnVuY3Rpb24gTWVzaERpc3RhbmNlTWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczI1O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc2hEaXN0YW5jZU1hdGVyaWFsKTtcblxuICAgIF90aGlzMjUgPSBfc3VwZXIzMy5jYWxsKHRoaXMpO1xuICAgIF90aGlzMjUuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCA9IHRydWU7XG4gICAgX3RoaXMyNS50eXBlID0gJ01lc2hEaXN0YW5jZU1hdGVyaWFsJztcbiAgICBfdGhpczI1LnJlZmVyZW5jZVBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBfdGhpczI1Lm5lYXJEaXN0YW5jZSA9IDE7XG4gICAgX3RoaXMyNS5mYXJEaXN0YW5jZSA9IDEwMDA7XG4gICAgX3RoaXMyNS5tYXAgPSBudWxsO1xuICAgIF90aGlzMjUuYWxwaGFNYXAgPSBudWxsO1xuICAgIF90aGlzMjUuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcbiAgICBfdGhpczI1LmRpc3BsYWNlbWVudFNjYWxlID0gMTtcbiAgICBfdGhpczI1LmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG4gICAgX3RoaXMyNS5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cbiAgICByZXR1cm4gX3RoaXMyNTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZXNoRGlzdGFuY2VNYXRlcmlhbCwgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWVzaERpc3RhbmNlTWF0ZXJpYWwucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5yZWZlcmVuY2VQb3NpdGlvbi5jb3B5KHNvdXJjZS5yZWZlcmVuY2VQb3NpdGlvbik7XG4gICAgICB0aGlzLm5lYXJEaXN0YW5jZSA9IHNvdXJjZS5uZWFyRGlzdGFuY2U7XG4gICAgICB0aGlzLmZhckRpc3RhbmNlID0gc291cmNlLmZhckRpc3RhbmNlO1xuICAgICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuICAgICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcbiAgICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcbiAgICAgIHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNoRGlzdGFuY2VNYXRlcmlhbDtcbn0oTWF0ZXJpYWwpO1xuXG52YXIgdmVydGV4ID0gXCJ2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxufVwiO1xudmFyIGZyYWdtZW50ID0gXCJ1bmlmb3JtIHNhbXBsZXIyRCBzaGFkb3dfcGFzcztcXG51bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcXG51bmlmb3JtIGZsb2F0IHJhZGl1cztcXG4jaW5jbHVkZSA8cGFja2luZz5cXG52b2lkIG1haW4oKSB7XFxuXFx0Y29uc3QgZmxvYXQgc2FtcGxlcyA9IGZsb2F0KCBWU01fU0FNUExFUyApO1xcblxcdGZsb2F0IG1lYW4gPSAwLjA7XFxuXFx0ZmxvYXQgc3F1YXJlZF9tZWFuID0gMC4wO1xcblxcdGZsb2F0IHV2U3RyaWRlID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAyLjAgLyAoIHNhbXBsZXMgLSAxLjAgKTtcXG5cXHRmbG9hdCB1dlN0YXJ0ID0gc2FtcGxlcyA8PSAxLjAgPyAwLjAgOiAtIDEuMDtcXG5cXHRmb3IgKCBmbG9hdCBpID0gMC4wOyBpIDwgc2FtcGxlczsgaSArKyApIHtcXG5cXHRcXHRmbG9hdCB1dk9mZnNldCA9IHV2U3RhcnQgKyBpICogdXZTdHJpZGU7XFxuXFx0XFx0I2lmZGVmIEhPUklaT05UQUxfUEFTU1xcblxcdFxcdFxcdHZlYzIgZGlzdHJpYnV0aW9uID0gdW5wYWNrUkdCQVRvMkhhbGYoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggdXZPZmZzZXQsIDAuMCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTtcXG5cXHRcXHRcXHRtZWFuICs9IGRpc3RyaWJ1dGlvbi54O1xcblxcdFxcdFxcdHNxdWFyZWRfbWVhbiArPSBkaXN0cmlidXRpb24ueSAqIGRpc3RyaWJ1dGlvbi55ICsgZGlzdHJpYnV0aW9uLnggKiBkaXN0cmlidXRpb24ueDtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdGZsb2F0IGRlcHRoID0gdW5wYWNrUkdCQVRvRGVwdGgoIHRleHR1cmUyRCggc2hhZG93X3Bhc3MsICggZ2xfRnJhZ0Nvb3JkLnh5ICsgdmVjMiggMC4wLCB1dk9mZnNldCApICogcmFkaXVzICkgLyByZXNvbHV0aW9uICkgKTtcXG5cXHRcXHRcXHRtZWFuICs9IGRlcHRoO1xcblxcdFxcdFxcdHNxdWFyZWRfbWVhbiArPSBkZXB0aCAqIGRlcHRoO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXHRtZWFuID0gbWVhbiAvIHNhbXBsZXM7XFxuXFx0c3F1YXJlZF9tZWFuID0gc3F1YXJlZF9tZWFuIC8gc2FtcGxlcztcXG5cXHRmbG9hdCBzdGRfZGV2ID0gc3FydCggc3F1YXJlZF9tZWFuIC0gbWVhbiAqIG1lYW4gKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBwYWNrMkhhbGZUb1JHQkEoIHZlYzIoIG1lYW4sIHN0ZF9kZXYgKSApO1xcbn1cIjtcblxuZnVuY3Rpb24gV2ViR0xTaGFkb3dNYXAoX3JlbmRlcmVyLCBfb2JqZWN0cywgX2NhcGFiaWxpdGllcykge1xuICB2YXIgX2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpO1xuXG4gIHZhciBfc2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCksXG4gICAgICBfdmlld3BvcnRTaXplID0gbmV3IFZlY3RvcjIoKSxcbiAgICAgIF92aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCksXG4gICAgICBfZGVwdGhNYXRlcmlhbCA9IG5ldyBNZXNoRGVwdGhNYXRlcmlhbCh7XG4gICAgZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nXG4gIH0pLFxuICAgICAgX2Rpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcbiAgICAgIF9tYXRlcmlhbENhY2hlID0ge30sXG4gICAgICBfbWF4VGV4dHVyZVNpemUgPSBfY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplO1xuXG4gIHZhciBzaGFkb3dTaWRlID0ge1xuICAgIDA6IEJhY2tTaWRlLFxuICAgIDE6IEZyb250U2lkZSxcbiAgICAyOiBEb3VibGVTaWRlXG4gIH07XG4gIHZhciBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsID0gbmV3IFNoYWRlck1hdGVyaWFsKHtcbiAgICBkZWZpbmVzOiB7XG4gICAgICBWU01fU0FNUExFUzogOFxuICAgIH0sXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIHNoYWRvd19wYXNzOiB7XG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9LFxuICAgICAgcmVzb2x1dGlvbjoge1xuICAgICAgICB2YWx1ZTogbmV3IFZlY3RvcjIoKVxuICAgICAgfSxcbiAgICAgIHJhZGl1czoge1xuICAgICAgICB2YWx1ZTogNC4wXG4gICAgICB9XG4gICAgfSxcbiAgICB2ZXJ0ZXhTaGFkZXI6IHZlcnRleCxcbiAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRcbiAgfSk7XG4gIHZhciBzaGFkb3dNYXRlcmlhbEhvcml6b250YWwgPSBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLmNsb25lKCk7XG4gIHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC5kZWZpbmVzLkhPUklaT05UQUxfUEFTUyA9IDE7XG4gIHZhciBmdWxsU2NyZWVuVHJpID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gIGZ1bGxTY3JlZW5Ucmkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShbLTEsIC0xLCAwLjUsIDMsIC0xLCAwLjUsIC0xLCAzLCAwLjVdKSwgMykpO1xuICB2YXIgZnVsbFNjcmVlbk1lc2ggPSBuZXcgTWVzaChmdWxsU2NyZWVuVHJpLCBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsKTtcbiAgdmFyIHNjb3BlID0gdGhpcztcbiAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG4gIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy50eXBlID0gUENGU2hhZG93TWFwO1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKGxpZ2h0cywgc2NlbmUsIGNhbWVyYSkge1xuICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGlmIChzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICBpZiAobGlnaHRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgdmFyIGN1cnJlbnRSZW5kZXJUYXJnZXQgPSBfcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG5cbiAgICB2YXIgYWN0aXZlQ3ViZUZhY2UgPSBfcmVuZGVyZXIuZ2V0QWN0aXZlQ3ViZUZhY2UoKTtcblxuICAgIHZhciBhY3RpdmVNaXBtYXBMZXZlbCA9IF9yZW5kZXJlci5nZXRBY3RpdmVNaXBtYXBMZXZlbCgpO1xuXG4gICAgdmFyIF9zdGF0ZSA9IF9yZW5kZXJlci5zdGF0ZTsgLy8gU2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXAuXG5cbiAgICBfc3RhdGUuc2V0QmxlbmRpbmcoTm9CbGVuZGluZyk7XG5cbiAgICBfc3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhcigxLCAxLCAxLCAxKTtcblxuICAgIF9zdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QodHJ1ZSk7XG5cbiAgICBfc3RhdGUuc2V0U2Npc3NvclRlc3QoZmFsc2UpOyAvLyByZW5kZXIgZGVwdGggbWFwXG5cblxuICAgIGZvciAodmFyIF9pMTIxID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBfaTEyMSA8IGlsOyBfaTEyMSsrKSB7XG4gICAgICB2YXIgbGlnaHQgPSBsaWdodHNbX2kxMjFdO1xuICAgICAgdmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcblxuICAgICAgaWYgKHNoYWRvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xTaGFkb3dNYXA6JywgbGlnaHQsICdoYXMgbm8gc2hhZG93LicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoYWRvdy5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzaGFkb3cubmVlZHNVcGRhdGUgPT09IGZhbHNlKSBjb250aW51ZTtcblxuICAgICAgX3NoYWRvd01hcFNpemUuY29weShzaGFkb3cubWFwU2l6ZSk7XG5cbiAgICAgIHZhciBzaGFkb3dGcmFtZUV4dGVudHMgPSBzaGFkb3cuZ2V0RnJhbWVFeHRlbnRzKCk7XG5cbiAgICAgIF9zaGFkb3dNYXBTaXplLm11bHRpcGx5KHNoYWRvd0ZyYW1lRXh0ZW50cyk7XG5cbiAgICAgIF92aWV3cG9ydFNpemUuY29weShzaGFkb3cubWFwU2l6ZSk7XG5cbiAgICAgIGlmIChfc2hhZG93TWFwU2l6ZS54ID4gX21heFRleHR1cmVTaXplIHx8IF9zaGFkb3dNYXBTaXplLnkgPiBfbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgICAgaWYgKF9zaGFkb3dNYXBTaXplLnggPiBfbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgICAgICBfdmlld3BvcnRTaXplLnggPSBNYXRoLmZsb29yKF9tYXhUZXh0dXJlU2l6ZSAvIHNoYWRvd0ZyYW1lRXh0ZW50cy54KTtcbiAgICAgICAgICBfc2hhZG93TWFwU2l6ZS54ID0gX3ZpZXdwb3J0U2l6ZS54ICogc2hhZG93RnJhbWVFeHRlbnRzLng7XG4gICAgICAgICAgc2hhZG93Lm1hcFNpemUueCA9IF92aWV3cG9ydFNpemUueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfc2hhZG93TWFwU2l6ZS55ID4gX21heFRleHR1cmVTaXplKSB7XG4gICAgICAgICAgX3ZpZXdwb3J0U2l6ZS55ID0gTWF0aC5mbG9vcihfbWF4VGV4dHVyZVNpemUgLyBzaGFkb3dGcmFtZUV4dGVudHMueSk7XG4gICAgICAgICAgX3NoYWRvd01hcFNpemUueSA9IF92aWV3cG9ydFNpemUueSAqIHNoYWRvd0ZyYW1lRXh0ZW50cy55O1xuICAgICAgICAgIHNoYWRvdy5tYXBTaXplLnkgPSBfdmlld3BvcnRTaXplLnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNoYWRvdy5tYXAgPT09IG51bGwgJiYgIXNoYWRvdy5pc1BvaW50TGlnaHRTaGFkb3cgJiYgdGhpcy50eXBlID09PSBWU01TaGFkb3dNYXApIHtcbiAgICAgICAgc2hhZG93Lm1hcCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChfc2hhZG93TWFwU2l6ZS54LCBfc2hhZG93TWFwU2l6ZS55KTtcbiAgICAgICAgc2hhZG93Lm1hcC50ZXh0dXJlLm5hbWUgPSBsaWdodC5uYW1lICsgJy5zaGFkb3dNYXAnO1xuICAgICAgICBzaGFkb3cubWFwUGFzcyA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChfc2hhZG93TWFwU2l6ZS54LCBfc2hhZG93TWFwU2l6ZS55KTtcbiAgICAgICAgc2hhZG93LmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGFkb3cubWFwID09PSBudWxsKSB7XG4gICAgICAgIHZhciBwYXJzID0ge1xuICAgICAgICAgIG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlcixcbiAgICAgICAgICBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgICAgZm9ybWF0OiBSR0JBRm9ybWF0XG4gICAgICAgIH07XG4gICAgICAgIHNoYWRvdy5tYXAgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoX3NoYWRvd01hcFNpemUueCwgX3NoYWRvd01hcFNpemUueSwgcGFycyk7XG4gICAgICAgIHNoYWRvdy5tYXAudGV4dHVyZS5uYW1lID0gbGlnaHQubmFtZSArICcuc2hhZG93TWFwJztcbiAgICAgICAgc2hhZG93LmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICB9XG5cbiAgICAgIF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoc2hhZG93Lm1hcCk7XG5cbiAgICAgIF9yZW5kZXJlci5jbGVhcigpO1xuXG4gICAgICB2YXIgdmlld3BvcnRDb3VudCA9IHNoYWRvdy5nZXRWaWV3cG9ydENvdW50KCk7XG5cbiAgICAgIGZvciAodmFyIHZwID0gMDsgdnAgPCB2aWV3cG9ydENvdW50OyB2cCsrKSB7XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHNoYWRvdy5nZXRWaWV3cG9ydCh2cCk7XG5cbiAgICAgICAgX3ZpZXdwb3J0LnNldChfdmlld3BvcnRTaXplLnggKiB2aWV3cG9ydC54LCBfdmlld3BvcnRTaXplLnkgKiB2aWV3cG9ydC55LCBfdmlld3BvcnRTaXplLnggKiB2aWV3cG9ydC56LCBfdmlld3BvcnRTaXplLnkgKiB2aWV3cG9ydC53KTtcblxuICAgICAgICBfc3RhdGUudmlld3BvcnQoX3ZpZXdwb3J0KTtcblxuICAgICAgICBzaGFkb3cudXBkYXRlTWF0cmljZXMobGlnaHQsIHZwKTtcbiAgICAgICAgX2ZydXN0dW0gPSBzaGFkb3cuZ2V0RnJ1c3R1bSgpO1xuICAgICAgICByZW5kZXJPYmplY3Qoc2NlbmUsIGNhbWVyYSwgc2hhZG93LmNhbWVyYSwgbGlnaHQsIHRoaXMudHlwZSk7XG4gICAgICB9IC8vIGRvIGJsdXIgcGFzcyBmb3IgVlNNXG5cblxuICAgICAgaWYgKCFzaGFkb3cuaXNQb2ludExpZ2h0U2hhZG93ICYmIHRoaXMudHlwZSA9PT0gVlNNU2hhZG93TWFwKSB7XG4gICAgICAgIFZTTVBhc3Moc2hhZG93LCBjYW1lcmEpO1xuICAgICAgfVxuXG4gICAgICBzaGFkb3cubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBzY29wZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChjdXJyZW50UmVuZGVyVGFyZ2V0LCBhY3RpdmVDdWJlRmFjZSwgYWN0aXZlTWlwbWFwTGV2ZWwpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFZTTVBhc3Moc2hhZG93LCBjYW1lcmEpIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUoZnVsbFNjcmVlbk1lc2gpO1xuXG4gICAgaWYgKHNoYWRvd01hdGVyaWFsVmVydGljYWwuZGVmaW5lcy5WU01fU0FNUExFUyAhPT0gc2hhZG93LmJsdXJTYW1wbGVzKSB7XG4gICAgICBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLmRlZmluZXMuVlNNX1NBTVBMRVMgPSBzaGFkb3cuYmx1clNhbXBsZXM7XG4gICAgICBzaGFkb3dNYXRlcmlhbEhvcml6b250YWwuZGVmaW5lcy5WU01fU0FNUExFUyA9IHNoYWRvdy5ibHVyU2FtcGxlcztcbiAgICAgIHNoYWRvd01hdGVyaWFsVmVydGljYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgc2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9IC8vIHZlcnRpY2FsIHBhc3NcblxuXG4gICAgc2hhZG93TWF0ZXJpYWxWZXJ0aWNhbC51bmlmb3Jtcy5zaGFkb3dfcGFzcy52YWx1ZSA9IHNoYWRvdy5tYXAudGV4dHVyZTtcbiAgICBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLnVuaWZvcm1zLnJlc29sdXRpb24udmFsdWUgPSBzaGFkb3cubWFwU2l6ZTtcbiAgICBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cbiAgICBfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHNoYWRvdy5tYXBQYXNzKTtcblxuICAgIF9yZW5kZXJlci5jbGVhcigpO1xuXG4gICAgX3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdChjYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBzaGFkb3dNYXRlcmlhbFZlcnRpY2FsLCBmdWxsU2NyZWVuTWVzaCwgbnVsbCk7IC8vIGhvcml6b250YWwgcGFzc1xuXG5cbiAgICBzaGFkb3dNYXRlcmlhbEhvcml6b250YWwudW5pZm9ybXMuc2hhZG93X3Bhc3MudmFsdWUgPSBzaGFkb3cubWFwUGFzcy50ZXh0dXJlO1xuICAgIHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbC51bmlmb3Jtcy5yZXNvbHV0aW9uLnZhbHVlID0gc2hhZG93Lm1hcFNpemU7XG4gICAgc2hhZG93TWF0ZXJpYWxIb3Jpem9udGFsLnVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHNoYWRvdy5yYWRpdXM7XG5cbiAgICBfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHNoYWRvdy5tYXApO1xuXG4gICAgX3JlbmRlcmVyLmNsZWFyKCk7XG5cbiAgICBfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KGNhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIHNoYWRvd01hdGVyaWFsSG9yaXpvbnRhbCwgZnVsbFNjcmVlbk1lc2gsIG51bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbChvYmplY3QsIG1hdGVyaWFsLCBsaWdodCwgc2hhZG93Q2FtZXJhTmVhciwgc2hhZG93Q2FtZXJhRmFyLCB0eXBlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgdmFyIGN1c3RvbU1hdGVyaWFsID0gbGlnaHQuaXNQb2ludExpZ2h0ID09PSB0cnVlID8gb2JqZWN0LmN1c3RvbURpc3RhbmNlTWF0ZXJpYWwgOiBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblxuICAgIGlmIChjdXN0b21NYXRlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHQgPSBjdXN0b21NYXRlcmlhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gbGlnaHQuaXNQb2ludExpZ2h0ID09PSB0cnVlID8gX2Rpc3RhbmNlTWF0ZXJpYWwgOiBfZGVwdGhNYXRlcmlhbDtcbiAgICB9XG5cbiAgICBpZiAoX3JlbmRlcmVyLmxvY2FsQ2xpcHBpbmdFbmFibGVkICYmIG1hdGVyaWFsLmNsaXBTaGFkb3dzID09PSB0cnVlICYmIG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCAhPT0gMCB8fCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgJiYgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgIT09IDAgfHwgbWF0ZXJpYWwuYWxwaGFNYXAgJiYgbWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCkge1xuICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIG5lZWQgYSB1bmlxdWUgbWF0ZXJpYWwgaW5zdGFuY2UgcmVmbGVjdGluZyB0aGVcbiAgICAgIC8vIGFwcHJvcHJpYXRlIHN0YXRlXG4gICAgICB2YXIga2V5QSA9IHJlc3VsdC51dWlkLFxuICAgICAgICAgIGtleUIgPSBtYXRlcmlhbC51dWlkO1xuICAgICAgdmFyIG1hdGVyaWFsc0ZvclZhcmlhbnQgPSBfbWF0ZXJpYWxDYWNoZVtrZXlBXTtcblxuICAgICAgaWYgKG1hdGVyaWFsc0ZvclZhcmlhbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXRlcmlhbHNGb3JWYXJpYW50ID0ge307XG4gICAgICAgIF9tYXRlcmlhbENhY2hlW2tleUFdID0gbWF0ZXJpYWxzRm9yVmFyaWFudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWxzRm9yVmFyaWFudFtrZXlCXTtcblxuICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FjaGVkTWF0ZXJpYWwgPSByZXN1bHQuY2xvbmUoKTtcbiAgICAgICAgbWF0ZXJpYWxzRm9yVmFyaWFudFtrZXlCXSA9IGNhY2hlZE1hdGVyaWFsO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBjYWNoZWRNYXRlcmlhbDtcbiAgICB9XG5cbiAgICByZXN1bHQudmlzaWJsZSA9IG1hdGVyaWFsLnZpc2libGU7XG4gICAgcmVzdWx0LndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcblxuICAgIGlmICh0eXBlID09PSBWU01TaGFkb3dNYXApIHtcbiAgICAgIHJlc3VsdC5zaWRlID0gbWF0ZXJpYWwuc2hhZG93U2lkZSAhPT0gbnVsbCA/IG1hdGVyaWFsLnNoYWRvd1NpZGUgOiBtYXRlcmlhbC5zaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2lkZSA9IG1hdGVyaWFsLnNoYWRvd1NpZGUgIT09IG51bGwgPyBtYXRlcmlhbC5zaGFkb3dTaWRlIDogc2hhZG93U2lkZVttYXRlcmlhbC5zaWRlXTtcbiAgICB9XG5cbiAgICByZXN1bHQuYWxwaGFNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcbiAgICByZXN1bHQuYWxwaGFUZXN0ID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xuICAgIHJlc3VsdC5jbGlwU2hhZG93cyA9IG1hdGVyaWFsLmNsaXBTaGFkb3dzO1xuICAgIHJlc3VsdC5jbGlwcGluZ1BsYW5lcyA9IG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzO1xuICAgIHJlc3VsdC5jbGlwSW50ZXJzZWN0aW9uID0gbWF0ZXJpYWwuY2xpcEludGVyc2VjdGlvbjtcbiAgICByZXN1bHQuZGlzcGxhY2VtZW50TWFwID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuICAgIHJlc3VsdC5kaXNwbGFjZW1lbnRTY2FsZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIHJlc3VsdC5kaXNwbGFjZW1lbnRCaWFzID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcbiAgICByZXN1bHQud2lyZWZyYW1lTGluZXdpZHRoID0gbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIHJlc3VsdC5saW5ld2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cbiAgICBpZiAobGlnaHQuaXNQb2ludExpZ2h0ID09PSB0cnVlICYmIHJlc3VsdC5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID09PSB0cnVlKSB7XG4gICAgICByZXN1bHQucmVmZXJlbmNlUG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcbiAgICAgIHJlc3VsdC5uZWFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFOZWFyO1xuICAgICAgcmVzdWx0LmZhckRpc3RhbmNlID0gc2hhZG93Q2FtZXJhRmFyO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJPYmplY3Qob2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgbGlnaHQsIHR5cGUpIHtcbiAgICBpZiAob2JqZWN0LnZpc2libGUgPT09IGZhbHNlKSByZXR1cm47XG4gICAgdmFyIHZpc2libGUgPSBvYmplY3QubGF5ZXJzLnRlc3QoY2FtZXJhLmxheWVycyk7XG5cbiAgICBpZiAodmlzaWJsZSAmJiAob2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cykpIHtcbiAgICAgIGlmICgob2JqZWN0LmNhc3RTaGFkb3cgfHwgb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgdHlwZSA9PT0gVlNNU2hhZG93TWFwKSAmJiAoIW9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3Qob2JqZWN0KSkpIHtcbiAgICAgICAgb2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCk7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKG9iamVjdCk7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgICAgIHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsrKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2tdO1xuICAgICAgICAgICAgdmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgIHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbChvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGxpZ2h0LCBzaGFkb3dDYW1lcmEubmVhciwgc2hhZG93Q2FtZXJhLmZhciwgdHlwZSk7XG5cbiAgICAgICAgICAgICAgX3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdChzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwudmlzaWJsZSkge1xuICAgICAgICAgIHZhciBfZGVwdGhNYXRlcmlhbDIgPSBnZXREZXB0aE1hdGVyaWFsKG9iamVjdCwgbWF0ZXJpYWwsIGxpZ2h0LCBzaGFkb3dDYW1lcmEubmVhciwgc2hhZG93Q2FtZXJhLmZhciwgdHlwZSk7XG5cbiAgICAgICAgICBfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIF9kZXB0aE1hdGVyaWFsMiwgb2JqZWN0LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuICAgIGZvciAodmFyIF9pMTIyID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgX2kxMjIgPCBsOyBfaTEyMisrKSB7XG4gICAgICByZW5kZXJPYmplY3QoY2hpbGRyZW5bX2kxMjJdLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgbGlnaHQsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBXZWJHTFN0YXRlKGdsLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpIHtcbiAgdmFyIF9lcXVhdGlvblRvR0wsIF9mYWN0b3JUb0dMO1xuXG4gIHZhciBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcblxuICBmdW5jdGlvbiBDb2xvckJ1ZmZlcigpIHtcbiAgICB2YXIgbG9ja2VkID0gZmFsc2U7XG4gICAgdmFyIGNvbG9yID0gbmV3IFZlY3RvcjQoKTtcbiAgICB2YXIgY3VycmVudENvbG9yTWFzayA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRDb2xvckNsZWFyID0gbmV3IFZlY3RvcjQoMCwgMCwgMCwgMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldE1hc2s6IGZ1bmN0aW9uIHNldE1hc2soY29sb3JNYXNrKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgJiYgIWxvY2tlZCkge1xuICAgICAgICAgIGdsLmNvbG9yTWFzayhjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2spO1xuICAgICAgICAgIGN1cnJlbnRDb2xvck1hc2sgPSBjb2xvck1hc2s7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRMb2NrZWQ6IGZ1bmN0aW9uIHNldExvY2tlZChsb2NrKSB7XG4gICAgICAgIGxvY2tlZCA9IGxvY2s7XG4gICAgICB9LFxuICAgICAgc2V0Q2xlYXI6IGZ1bmN0aW9uIHNldENsZWFyKHIsIGcsIGIsIGEsIHByZW11bHRpcGxpZWRBbHBoYSkge1xuICAgICAgICBpZiAocHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlKSB7XG4gICAgICAgICAgciAqPSBhO1xuICAgICAgICAgIGcgKj0gYTtcbiAgICAgICAgICBiICo9IGE7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xvci5zZXQociwgZywgYiwgYSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvckNsZWFyLmVxdWFscyhjb2xvcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcbiAgICAgICAgICBjdXJyZW50Q29sb3JDbGVhci5jb3B5KGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xuICAgICAgICBjdXJyZW50Q29sb3JDbGVhci5zZXQoLTEsIDAsIDAsIDApOyAvLyBzZXQgdG8gaW52YWxpZCBzdGF0ZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBEZXB0aEJ1ZmZlcigpIHtcbiAgICB2YXIgbG9ja2VkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xuICAgIHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcbiAgICB2YXIgY3VycmVudERlcHRoQ2xlYXIgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBzZXRUZXN0OiBmdW5jdGlvbiBzZXRUZXN0KGRlcHRoVGVzdCkge1xuICAgICAgICBpZiAoZGVwdGhUZXN0KSB7XG4gICAgICAgICAgZW5hYmxlKDI5MjkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc2FibGUoMjkyOSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRNYXNrOiBmdW5jdGlvbiBzZXRNYXNrKGRlcHRoTWFzaykge1xuICAgICAgICBpZiAoY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICYmICFsb2NrZWQpIHtcbiAgICAgICAgICBnbC5kZXB0aE1hc2soZGVwdGhNYXNrKTtcbiAgICAgICAgICBjdXJyZW50RGVwdGhNYXNrID0gZGVwdGhNYXNrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0RnVuYzogZnVuY3Rpb24gc2V0RnVuYyhkZXB0aEZ1bmMpIHtcbiAgICAgICAgaWYgKGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYykge1xuICAgICAgICAgIGlmIChkZXB0aEZ1bmMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZGVwdGhGdW5jKSB7XG4gICAgICAgICAgICAgIGNhc2UgTmV2ZXJEZXB0aDpcbiAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoNTEyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIEFsd2F5c0RlcHRoOlxuICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyg1MTkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgTGVzc0RlcHRoOlxuICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyg1MTMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgTGVzc0VxdWFsRGVwdGg6XG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKDUxNSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBFcXVhbERlcHRoOlxuICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyg1MTQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKDUxOCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBHcmVhdGVyRGVwdGg6XG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKDUxNik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBOb3RFcXVhbERlcHRoOlxuICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyg1MTcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKDUxNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmRlcHRoRnVuYyg1MTUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRMb2NrZWQ6IGZ1bmN0aW9uIHNldExvY2tlZChsb2NrKSB7XG4gICAgICAgIGxvY2tlZCA9IGxvY2s7XG4gICAgICB9LFxuICAgICAgc2V0Q2xlYXI6IGZ1bmN0aW9uIHNldENsZWFyKGRlcHRoKSB7XG4gICAgICAgIGlmIChjdXJyZW50RGVwdGhDbGVhciAhPT0gZGVwdGgpIHtcbiAgICAgICAgICBnbC5jbGVhckRlcHRoKGRlcHRoKTtcbiAgICAgICAgICBjdXJyZW50RGVwdGhDbGVhciA9IGRlcHRoO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY3VycmVudERlcHRoTWFzayA9IG51bGw7XG4gICAgICAgIGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xuICAgICAgICBjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFN0ZW5jaWxCdWZmZXIoKSB7XG4gICAgdmFyIGxvY2tlZCA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50U3RlbmNpbE1hc2sgPSBudWxsO1xuICAgIHZhciBjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xuICAgIHZhciBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xuICAgIHZhciBjdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xuICAgIHZhciBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcbiAgICB2YXIgY3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XG4gICAgdmFyIGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBzZXRUZXN0OiBmdW5jdGlvbiBzZXRUZXN0KHN0ZW5jaWxUZXN0KSB7XG4gICAgICAgIGlmICghbG9ja2VkKSB7XG4gICAgICAgICAgaWYgKHN0ZW5jaWxUZXN0KSB7XG4gICAgICAgICAgICBlbmFibGUoMjk2MCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc2FibGUoMjk2MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0TWFzazogZnVuY3Rpb24gc2V0TWFzayhzdGVuY2lsTWFzaykge1xuICAgICAgICBpZiAoY3VycmVudFN0ZW5jaWxNYXNrICE9PSBzdGVuY2lsTWFzayAmJiAhbG9ja2VkKSB7XG4gICAgICAgICAgZ2wuc3RlbmNpbE1hc2soc3RlbmNpbE1hc2spO1xuICAgICAgICAgIGN1cnJlbnRTdGVuY2lsTWFzayA9IHN0ZW5jaWxNYXNrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0RnVuYzogZnVuY3Rpb24gc2V0RnVuYyhzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2spIHtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGVuY2lsRnVuYyAhPT0gc3RlbmNpbEZ1bmMgfHwgY3VycmVudFN0ZW5jaWxSZWYgIT09IHN0ZW5jaWxSZWYgfHwgY3VycmVudFN0ZW5jaWxGdW5jTWFzayAhPT0gc3RlbmNpbE1hc2spIHtcbiAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2spO1xuICAgICAgICAgIGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xuICAgICAgICAgIGN1cnJlbnRTdGVuY2lsUmVmID0gc3RlbmNpbFJlZjtcbiAgICAgICAgICBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gc3RlbmNpbE1hc2s7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRPcDogZnVuY3Rpb24gc2V0T3Aoc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzKSB7XG4gICAgICAgIGlmIChjdXJyZW50U3RlbmNpbEZhaWwgIT09IHN0ZW5jaWxGYWlsIHx8IGN1cnJlbnRTdGVuY2lsWkZhaWwgIT09IHN0ZW5jaWxaRmFpbCB8fCBjdXJyZW50U3RlbmNpbFpQYXNzICE9PSBzdGVuY2lsWlBhc3MpIHtcbiAgICAgICAgICBnbC5zdGVuY2lsT3Aoc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzKTtcbiAgICAgICAgICBjdXJyZW50U3RlbmNpbEZhaWwgPSBzdGVuY2lsRmFpbDtcbiAgICAgICAgICBjdXJyZW50U3RlbmNpbFpGYWlsID0gc3RlbmNpbFpGYWlsO1xuICAgICAgICAgIGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRMb2NrZWQ6IGZ1bmN0aW9uIHNldExvY2tlZChsb2NrKSB7XG4gICAgICAgIGxvY2tlZCA9IGxvY2s7XG4gICAgICB9LFxuICAgICAgc2V0Q2xlYXI6IGZ1bmN0aW9uIHNldENsZWFyKHN0ZW5jaWwpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRTdGVuY2lsQ2xlYXIgIT09IHN0ZW5jaWwpIHtcbiAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoc3RlbmNpbCk7XG4gICAgICAgICAgY3VycmVudFN0ZW5jaWxDbGVhciA9IHN0ZW5jaWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIGxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjdXJyZW50U3RlbmNpbE1hc2sgPSBudWxsO1xuICAgICAgICBjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xuICAgICAgICBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xuICAgICAgICBjdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xuICAgICAgICBjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcbiAgICAgICAgY3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0gLy9cblxuXG4gIHZhciBjb2xvckJ1ZmZlciA9IG5ldyBDb2xvckJ1ZmZlcigpO1xuICB2YXIgZGVwdGhCdWZmZXIgPSBuZXcgRGVwdGhCdWZmZXIoKTtcbiAgdmFyIHN0ZW5jaWxCdWZmZXIgPSBuZXcgU3RlbmNpbEJ1ZmZlcigpO1xuICB2YXIgZW5hYmxlZENhcGFiaWxpdGllcyA9IHt9O1xuICB2YXIgY3VycmVudEJvdW5kRnJhbWVidWZmZXJzID0ge307XG4gIHZhciBjdXJyZW50RHJhd2J1ZmZlcnMgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgZGVmYXVsdERyYXdidWZmZXJzID0gW107XG4gIHZhciBjdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gIHZhciBjdXJyZW50QmxlbmRpbmdFbmFibGVkID0gZmFsc2U7XG4gIHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG4gIHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xuICB2YXIgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG4gIHZhciBjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xuICB2YXIgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG4gIHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG4gIHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcbiAgdmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKDM1NjYxKTtcbiAgdmFyIGxpbmVXaWR0aEF2YWlsYWJsZSA9IGZhbHNlO1xuICB2YXIgdmVyc2lvbiA9IDA7XG4gIHZhciBnbFZlcnNpb24gPSBnbC5nZXRQYXJhbWV0ZXIoNzkzOCk7XG5cbiAgaWYgKGdsVmVyc2lvbi5pbmRleE9mKCdXZWJHTCcpICE9PSAtMSkge1xuICAgIHZlcnNpb24gPSBwYXJzZUZsb2F0KC9eV2ViR0wgKFxcZCkvLmV4ZWMoZ2xWZXJzaW9uKVsxXSk7XG4gICAgbGluZVdpZHRoQXZhaWxhYmxlID0gdmVyc2lvbiA+PSAxLjA7XG4gIH0gZWxzZSBpZiAoZ2xWZXJzaW9uLmluZGV4T2YoJ09wZW5HTCBFUycpICE9PSAtMSkge1xuICAgIHZlcnNpb24gPSBwYXJzZUZsb2F0KC9eT3BlbkdMIEVTIChcXGQpLy5leGVjKGdsVmVyc2lvbilbMV0pO1xuICAgIGxpbmVXaWR0aEF2YWlsYWJsZSA9IHZlcnNpb24gPj0gMi4wO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG4gIHZhciBjdXJyZW50Qm91bmRUZXh0dXJlcyA9IHt9O1xuICB2YXIgc2Npc3NvclBhcmFtID0gZ2wuZ2V0UGFyYW1ldGVyKDMwODgpO1xuICB2YXIgdmlld3BvcnRQYXJhbSA9IGdsLmdldFBhcmFtZXRlcigyOTc4KTtcbiAgdmFyIGN1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkoc2Npc3NvclBhcmFtKTtcbiAgdmFyIGN1cnJlbnRWaWV3cG9ydCA9IG5ldyBWZWN0b3I0KCkuZnJvbUFycmF5KHZpZXdwb3J0UGFyYW0pO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUodHlwZSwgdGFyZ2V0LCBjb3VudCkge1xuICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoNCk7IC8vIDQgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggZGVmYXVsdCB1bnBhY2sgYWxpZ25tZW50IG9mIDQuXG5cbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZSh0eXBlLCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHR5cGUsIDEwMjQxLCA5NzI4KTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKHR5cGUsIDEwMjQwLCA5NzI4KTtcblxuICAgIGZvciAodmFyIF9pMTIzID0gMDsgX2kxMjMgPCBjb3VudDsgX2kxMjMrKykge1xuICAgICAgZ2wudGV4SW1hZ2UyRCh0YXJnZXQgKyBfaTEyMywgMCwgNjQwOCwgMSwgMSwgMCwgNjQwOCwgNTEyMSwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICB2YXIgZW1wdHlUZXh0dXJlcyA9IHt9O1xuICBlbXB0eVRleHR1cmVzWzM1NTNdID0gY3JlYXRlVGV4dHVyZSgzNTUzLCAzNTUzLCAxKTtcbiAgZW1wdHlUZXh0dXJlc1szNDA2N10gPSBjcmVhdGVUZXh0dXJlKDM0MDY3LCAzNDA2OSwgNik7IC8vIGluaXRcblxuICBjb2xvckJ1ZmZlci5zZXRDbGVhcigwLCAwLCAwLCAxKTtcbiAgZGVwdGhCdWZmZXIuc2V0Q2xlYXIoMSk7XG4gIHN0ZW5jaWxCdWZmZXIuc2V0Q2xlYXIoMCk7XG4gIGVuYWJsZSgyOTI5KTtcbiAgZGVwdGhCdWZmZXIuc2V0RnVuYyhMZXNzRXF1YWxEZXB0aCk7XG4gIHNldEZsaXBTaWRlZChmYWxzZSk7XG4gIHNldEN1bGxGYWNlKEN1bGxGYWNlQmFjayk7XG4gIGVuYWJsZSgyODg0KTtcbiAgc2V0QmxlbmRpbmcoTm9CbGVuZGluZyk7IC8vXG5cbiAgZnVuY3Rpb24gZW5hYmxlKGlkKSB7XG4gICAgaWYgKGVuYWJsZWRDYXBhYmlsaXRpZXNbaWRdICE9PSB0cnVlKSB7XG4gICAgICBnbC5lbmFibGUoaWQpO1xuICAgICAgZW5hYmxlZENhcGFiaWxpdGllc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoaWQpIHtcbiAgICBpZiAoZW5hYmxlZENhcGFiaWxpdGllc1tpZF0gIT09IGZhbHNlKSB7XG4gICAgICBnbC5kaXNhYmxlKGlkKTtcbiAgICAgIGVuYWJsZWRDYXBhYmlsaXRpZXNbaWRdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgZnJhbWVidWZmZXIpIHtcbiAgICBpZiAoY3VycmVudEJvdW5kRnJhbWVidWZmZXJzW3RhcmdldF0gIT09IGZyYW1lYnVmZmVyKSB7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmcmFtZWJ1ZmZlcik7XG4gICAgICBjdXJyZW50Qm91bmRGcmFtZWJ1ZmZlcnNbdGFyZ2V0XSA9IGZyYW1lYnVmZmVyO1xuXG4gICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgLy8gMzYwMDkgaXMgZXF1aXZhbGVudCB0byAzNjE2MFxuICAgICAgICBpZiAodGFyZ2V0ID09PSAzNjAwOSkge1xuICAgICAgICAgIGN1cnJlbnRCb3VuZEZyYW1lYnVmZmVyc1szNjE2MF0gPSBmcmFtZWJ1ZmZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQgPT09IDM2MTYwKSB7XG4gICAgICAgICAgY3VycmVudEJvdW5kRnJhbWVidWZmZXJzWzM2MDA5XSA9IGZyYW1lYnVmZmVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXdCdWZmZXJzKHJlbmRlclRhcmdldCwgZnJhbWVidWZmZXIpIHtcbiAgICB2YXIgZHJhd0J1ZmZlcnMgPSBkZWZhdWx0RHJhd2J1ZmZlcnM7XG4gICAgdmFyIG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBpZiAocmVuZGVyVGFyZ2V0KSB7XG4gICAgICBkcmF3QnVmZmVycyA9IGN1cnJlbnREcmF3YnVmZmVycy5nZXQoZnJhbWVidWZmZXIpO1xuXG4gICAgICBpZiAoZHJhd0J1ZmZlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkcmF3QnVmZmVycyA9IFtdO1xuICAgICAgICBjdXJyZW50RHJhd2J1ZmZlcnMuc2V0KGZyYW1lYnVmZmVyLCBkcmF3QnVmZmVycyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cykge1xuICAgICAgICB2YXIgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuICAgICAgICBpZiAoZHJhd0J1ZmZlcnMubGVuZ3RoICE9PSB0ZXh0dXJlcy5sZW5ndGggfHwgZHJhd0J1ZmZlcnNbMF0gIT09IDM2MDY0KSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kxMjQgPSAwLCBpbCA9IHRleHR1cmVzLmxlbmd0aDsgX2kxMjQgPCBpbDsgX2kxMjQrKykge1xuICAgICAgICAgICAgZHJhd0J1ZmZlcnNbX2kxMjRdID0gMzYwNjQgKyBfaTEyNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkcmF3QnVmZmVycy5sZW5ndGggPSB0ZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZHJhd0J1ZmZlcnNbMF0gIT09IDM2MDY0KSB7XG4gICAgICAgICAgZHJhd0J1ZmZlcnNbMF0gPSAzNjA2NDtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRyYXdCdWZmZXJzWzBdICE9PSAxMDI5KSB7XG4gICAgICAgIGRyYXdCdWZmZXJzWzBdID0gMTAyOTtcbiAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgaWYgKGNhcGFiaWxpdGllcy5pc1dlYkdMMikge1xuICAgICAgICBnbC5kcmF3QnVmZmVycyhkcmF3QnVmZmVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHRlbnNpb25zLmdldCgnV0VCR0xfZHJhd19idWZmZXJzJykuZHJhd0J1ZmZlcnNXRUJHTChkcmF3QnVmZmVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgaWYgKGN1cnJlbnRQcm9ncmFtICE9PSBwcm9ncmFtKSB7XG4gICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgY3VycmVudFByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGVxdWF0aW9uVG9HTCA9IChfZXF1YXRpb25Ub0dMID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfZXF1YXRpb25Ub0dMLCBBZGRFcXVhdGlvbiwgMzI3NzQpLCBfZGVmaW5lUHJvcGVydHkoX2VxdWF0aW9uVG9HTCwgU3VidHJhY3RFcXVhdGlvbiwgMzI3NzgpLCBfZGVmaW5lUHJvcGVydHkoX2VxdWF0aW9uVG9HTCwgUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24sIDMyNzc5KSwgX2VxdWF0aW9uVG9HTCk7XG5cbiAgaWYgKGlzV2ViR0wyKSB7XG4gICAgZXF1YXRpb25Ub0dMW01pbkVxdWF0aW9uXSA9IDMyNzc1O1xuICAgIGVxdWF0aW9uVG9HTFtNYXhFcXVhdGlvbl0gPSAzMjc3NjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0VYVF9ibGVuZF9taW5tYXgnKTtcblxuICAgIGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcbiAgICAgIGVxdWF0aW9uVG9HTFtNaW5FcXVhdGlvbl0gPSBleHRlbnNpb24uTUlOX0VYVDtcbiAgICAgIGVxdWF0aW9uVG9HTFtNYXhFcXVhdGlvbl0gPSBleHRlbnNpb24uTUFYX0VYVDtcbiAgICB9XG4gIH1cblxuICB2YXIgZmFjdG9yVG9HTCA9IChfZmFjdG9yVG9HTCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2ZhY3RvclRvR0wsIFplcm9GYWN0b3IsIDApLCBfZGVmaW5lUHJvcGVydHkoX2ZhY3RvclRvR0wsIE9uZUZhY3RvciwgMSksIF9kZWZpbmVQcm9wZXJ0eShfZmFjdG9yVG9HTCwgU3JjQ29sb3JGYWN0b3IsIDc2OCksIF9kZWZpbmVQcm9wZXJ0eShfZmFjdG9yVG9HTCwgU3JjQWxwaGFGYWN0b3IsIDc3MCksIF9kZWZpbmVQcm9wZXJ0eShfZmFjdG9yVG9HTCwgU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciwgNzc2KSwgX2RlZmluZVByb3BlcnR5KF9mYWN0b3JUb0dMLCBEc3RDb2xvckZhY3RvciwgNzc0KSwgX2RlZmluZVByb3BlcnR5KF9mYWN0b3JUb0dMLCBEc3RBbHBoYUZhY3RvciwgNzcyKSwgX2RlZmluZVByb3BlcnR5KF9mYWN0b3JUb0dMLCBPbmVNaW51c1NyY0NvbG9yRmFjdG9yLCA3NjkpLCBfZGVmaW5lUHJvcGVydHkoX2ZhY3RvclRvR0wsIE9uZU1pbnVzU3JjQWxwaGFGYWN0b3IsIDc3MSksIF9kZWZpbmVQcm9wZXJ0eShfZmFjdG9yVG9HTCwgT25lTWludXNEc3RDb2xvckZhY3RvciwgNzc1KSwgX2RlZmluZVByb3BlcnR5KF9mYWN0b3JUb0dMLCBPbmVNaW51c0RzdEFscGhhRmFjdG9yLCA3NzMpLCBfZmFjdG9yVG9HTCk7XG5cbiAgZnVuY3Rpb24gc2V0QmxlbmRpbmcoYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCwgYmxlbmRFcXVhdGlvbkFscGhhLCBibGVuZFNyY0FscGhhLCBibGVuZERzdEFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEpIHtcbiAgICBpZiAoYmxlbmRpbmcgPT09IE5vQmxlbmRpbmcpIHtcbiAgICAgIGlmIChjdXJyZW50QmxlbmRpbmdFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIGRpc2FibGUoMzA0Mik7XG4gICAgICAgIGN1cnJlbnRCbGVuZGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50QmxlbmRpbmdFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgZW5hYmxlKDMwNDIpO1xuICAgICAgY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGJsZW5kaW5nICE9PSBDdXN0b21CbGVuZGluZykge1xuICAgICAgaWYgKGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgfHwgcHJlbXVsdGlwbGllZEFscGhhICE9PSBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRCbGVuZEVxdWF0aW9uICE9PSBBZGRFcXVhdGlvbiB8fCBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICE9PSBBZGRFcXVhdGlvbikge1xuICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb24oMzI3NzQpO1xuICAgICAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XG4gICAgICAgICAgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IEFkZEVxdWF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZW11bHRpcGxpZWRBbHBoYSkge1xuICAgICAgICAgIHN3aXRjaCAoYmxlbmRpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgTm9ybWFsQmxlbmRpbmc6XG4gICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKDEsIDc3MSwgMSwgNzcxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcbiAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKDEsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTdWJ0cmFjdGl2ZUJsZW5kaW5nOlxuICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSgwLCA3NjksIDAsIDEpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBNdWx0aXBseUJsZW5kaW5nOlxuICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSgwLCA3NjgsIDAsIDc3MCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOiBJbnZhbGlkIGJsZW5kaW5nOiAnLCBibGVuZGluZyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKGJsZW5kaW5nKSB7XG4gICAgICAgICAgICBjYXNlIE5vcm1hbEJsZW5kaW5nOlxuICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSg3NzAsIDc3MSwgMSwgNzcxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWRkaXRpdmVCbGVuZGluZzpcbiAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKDc3MCwgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFN1YnRyYWN0aXZlQmxlbmRpbmc6XG4gICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKDAsIDc2OSwgMCwgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIE11bHRpcGx5QmxlbmRpbmc6XG4gICAgICAgICAgICAgIGdsLmJsZW5kRnVuYygwLCA3NjgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTogSW52YWxpZCBibGVuZGluZzogJywgYmxlbmRpbmcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuICAgICAgICBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuICAgICAgICBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcbiAgICAgICAgY3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XG4gICAgICAgIGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gY3VzdG9tIGJsZW5kaW5nXG5cblxuICAgIGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuICAgIGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xuICAgIGJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhIHx8IGJsZW5kRHN0O1xuXG4gICAgaWYgKGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSkge1xuICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGVxdWF0aW9uVG9HTFtibGVuZEVxdWF0aW9uXSwgZXF1YXRpb25Ub0dMW2JsZW5kRXF1YXRpb25BbHBoYV0pO1xuICAgICAgY3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuICAgICAgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcbiAgICB9XG5cbiAgICBpZiAoYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhKSB7XG4gICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShmYWN0b3JUb0dMW2JsZW5kU3JjXSwgZmFjdG9yVG9HTFtibGVuZERzdF0sIGZhY3RvclRvR0xbYmxlbmRTcmNBbHBoYV0sIGZhY3RvclRvR0xbYmxlbmREc3RBbHBoYV0pO1xuICAgICAgY3VycmVudEJsZW5kU3JjID0gYmxlbmRTcmM7XG4gICAgICBjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcbiAgICAgIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcbiAgICAgIGN1cnJlbnRCbGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYTtcbiAgICB9XG5cbiAgICBjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcbiAgICBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGZyb250RmFjZUNXKSB7XG4gICAgbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSA/IGRpc2FibGUoMjg4NCkgOiBlbmFibGUoMjg4NCk7XG4gICAgdmFyIGZsaXBTaWRlZCA9IG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlO1xuICAgIGlmIChmcm9udEZhY2VDVykgZmxpcFNpZGVkID0gIWZsaXBTaWRlZDtcbiAgICBzZXRGbGlwU2lkZWQoZmxpcFNpZGVkKTtcbiAgICBtYXRlcmlhbC5ibGVuZGluZyA9PT0gTm9ybWFsQmxlbmRpbmcgJiYgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IGZhbHNlID8gc2V0QmxlbmRpbmcoTm9CbGVuZGluZykgOiBzZXRCbGVuZGluZyhtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSk7XG4gICAgZGVwdGhCdWZmZXIuc2V0RnVuYyhtYXRlcmlhbC5kZXB0aEZ1bmMpO1xuICAgIGRlcHRoQnVmZmVyLnNldFRlc3QobWF0ZXJpYWwuZGVwdGhUZXN0KTtcbiAgICBkZXB0aEJ1ZmZlci5zZXRNYXNrKG1hdGVyaWFsLmRlcHRoV3JpdGUpO1xuICAgIGNvbG9yQnVmZmVyLnNldE1hc2sobWF0ZXJpYWwuY29sb3JXcml0ZSk7XG4gICAgdmFyIHN0ZW5jaWxXcml0ZSA9IG1hdGVyaWFsLnN0ZW5jaWxXcml0ZTtcbiAgICBzdGVuY2lsQnVmZmVyLnNldFRlc3Qoc3RlbmNpbFdyaXRlKTtcblxuICAgIGlmIChzdGVuY2lsV3JpdGUpIHtcbiAgICAgIHN0ZW5jaWxCdWZmZXIuc2V0TWFzayhtYXRlcmlhbC5zdGVuY2lsV3JpdGVNYXNrKTtcbiAgICAgIHN0ZW5jaWxCdWZmZXIuc2V0RnVuYyhtYXRlcmlhbC5zdGVuY2lsRnVuYywgbWF0ZXJpYWwuc3RlbmNpbFJlZiwgbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrKTtcbiAgICAgIHN0ZW5jaWxCdWZmZXIuc2V0T3AobWF0ZXJpYWwuc3RlbmNpbEZhaWwsIG1hdGVyaWFsLnN0ZW5jaWxaRmFpbCwgbWF0ZXJpYWwuc3RlbmNpbFpQYXNzKTtcbiAgICB9XG5cbiAgICBzZXRQb2x5Z29uT2Zmc2V0KG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyk7XG4gICAgbWF0ZXJpYWwuYWxwaGFUb0NvdmVyYWdlID09PSB0cnVlID8gZW5hYmxlKDMyOTI2KSA6IGRpc2FibGUoMzI5MjYpO1xuICB9IC8vXG5cblxuICBmdW5jdGlvbiBzZXRGbGlwU2lkZWQoZmxpcFNpZGVkKSB7XG4gICAgaWYgKGN1cnJlbnRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCkge1xuICAgICAgaWYgKGZsaXBTaWRlZCkge1xuICAgICAgICBnbC5mcm9udEZhY2UoMjMwNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5mcm9udEZhY2UoMjMwNSk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q3VsbEZhY2UoY3VsbEZhY2UpIHtcbiAgICBpZiAoY3VsbEZhY2UgIT09IEN1bGxGYWNlTm9uZSkge1xuICAgICAgZW5hYmxlKDI4ODQpO1xuXG4gICAgICBpZiAoY3VsbEZhY2UgIT09IGN1cnJlbnRDdWxsRmFjZSkge1xuICAgICAgICBpZiAoY3VsbEZhY2UgPT09IEN1bGxGYWNlQmFjaykge1xuICAgICAgICAgIGdsLmN1bGxGYWNlKDEwMjkpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1bGxGYWNlID09PSBDdWxsRmFjZUZyb250KSB7XG4gICAgICAgICAgZ2wuY3VsbEZhY2UoMTAyOCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2wuY3VsbEZhY2UoMTAzMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGlzYWJsZSgyODg0KTtcbiAgICB9XG5cbiAgICBjdXJyZW50Q3VsbEZhY2UgPSBjdWxsRmFjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExpbmVXaWR0aCh3aWR0aCkge1xuICAgIGlmICh3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCkge1xuICAgICAgaWYgKGxpbmVXaWR0aEF2YWlsYWJsZSkgZ2wubGluZVdpZHRoKHdpZHRoKTtcbiAgICAgIGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQb2x5Z29uT2Zmc2V0KHBvbHlnb25PZmZzZXQsIGZhY3RvciwgdW5pdHMpIHtcbiAgICBpZiAocG9seWdvbk9mZnNldCkge1xuICAgICAgZW5hYmxlKDMyODIzKTtcblxuICAgICAgaWYgKGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBmYWN0b3IgfHwgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyAhPT0gdW5pdHMpIHtcbiAgICAgICAgZ2wucG9seWdvbk9mZnNldChmYWN0b3IsIHVuaXRzKTtcbiAgICAgICAgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG4gICAgICAgIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGlzYWJsZSgzMjgyMyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2Npc3NvclRlc3Qoc2Npc3NvclRlc3QpIHtcbiAgICBpZiAoc2Npc3NvclRlc3QpIHtcbiAgICAgIGVuYWJsZSgzMDg5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzYWJsZSgzMDg5KTtcbiAgICB9XG4gIH0gLy8gdGV4dHVyZVxuXG5cbiAgZnVuY3Rpb24gYWN0aXZlVGV4dHVyZSh3ZWJnbFNsb3QpIHtcbiAgICBpZiAod2ViZ2xTbG90ID09PSB1bmRlZmluZWQpIHdlYmdsU2xvdCA9IDMzOTg0ICsgbWF4VGV4dHVyZXMgLSAxO1xuXG4gICAgaWYgKGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90KSB7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKHdlYmdsU2xvdCk7XG4gICAgICBjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmluZFRleHR1cmUod2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUpIHtcbiAgICBpZiAoY3VycmVudFRleHR1cmVTbG90ID09PSBudWxsKSB7XG4gICAgICBhY3RpdmVUZXh0dXJlKCk7XG4gICAgfVxuXG4gICAgdmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzW2N1cnJlbnRUZXh0dXJlU2xvdF07XG5cbiAgICBpZiAoYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJvdW5kVGV4dHVyZSA9IHtcbiAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICB0ZXh0dXJlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBjdXJyZW50Qm91bmRUZXh0dXJlc1tjdXJyZW50VGV4dHVyZVNsb3RdID0gYm91bmRUZXh0dXJlO1xuICAgIH1cblxuICAgIGlmIChib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUpIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlIHx8IGVtcHR5VGV4dHVyZXNbd2ViZ2xUeXBlXSk7XG4gICAgICBib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcbiAgICAgIGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVuYmluZFRleHR1cmUoKSB7XG4gICAgdmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzW2N1cnJlbnRUZXh0dXJlU2xvdF07XG5cbiAgICBpZiAoYm91bmRUZXh0dXJlICE9PSB1bmRlZmluZWQgJiYgYm91bmRUZXh0dXJlLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZ2wuYmluZFRleHR1cmUoYm91bmRUZXh0dXJlLnR5cGUsIG51bGwpO1xuICAgICAgYm91bmRUZXh0dXJlLnR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICBib3VuZFRleHR1cmUudGV4dHVyZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wcmVzc2VkVGV4SW1hZ2UyRCgpIHtcbiAgICB0cnkge1xuICAgICAgZ2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRleFN1YkltYWdlMkQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRleFN1YkltYWdlM0QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGdsLnRleFN1YkltYWdlM0QuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKCkge1xuICAgIHRyeSB7XG4gICAgICBnbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRC5hcHBseShnbCwgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGV4U3RvcmFnZTJEKCkge1xuICAgIHRyeSB7XG4gICAgICBnbC50ZXhTdG9yYWdlMkQuYXBwbHkoZ2wsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRleFN0b3JhZ2UzRCgpIHtcbiAgICB0cnkge1xuICAgICAgZ2wudGV4U3RvcmFnZTNELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0ZXhJbWFnZTJEKCkge1xuICAgIHRyeSB7XG4gICAgICBnbC50ZXhJbWFnZTJELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0ZXhJbWFnZTNEKCkge1xuICAgIHRyeSB7XG4gICAgICBnbC50ZXhJbWFnZTNELmFwcGx5KGdsLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yKTtcbiAgICB9XG4gIH0gLy9cblxuXG4gIGZ1bmN0aW9uIHNjaXNzb3Ioc2Npc3Nvcikge1xuICAgIGlmIChjdXJyZW50U2Npc3Nvci5lcXVhbHMoc2Npc3NvcikgPT09IGZhbHNlKSB7XG4gICAgICBnbC5zY2lzc29yKHNjaXNzb3IueCwgc2Npc3Nvci55LCBzY2lzc29yLnosIHNjaXNzb3Iudyk7XG4gICAgICBjdXJyZW50U2Npc3Nvci5jb3B5KHNjaXNzb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgaWYgKGN1cnJlbnRWaWV3cG9ydC5lcXVhbHModmlld3BvcnQpID09PSBmYWxzZSkge1xuICAgICAgZ2wudmlld3BvcnQodmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQueiwgdmlld3BvcnQudyk7XG4gICAgICBjdXJyZW50Vmlld3BvcnQuY29weSh2aWV3cG9ydCk7XG4gICAgfVxuICB9IC8vXG5cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAvLyByZXNldCBzdGF0ZVxuICAgIGdsLmRpc2FibGUoMzA0Mik7XG4gICAgZ2wuZGlzYWJsZSgyODg0KTtcbiAgICBnbC5kaXNhYmxlKDI5MjkpO1xuICAgIGdsLmRpc2FibGUoMzI4MjMpO1xuICAgIGdsLmRpc2FibGUoMzA4OSk7XG4gICAgZ2wuZGlzYWJsZSgyOTYwKTtcbiAgICBnbC5kaXNhYmxlKDMyOTI2KTtcbiAgICBnbC5ibGVuZEVxdWF0aW9uKDMyNzc0KTtcbiAgICBnbC5ibGVuZEZ1bmMoMSwgMCk7XG4gICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoMSwgMCwgMSwgMCk7XG4gICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgZ2wuZGVwdGhNYXNrKHRydWUpO1xuICAgIGdsLmRlcHRoRnVuYyg1MTMpO1xuICAgIGdsLmNsZWFyRGVwdGgoMSk7XG4gICAgZ2wuc3RlbmNpbE1hc2soMHhmZmZmZmZmZik7XG4gICAgZ2wuc3RlbmNpbEZ1bmMoNTE5LCAwLCAweGZmZmZmZmZmKTtcbiAgICBnbC5zdGVuY2lsT3AoNzY4MCwgNzY4MCwgNzY4MCk7XG4gICAgZ2wuY2xlYXJTdGVuY2lsKDApO1xuICAgIGdsLmN1bGxGYWNlKDEwMjkpO1xuICAgIGdsLmZyb250RmFjZSgyMzA1KTtcbiAgICBnbC5wb2x5Z29uT2Zmc2V0KDAsIDApO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoMzM5ODQpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgbnVsbCk7XG5cbiAgICBpZiAoaXNXZWJHTDIgPT09IHRydWUpIHtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcigzNjAwOSwgbnVsbCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoMzYwMDgsIG51bGwpO1xuICAgIH1cblxuICAgIGdsLnVzZVByb2dyYW0obnVsbCk7XG4gICAgZ2wubGluZVdpZHRoKDEpO1xuICAgIGdsLnNjaXNzb3IoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpOyAvLyByZXNldCBpbnRlcm5hbHNcblxuICAgIGVuYWJsZWRDYXBhYmlsaXRpZXMgPSB7fTtcbiAgICBjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xuICAgIGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG4gICAgY3VycmVudEJvdW5kRnJhbWVidWZmZXJzID0ge307XG4gICAgY3VycmVudERyYXdidWZmZXJzID0gbmV3IFdlYWtNYXAoKTtcbiAgICBkZWZhdWx0RHJhd2J1ZmZlcnMgPSBbXTtcbiAgICBjdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gICAgY3VycmVudEJsZW5kaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XG4gICAgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuICAgIGN1cnJlbnRCbGVuZFNyYyA9IG51bGw7XG4gICAgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcbiAgICBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcbiAgICBjdXJyZW50QmxlbmRTcmNBbHBoYSA9IG51bGw7XG4gICAgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuICAgIGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xuICAgIGN1cnJlbnRGbGlwU2lkZWQgPSBudWxsO1xuICAgIGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XG4gICAgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG4gICAgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsO1xuICAgIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xuICAgIGN1cnJlbnRTY2lzc29yLnNldCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xuICAgIGN1cnJlbnRWaWV3cG9ydC5zZXQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbiAgICBjb2xvckJ1ZmZlci5yZXNldCgpO1xuICAgIGRlcHRoQnVmZmVyLnJlc2V0KCk7XG4gICAgc3RlbmNpbEJ1ZmZlci5yZXNldCgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBidWZmZXJzOiB7XG4gICAgICBjb2xvcjogY29sb3JCdWZmZXIsXG4gICAgICBkZXB0aDogZGVwdGhCdWZmZXIsXG4gICAgICBzdGVuY2lsOiBzdGVuY2lsQnVmZmVyXG4gICAgfSxcbiAgICBlbmFibGU6IGVuYWJsZSxcbiAgICBkaXNhYmxlOiBkaXNhYmxlLFxuICAgIGJpbmRGcmFtZWJ1ZmZlcjogYmluZEZyYW1lYnVmZmVyLFxuICAgIGRyYXdCdWZmZXJzOiBkcmF3QnVmZmVycyxcbiAgICB1c2VQcm9ncmFtOiB1c2VQcm9ncmFtLFxuICAgIHNldEJsZW5kaW5nOiBzZXRCbGVuZGluZyxcbiAgICBzZXRNYXRlcmlhbDogc2V0TWF0ZXJpYWwsXG4gICAgc2V0RmxpcFNpZGVkOiBzZXRGbGlwU2lkZWQsXG4gICAgc2V0Q3VsbEZhY2U6IHNldEN1bGxGYWNlLFxuICAgIHNldExpbmVXaWR0aDogc2V0TGluZVdpZHRoLFxuICAgIHNldFBvbHlnb25PZmZzZXQ6IHNldFBvbHlnb25PZmZzZXQsXG4gICAgc2V0U2Npc3NvclRlc3Q6IHNldFNjaXNzb3JUZXN0LFxuICAgIGFjdGl2ZVRleHR1cmU6IGFjdGl2ZVRleHR1cmUsXG4gICAgYmluZFRleHR1cmU6IGJpbmRUZXh0dXJlLFxuICAgIHVuYmluZFRleHR1cmU6IHVuYmluZFRleHR1cmUsXG4gICAgY29tcHJlc3NlZFRleEltYWdlMkQ6IGNvbXByZXNzZWRUZXhJbWFnZTJELFxuICAgIHRleEltYWdlMkQ6IHRleEltYWdlMkQsXG4gICAgdGV4SW1hZ2UzRDogdGV4SW1hZ2UzRCxcbiAgICB0ZXhTdG9yYWdlMkQ6IHRleFN0b3JhZ2UyRCxcbiAgICB0ZXhTdG9yYWdlM0Q6IHRleFN0b3JhZ2UzRCxcbiAgICB0ZXhTdWJJbWFnZTJEOiB0ZXhTdWJJbWFnZTJELFxuICAgIHRleFN1YkltYWdlM0Q6IHRleFN1YkltYWdlM0QsXG4gICAgY29tcHJlc3NlZFRleFN1YkltYWdlMkQ6IGNvbXByZXNzZWRUZXhTdWJJbWFnZTJELFxuICAgIHNjaXNzb3I6IHNjaXNzb3IsXG4gICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgIHJlc2V0OiByZXNldFxuICB9O1xufVxuXG5mdW5jdGlvbiBXZWJHTFRleHR1cmVzKF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIGluZm8pIHtcbiAgdmFyIF93cmFwcGluZ1RvR0wsIF9maWx0ZXJUb0dMO1xuXG4gIHZhciBpc1dlYkdMMiA9IGNhcGFiaWxpdGllcy5pc1dlYkdMMjtcbiAgdmFyIG1heFRleHR1cmVzID0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzO1xuICB2YXIgbWF4Q3ViZW1hcFNpemUgPSBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemU7XG4gIHZhciBtYXhUZXh0dXJlU2l6ZSA9IGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZTtcbiAgdmFyIG1heFNhbXBsZXMgPSBjYXBhYmlsaXRpZXMubWF4U2FtcGxlcztcbiAgdmFyIG11bHRpc2FtcGxlZFJUVEV4dCA9IGV4dGVuc2lvbnMuaGFzKCdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnKSA/IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnKSA6IG51bGw7XG4gIHZhciBzdXBwb3J0c0ludmFsaWRhdGVGcmFtZWJ1ZmZlciA9IC9PY3VsdXNCcm93c2VyL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICB2YXIgX3ZpZGVvVGV4dHVyZXMgPSBuZXcgV2Vha01hcCgpO1xuXG4gIHZhciBfY2FudmFzO1xuXG4gIHZhciBfc291cmNlcyA9IG5ldyBXZWFrTWFwKCk7IC8vIG1hcHMgV2ViZ2xUZXh0dXJlIG9iamVjdHMgdG8gaW5zdGFuY2VzIG9mIFNvdXJjZVxuICAvLyBjb3Jkb3ZhIGlPUyAoYXMgb2YgNS4wKSBzdGlsbCB1c2VzIFVJV2ViVmlldywgd2hpY2ggcHJvdmlkZXMgT2Zmc2NyZWVuQ2FudmFzLFxuICAvLyBhbHNvIE9mZnNjcmVlbkNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiksIGJ1dCBub3QgT2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSFcbiAgLy8gU29tZSBpbXBsZW1lbnRhdGlvbnMgbWF5IG9ubHkgaW1wbGVtZW50IE9mZnNjcmVlbkNhbnZhcyBwYXJ0aWFsbHkgKGUuZy4gbGFja2luZyAyZCkuXG5cblxuICB2YXIgdXNlT2Zmc2NyZWVuQ2FudmFzID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB1c2VPZmZzY3JlZW5DYW52YXMgPSB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgICYmIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSkuZ2V0Q29udGV4dCgnMmQnKSAhPT0gbnVsbDtcbiAgfSBjYXRjaCAoZXJyKSB7Ly8gSWdub3JlIGFueSBlcnJvcnNcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gVXNlIE9mZnNjcmVlbkNhbnZhcyB3aGVuIGF2YWlsYWJsZS4gU3BlY2lhbGx5IG5lZWRlZCBpbiB3ZWIgd29ya2Vyc1xuICAgIHJldHVybiB1c2VPZmZzY3JlZW5DYW52YXMgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuICAgIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCkgOiBjcmVhdGVFbGVtZW50TlMoJ2NhbnZhcycpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzaXplSW1hZ2UoaW1hZ2UsIG5lZWRzUG93ZXJPZlR3bywgbmVlZHNOZXdDYW52YXMsIG1heFNpemUpIHtcbiAgICB2YXIgc2NhbGUgPSAxOyAvLyBoYW5kbGUgY2FzZSBpZiB0ZXh0dXJlIGV4Y2VlZHMgbWF4IHNpemVcblxuICAgIGlmIChpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSkge1xuICAgICAgc2NhbGUgPSBtYXhTaXplIC8gTWF0aC5tYXgoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgfSAvLyBvbmx5IHBlcmZvcm0gcmVzaXplIGlmIG5lY2Vzc2FyeVxuXG5cbiAgICBpZiAoc2NhbGUgPCAxIHx8IG5lZWRzUG93ZXJPZlR3byA9PT0gdHJ1ZSkge1xuICAgICAgLy8gb25seSBwZXJmb3JtIHJlc2l6ZSBmb3IgY2VydGFpbiBpbWFnZSB0eXBlc1xuICAgICAgaWYgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBuZWVkc1Bvd2VyT2ZUd28gPyBmbG9vclBvd2VyT2ZUd28gOiBNYXRoLmZsb29yO1xuICAgICAgICB2YXIgd2lkdGggPSBmbG9vcihzY2FsZSAqIGltYWdlLndpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGZsb29yKHNjYWxlICogaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgaWYgKF9jYW52YXMgPT09IHVuZGVmaW5lZCkgX2NhbnZhcyA9IGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsgLy8gY3ViZSB0ZXh0dXJlcyBjYW4ndCByZXVzZSB0aGUgc2FtZSBjYW52YXNcblxuICAgICAgICB2YXIgY2FudmFzID0gbmVlZHNOZXdDYW52YXMgPyBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkgOiBfY2FudmFzO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaGFzIGJlZW4gcmVzaXplZCBmcm9tICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKSB0byAoJyArIHdpZHRoICsgJ3gnICsgaGVpZ2h0ICsgJykuJyk7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJ2RhdGEnIGluIGltYWdlKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBJbWFnZSBpbiBEYXRhVGV4dHVyZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Bvd2VyT2ZUd28kMShpbWFnZSkge1xuICAgIHJldHVybiBpc1Bvd2VyT2ZUd28oaW1hZ2Uud2lkdGgpICYmIGlzUG93ZXJPZlR3byhpbWFnZS5oZWlnaHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byh0ZXh0dXJlKSB7XG4gICAgaWYgKGlzV2ViR0wyKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykge1xuICAgIHJldHVybiB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBzdXBwb3J0c01pcHMgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlTWlwbWFwKHRhcmdldCkge1xuICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJuYWxGb3JtYXQoaW50ZXJuYWxGb3JtYXROYW1lLCBnbEZvcm1hdCwgZ2xUeXBlLCBlbmNvZGluZykge1xuICAgIHZhciBpc1ZpZGVvVGV4dHVyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgaWYgKGlzV2ViR0wyID09PSBmYWxzZSkgcmV0dXJuIGdsRm9ybWF0O1xuXG4gICAgaWYgKGludGVybmFsRm9ybWF0TmFtZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKF9nbFtpbnRlcm5hbEZvcm1hdE5hbWVdICE9PSB1bmRlZmluZWQpIHJldHVybiBfZ2xbaW50ZXJuYWxGb3JtYXROYW1lXTtcbiAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byB1c2Ugbm9uLWV4aXN0aW5nIFdlYkdMIGludGVybmFsIGZvcm1hdCBcXCcnICsgaW50ZXJuYWxGb3JtYXROYW1lICsgJ1xcJycpO1xuICAgIH1cblxuICAgIHZhciBpbnRlcm5hbEZvcm1hdCA9IGdsRm9ybWF0O1xuXG4gICAgaWYgKGdsRm9ybWF0ID09PSA2NDAzKSB7XG4gICAgICBpZiAoZ2xUeXBlID09PSA1MTI2KSBpbnRlcm5hbEZvcm1hdCA9IDMzMzI2O1xuICAgICAgaWYgKGdsVHlwZSA9PT0gNTEzMSkgaW50ZXJuYWxGb3JtYXQgPSAzMzMyNTtcbiAgICAgIGlmIChnbFR5cGUgPT09IDUxMjEpIGludGVybmFsRm9ybWF0ID0gMzMzMjE7XG4gICAgfVxuXG4gICAgaWYgKGdsRm9ybWF0ID09PSAzMzMxOSkge1xuICAgICAgaWYgKGdsVHlwZSA9PT0gNTEyNikgaW50ZXJuYWxGb3JtYXQgPSAzMzMyODtcbiAgICAgIGlmIChnbFR5cGUgPT09IDUxMzEpIGludGVybmFsRm9ybWF0ID0gMzMzMjc7XG4gICAgICBpZiAoZ2xUeXBlID09PSA1MTIxKSBpbnRlcm5hbEZvcm1hdCA9IDMzMzIzO1xuICAgIH1cblxuICAgIGlmIChnbEZvcm1hdCA9PT0gNjQwOCkge1xuICAgICAgaWYgKGdsVHlwZSA9PT0gNTEyNikgaW50ZXJuYWxGb3JtYXQgPSAzNDgzNjtcbiAgICAgIGlmIChnbFR5cGUgPT09IDUxMzEpIGludGVybmFsRm9ybWF0ID0gMzQ4NDI7XG4gICAgICBpZiAoZ2xUeXBlID09PSA1MTIxKSBpbnRlcm5hbEZvcm1hdCA9IGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgJiYgaXNWaWRlb1RleHR1cmUgPT09IGZhbHNlID8gMzU5MDcgOiAzMjg1NjtcbiAgICAgIGlmIChnbFR5cGUgPT09IDMyODE5KSBpbnRlcm5hbEZvcm1hdCA9IDMyODU0O1xuICAgICAgaWYgKGdsVHlwZSA9PT0gMzI4MjApIGludGVybmFsRm9ybWF0ID0gMzI4NTU7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsRm9ybWF0ID09PSAzMzMyNSB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gMzMzMjYgfHwgaW50ZXJuYWxGb3JtYXQgPT09IDMzMzI3IHx8IGludGVybmFsRm9ybWF0ID09PSAzMzMyOCB8fCBpbnRlcm5hbEZvcm1hdCA9PT0gMzQ4NDIgfHwgaW50ZXJuYWxGb3JtYXQgPT09IDM0ODM2KSB7XG4gICAgICBleHRlbnNpb25zLmdldCgnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbEZvcm1hdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pcExldmVscyh0ZXh0dXJlLCBpbWFnZSwgc3VwcG9ydHNNaXBzKSB7XG4gICAgaWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpID09PSB0cnVlIHx8IHRleHR1cmUuaXNGcmFtZWJ1ZmZlclRleHR1cmUgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlcikge1xuICAgICAgcmV0dXJuIE1hdGgubG9nMihNYXRoLm1heChpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KSkgKyAxO1xuICAgIH0gZWxzZSBpZiAodGV4dHVyZS5taXBtYXBzICE9PSB1bmRlZmluZWQgJiYgdGV4dHVyZS5taXBtYXBzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHVzZXItZGVmaW5lZCBtaXBtYXBzXG4gICAgICByZXR1cm4gdGV4dHVyZS5taXBtYXBzLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSAmJiBBcnJheS5pc0FycmF5KHRleHR1cmUuaW1hZ2UpKSB7XG4gICAgICByZXR1cm4gaW1hZ2UubWlwbWFwcy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRleHR1cmUgd2l0aG91dCBtaXBtYXBzIChvbmx5IGJhc2UgbGV2ZWwpXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0gLy8gRmFsbGJhY2sgZmlsdGVycyBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcblxuXG4gIGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrKGYpIHtcbiAgICBpZiAoZiA9PT0gTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyKSB7XG4gICAgICByZXR1cm4gOTcyODtcbiAgICB9XG5cbiAgICByZXR1cm4gOTcyOTtcbiAgfSAvL1xuXG5cbiAgZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZShldmVudCkge1xuICAgIHZhciB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuICAgIHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UpO1xuICAgIGRlYWxsb2NhdGVUZXh0dXJlKHRleHR1cmUpO1xuXG4gICAgaWYgKHRleHR1cmUuaXNWaWRlb1RleHR1cmUpIHtcbiAgICAgIF92aWRlb1RleHR1cmVzLmRlbGV0ZSh0ZXh0dXJlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJlbmRlclRhcmdldERpc3Bvc2UoZXZlbnQpIHtcbiAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlKTtcbiAgICBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gIH0gLy9cblxuXG4gIGZ1bmN0aW9uIGRlYWxsb2NhdGVUZXh0dXJlKHRleHR1cmUpIHtcbiAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcbiAgICBpZiAodGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBjaGVjayBpZiBpdCdzIG5lY2Vzc2FyeSB0byByZW1vdmUgdGhlIFdlYkdMVGV4dHVyZSBvYmplY3RcblxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblxuICAgIHZhciB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICBpZiAod2ViZ2xUZXh0dXJlcykge1xuICAgICAgdmFyIHdlYmdsVGV4dHVyZSA9IHdlYmdsVGV4dHVyZXNbdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleV07XG4gICAgICB3ZWJnbFRleHR1cmUudXNlZFRpbWVzLS07IC8vIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0IGlzIG5vdCB1c2VkIGFueW1vcmUsIHJlbW92ZSBpdFxuXG4gICAgICBpZiAod2ViZ2xUZXh0dXJlLnVzZWRUaW1lcyA9PT0gMCkge1xuICAgICAgICBkZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgfSAvLyByZW1vdmUgdGhlIHdlYWsgbWFwIGVudHJ5IGlmIG5vIFdlYkdMVGV4dHVyZSB1c2VzIHRoZSBzb3VyY2UgYW55bW9yZVxuXG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyh3ZWJnbFRleHR1cmVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgX3NvdXJjZXMuZGVsZXRlKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcGVydGllcy5yZW1vdmUodGV4dHVyZSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVUZXh0dXJlKHRleHR1cmUpIHtcbiAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcblxuICAgIF9nbC5kZWxldGVUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblxuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcblxuICAgIHZhciB3ZWJnbFRleHR1cmVzID0gX3NvdXJjZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICBkZWxldGUgd2ViZ2xUZXh0dXJlc1t0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5XTtcbiAgICBpbmZvLm1lbW9yeS50ZXh0dXJlcy0tO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVhbGxvY2F0ZVJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpIHtcbiAgICB2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcbiAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcblxuICAgIGlmICh0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBfZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cbiAgICAgIGluZm8ubWVtb3J5LnRleHR1cmVzLS07XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUpIHtcbiAgICAgIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQpIHtcbiAgICAgIGZvciAodmFyIF9pMTI1ID0gMDsgX2kxMjUgPCA2OyBfaTEyNSsrKSB7XG4gICAgICAgIF9nbC5kZWxldGVGcmFtZWJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcltfaTEyNV0pO1xuXG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcikgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcltfaTEyNV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfZ2wuZGVsZXRlRnJhbWVidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIpO1xuXG4gICAgICBpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIpIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIpO1xuICAgICAgaWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKSBfZ2wuZGVsZXRlRnJhbWVidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpO1xuXG4gICAgICBpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXIpIHtcbiAgICAgICAgZm9yICh2YXIgX2kxMjYgPSAwOyBfaTEyNiA8IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyLmxlbmd0aDsgX2kxMjYrKykge1xuICAgICAgICAgIGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltfaTEyNl0pIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbX2kxMjZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpIF9nbC5kZWxldGVSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIpO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cykge1xuICAgICAgZm9yICh2YXIgX2kxMjcgPSAwLCBpbCA9IHRleHR1cmUubGVuZ3RoOyBfaTEyNyA8IGlsOyBfaTEyNysrKSB7XG4gICAgICAgIHZhciBhdHRhY2htZW50UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmVbX2kxMjddKTtcblxuICAgICAgICBpZiAoYXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpIHtcbiAgICAgICAgICBfZ2wuZGVsZXRlVGV4dHVyZShhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cbiAgICAgICAgICBpbmZvLm1lbW9yeS50ZXh0dXJlcy0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcGVydGllcy5yZW1vdmUodGV4dHVyZVtfaTEyN10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BlcnRpZXMucmVtb3ZlKHRleHR1cmUpO1xuICAgIHByb3BlcnRpZXMucmVtb3ZlKHJlbmRlclRhcmdldCk7XG4gIH0gLy9cblxuXG4gIHZhciB0ZXh0dXJlVW5pdHMgPSAwO1xuXG4gIGZ1bmN0aW9uIHJlc2V0VGV4dHVyZVVuaXRzKCkge1xuICAgIHRleHR1cmVVbml0cyA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvY2F0ZVRleHR1cmVVbml0KCkge1xuICAgIHZhciB0ZXh0dXJlVW5pdCA9IHRleHR1cmVVbml0cztcblxuICAgIGlmICh0ZXh0dXJlVW5pdCA+PSBtYXhUZXh0dXJlcykge1xuICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFRleHR1cmVzOiBUcnlpbmcgdG8gdXNlICcgKyB0ZXh0dXJlVW5pdCArICcgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICcgKyBtYXhUZXh0dXJlcyk7XG4gICAgfVxuXG4gICAgdGV4dHVyZVVuaXRzICs9IDE7XG4gICAgcmV0dXJuIHRleHR1cmVVbml0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGV4dHVyZUNhY2hlS2V5KHRleHR1cmUpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBhcnJheS5wdXNoKHRleHR1cmUud3JhcFMpO1xuICAgIGFycmF5LnB1c2godGV4dHVyZS53cmFwVCk7XG4gICAgYXJyYXkucHVzaCh0ZXh0dXJlLm1hZ0ZpbHRlcik7XG4gICAgYXJyYXkucHVzaCh0ZXh0dXJlLm1pbkZpbHRlcik7XG4gICAgYXJyYXkucHVzaCh0ZXh0dXJlLmFuaXNvdHJvcHkpO1xuICAgIGFycmF5LnB1c2godGV4dHVyZS5pbnRlcm5hbEZvcm1hdCk7XG4gICAgYXJyYXkucHVzaCh0ZXh0dXJlLmZvcm1hdCk7XG4gICAgYXJyYXkucHVzaCh0ZXh0dXJlLnR5cGUpO1xuICAgIGFycmF5LnB1c2godGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMpO1xuICAgIGFycmF5LnB1c2godGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcbiAgICBhcnJheS5wdXNoKHRleHR1cmUuZmxpcFkpO1xuICAgIGFycmF5LnB1c2godGV4dHVyZS51bnBhY2tBbGlnbm1lbnQpO1xuICAgIGFycmF5LnB1c2godGV4dHVyZS5lbmNvZGluZyk7XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oKTtcbiAgfSAvL1xuXG5cbiAgZnVuY3Rpb24gc2V0VGV4dHVyZTJEKHRleHR1cmUsIHNsb3QpIHtcbiAgICB2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKTtcbiAgICBpZiAodGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSkgdXBkYXRlVmlkZW9UZXh0dXJlKHRleHR1cmUpO1xuXG4gICAgaWYgKHRleHR1cmUuaXNSZW5kZXJUYXJnZXRUZXh0dXJlID09PSBmYWxzZSAmJiB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuXG4gICAgICBpZiAoaW1hZ2UgPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBubyBpbWFnZSBkYXRhIGZvdW5kLicpO1xuICAgICAgfSBlbHNlIGlmIChpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGxvYWRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoMzM5ODQgKyBzbG90KTtcbiAgICBzdGF0ZS5iaW5kVGV4dHVyZSgzNTUzLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUZXh0dXJlMkRBcnJheSh0ZXh0dXJlLCBzbG90KSB7XG4gICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSk7XG5cbiAgICBpZiAodGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbikge1xuICAgICAgdXBsb2FkVGV4dHVyZSh0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUuYWN0aXZlVGV4dHVyZSgzMzk4NCArIHNsb3QpO1xuICAgIHN0YXRlLmJpbmRUZXh0dXJlKDM1ODY2LCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUZXh0dXJlM0QodGV4dHVyZSwgc2xvdCkge1xuICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXG4gICAgaWYgKHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24pIHtcbiAgICAgIHVwbG9hZFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRlLmFjdGl2ZVRleHR1cmUoMzM5ODQgKyBzbG90KTtcbiAgICBzdGF0ZS5iaW5kVGV4dHVyZSgzMjg3OSwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUodGV4dHVyZSwgc2xvdCkge1xuICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuXG4gICAgaWYgKHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24pIHtcbiAgICAgIHVwbG9hZEN1YmVUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKDMzOTg0ICsgc2xvdCk7XG4gICAgc3RhdGUuYmluZFRleHR1cmUoMzQwNjcsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcbiAgfVxuXG4gIHZhciB3cmFwcGluZ1RvR0wgPSAoX3dyYXBwaW5nVG9HTCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX3dyYXBwaW5nVG9HTCwgUmVwZWF0V3JhcHBpbmcsIDEwNDk3KSwgX2RlZmluZVByb3BlcnR5KF93cmFwcGluZ1RvR0wsIENsYW1wVG9FZGdlV3JhcHBpbmcsIDMzMDcxKSwgX2RlZmluZVByb3BlcnR5KF93cmFwcGluZ1RvR0wsIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsIDMzNjQ4KSwgX3dyYXBwaW5nVG9HTCk7XG4gIHZhciBmaWx0ZXJUb0dMID0gKF9maWx0ZXJUb0dMID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfZmlsdGVyVG9HTCwgTmVhcmVzdEZpbHRlciwgOTcyOCksIF9kZWZpbmVQcm9wZXJ0eShfZmlsdGVyVG9HTCwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIDk5ODQpLCBfZGVmaW5lUHJvcGVydHkoX2ZpbHRlclRvR0wsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIDk5ODYpLCBfZGVmaW5lUHJvcGVydHkoX2ZpbHRlclRvR0wsIExpbmVhckZpbHRlciwgOTcyOSksIF9kZWZpbmVQcm9wZXJ0eShfZmlsdGVyVG9HTCwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgOTk4NSksIF9kZWZpbmVQcm9wZXJ0eShfZmlsdGVyVG9HTCwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCA5OTg3KSwgX2ZpbHRlclRvR0wpO1xuXG4gIGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpIHtcbiAgICBpZiAoc3VwcG9ydHNNaXBzKSB7XG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgMTAyNDIsIHdyYXBwaW5nVG9HTFt0ZXh0dXJlLndyYXBTXSk7XG5cbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCAxMDI0Mywgd3JhcHBpbmdUb0dMW3RleHR1cmUud3JhcFRdKTtcblxuICAgICAgaWYgKHRleHR1cmVUeXBlID09PSAzMjg3OSB8fCB0ZXh0dXJlVHlwZSA9PT0gMzU4NjYpIHtcbiAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIDMyODgyLCB3cmFwcGluZ1RvR0xbdGV4dHVyZS53cmFwUl0pO1xuICAgICAgfVxuXG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgMTAyNDAsIGZpbHRlclRvR0xbdGV4dHVyZS5tYWdGaWx0ZXJdKTtcblxuICAgICAgX2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIDEwMjQxLCBmaWx0ZXJUb0dMW3RleHR1cmUubWluRmlsdGVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCAxMDI0MiwgMzMwNzEpO1xuXG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgMTAyNDMsIDMzMDcxKTtcblxuICAgICAgaWYgKHRleHR1cmVUeXBlID09PSAzMjg3OSB8fCB0ZXh0dXJlVHlwZSA9PT0gMzU4NjYpIHtcbiAgICAgICAgX2dsLnRleFBhcmFtZXRlcmkodGV4dHVyZVR5cGUsIDMyODgyLCAzMzA3MSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0dXJlLndyYXBTICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicpO1xuICAgICAgfVxuXG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlVHlwZSwgMTAyNDAsIGZpbHRlckZhbGxiYWNrKHRleHR1cmUubWFnRmlsdGVyKSk7XG5cbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmVUeXBlLCAxMDI0MSwgZmlsdGVyRmFsbGJhY2sodGV4dHVyZS5taW5GaWx0ZXIpKTtcblxuICAgICAgaWYgKHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbnMuaGFzKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKTtcbiAgICAgIGlmICh0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmhhcygnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykgPT09IGZhbHNlKSByZXR1cm47IC8vIHZlcmlmeSBleHRlbnNpb24gZm9yIFdlYkdMIDEgYW5kIFdlYkdMIDJcblxuICAgICAgaWYgKGlzV2ViR0wyID09PSBmYWxzZSAmJiB0ZXh0dXJlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5oYXMoJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJykgPT09IGZhbHNlKSByZXR1cm47IC8vIHZlcmlmeSBleHRlbnNpb24gZm9yIFdlYkdMIDEgb25seVxuXG4gICAgICBpZiAodGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX2N1cnJlbnRBbmlzb3Ryb3B5KSB7XG4gICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJmKHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKHRleHR1cmUuYW5pc290cm9weSwgY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKSkpO1xuXG4gICAgICAgIHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpLl9fY3VycmVudEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUpIHtcbiAgICB2YXIgZm9yY2VVcGxvYWQgPSBmYWxzZTtcblxuICAgIGlmICh0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9IHRydWU7XG4gICAgICB0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlKTtcbiAgICB9IC8vIGNyZWF0ZSBTb3VyY2UgPC0+IFdlYkdMVGV4dHVyZXMgbWFwcGluZyBpZiBuZWNlc3NhcnlcblxuXG4gICAgdmFyIHNvdXJjZSA9IHRleHR1cmUuc291cmNlO1xuXG4gICAgdmFyIHdlYmdsVGV4dHVyZXMgPSBfc291cmNlcy5nZXQoc291cmNlKTtcblxuICAgIGlmICh3ZWJnbFRleHR1cmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHdlYmdsVGV4dHVyZXMgPSB7fTtcblxuICAgICAgX3NvdXJjZXMuc2V0KHNvdXJjZSwgd2ViZ2xUZXh0dXJlcyk7XG4gICAgfSAvLyBjaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgV2ViR0xUZXh0dXJlIG9iamVjdCBmb3IgdGhlIGdpdmVuIHRleHR1cmUgcGFyYW1ldGVyc1xuXG5cbiAgICB2YXIgdGV4dHVyZUNhY2hlS2V5ID0gZ2V0VGV4dHVyZUNhY2hlS2V5KHRleHR1cmUpO1xuXG4gICAgaWYgKHRleHR1cmVDYWNoZUtleSAhPT0gdGV4dHVyZVByb3BlcnRpZXMuX19jYWNoZUtleSkge1xuICAgICAgLy8gaWYgbm90LCBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgV2ViR0xUZXh0dXJlXG4gICAgICBpZiAod2ViZ2xUZXh0dXJlc1t0ZXh0dXJlQ2FjaGVLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgICAgICB3ZWJnbFRleHR1cmVzW3RleHR1cmVDYWNoZUtleV0gPSB7XG4gICAgICAgICAgdGV4dHVyZTogX2dsLmNyZWF0ZVRleHR1cmUoKSxcbiAgICAgICAgICB1c2VkVGltZXM6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaW5mby5tZW1vcnkudGV4dHVyZXMrKzsgLy8gd2hlbiBhIG5ldyBpbnN0YW5jZSBvZiBXZWJHTFRleHR1cmUgd2FzIGNyZWF0ZWQsIGEgdGV4dHVyZSB1cGxvYWQgaXMgcmVxdWlyZWRcbiAgICAgICAgLy8gZXZlbiBpZiB0aGUgaW1hZ2UgY29udGVudHMgYXJlIGlkZW50aWNhbFxuXG4gICAgICAgIGZvcmNlVXBsb2FkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgd2ViZ2xUZXh0dXJlc1t0ZXh0dXJlQ2FjaGVLZXldLnVzZWRUaW1lcysrOyAvLyBldmVyeSB0aW1lIHRoZSB0ZXh0dXJlIGNhY2hlIGtleSBjaGFuZ2VzLCBpdCdzIG5lY2Vzc2FyeSB0byBjaGVjayBpZiBhbiBpbnN0YW5jZSBvZlxuICAgICAgLy8gV2ViR0xUZXh0dXJlIGNhbiBiZSBkZWxldGVkIGluIG9yZGVyIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsuXG5cbiAgICAgIHZhciB3ZWJnbFRleHR1cmUgPSB3ZWJnbFRleHR1cmVzW3RleHR1cmVQcm9wZXJ0aWVzLl9fY2FjaGVLZXldO1xuXG4gICAgICBpZiAod2ViZ2xUZXh0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2ViZ2xUZXh0dXJlc1t0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5XS51c2VkVGltZXMtLTtcblxuICAgICAgICBpZiAod2ViZ2xUZXh0dXJlLnVzZWRUaW1lcyA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc3RvcmUgcmVmZXJlbmNlcyB0byBjYWNoZSBrZXkgYW5kIFdlYkdMVGV4dHVyZSBvYmplY3RcblxuXG4gICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX2NhY2hlS2V5ID0gdGV4dHVyZUNhY2hlS2V5O1xuICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSB3ZWJnbFRleHR1cmVzW3RleHR1cmVDYWNoZUtleV0udGV4dHVyZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9yY2VVcGxvYWQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGxvYWRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KSB7XG4gICAgdmFyIHRleHR1cmVUeXBlID0gMzU1MztcbiAgICBpZiAodGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUpIHRleHR1cmVUeXBlID0gMzU4NjY7XG4gICAgaWYgKHRleHR1cmUuaXNEYXRhM0RUZXh0dXJlKSB0ZXh0dXJlVHlwZSA9IDMyODc5O1xuICAgIHZhciBmb3JjZVVwbG9hZCA9IGluaXRUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlKTtcbiAgICB2YXIgc291cmNlID0gdGV4dHVyZS5zb3VyY2U7XG4gICAgc3RhdGUuYWN0aXZlVGV4dHVyZSgzMzk4NCArIHNsb3QpO1xuICAgIHN0YXRlLmJpbmRUZXh0dXJlKHRleHR1cmVUeXBlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG5cbiAgICBpZiAoc291cmNlLnZlcnNpb24gIT09IHNvdXJjZS5fX2N1cnJlbnRWZXJzaW9uIHx8IGZvcmNlVXBsb2FkID09PSB0cnVlKSB7XG4gICAgICBfZ2wucGl4ZWxTdG9yZWkoMzc0NDAsIHRleHR1cmUuZmxpcFkpO1xuXG4gICAgICBfZ2wucGl4ZWxTdG9yZWkoMzc0NDEsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG5cbiAgICAgIF9nbC5waXhlbFN0b3JlaSgzMzE3LCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCk7XG5cbiAgICAgIF9nbC5waXhlbFN0b3JlaSgzNzQ0MywgMCk7XG5cbiAgICAgIHZhciBuZWVkc1Bvd2VyT2ZUd28gPSB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKHRleHR1cmUpICYmIGlzUG93ZXJPZlR3byQxKHRleHR1cmUuaW1hZ2UpID09PSBmYWxzZTtcbiAgICAgIHZhciBpbWFnZSA9IHJlc2l6ZUltYWdlKHRleHR1cmUuaW1hZ2UsIG5lZWRzUG93ZXJPZlR3bywgZmFsc2UsIG1heFRleHR1cmVTaXplKTtcbiAgICAgIGltYWdlID0gdmVyaWZ5Q29sb3JTcGFjZSh0ZXh0dXJlLCBpbWFnZSk7XG4gICAgICB2YXIgc3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvJDEoaW1hZ2UpIHx8IGlzV2ViR0wyLFxuICAgICAgICAgIGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS5lbmNvZGluZyk7XG4gICAgICB2YXIgZ2xUeXBlID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLnR5cGUpLFxuICAgICAgICAgIGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCh0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmVuY29kaW5nLCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlKTtcbiAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpO1xuICAgICAgdmFyIG1pcG1hcDtcbiAgICAgIHZhciBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xuICAgICAgdmFyIHVzZVRleFN0b3JhZ2UgPSBpc1dlYkdMMiAmJiB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlICE9PSB0cnVlO1xuICAgICAgdmFyIGFsbG9jYXRlTWVtb3J5ID0gc291cmNlLl9fY3VycmVudFZlcnNpb24gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVVwbG9hZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBsZXZlbHMgPSBnZXRNaXBMZXZlbHModGV4dHVyZSwgaW1hZ2UsIHN1cHBvcnRzTWlwcyk7XG5cbiAgICAgIGlmICh0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSB7XG4gICAgICAgIC8vIHBvcHVsYXRlIGRlcHRoIHRleHR1cmUgd2l0aCBkdW1teSBkYXRhXG4gICAgICAgIGdsSW50ZXJuYWxGb3JtYXQgPSA2NDAyO1xuXG4gICAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICAgIGlmICh0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSkge1xuICAgICAgICAgICAgZ2xJbnRlcm5hbEZvcm1hdCA9IDM2MDEyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dHVyZS50eXBlID09PSBVbnNpZ25lZEludFR5cGUpIHtcbiAgICAgICAgICAgIGdsSW50ZXJuYWxGb3JtYXQgPSAzMzE5MDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRleHR1cmUudHlwZSA9PT0gVW5zaWduZWRJbnQyNDhUeXBlKSB7XG4gICAgICAgICAgICBnbEludGVybmFsRm9ybWF0ID0gMzUwNTY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsSW50ZXJuYWxGb3JtYXQgPSAzMzE4OTsgLy8gV2ViR0wyIHJlcXVpcmVzIHNpemVkIGludGVybmFsZm9ybWF0IGZvciBnbFRleEltYWdlMkRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdXZWJHTFJlbmRlcmVyOiBGbG9hdGluZyBwb2ludCBkZXB0aCB0ZXh0dXJlIHJlcXVpcmVzIFdlYkdMMi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gdmFsaWRhdGlvbiBjaGVja3MgZm9yIFdlYkdMIDFcblxuXG4gICAgICAgIGlmICh0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgJiYgZ2xJbnRlcm5hbEZvcm1hdCA9PT0gNjQwMikge1xuICAgICAgICAgIC8vIFRoZSBlcnJvciBJTlZBTElEX09QRVJBVElPTiBpcyBnZW5lcmF0ZWQgYnkgdGV4SW1hZ2UyRCBpZiBmb3JtYXQgYW5kIGludGVybmFsZm9ybWF0IGFyZVxuICAgICAgICAgIC8vIERFUFRIX0NPTVBPTkVOVCBhbmQgdHlwZSBpcyBub3QgVU5TSUdORURfU0hPUlQgb3IgVU5TSUdORURfSU5UXG4gICAgICAgICAgLy8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXG4gICAgICAgICAgaWYgKHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRTaG9ydFR5cGUgJiYgdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZEludFR5cGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkU2hvcnRUeXBlIG9yIFVuc2lnbmVkSW50VHlwZSBmb3IgRGVwdGhGb3JtYXQgRGVwdGhUZXh0dXJlLicpO1xuICAgICAgICAgICAgdGV4dHVyZS50eXBlID0gVW5zaWduZWRJbnRUeXBlO1xuICAgICAgICAgICAgZ2xUeXBlID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICYmIGdsSW50ZXJuYWxGb3JtYXQgPT09IDY0MDIpIHtcbiAgICAgICAgICAvLyBEZXB0aCBzdGVuY2lsIHRleHR1cmVzIG5lZWQgdGhlIERFUFRIX1NURU5DSUwgaW50ZXJuYWwgZm9ybWF0XG4gICAgICAgICAgLy8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXG4gICAgICAgICAgZ2xJbnRlcm5hbEZvcm1hdCA9IDM0MDQxOyAvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcbiAgICAgICAgICAvLyBERVBUSF9TVEVOQ0lMIGFuZCB0eXBlIGlzIG5vdCBVTlNJR05FRF9JTlRfMjRfOF9XRUJHTC5cbiAgICAgICAgICAvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcblxuICAgICAgICAgIGlmICh0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkSW50MjQ4VHlwZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVc2UgVW5zaWduZWRJbnQyNDhUeXBlIGZvciBEZXB0aFN0ZW5jaWxGb3JtYXQgRGVwdGhUZXh0dXJlLicpO1xuICAgICAgICAgICAgdGV4dHVyZS50eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xuICAgICAgICAgICAgZ2xUeXBlID0gdXRpbHMuY29udmVydCh0ZXh0dXJlLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvL1xuXG5cbiAgICAgICAgaWYgKGFsbG9jYXRlTWVtb3J5KSB7XG4gICAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHN0YXRlLnRleFN0b3JhZ2UyRCgzNTUzLCAxLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCgzNTUzLCAwLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGV4dHVyZS5pc0RhdGFUZXh0dXJlKSB7XG4gICAgICAgIC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuICAgICAgICAvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcbiAgICAgICAgaWYgKG1pcG1hcHMubGVuZ3RoID4gMCAmJiBzdXBwb3J0c01pcHMpIHtcbiAgICAgICAgICBpZiAodXNlVGV4U3RvcmFnZSAmJiBhbGxvY2F0ZU1lbW9yeSkge1xuICAgICAgICAgICAgc3RhdGUudGV4U3RvcmFnZTJEKDM1NTMsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwc1swXS53aWR0aCwgbWlwbWFwc1swXS5oZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9pMTI4ID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgX2kxMjggPCBpbDsgX2kxMjgrKykge1xuICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1tfaTEyOF07XG5cbiAgICAgICAgICAgIGlmICh1c2VUZXhTdG9yYWdlKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRleFN1YkltYWdlMkQoMzU1MywgX2kxMjgsIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCgzNTUzLCBfaTEyOCwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodXNlVGV4U3RvcmFnZSkge1xuICAgICAgICAgICAgaWYgKGFsbG9jYXRlTWVtb3J5KSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRleFN0b3JhZ2UyRCgzNTUzLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS50ZXhTdWJJbWFnZTJEKDM1NTMsIDAsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKDM1NTMsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUpIHtcbiAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkpIHtcbiAgICAgICAgICBzdGF0ZS50ZXhTdG9yYWdlMkQoMzU1MywgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXBzWzBdLndpZHRoLCBtaXBtYXBzWzBdLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTEyOSA9IDAsIF9pbDkgPSBtaXBtYXBzLmxlbmd0aDsgX2kxMjkgPCBfaWw5OyBfaTEyOSsrKSB7XG4gICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1tfaTEyOV07XG5cbiAgICAgICAgICBpZiAodGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChnbEZvcm1hdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodXNlVGV4U3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKDM1NTMsIF9pMTI5LCAwLCAwLCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIGdsRm9ybWF0LCBtaXBtYXAuZGF0YSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoMzU1MywgX2kxMjksIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgc3RhdGUudGV4U3ViSW1hZ2UyRCgzNTUzLCBfaTEyOSwgMCwgMCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKDM1NTMsIF9pMTI5LCBnbEludGVybmFsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUpIHtcbiAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UpIHtcbiAgICAgICAgICBpZiAoYWxsb2NhdGVNZW1vcnkpIHtcbiAgICAgICAgICAgIHN0YXRlLnRleFN0b3JhZ2UzRCgzNTg2NiwgbGV2ZWxzLCBnbEludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdGUudGV4U3ViSW1hZ2UzRCgzNTg2NiwgMCwgMCwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRleEltYWdlM0QoMzU4NjYsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZXh0dXJlLmlzRGF0YTNEVGV4dHVyZSkge1xuICAgICAgICBpZiAodXNlVGV4U3RvcmFnZSkge1xuICAgICAgICAgIGlmIChhbGxvY2F0ZU1lbW9yeSkge1xuICAgICAgICAgICAgc3RhdGUudGV4U3RvcmFnZTNEKDMyODc5LCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIGltYWdlLmRlcHRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGF0ZS50ZXhTdWJJbWFnZTNEKDMyODc5LCAwLCAwLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCBpbWFnZS5kZXB0aCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUudGV4SW1hZ2UzRCgzMjg3OSwgMCwgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2UuZGVwdGgsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRleHR1cmUuaXNGcmFtZWJ1ZmZlclRleHR1cmUpIHtcbiAgICAgICAgaWYgKGFsbG9jYXRlTWVtb3J5KSB7XG4gICAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHN0YXRlLnRleFN0b3JhZ2UyRCgzNTUzLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTMwID0gMDsgX2kxMzAgPCBsZXZlbHM7IF9pMTMwKyspIHtcbiAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCgzNTUzLCBfaTEzMCwgZ2xJbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCk7XG4gICAgICAgICAgICAgIHdpZHRoID4+PSAxO1xuICAgICAgICAgICAgICBoZWlnaHQgPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuICAgICAgICAvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcbiAgICAgICAgLy8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG4gICAgICAgIGlmIChtaXBtYXBzLmxlbmd0aCA+IDAgJiYgc3VwcG9ydHNNaXBzKSB7XG4gICAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkpIHtcbiAgICAgICAgICAgIHN0YXRlLnRleFN0b3JhZ2UyRCgzNTUzLCBsZXZlbHMsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcHNbMF0ud2lkdGgsIG1pcG1hcHNbMF0uaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTEzMSA9IDAsIF9pbDEwID0gbWlwbWFwcy5sZW5ndGg7IF9pMTMxIDwgX2lsMTA7IF9pMTMxKyspIHtcbiAgICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbX2kxMzFdO1xuXG4gICAgICAgICAgICBpZiAodXNlVGV4U3RvcmFnZSkge1xuICAgICAgICAgICAgICBzdGF0ZS50ZXhTdWJJbWFnZTJEKDM1NTMsIF9pMTMxLCAwLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCgzNTUzLCBfaTEzMSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1c2VUZXhTdG9yYWdlKSB7XG4gICAgICAgICAgICBpZiAoYWxsb2NhdGVNZW1vcnkpIHtcbiAgICAgICAgICAgICAgc3RhdGUudGV4U3RvcmFnZTJEKDM1NTMsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLnRleFN1YkltYWdlMkQoMzU1MywgMCwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKDM1NTMsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpKSB7XG4gICAgICAgIGdlbmVyYXRlTWlwbWFwKHRleHR1cmVUeXBlKTtcbiAgICAgIH1cblxuICAgICAgc291cmNlLl9fY3VycmVudFZlcnNpb24gPSBzb3VyY2UudmVyc2lvbjtcbiAgICAgIGlmICh0ZXh0dXJlLm9uVXBkYXRlKSB0ZXh0dXJlLm9uVXBkYXRlKHRleHR1cmUpO1xuICAgIH1cblxuICAgIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwbG9hZEN1YmVUZXh0dXJlKHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90KSB7XG4gICAgaWYgKHRleHR1cmUuaW1hZ2UubGVuZ3RoICE9PSA2KSByZXR1cm47XG4gICAgdmFyIGZvcmNlVXBsb2FkID0gaW5pdFRleHR1cmUodGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUpO1xuICAgIHZhciBzb3VyY2UgPSB0ZXh0dXJlLnNvdXJjZTtcbiAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKDMzOTg0ICsgc2xvdCk7XG4gICAgc3RhdGUuYmluZFRleHR1cmUoMzQwNjcsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlKTtcblxuICAgIGlmIChzb3VyY2UudmVyc2lvbiAhPT0gc291cmNlLl9fY3VycmVudFZlcnNpb24gfHwgZm9yY2VVcGxvYWQgPT09IHRydWUpIHtcbiAgICAgIF9nbC5waXhlbFN0b3JlaSgzNzQ0MCwgdGV4dHVyZS5mbGlwWSk7XG5cbiAgICAgIF9nbC5waXhlbFN0b3JlaSgzNzQ0MSwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcblxuICAgICAgX2dsLnBpeGVsU3RvcmVpKDMzMTcsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50KTtcblxuICAgICAgX2dsLnBpeGVsU3RvcmVpKDM3NDQzLCAwKTtcblxuICAgICAgdmFyIGlzQ29tcHJlc3NlZCA9IHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSB8fCB0ZXh0dXJlLmltYWdlWzBdLmlzQ29tcHJlc3NlZFRleHR1cmU7XG4gICAgICB2YXIgaXNEYXRhVGV4dHVyZSA9IHRleHR1cmUuaW1hZ2VbMF0gJiYgdGV4dHVyZS5pbWFnZVswXS5pc0RhdGFUZXh0dXJlO1xuICAgICAgdmFyIGN1YmVJbWFnZSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTEzMiA9IDA7IF9pMTMyIDwgNjsgX2kxMzIrKykge1xuICAgICAgICBpZiAoIWlzQ29tcHJlc3NlZCAmJiAhaXNEYXRhVGV4dHVyZSkge1xuICAgICAgICAgIGN1YmVJbWFnZVtfaTEzMl0gPSByZXNpemVJbWFnZSh0ZXh0dXJlLmltYWdlW19pMTMyXSwgZmFsc2UsIHRydWUsIG1heEN1YmVtYXBTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdWJlSW1hZ2VbX2kxMzJdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbX2kxMzJdLmltYWdlIDogdGV4dHVyZS5pbWFnZVtfaTEzMl07XG4gICAgICAgIH1cblxuICAgICAgICBjdWJlSW1hZ2VbX2kxMzJdID0gdmVyaWZ5Q29sb3JTcGFjZSh0ZXh0dXJlLCBjdWJlSW1hZ2VbX2kxMzJdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGltYWdlID0gY3ViZUltYWdlWzBdLFxuICAgICAgICAgIHN1cHBvcnRzTWlwcyA9IGlzUG93ZXJPZlR3byQxKGltYWdlKSB8fCBpc1dlYkdMMixcbiAgICAgICAgICBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuZW5jb2RpbmcpLFxuICAgICAgICAgIGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKSxcbiAgICAgICAgICBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQodGV4dHVyZS5pbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5lbmNvZGluZyk7XG4gICAgICB2YXIgdXNlVGV4U3RvcmFnZSA9IGlzV2ViR0wyICYmIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgIT09IHRydWU7XG4gICAgICB2YXIgYWxsb2NhdGVNZW1vcnkgPSBzb3VyY2UuX19jdXJyZW50VmVyc2lvbiA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlVXBsb2FkID09PSB0cnVlO1xuICAgICAgdmFyIGxldmVscyA9IGdldE1pcExldmVscyh0ZXh0dXJlLCBpbWFnZSwgc3VwcG9ydHNNaXBzKTtcbiAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKDM0MDY3LCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpO1xuICAgICAgdmFyIG1pcG1hcHM7XG5cbiAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkpIHtcbiAgICAgICAgICBzdGF0ZS50ZXhTdG9yYWdlMkQoMzQwNjcsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTEzMyA9IDA7IF9pMTMzIDwgNjsgX2kxMzMrKykge1xuICAgICAgICAgIG1pcG1hcHMgPSBjdWJlSW1hZ2VbX2kxMzNdLm1pcG1hcHM7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1pcG1hcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBtaXBtYXAgPSBtaXBtYXBzW2pdO1xuXG4gICAgICAgICAgICBpZiAodGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQpIHtcbiAgICAgICAgICAgICAgaWYgKGdsRm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKDM0MDY5ICsgX2kxMzMsIGosIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIG1pcG1hcC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcHJlc3NlZFRleEltYWdlMkQoMzQwNjkgKyBfaTEzMywgaiwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldFRleHR1cmVDdWJlKCknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS50ZXhTdWJJbWFnZTJEKDM0MDY5ICsgX2kxMzMsIGosIDAsIDAsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoMzQwNjkgKyBfaTEzMywgaiwgZ2xJbnRlcm5hbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XG5cbiAgICAgICAgaWYgKHVzZVRleFN0b3JhZ2UgJiYgYWxsb2NhdGVNZW1vcnkpIHtcbiAgICAgICAgICAvLyBUT0RPOiBVbmlmb3JtbHkgaGFuZGxlIG1pcG1hcCBkZWZpbml0aW9uc1xuICAgICAgICAgIC8vIE5vcm1hbCB0ZXh0dXJlcyBhbmQgY29tcHJlc3NlZCBjdWJlIHRleHR1cmVzIGRlZmluZSBiYXNlIGxldmVsICsgbWlwcyB3aXRoIHRoZWlyIG1pcG1hcCBhcnJheVxuICAgICAgICAgIC8vIFVuY29tcHJlc3NlZCBjdWJlIHRleHR1cmVzIHVzZSB0aGVpciBtaXBtYXAgYXJyYXkgb25seSBmb3IgbWlwcyAobm8gYmFzZSBsZXZlbClcbiAgICAgICAgICBpZiAobWlwbWFwcy5sZW5ndGggPiAwKSBsZXZlbHMrKztcbiAgICAgICAgICBzdGF0ZS50ZXhTdG9yYWdlMkQoMzQwNjcsIGxldmVscywgZ2xJbnRlcm5hbEZvcm1hdCwgY3ViZUltYWdlWzBdLndpZHRoLCBjdWJlSW1hZ2VbMF0uaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pMTM0ID0gMDsgX2kxMzQgPCA2OyBfaTEzNCsrKSB7XG4gICAgICAgICAgaWYgKGlzRGF0YVRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmICh1c2VUZXhTdG9yYWdlKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRleFN1YkltYWdlMkQoMzQwNjkgKyBfaTEzNCwgMCwgMCwgMCwgY3ViZUltYWdlW19pMTM0XS53aWR0aCwgY3ViZUltYWdlW19pMTM0XS5oZWlnaHQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVtfaTEzNF0uZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKDM0MDY5ICsgX2kxMzQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGN1YmVJbWFnZVtfaTEzNF0ud2lkdGgsIGN1YmVJbWFnZVtfaTEzNF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbX2kxMzRdLmRhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBtaXBtYXBzLmxlbmd0aDsgX2ozKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9taXBtYXAgPSBtaXBtYXBzW19qM107XG4gICAgICAgICAgICAgIHZhciBtaXBtYXBJbWFnZSA9IF9taXBtYXAuaW1hZ2VbX2kxMzRdLmltYWdlO1xuXG4gICAgICAgICAgICAgIGlmICh1c2VUZXhTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudGV4U3ViSW1hZ2UyRCgzNDA2OSArIF9pMTM0LCBfajMgKyAxLCAwLCAwLCBtaXBtYXBJbWFnZS53aWR0aCwgbWlwbWFwSW1hZ2UuaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXBJbWFnZS5kYXRhKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKDM0MDY5ICsgX2kxMzQsIF9qMyArIDEsIGdsSW50ZXJuYWxGb3JtYXQsIG1pcG1hcEltYWdlLndpZHRoLCBtaXBtYXBJbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcEltYWdlLmRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1c2VUZXhTdG9yYWdlKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnRleFN1YkltYWdlMkQoMzQwNjkgKyBfaTEzNCwgMCwgMCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlW19pMTM0XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKDM0MDY5ICsgX2kxMzQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVtfaTEzNF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfajQgPSAwOyBfajQgPCBtaXBtYXBzLmxlbmd0aDsgX2o0KyspIHtcbiAgICAgICAgICAgICAgdmFyIF9taXBtYXAyID0gbWlwbWFwc1tfajRdO1xuXG4gICAgICAgICAgICAgIGlmICh1c2VUZXhTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudGV4U3ViSW1hZ2UyRCgzNDA2OSArIF9pMTM0LCBfajQgKyAxLCAwLCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBfbWlwbWFwMi5pbWFnZVtfaTEzNF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoMzQwNjkgKyBfaTEzNCwgX2o0ICsgMSwgZ2xJbnRlcm5hbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgX21pcG1hcDIuaW1hZ2VbX2kxMzRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIGltYWdlcyBmb3IgY3ViZSBtYXAgaGF2ZSB0aGUgc2FtZSBzaXplLlxuICAgICAgICBnZW5lcmF0ZU1pcG1hcCgzNDA2Nyk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5fX2N1cnJlbnRWZXJzaW9uID0gc291cmNlLnZlcnNpb247XG4gICAgICBpZiAodGV4dHVyZS5vblVwZGF0ZSkgdGV4dHVyZS5vblVwZGF0ZSh0ZXh0dXJlKTtcbiAgICB9XG5cbiAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG4gIH0gLy8gUmVuZGVyIHRhcmdldHNcbiAgLy8gU2V0dXAgc3RvcmFnZSBmb3IgdGFyZ2V0IHRleHR1cmUgYW5kIGJpbmQgaXQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuXG5cbiAgZnVuY3Rpb24gc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCkge1xuICAgIHZhciBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS5mb3JtYXQsIHRleHR1cmUuZW5jb2RpbmcpO1xuICAgIHZhciBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUudHlwZSk7XG4gICAgdmFyIGdsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCh0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmVuY29kaW5nKTtcbiAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG5cbiAgICBpZiAoIXJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzKSB7XG4gICAgICBpZiAodGV4dHVyZVRhcmdldCA9PT0gMzI4NzkgfHwgdGV4dHVyZVRhcmdldCA9PT0gMzU4NjYpIHtcbiAgICAgICAgc3RhdGUudGV4SW1hZ2UzRCh0ZXh0dXJlVGFyZ2V0LCAwLCBnbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIHJlbmRlclRhcmdldC5kZXB0aCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKHRleHR1cmVUYXJnZXQsIDAsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBmcmFtZWJ1ZmZlcik7XG5cbiAgICBpZiAodXNlTXVsdGlzYW1wbGVkUlRUKHJlbmRlclRhcmdldCkpIHtcbiAgICAgIG11bHRpc2FtcGxlZFJUVEV4dC5mcmFtZWJ1ZmZlclRleHR1cmUyRE11bHRpc2FtcGxlRVhUKDM2MTYwLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSwgMCwgZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKDM2MTYwLCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0LCBwcm9wZXJ0aWVzLmdldCh0ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSwgMCk7XG4gICAgfVxuXG4gICAgc3RhdGUuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBudWxsKTtcbiAgfSAvLyBTZXR1cCBzdG9yYWdlIGZvciBpbnRlcm5hbCBkZXB0aC9zdGVuY2lsIGJ1ZmZlcnMgYW5kIGJpbmQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuXG5cbiAgZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBpc011bHRpc2FtcGxlKSB7XG4gICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsIHJlbmRlcmJ1ZmZlcik7XG5cbiAgICBpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICFyZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlcikge1xuICAgICAgdmFyIGdsSW50ZXJuYWxGb3JtYXQgPSAzMzE4OTtcblxuICAgICAgaWYgKGlzTXVsdGlzYW1wbGUgfHwgdXNlTXVsdGlzYW1wbGVkUlRUKHJlbmRlclRhcmdldCkpIHtcbiAgICAgICAgdmFyIGRlcHRoVGV4dHVyZSA9IHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmU7XG5cbiAgICAgICAgaWYgKGRlcHRoVGV4dHVyZSAmJiBkZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUpIHtcbiAgICAgICAgICBpZiAoZGVwdGhUZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSkge1xuICAgICAgICAgICAgZ2xJbnRlcm5hbEZvcm1hdCA9IDM2MDEyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVwdGhUZXh0dXJlLnR5cGUgPT09IFVuc2lnbmVkSW50VHlwZSkge1xuICAgICAgICAgICAgZ2xJbnRlcm5hbEZvcm1hdCA9IDMzMTkwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzYW1wbGVzID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXG4gICAgICAgIGlmICh1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSkge1xuICAgICAgICAgIG11bHRpc2FtcGxlZFJUVEV4dC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQoMzYxNjEsIHNhbXBsZXMsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2VNdWx0aXNhbXBsZSgzNjE2MSwgc2FtcGxlcywgZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoMzYxNjEsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcigzNjE2MCwgMzYwOTYsIDM2MTYxLCByZW5kZXJidWZmZXIpO1xuICAgIH0gZWxzZSBpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyKSB7XG4gICAgICB2YXIgX3NhbXBsZXMgPSBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKHJlbmRlclRhcmdldCk7XG5cbiAgICAgIGlmIChpc011bHRpc2FtcGxlICYmIHVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpID09PSBmYWxzZSkge1xuICAgICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlKDM2MTYxLCBfc2FtcGxlcywgMzUwNTYsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKHVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpKSB7XG4gICAgICAgIG11bHRpc2FtcGxlZFJUVEV4dC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGVFWFQoMzYxNjEsIF9zYW1wbGVzLCAzNTA1NiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKDM2MTYxLCAzNDA0MSwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKDM2MTYwLCAzMzMwNiwgMzYxNjEsIHJlbmRlcmJ1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID09PSB0cnVlID8gcmVuZGVyVGFyZ2V0LnRleHR1cmUgOiBbcmVuZGVyVGFyZ2V0LnRleHR1cmVdO1xuXG4gICAgICBmb3IgKHZhciBfaTEzNSA9IDA7IF9pMTM1IDwgdGV4dHVyZXMubGVuZ3RoOyBfaTEzNSsrKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZXNbX2kxMzVdO1xuICAgICAgICB2YXIgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLmVuY29kaW5nKTtcbiAgICAgICAgdmFyIGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQodGV4dHVyZS50eXBlKTtcblxuICAgICAgICB2YXIgX2dsSW50ZXJuYWxGb3JtYXQgPSBnZXRJbnRlcm5hbEZvcm1hdCh0ZXh0dXJlLmludGVybmFsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmVuY29kaW5nKTtcblxuICAgICAgICB2YXIgX3NhbXBsZXMyID0gZ2V0UmVuZGVyVGFyZ2V0U2FtcGxlcyhyZW5kZXJUYXJnZXQpO1xuXG4gICAgICAgIGlmIChpc011bHRpc2FtcGxlICYmIHVzZU11bHRpc2FtcGxlZFJUVChyZW5kZXJUYXJnZXQpID09PSBmYWxzZSkge1xuICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoMzYxNjEsIF9zYW1wbGVzMiwgX2dsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXNlTXVsdGlzYW1wbGVkUlRUKHJlbmRlclRhcmdldCkpIHtcbiAgICAgICAgICBtdWx0aXNhbXBsZWRSVFRFeHQucmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlRVhUKDM2MTYxLCBfc2FtcGxlczIsIF9nbEludGVybmFsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKDM2MTYxLCBfZ2xJbnRlcm5hbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9nbC5iaW5kUmVuZGVyYnVmZmVyKDM2MTYxLCBudWxsKTtcbiAgfSAvLyBTZXR1cCByZXNvdXJjZXMgZm9yIGEgRGVwdGggVGV4dHVyZSBmb3IgYSBGQk8gKG5lZWRzIGFuIGV4dGVuc2lvbilcblxuXG4gIGZ1bmN0aW9uIHNldHVwRGVwdGhUZXh0dXJlKGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQpIHtcbiAgICB2YXIgaXNDdWJlID0gcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldDtcbiAgICBpZiAoaXNDdWJlKSB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIGZyYW1lYnVmZmVyKTtcblxuICAgIGlmICghKHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgJiYgcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFRIUkVFLkRlcHRoVGV4dHVyZScpO1xuICAgIH0gLy8gdXBsb2FkIGFuIGVtcHR5IGRlcHRoIHRleHR1cmUgd2l0aCBmcmFtZWJ1ZmZlciBzaXplXG5cblxuICAgIGlmICghcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmUgfHwgcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCAhPT0gcmVuZGVyVGFyZ2V0LndpZHRoIHx8IHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ICE9PSByZW5kZXJUYXJnZXQuaGVpZ2h0KSB7XG4gICAgICByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgICAgcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuICAgICAgcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgc2V0VGV4dHVyZTJEKHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUsIDApO1xuXG4gICAgdmFyIHdlYmdsRGVwdGhUZXh0dXJlID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmU7XG5cbiAgICB2YXIgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KTtcblxuICAgIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQpIHtcbiAgICAgIGlmICh1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSkge1xuICAgICAgICBtdWx0aXNhbXBsZWRSVFRFeHQuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVCgzNjE2MCwgMzYwOTYsIDM1NTMsIHdlYmdsRGVwdGhUZXh0dXJlLCAwLCBzYW1wbGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjE2MCwgMzYwOTYsIDM1NTMsIHdlYmdsRGVwdGhUZXh0dXJlLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQpIHtcbiAgICAgIGlmICh1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSkge1xuICAgICAgICBtdWx0aXNhbXBsZWRSVFRFeHQuZnJhbWVidWZmZXJUZXh0dXJlMkRNdWx0aXNhbXBsZUVYVCgzNjE2MCwgMzMzMDYsIDM1NTMsIHdlYmdsRGVwdGhUZXh0dXJlLCAwLCBzYW1wbGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjE2MCwgMzMzMDYsIDM1NTMsIHdlYmdsRGVwdGhUZXh0dXJlLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXQnKTtcbiAgICB9XG4gIH0gLy8gU2V0dXAgR0wgcmVzb3VyY2VzIGZvciBhIG5vbi10ZXh0dXJlIGRlcHRoIGJ1ZmZlclxuXG5cbiAgZnVuY3Rpb24gc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlcihyZW5kZXJUYXJnZXQpIHtcbiAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgdmFyIGlzQ3ViZSA9IHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA9PT0gdHJ1ZTtcblxuICAgIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICYmICFyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIpIHtcbiAgICAgIGlmIChpc0N1YmUpIHRocm93IG5ldyBFcnJvcigndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnKTtcbiAgICAgIHNldHVwRGVwdGhUZXh0dXJlKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNDdWJlKSB7XG4gICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kxMzYgPSAwOyBfaTEzNiA8IDY7IF9pMTM2KyspIHtcbiAgICAgICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyW19pMTM2XSk7XG4gICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbX2kxMzZdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICAgIHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlcltfaTEzNl0sIHJlbmRlclRhcmdldCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyKTtcbiAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgICAgIHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBudWxsKTtcbiAgfSAvLyByZWJpbmQgZnJhbWVidWZmZXIgd2l0aCBleHRlcm5hbCB0ZXh0dXJlc1xuXG5cbiAgZnVuY3Rpb24gcmViaW5kVGV4dHVyZXMocmVuZGVyVGFyZ2V0LCBjb2xvclRleHR1cmUsIGRlcHRoVGV4dHVyZSkge1xuICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblxuICAgIGlmIChjb2xvclRleHR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIDM2MDY0LCAzNTUzKTtcbiAgICB9XG5cbiAgICBpZiAoZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNldHVwRGVwdGhSZW5kZXJidWZmZXIocmVuZGVyVGFyZ2V0KTtcbiAgICB9XG4gIH0gLy8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcblxuXG4gIGZ1bmN0aW9uIHNldHVwUmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCkge1xuICAgIHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgdmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpO1xuICAgIHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmUpO1xuICAgIHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlKTtcblxuICAgIGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgfVxuXG4gICAgICB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG4gICAgICBpbmZvLm1lbW9yeS50ZXh0dXJlcysrO1xuICAgIH1cblxuICAgIHZhciBpc0N1YmUgPSByZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgPT09IHRydWU7XG4gICAgdmFyIGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMgPT09IHRydWU7XG4gICAgdmFyIHN1cHBvcnRzTWlwcyA9IGlzUG93ZXJPZlR3byQxKHJlbmRlclRhcmdldCkgfHwgaXNXZWJHTDI7IC8vIFNldHVwIGZyYW1lYnVmZmVyXG5cbiAgICBpZiAoaXNDdWJlKSB7XG4gICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTEzNyA9IDA7IF9pMTM3IDwgNjsgX2kxMzcrKykge1xuICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcltfaTEzN10gPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgICAgaWYgKGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzKSB7XG4gICAgICAgIGlmIChjYXBhYmlsaXRpZXMuZHJhd0J1ZmZlcnMpIHtcbiAgICAgICAgICB2YXIgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMTM4ID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IF9pMTM4IDwgaWw7IF9pMTM4KyspIHtcbiAgICAgICAgICAgIHZhciBhdHRhY2htZW50UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHRleHR1cmVzW19pMTM4XSk7XG5cbiAgICAgICAgICAgIGlmIChhdHRhY2htZW50UHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGF0dGFjaG1lbnRQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgICAgaW5mby5tZW1vcnkudGV4dHVyZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiBXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyBjYW4gb25seSBiZSB1c2VkIHdpdGggV2ViR0wyIG9yIFdFQkdMX2RyYXdfYnVmZmVycyBleHRlbnNpb24uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzV2ViR0wyICYmIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCAmJiB1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFyIF90ZXh0dXJlcyA9IGlzTXVsdGlwbGVSZW5kZXJUYXJnZXRzID8gdGV4dHVyZSA6IFt0ZXh0dXJlXTtcblxuICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlciA9IFtdO1xuICAgICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtcblxuICAgICAgICBmb3IgKHZhciBfaTEzOSA9IDA7IF9pMTM5IDwgX3RleHR1cmVzLmxlbmd0aDsgX2kxMzkrKykge1xuICAgICAgICAgIHZhciBfdGV4dHVyZSA9IF90ZXh0dXJlc1tfaTEzOV07XG4gICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbX2kxMzldID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXG4gICAgICAgICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbENvbG9yUmVuZGVyYnVmZmVyW19pMTM5XSk7XG5cbiAgICAgICAgICB2YXIgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KF90ZXh0dXJlLmZvcm1hdCwgX3RleHR1cmUuZW5jb2RpbmcpO1xuICAgICAgICAgIHZhciBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KF90ZXh0dXJlLnR5cGUpO1xuICAgICAgICAgIHZhciBnbEludGVybmFsRm9ybWF0ID0gZ2V0SW50ZXJuYWxGb3JtYXQoX3RleHR1cmUuaW50ZXJuYWxGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIF90ZXh0dXJlLmVuY29kaW5nKTtcbiAgICAgICAgICB2YXIgc2FtcGxlcyA9IGdldFJlbmRlclRhcmdldFNhbXBsZXMocmVuZGVyVGFyZ2V0KTtcblxuICAgICAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoMzYxNjEsIHNhbXBsZXMsIGdsSW50ZXJuYWxGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cbiAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoMzYxNjAsIDM2MDY0ICsgX2kxMzksIDM2MTYxLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltfaTEzOV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoMzYxNjEsIG51bGwpO1xuXG4gICAgICAgIGlmIChyZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIpIHtcbiAgICAgICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aFJlbmRlcmJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgICBzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhSZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIG51bGwpO1xuICAgICAgfVxuICAgIH0gLy8gU2V0dXAgY29sb3IgYnVmZmVyXG5cblxuICAgIGlmIChpc0N1YmUpIHtcbiAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKDM0MDY3LCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG4gICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycygzNDA2NywgdGV4dHVyZSwgc3VwcG9ydHNNaXBzKTtcblxuICAgICAgZm9yICh2YXIgX2kxNDAgPSAwOyBfaTE0MCA8IDY7IF9pMTQwKyspIHtcbiAgICAgICAgc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbX2kxNDBdLCByZW5kZXJUYXJnZXQsIHRleHR1cmUsIDM2MDY0LCAzNDA2OSArIF9pMTQwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyh0ZXh0dXJlLCBzdXBwb3J0c01pcHMpKSB7XG4gICAgICAgIGdlbmVyYXRlTWlwbWFwKDM0MDY3KTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcbiAgICAgIHZhciBfdGV4dHVyZXMyID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cbiAgICAgIGZvciAodmFyIF9pMTQxID0gMCwgX2lsMTEgPSBfdGV4dHVyZXMyLmxlbmd0aDsgX2kxNDEgPCBfaWwxMTsgX2kxNDErKykge1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IF90ZXh0dXJlczJbX2kxNDFdO1xuXG4gICAgICAgIHZhciBfYXR0YWNobWVudFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChhdHRhY2htZW50KTtcblxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSgzNTUzLCBfYXR0YWNobWVudFByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUpO1xuICAgICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycygzNTUzLCBhdHRhY2htZW50LCBzdXBwb3J0c01pcHMpO1xuICAgICAgICBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZShyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBhdHRhY2htZW50LCAzNjA2NCArIF9pMTQxLCAzNTUzKTtcblxuICAgICAgICBpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKGF0dGFjaG1lbnQsIHN1cHBvcnRzTWlwcykpIHtcbiAgICAgICAgICBnZW5lcmF0ZU1pcG1hcCgzNTUzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBnbFRleHR1cmVUeXBlID0gMzU1MztcblxuICAgICAgaWYgKHJlbmRlclRhcmdldC5pc1dlYkdMM0RSZW5kZXJUYXJnZXQgfHwgcmVuZGVyVGFyZ2V0LmlzV2ViR0xBcnJheVJlbmRlclRhcmdldCkge1xuICAgICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgICBnbFRleHR1cmVUeXBlID0gcmVuZGVyVGFyZ2V0LmlzV2ViR0wzRFJlbmRlclRhcmdldCA/IDMyODc5IDogMzU4NjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xUZXh0dXJlczogVEhSRUUuRGF0YTNEVGV4dHVyZSBhbmQgVEhSRUUuRGF0YUFycmF5VGV4dHVyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIFdlYkdMMi4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS5iaW5kVGV4dHVyZShnbFRleHR1cmVUeXBlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSk7XG4gICAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyhnbFRleHR1cmVUeXBlLCB0ZXh0dXJlLCBzdXBwb3J0c01pcHMpO1xuICAgICAgc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgdGV4dHVyZSwgMzYwNjQsIGdsVGV4dHVyZVR5cGUpO1xuXG4gICAgICBpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykpIHtcbiAgICAgICAgZ2VuZXJhdGVNaXBtYXAoZ2xUZXh0dXJlVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnVuYmluZFRleHR1cmUoKTtcbiAgICB9IC8vIFNldHVwIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnNcblxuXG4gICAgaWYgKHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlcikge1xuICAgICAgc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlcihyZW5kZXJUYXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChyZW5kZXJUYXJnZXQpIHtcbiAgICB2YXIgc3VwcG9ydHNNaXBzID0gaXNQb3dlck9mVHdvJDEocmVuZGVyVGFyZ2V0KSB8fCBpc1dlYkdMMjtcbiAgICB2YXIgdGV4dHVyZXMgPSByZW5kZXJUYXJnZXQuaXNXZWJHTE11bHRpcGxlUmVuZGVyVGFyZ2V0cyA9PT0gdHJ1ZSA/IHJlbmRlclRhcmdldC50ZXh0dXJlIDogW3JlbmRlclRhcmdldC50ZXh0dXJlXTtcblxuICAgIGZvciAodmFyIF9pMTQyID0gMCwgaWwgPSB0ZXh0dXJlcy5sZW5ndGg7IF9pMTQyIDwgaWw7IF9pMTQyKyspIHtcbiAgICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZXNbX2kxNDJdO1xuXG4gICAgICBpZiAodGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKHRleHR1cmUsIHN1cHBvcnRzTWlwcykpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCA/IDM0MDY3IDogMzU1MztcblxuICAgICAgICB2YXIgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQodGV4dHVyZSkuX193ZWJnbFRleHR1cmU7XG5cbiAgICAgICAgc3RhdGUuYmluZFRleHR1cmUodGFyZ2V0LCB3ZWJnbFRleHR1cmUpO1xuICAgICAgICBnZW5lcmF0ZU1pcG1hcCh0YXJnZXQpO1xuICAgICAgICBzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KSB7XG4gICAgaWYgKGlzV2ViR0wyICYmIHJlbmRlclRhcmdldC5zYW1wbGVzID4gMCAmJiB1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhciB0ZXh0dXJlcyA9IHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID8gcmVuZGVyVGFyZ2V0LnRleHR1cmUgOiBbcmVuZGVyVGFyZ2V0LnRleHR1cmVdO1xuICAgICAgdmFyIHdpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XG4gICAgICB2YXIgbWFzayA9IDE2Mzg0O1xuICAgICAgdmFyIGludmFsaWRhdGlvbkFycmF5ID0gW107XG4gICAgICB2YXIgZGVwdGhTdHlsZSA9IHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID8gMzMzMDYgOiAzNjA5NjtcbiAgICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcbiAgICAgIHZhciBpc011bHRpcGxlUmVuZGVyVGFyZ2V0cyA9IHJlbmRlclRhcmdldC5pc1dlYkdMTXVsdGlwbGVSZW5kZXJUYXJnZXRzID09PSB0cnVlOyAvLyBJZiBNUlQgd2UgbmVlZCB0byByZW1vdmUgRkJPIGF0dGFjaG1lbnRzXG5cbiAgICAgIGlmIChpc011bHRpcGxlUmVuZGVyVGFyZ2V0cykge1xuICAgICAgICBmb3IgKHZhciBfaTE0MyA9IDA7IF9pMTQzIDwgdGV4dHVyZXMubGVuZ3RoOyBfaTE0MysrKSB7XG4gICAgICAgICAgc3RhdGUuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xNdWx0aXNhbXBsZWRGcmFtZWJ1ZmZlcik7XG5cbiAgICAgICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoMzYxNjAsIDM2MDY0ICsgX2kxNDMsIDM2MTYxLCBudWxsKTtcblxuICAgICAgICAgIHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIpO1xuXG4gICAgICAgICAgX2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKDM2MDA5LCAzNjA2NCArIF9pMTQzLCAzNTUzLCBudWxsLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYwMDgsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtcbiAgICAgIHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcigzNjAwOSwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIpO1xuXG4gICAgICBmb3IgKHZhciBfaTE0NCA9IDA7IF9pMTQ0IDwgdGV4dHVyZXMubGVuZ3RoOyBfaTE0NCsrKSB7XG4gICAgICAgIGludmFsaWRhdGlvbkFycmF5LnB1c2goMzYwNjQgKyBfaTE0NCk7XG5cbiAgICAgICAgaWYgKHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlcikge1xuICAgICAgICAgIGludmFsaWRhdGlvbkFycmF5LnB1c2goZGVwdGhTdHlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWdub3JlRGVwdGhWYWx1ZXMgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faWdub3JlRGVwdGhWYWx1ZXMgIT09IHVuZGVmaW5lZCA/IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19pZ25vcmVEZXB0aFZhbHVlcyA6IGZhbHNlO1xuXG4gICAgICAgIGlmIChpZ25vcmVEZXB0aFZhbHVlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAocmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyKSBtYXNrIHw9IDI1NjtcbiAgICAgICAgICBpZiAocmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIpIG1hc2sgfD0gMTAyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc011bHRpcGxlUmVuZGVyVGFyZ2V0cykge1xuICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcigzNjAwOCwgMzYwNjQsIDM2MTYxLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xDb2xvclJlbmRlcmJ1ZmZlcltfaTE0NF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlnbm9yZURlcHRoVmFsdWVzID09PSB0cnVlKSB7XG4gICAgICAgICAgX2dsLmludmFsaWRhdGVGcmFtZWJ1ZmZlcigzNjAwOCwgW2RlcHRoU3R5bGVdKTtcblxuICAgICAgICAgIF9nbC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoMzYwMDksIFtkZXB0aFN0eWxlXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcbiAgICAgICAgICB2YXIgd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQodGV4dHVyZXNbX2kxNDRdKS5fX3dlYmdsVGV4dHVyZTtcblxuICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCgzNjAwOSwgMzYwNjQsIDM1NTMsIHdlYmdsVGV4dHVyZSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBfZ2wuYmxpdEZyYW1lYnVmZmVyKDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIG1hc2ssIDk3MjgpO1xuXG4gICAgICAgIGlmIChzdXBwb3J0c0ludmFsaWRhdGVGcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIF9nbC5pbnZhbGlkYXRlRnJhbWVidWZmZXIoMzYwMDgsIGludmFsaWRhdGlvbkFycmF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYwMDgsIG51bGwpO1xuICAgICAgc3RhdGUuYmluZEZyYW1lYnVmZmVyKDM2MDA5LCBudWxsKTsgLy8gSWYgTVJUIHNpbmNlIHByZS1ibGl0IHdlIHJlbW92ZWQgdGhlIEZCTyB3ZSBuZWVkIHRvIHJlY29uc3RydWN0IHRoZSBhdHRhY2htZW50c1xuXG4gICAgICBpZiAoaXNNdWx0aXBsZVJlbmRlclRhcmdldHMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kxNDUgPSAwOyBfaTE0NSA8IHRleHR1cmVzLmxlbmd0aDsgX2kxNDUrKykge1xuICAgICAgICAgIHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXIpO1xuXG4gICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKDM2MTYwLCAzNjA2NCArIF9pMTQ1LCAzNjE2MSwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsQ29sb3JSZW5kZXJidWZmZXJbX2kxNDVdKTtcblxuICAgICAgICAgIHZhciBfd2ViZ2xUZXh0dXJlID0gcHJvcGVydGllcy5nZXQodGV4dHVyZXNbX2kxNDVdKS5fX3dlYmdsVGV4dHVyZTtcblxuICAgICAgICAgIHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIpO1xuXG4gICAgICAgICAgX2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKDM2MDA5LCAzNjA2NCArIF9pMTQ1LCAzNTUzLCBfd2ViZ2xUZXh0dXJlLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYwMDksIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbE11bHRpc2FtcGxlZEZyYW1lYnVmZmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRTYW1wbGVzKHJlbmRlclRhcmdldCkge1xuICAgIHJldHVybiBNYXRoLm1pbihtYXhTYW1wbGVzLCByZW5kZXJUYXJnZXQuc2FtcGxlcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VNdWx0aXNhbXBsZWRSVFQocmVuZGVyVGFyZ2V0KSB7XG4gICAgdmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpO1xuICAgIHJldHVybiBpc1dlYkdMMiAmJiByZW5kZXJUYXJnZXQuc2FtcGxlcyA+IDAgJiYgZXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX211bHRpc2FtcGxlZF9yZW5kZXJfdG9fdGV4dHVyZScpID09PSB0cnVlICYmIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX191c2VSZW5kZXJUb1RleHR1cmUgIT09IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVmlkZW9UZXh0dXJlKHRleHR1cmUpIHtcbiAgICB2YXIgZnJhbWUgPSBpbmZvLnJlbmRlci5mcmFtZTsgLy8gQ2hlY2sgdGhlIGxhc3QgZnJhbWUgd2UgdXBkYXRlZCB0aGUgVmlkZW9UZXh0dXJlXG5cbiAgICBpZiAoX3ZpZGVvVGV4dHVyZXMuZ2V0KHRleHR1cmUpICE9PSBmcmFtZSkge1xuICAgICAgX3ZpZGVvVGV4dHVyZXMuc2V0KHRleHR1cmUsIGZyYW1lKTtcblxuICAgICAgdGV4dHVyZS51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2ZXJpZnlDb2xvclNwYWNlKHRleHR1cmUsIGltYWdlKSB7XG4gICAgdmFyIGVuY29kaW5nID0gdGV4dHVyZS5lbmNvZGluZztcbiAgICB2YXIgZm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG4gICAgdmFyIHR5cGUgPSB0ZXh0dXJlLnR5cGU7XG4gICAgaWYgKHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSA9PT0gdHJ1ZSB8fCB0ZXh0dXJlLmlzVmlkZW9UZXh0dXJlID09PSB0cnVlIHx8IHRleHR1cmUuZm9ybWF0ID09PSBfU1JHQkFGb3JtYXQpIHJldHVybiBpbWFnZTtcblxuICAgIGlmIChlbmNvZGluZyAhPT0gTGluZWFyRW5jb2RpbmcpIHtcbiAgICAgIC8vIHNSR0JcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nKSB7XG4gICAgICAgIGlmIChpc1dlYkdMMiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBpbiBXZWJHTCAxLCB0cnkgdG8gdXNlIEVYVF9zUkdCIGV4dGVuc2lvbiBhbmQgdW5zaXplZCBmb3JtYXRzXG4gICAgICAgICAgaWYgKGV4dGVuc2lvbnMuaGFzKCdFWFRfc1JHQicpID09PSB0cnVlICYmIGZvcm1hdCA9PT0gUkdCQUZvcm1hdCkge1xuICAgICAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSBfU1JHQkFGb3JtYXQ7IC8vIGl0J3Mgbm90IHBvc3NpYmxlIHRvIGdlbmVyYXRlIG1pcHMgaW4gV2ViR0wgMSB3aXRoIHRoaXMgZXh0ZW5zaW9uXG5cbiAgICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2xvdyBmYWxsYmFjayAoQ1BVIGRlY29kZSlcbiAgICAgICAgICAgIGltYWdlID0gSW1hZ2VVdGlscy5zUkdCVG9MaW5lYXIoaW1hZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbiBXZWJHTCAyIHVuY29tcHJlc3NlZCB0ZXh0dXJlcyBjYW4gb25seSBiZSBzUkdCIGVuY29kZWQgaWYgdGhleSBoYXZlIHRoZSBSR0JBOCBmb3JtYXRcbiAgICAgICAgICBpZiAoZm9ybWF0ICE9PSBSR0JBRm9ybWF0IHx8IHR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xUZXh0dXJlczogc1JHQiBlbmNvZGVkIHRleHR1cmVzIGhhdmUgdG8gdXNlIFJHQkFGb3JtYXQgYW5kIFVuc2lnbmVkQnl0ZVR5cGUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFRleHR1cmVzOiBVbnN1cHBvcnRlZCB0ZXh0dXJlIGVuY29kaW5nOicsIGVuY29kaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2U7XG4gIH0gLy9cblxuXG4gIHRoaXMuYWxsb2NhdGVUZXh0dXJlVW5pdCA9IGFsbG9jYXRlVGV4dHVyZVVuaXQ7XG4gIHRoaXMucmVzZXRUZXh0dXJlVW5pdHMgPSByZXNldFRleHR1cmVVbml0cztcbiAgdGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XG4gIHRoaXMuc2V0VGV4dHVyZTJEQXJyYXkgPSBzZXRUZXh0dXJlMkRBcnJheTtcbiAgdGhpcy5zZXRUZXh0dXJlM0QgPSBzZXRUZXh0dXJlM0Q7XG4gIHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBzZXRUZXh0dXJlQ3ViZTtcbiAgdGhpcy5yZWJpbmRUZXh0dXJlcyA9IHJlYmluZFRleHR1cmVzO1xuICB0aGlzLnNldHVwUmVuZGVyVGFyZ2V0ID0gc2V0dXBSZW5kZXJUYXJnZXQ7XG4gIHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwO1xuICB0aGlzLnVwZGF0ZU11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0ID0gdXBkYXRlTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQ7XG4gIHRoaXMuc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciA9IHNldHVwRGVwdGhSZW5kZXJidWZmZXI7XG4gIHRoaXMuc2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUgPSBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZTtcbiAgdGhpcy51c2VNdWx0aXNhbXBsZWRSVFQgPSB1c2VNdWx0aXNhbXBsZWRSVFQ7XG59XG5cbmZ1bmN0aW9uIFdlYkdMVXRpbHMoZ2wsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcykge1xuICB2YXIgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cbiAgZnVuY3Rpb24gY29udmVydChwKSB7XG4gICAgdmFyIGVuY29kaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIHZhciBleHRlbnNpb247XG4gICAgaWYgKHAgPT09IFVuc2lnbmVkQnl0ZVR5cGUpIHJldHVybiA1MTIxO1xuICAgIGlmIChwID09PSBVbnNpZ25lZFNob3J0NDQ0NFR5cGUpIHJldHVybiAzMjgxOTtcbiAgICBpZiAocCA9PT0gVW5zaWduZWRTaG9ydDU1NTFUeXBlKSByZXR1cm4gMzI4MjA7XG4gICAgaWYgKHAgPT09IEJ5dGVUeXBlKSByZXR1cm4gNTEyMDtcbiAgICBpZiAocCA9PT0gU2hvcnRUeXBlKSByZXR1cm4gNTEyMjtcbiAgICBpZiAocCA9PT0gVW5zaWduZWRTaG9ydFR5cGUpIHJldHVybiA1MTIzO1xuICAgIGlmIChwID09PSBJbnRUeXBlKSByZXR1cm4gNTEyNDtcbiAgICBpZiAocCA9PT0gVW5zaWduZWRJbnRUeXBlKSByZXR1cm4gNTEyNTtcbiAgICBpZiAocCA9PT0gRmxvYXRUeXBlKSByZXR1cm4gNTEyNjtcblxuICAgIGlmIChwID09PSBIYWxmRmxvYXRUeXBlKSB7XG4gICAgICBpZiAoaXNXZWJHTDIpIHJldHVybiA1MTMxO1xuICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnKTtcblxuICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHAgPT09IEFscGhhRm9ybWF0KSByZXR1cm4gNjQwNjtcbiAgICBpZiAocCA9PT0gUkdCQUZvcm1hdCkgcmV0dXJuIDY0MDg7XG4gICAgaWYgKHAgPT09IEx1bWluYW5jZUZvcm1hdCkgcmV0dXJuIDY0MDk7XG4gICAgaWYgKHAgPT09IEx1bWluYW5jZUFscGhhRm9ybWF0KSByZXR1cm4gNjQxMDtcbiAgICBpZiAocCA9PT0gRGVwdGhGb3JtYXQpIHJldHVybiA2NDAyO1xuICAgIGlmIChwID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQpIHJldHVybiAzNDA0MTtcbiAgICBpZiAocCA9PT0gUmVkRm9ybWF0KSByZXR1cm4gNjQwMztcblxuICAgIGlmIChwID09PSBSR0JGb3JtYXQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogVEhSRUUuUkdCRm9ybWF0IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5SR0JBRm9ybWF0IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzIyOCcpO1xuICAgICAgcmV0dXJuIDY0MDg7XG4gICAgfSAvLyBXZWJHTCAxIHNSR0IgZmFsbGJhY2tcblxuXG4gICAgaWYgKHAgPT09IF9TUkdCQUZvcm1hdCkge1xuICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ0VYVF9zUkdCJyk7XG5cbiAgICAgIGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbi5TUkdCX0FMUEhBX0VYVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gLy8gV2ViR0wyIGZvcm1hdHMuXG5cblxuICAgIGlmIChwID09PSBSZWRJbnRlZ2VyRm9ybWF0KSByZXR1cm4gMzYyNDQ7XG4gICAgaWYgKHAgPT09IFJHRm9ybWF0KSByZXR1cm4gMzMzMTk7XG4gICAgaWYgKHAgPT09IFJHSW50ZWdlckZvcm1hdCkgcmV0dXJuIDMzMzIwO1xuICAgIGlmIChwID09PSBSR0JBSW50ZWdlckZvcm1hdCkgcmV0dXJuIDM2MjQ5OyAvLyBTM1RDXG5cbiAgICBpZiAocCA9PT0gUkdCX1MzVENfRFhUMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQpIHtcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nKSB7XG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y19zcmdiJyk7XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfUzNUQ19EWFQxX0VYVDtcbiAgICAgICAgICBpZiAocCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9TM1RDX0RYVDFfRVhUO1xuICAgICAgICAgIGlmIChwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCX0FMUEhBX1MzVENfRFhUM19FWFQ7XG4gICAgICAgICAgaWYgKHAgPT09IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0JfQUxQSEFfUzNUQ19EWFQ1X0VYVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyk7XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICAgICAgICAgIGlmIChwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XG4gICAgICAgICAgaWYgKHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcbiAgICAgICAgICBpZiAocCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0KSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBQVlJUQ1xuXG5cbiAgICBpZiAocCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCkge1xuICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycpO1xuXG4gICAgICBpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO1xuICAgICAgICBpZiAocCA9PT0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQpIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcbiAgICAgICAgaWYgKHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcbiAgICAgICAgaWYgKHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gLy8gRVRDMVxuXG5cbiAgICBpZiAocCA9PT0gUkdCX0VUQzFfRm9ybWF0KSB7XG4gICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCgnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnKTtcblxuICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0w7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IC8vIEVUQzJcblxuXG4gICAgaWYgKHAgPT09IFJHQl9FVEMyX0Zvcm1hdCB8fCBwID09PSBSR0JBX0VUQzJfRUFDX0Zvcm1hdCkge1xuICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMnKTtcblxuICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAocCA9PT0gUkdCX0VUQzJfRm9ybWF0KSByZXR1cm4gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0VUQzIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0I4X0VUQzI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0VUQzJfRUFDX0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfRVRDMl9FQUMgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBOF9FVEMyX0VBQztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gLy8gQVNUQ1xuXG5cbiAgICBpZiAocCA9PT0gUkdCQV9BU1RDXzR4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzV4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzZ4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4NV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4Nl9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzh4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDVfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMHg2X0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9BU1RDXzEweDEwX0Zvcm1hdCB8fCBwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0IHx8IHAgPT09IFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQpIHtcbiAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfYXN0YycpO1xuXG4gICAgICBpZiAoZXh0ZW5zaW9uICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfNHg0X0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ180eDRfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzR4NF9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfNXg0X0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDRfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NF9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfNXg1X0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ181eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzV4NV9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfNng1X0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4NV9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfNng2X0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ182eDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzZ4Nl9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfOHg1X0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDVfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4NV9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfOHg2X0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDZfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4Nl9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfOHg4X0Zvcm1hdCkgcmV0dXJuIGVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyBleHRlbnNpb24uQ09NUFJFU1NFRF9TUkdCOF9BTFBIQThfQVNUQ184eDhfS0hSIDogZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9BU1RDXzh4OF9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfMTB4NV9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4NV9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4NV9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfMTB4Nl9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4Nl9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4Nl9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfMTB4OF9Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQjhfQUxQSEE4X0FTVENfMTB4OF9LSFIgOiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX0FTVENfMTB4OF9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfMTB4MTBfRm9ybWF0KSByZXR1cm4gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEweDEwX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMHgxMF9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfMTJ4MTBfRm9ybWF0KSByZXR1cm4gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEwX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMF9LSFI7XG4gICAgICAgIGlmIChwID09PSBSR0JBX0FTVENfMTJ4MTJfRm9ybWF0KSByZXR1cm4gZW5jb2RpbmcgPT09IHNSR0JFbmNvZGluZyA/IGV4dGVuc2lvbi5DT01QUkVTU0VEX1NSR0I4X0FMUEhBOF9BU1RDXzEyeDEyX0tIUiA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQVNUQ18xMngxMl9LSFI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IC8vIEJQVENcblxuXG4gICAgaWYgKHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQpIHtcbiAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCdFWFRfdGV4dHVyZV9jb21wcmVzc2lvbl9icHRjJyk7XG5cbiAgICAgIGlmIChleHRlbnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHAgPT09IFJHQkFfQlBUQ19Gb3JtYXQpIHJldHVybiBlbmNvZGluZyA9PT0gc1JHQkVuY29kaW5nID8gZXh0ZW5zaW9uLkNPTVBSRVNTRURfU1JHQl9BTFBIQV9CUFRDX1VOT1JNX0VYVCA6IGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfQlBUQ19VTk9STV9FWFQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IC8vXG5cblxuICAgIGlmIChwID09PSBVbnNpZ25lZEludDI0OFR5cGUpIHtcbiAgICAgIGlmIChpc1dlYkdMMikgcmV0dXJuIDM0MDQyO1xuICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2RlcHRoX3RleHR1cmUnKTtcblxuICAgICAgaWYgKGV4dGVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLlVOU0lHTkVEX0lOVF8yNF84X1dFQkdMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSAvLyBpZiBcInBcIiBjYW4ndCBiZSByZXNvbHZlZCwgYXNzdW1lIHRoZSB1c2VyIGRlZmluZXMgYSBXZWJHTCBjb25zdGFudCBhcyBhIHN0cmluZyAoZmFsbGJhY2svd29ya2Fyb3VuZCBmb3IgcGFja2VkIFJHQiBmb3JtYXRzKVxuXG5cbiAgICByZXR1cm4gZ2xbcF0gIT09IHVuZGVmaW5lZCA/IGdsW3BdIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29udmVydDogY29udmVydFxuICB9O1xufVxuXG52YXIgQXJyYXlDYW1lcmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QZXJzcGVjdGl2ZUNhbWVyYSkge1xuICBfaW5oZXJpdHMoQXJyYXlDYW1lcmEsIF9QZXJzcGVjdGl2ZUNhbWVyYSk7XG5cbiAgdmFyIF9zdXBlcjM0ID0gX2NyZWF0ZVN1cGVyKEFycmF5Q2FtZXJhKTtcblxuICBmdW5jdGlvbiBBcnJheUNhbWVyYSgpIHtcbiAgICB2YXIgX3RoaXMyNjtcblxuICAgIHZhciBhcnJheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJyYXlDYW1lcmEpO1xuXG4gICAgX3RoaXMyNiA9IF9zdXBlcjM0LmNhbGwodGhpcyk7XG4gICAgX3RoaXMyNi5pc0FycmF5Q2FtZXJhID0gdHJ1ZTtcbiAgICBfdGhpczI2LmNhbWVyYXMgPSBhcnJheTtcbiAgICByZXR1cm4gX3RoaXMyNjtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXJyYXlDYW1lcmEpO1xufShQZXJzcGVjdGl2ZUNhbWVyYSk7XG5cbnZhciBHcm91cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iamVjdDNENCkge1xuICBfaW5oZXJpdHMoR3JvdXAsIF9PYmplY3QzRDQpO1xuXG4gIHZhciBfc3VwZXIzNSA9IF9jcmVhdGVTdXBlcihHcm91cCk7XG5cbiAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgdmFyIF90aGlzMjc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JvdXApO1xuXG4gICAgX3RoaXMyNyA9IF9zdXBlcjM1LmNhbGwodGhpcyk7XG4gICAgX3RoaXMyNy5pc0dyb3VwID0gdHJ1ZTtcbiAgICBfdGhpczI3LnR5cGUgPSAnR3JvdXAnO1xuICAgIHJldHVybiBfdGhpczI3O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhHcm91cCk7XG59KE9iamVjdDNEKTtcblxudmFyIF9tb3ZlRXZlbnQgPSB7XG4gIHR5cGU6ICdtb3ZlJ1xufTtcblxudmFyIFdlYlhSQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdlYlhSQ29udHJvbGxlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViWFJDb250cm9sbGVyKTtcblxuICAgIHRoaXMuX3RhcmdldFJheSA9IG51bGw7XG4gICAgdGhpcy5fZ3JpcCA9IG51bGw7XG4gICAgdGhpcy5faGFuZCA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2ViWFJDb250cm9sbGVyLCBbe1xuICAgIGtleTogXCJnZXRIYW5kU3BhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGFuZFNwYWNlKCkge1xuICAgICAgaWYgKHRoaXMuX2hhbmQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5faGFuZCA9IG5ldyBHcm91cCgpO1xuICAgICAgICB0aGlzLl9oYW5kLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGFuZC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhbmQuam9pbnRzID0ge307XG4gICAgICAgIHRoaXMuX2hhbmQuaW5wdXRTdGF0ZSA9IHtcbiAgICAgICAgICBwaW5jaGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2hhbmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRhcmdldFJheVNwYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhcmdldFJheVNwYWNlKCkge1xuICAgICAgaWYgKHRoaXMuX3RhcmdldFJheSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl90YXJnZXRSYXkgPSBuZXcgR3JvdXAoKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UmF5Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UmF5LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RhcmdldFJheS5saW5lYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHRoaXMuX3RhcmdldFJheS5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UmF5LmFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl90YXJnZXRSYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEdyaXBTcGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmlwU3BhY2UoKSB7XG4gICAgICBpZiAodGhpcy5fZ3JpcCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9ncmlwID0gbmV3IEdyb3VwKCk7XG4gICAgICAgIHRoaXMuX2dyaXAubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ncmlwLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZ3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ncmlwLmxpbmVhclZlbG9jaXR5ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5fZ3JpcC5oYXNBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZ3JpcC5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZ3JpcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcGF0Y2hFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5fdGFyZ2V0UmF5ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFJheS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2dyaXAgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZ3JpcC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2hhbmQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5faGFuZC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdChpbnB1dFNvdXJjZSkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgIGRhdGE6IGlucHV0U291cmNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3RhcmdldFJheSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl90YXJnZXRSYXkudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZ3JpcCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9ncmlwLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2hhbmQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5faGFuZC52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlucHV0U291cmNlLCBmcmFtZSwgcmVmZXJlbmNlU3BhY2UpIHtcbiAgICAgIHZhciBpbnB1dFBvc2UgPSBudWxsO1xuICAgICAgdmFyIGdyaXBQb3NlID0gbnVsbDtcbiAgICAgIHZhciBoYW5kUG9zZSA9IG51bGw7XG4gICAgICB2YXIgdGFyZ2V0UmF5ID0gdGhpcy5fdGFyZ2V0UmF5O1xuICAgICAgdmFyIGdyaXAgPSB0aGlzLl9ncmlwO1xuICAgICAgdmFyIGhhbmQgPSB0aGlzLl9oYW5kO1xuXG4gICAgICBpZiAoaW5wdXRTb3VyY2UgJiYgZnJhbWUuc2Vzc2lvbi52aXNpYmlsaXR5U3RhdGUgIT09ICd2aXNpYmxlLWJsdXJyZWQnKSB7XG4gICAgICAgIGlmICh0YXJnZXRSYXkgIT09IG51bGwpIHtcbiAgICAgICAgICBpbnB1dFBvc2UgPSBmcmFtZS5nZXRQb3NlKGlucHV0U291cmNlLnRhcmdldFJheVNwYWNlLCByZWZlcmVuY2VTcGFjZSk7XG5cbiAgICAgICAgICBpZiAoaW5wdXRQb3NlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0YXJnZXRSYXkubWF0cml4LmZyb21BcnJheShpbnB1dFBvc2UudHJhbnNmb3JtLm1hdHJpeCk7XG4gICAgICAgICAgICB0YXJnZXRSYXkubWF0cml4LmRlY29tcG9zZSh0YXJnZXRSYXkucG9zaXRpb24sIHRhcmdldFJheS5yb3RhdGlvbiwgdGFyZ2V0UmF5LnNjYWxlKTtcblxuICAgICAgICAgICAgaWYgKGlucHV0UG9zZS5saW5lYXJWZWxvY2l0eSkge1xuICAgICAgICAgICAgICB0YXJnZXRSYXkuaGFzTGluZWFyVmVsb2NpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICB0YXJnZXRSYXkubGluZWFyVmVsb2NpdHkuY29weShpbnB1dFBvc2UubGluZWFyVmVsb2NpdHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0UmF5Lmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnB1dFBvc2UuYW5ndWxhclZlbG9jaXR5KSB7XG4gICAgICAgICAgICAgIHRhcmdldFJheS5oYXNBbmd1bGFyVmVsb2NpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICB0YXJnZXRSYXkuYW5ndWxhclZlbG9jaXR5LmNvcHkoaW5wdXRQb3NlLmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRSYXkuaGFzQW5ndWxhclZlbG9jaXR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChfbW92ZUV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFuZCAmJiBpbnB1dFNvdXJjZS5oYW5kKSB7XG4gICAgICAgICAgaGFuZFBvc2UgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpbnB1dFNvdXJjZS5oYW5kLnZhbHVlcygpKSxcbiAgICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBpbnB1dGpvaW50ID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGpvaW50cyBncm91cHMgd2l0aCB0aGUgWFJKb2ludCBwb3Nlc1xuICAgICAgICAgICAgICB2YXIgam9pbnRQb3NlID0gZnJhbWUuZ2V0Sm9pbnRQb3NlKGlucHV0am9pbnQsIHJlZmVyZW5jZVNwYWNlKTtcblxuICAgICAgICAgICAgICBpZiAoaGFuZC5qb2ludHNbaW5wdXRqb2ludC5qb2ludE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdHJhbnNmb3JtIG9mIHRoaXMgam9pbnQgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIGpvaW50IHBvc2Ugb24gZWFjaCBmcmFtZVxuICAgICAgICAgICAgICAgIHZhciBfam9pbnQgPSBuZXcgR3JvdXAoKTtcblxuICAgICAgICAgICAgICAgIF9qb2ludC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX2pvaW50LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYW5kLmpvaW50c1tpbnB1dGpvaW50LmpvaW50TmFtZV0gPSBfam9pbnQ7IC8vID8/XG5cbiAgICAgICAgICAgICAgICBoYW5kLmFkZChfam9pbnQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGpvaW50ID0gaGFuZC5qb2ludHNbaW5wdXRqb2ludC5qb2ludE5hbWVdO1xuXG4gICAgICAgICAgICAgIGlmIChqb2ludFBvc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBqb2ludC5tYXRyaXguZnJvbUFycmF5KGpvaW50UG9zZS50cmFuc2Zvcm0ubWF0cml4KTtcbiAgICAgICAgICAgICAgICBqb2ludC5tYXRyaXguZGVjb21wb3NlKGpvaW50LnBvc2l0aW9uLCBqb2ludC5yb3RhdGlvbiwgam9pbnQuc2NhbGUpO1xuICAgICAgICAgICAgICAgIGpvaW50LmpvaW50UmFkaXVzID0gam9pbnRQb3NlLnJhZGl1cztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGpvaW50LnZpc2libGUgPSBqb2ludFBvc2UgIT09IG51bGw7XG4gICAgICAgICAgICB9IC8vIEN1c3RvbSBldmVudHNcbiAgICAgICAgICAgIC8vIENoZWNrIHBpbmNoelxuXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZGV4VGlwID0gaGFuZC5qb2ludHNbJ2luZGV4LWZpbmdlci10aXAnXTtcbiAgICAgICAgICB2YXIgdGh1bWJUaXAgPSBoYW5kLmpvaW50c1sndGh1bWItdGlwJ107XG4gICAgICAgICAgdmFyIGRpc3RhbmNlID0gaW5kZXhUaXAucG9zaXRpb24uZGlzdGFuY2VUbyh0aHVtYlRpcC5wb3NpdGlvbik7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlVG9QaW5jaCA9IDAuMDI7XG4gICAgICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMDA1O1xuXG4gICAgICAgICAgaWYgKGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyAmJiBkaXN0YW5jZSA+IGRpc3RhbmNlVG9QaW5jaCArIHRocmVzaG9sZCkge1xuICAgICAgICAgICAgaGFuZC5pbnB1dFN0YXRlLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICB0eXBlOiAncGluY2hlbmQnLFxuICAgICAgICAgICAgICBoYW5kZWRuZXNzOiBpbnB1dFNvdXJjZS5oYW5kZWRuZXNzLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyAmJiBkaXN0YW5jZSA8PSBkaXN0YW5jZVRvUGluY2ggLSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIGhhbmQuaW5wdXRTdGF0ZS5waW5jaGluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICB0eXBlOiAncGluY2hzdGFydCcsXG4gICAgICAgICAgICAgIGhhbmRlZG5lc3M6IGlucHV0U291cmNlLmhhbmRlZG5lc3MsXG4gICAgICAgICAgICAgIHRhcmdldDogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChncmlwICE9PSBudWxsICYmIGlucHV0U291cmNlLmdyaXBTcGFjZSkge1xuICAgICAgICAgICAgZ3JpcFBvc2UgPSBmcmFtZS5nZXRQb3NlKGlucHV0U291cmNlLmdyaXBTcGFjZSwgcmVmZXJlbmNlU3BhY2UpO1xuXG4gICAgICAgICAgICBpZiAoZ3JpcFBvc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZ3JpcC5tYXRyaXguZnJvbUFycmF5KGdyaXBQb3NlLnRyYW5zZm9ybS5tYXRyaXgpO1xuICAgICAgICAgICAgICBncmlwLm1hdHJpeC5kZWNvbXBvc2UoZ3JpcC5wb3NpdGlvbiwgZ3JpcC5yb3RhdGlvbiwgZ3JpcC5zY2FsZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGdyaXBQb3NlLmxpbmVhclZlbG9jaXR5KSB7XG4gICAgICAgICAgICAgICAgZ3JpcC5oYXNMaW5lYXJWZWxvY2l0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZ3JpcC5saW5lYXJWZWxvY2l0eS5jb3B5KGdyaXBQb3NlLmxpbmVhclZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlwLmhhc0xpbmVhclZlbG9jaXR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5KSB7XG4gICAgICAgICAgICAgICAgZ3JpcC5oYXNBbmd1bGFyVmVsb2NpdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdyaXAuYW5ndWxhclZlbG9jaXR5LmNvcHkoZ3JpcFBvc2UuYW5ndWxhclZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncmlwLmhhc0FuZ3VsYXJWZWxvY2l0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRSYXkgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0UmF5LnZpc2libGUgPSBpbnB1dFBvc2UgIT09IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChncmlwICE9PSBudWxsKSB7XG4gICAgICAgIGdyaXAudmlzaWJsZSA9IGdyaXBQb3NlICE9PSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFuZCAhPT0gbnVsbCkge1xuICAgICAgICBoYW5kLnZpc2libGUgPSBoYW5kUG9zZSAhPT0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYlhSQ29udHJvbGxlcjtcbn0oKTtcblxudmFyIERlcHRoVGV4dHVyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RleHR1cmU0KSB7XG4gIF9pbmhlcml0cyhEZXB0aFRleHR1cmUsIF9UZXh0dXJlNCk7XG5cbiAgdmFyIF9zdXBlcjM2ID0gX2NyZWF0ZVN1cGVyKERlcHRoVGV4dHVyZSk7XG5cbiAgZnVuY3Rpb24gRGVwdGhUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGZvcm1hdCkge1xuICAgIHZhciBfdGhpczI4O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlcHRoVGV4dHVyZSk7XG5cbiAgICBmb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IERlcHRoRm9ybWF0O1xuXG4gICAgaWYgKGZvcm1hdCAhPT0gRGVwdGhGb3JtYXQgJiYgZm9ybWF0ICE9PSBEZXB0aFN0ZW5jaWxGb3JtYXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGVwdGhUZXh0dXJlIGZvcm1hdCBtdXN0IGJlIGVpdGhlciBUSFJFRS5EZXB0aEZvcm1hdCBvciBUSFJFRS5EZXB0aFN0ZW5jaWxGb3JtYXQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhGb3JtYXQpIHR5cGUgPSBVbnNpZ25lZEludFR5cGU7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCkgdHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcbiAgICBfdGhpczI4ID0gX3N1cGVyMzYuY2FsbCh0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpO1xuICAgIF90aGlzMjguaXNEZXB0aFRleHR1cmUgPSB0cnVlO1xuICAgIF90aGlzMjguaW1hZ2UgPSB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gICAgX3RoaXMyOC5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG4gICAgX3RoaXMyOC5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG4gICAgX3RoaXMyOC5mbGlwWSA9IGZhbHNlO1xuICAgIF90aGlzMjguZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzMjg7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERlcHRoVGV4dHVyZSk7XG59KFRleHR1cmUpO1xuXG52YXIgV2ViWFJNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnREaXNwYXRjaGVyNikge1xuICBfaW5oZXJpdHMoV2ViWFJNYW5hZ2VyLCBfRXZlbnREaXNwYXRjaGVyNik7XG5cbiAgdmFyIF9zdXBlcjM3ID0gX2NyZWF0ZVN1cGVyKFdlYlhSTWFuYWdlcik7XG5cbiAgZnVuY3Rpb24gV2ViWFJNYW5hZ2VyKHJlbmRlcmVyLCBnbCkge1xuICAgIHZhciBfdGhpczI5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYlhSTWFuYWdlcik7XG5cbiAgICBfdGhpczI5ID0gX3N1cGVyMzcuY2FsbCh0aGlzKTtcblxuICAgIHZhciBzY29wZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyOSk7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IG51bGw7XG4gICAgdmFyIGZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSAxLjA7XG4gICAgdmFyIHJlZmVyZW5jZVNwYWNlID0gbnVsbDtcbiAgICB2YXIgcmVmZXJlbmNlU3BhY2VUeXBlID0gJ2xvY2FsLWZsb29yJztcbiAgICB2YXIgY3VzdG9tUmVmZXJlbmNlU3BhY2UgPSBudWxsO1xuICAgIHZhciBwb3NlID0gbnVsbDtcbiAgICB2YXIgZ2xCaW5kaW5nID0gbnVsbDtcbiAgICB2YXIgZ2xQcm9qTGF5ZXIgPSBudWxsO1xuICAgIHZhciBnbEJhc2VMYXllciA9IG51bGw7XG4gICAgdmFyIHhyRnJhbWUgPSBudWxsO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcbiAgICB2YXIgaW5pdGlhbFJlbmRlclRhcmdldCA9IG51bGw7XG4gICAgdmFyIG5ld1JlbmRlclRhcmdldCA9IG51bGw7XG4gICAgdmFyIGNvbnRyb2xsZXJzID0gW107XG4gICAgdmFyIGlucHV0U291cmNlc01hcCA9IG5ldyBNYXAoKTsgLy9cblxuICAgIHZhciBjYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG4gICAgY2FtZXJhTC5sYXllcnMuZW5hYmxlKDEpO1xuICAgIGNhbWVyYUwudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuICAgIHZhciBjYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG4gICAgY2FtZXJhUi5sYXllcnMuZW5hYmxlKDIpO1xuICAgIGNhbWVyYVIudmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuICAgIHZhciBjYW1lcmFzID0gW2NhbWVyYUwsIGNhbWVyYVJdO1xuICAgIHZhciBjYW1lcmFWUiA9IG5ldyBBcnJheUNhbWVyYSgpO1xuICAgIGNhbWVyYVZSLmxheWVycy5lbmFibGUoMSk7XG4gICAgY2FtZXJhVlIubGF5ZXJzLmVuYWJsZSgyKTtcbiAgICB2YXIgX2N1cnJlbnREZXB0aE5lYXIgPSBudWxsO1xuICAgIHZhciBfY3VycmVudERlcHRoRmFyID0gbnVsbDsgLy9cblxuICAgIF90aGlzMjkuY2FtZXJhQXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgX3RoaXMyOS5lbmFibGVkID0gZmFsc2U7XG4gICAgX3RoaXMyOS5pc1ByZXNlbnRpbmcgPSBmYWxzZTtcblxuICAgIF90aGlzMjkuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1tpbmRleF07XG5cbiAgICAgIGlmIChjb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcbiAgICAgICAgY29udHJvbGxlcnNbaW5kZXhdID0gY29udHJvbGxlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZ2V0VGFyZ2V0UmF5U3BhY2UoKTtcbiAgICB9O1xuXG4gICAgX3RoaXMyOS5nZXRDb250cm9sbGVyR3JpcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1tpbmRleF07XG5cbiAgICAgIGlmIChjb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcbiAgICAgICAgY29udHJvbGxlcnNbaW5kZXhdID0gY29udHJvbGxlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZ2V0R3JpcFNwYWNlKCk7XG4gICAgfTtcblxuICAgIF90aGlzMjkuZ2V0SGFuZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1tpbmRleF07XG5cbiAgICAgIGlmIChjb250cm9sbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udHJvbGxlciA9IG5ldyBXZWJYUkNvbnRyb2xsZXIoKTtcbiAgICAgICAgY29udHJvbGxlcnNbaW5kZXhdID0gY29udHJvbGxlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZ2V0SGFuZFNwYWNlKCk7XG4gICAgfTsgLy9cblxuXG4gICAgZnVuY3Rpb24gb25TZXNzaW9uRXZlbnQoZXZlbnQpIHtcbiAgICAgIHZhciBjb250cm9sbGVyID0gaW5wdXRTb3VyY2VzTWFwLmdldChldmVudC5pbnB1dFNvdXJjZSk7XG5cbiAgICAgIGlmIChjb250cm9sbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udHJvbGxlci5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiBldmVudC50eXBlLFxuICAgICAgICAgIGRhdGE6IGV2ZW50LmlucHV0U291cmNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uU2Vzc2lvbkVuZCgpIHtcbiAgICAgIHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0Jywgb25TZXNzaW9uRXZlbnQpO1xuICAgICAgc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIG9uU2Vzc2lvbkV2ZW50KTtcbiAgICAgIHNlc3Npb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0ZW5kJywgb25TZXNzaW9uRXZlbnQpO1xuICAgICAgc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzcXVlZXplJywgb25TZXNzaW9uRXZlbnQpO1xuICAgICAgc2Vzc2lvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzcXVlZXplc3RhcnQnLCBvblNlc3Npb25FdmVudCk7XG4gICAgICBzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NxdWVlemVlbmQnLCBvblNlc3Npb25FdmVudCk7XG4gICAgICBzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIG9uU2Vzc2lvbkVuZCk7XG4gICAgICBzZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0c291cmNlc2NoYW5nZScsIG9uSW5wdXRTb3VyY2VzQ2hhbmdlKTtcbiAgICAgIGlucHV0U291cmNlc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyLCBpbnB1dFNvdXJjZSkge1xuICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29udHJvbGxlci5kaXNjb25uZWN0KGlucHV0U291cmNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnB1dFNvdXJjZXNNYXAuY2xlYXIoKTtcbiAgICAgIF9jdXJyZW50RGVwdGhOZWFyID0gbnVsbDtcbiAgICAgIF9jdXJyZW50RGVwdGhGYXIgPSBudWxsOyAvLyByZXN0b3JlIGZyYW1lYnVmZmVyL3JlbmRlcmluZyBzdGF0ZVxuXG4gICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoaW5pdGlhbFJlbmRlclRhcmdldCk7XG4gICAgICBnbEJhc2VMYXllciA9IG51bGw7XG4gICAgICBnbFByb2pMYXllciA9IG51bGw7XG4gICAgICBnbEJpbmRpbmcgPSBudWxsO1xuICAgICAgc2Vzc2lvbiA9IG51bGw7XG4gICAgICBuZXdSZW5kZXJUYXJnZXQgPSBudWxsOyAvL1xuXG4gICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgICAgc2NvcGUuaXNQcmVzZW50aW5nID0gZmFsc2U7XG4gICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogJ3Nlc3Npb25lbmQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfdGhpczI5LnNldEZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGZyYW1lYnVmZmVyU2NhbGVGYWN0b3IgPSB2YWx1ZTtcblxuICAgICAgaWYgKHNjb3BlLmlzUHJlc2VudGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLldlYlhSTWFuYWdlcjogQ2Fubm90IGNoYW5nZSBmcmFtZWJ1ZmZlciBzY2FsZSB3aGlsZSBwcmVzZW50aW5nLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpczI5LnNldFJlZmVyZW5jZVNwYWNlVHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmVmZXJlbmNlU3BhY2VUeXBlID0gdmFsdWU7XG5cbiAgICAgIGlmIChzY29wZS5pc1ByZXNlbnRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJYUk1hbmFnZXI6IENhbm5vdCBjaGFuZ2UgcmVmZXJlbmNlIHNwYWNlIHR5cGUgd2hpbGUgcHJlc2VudGluZy4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMyOS5nZXRSZWZlcmVuY2VTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXN0b21SZWZlcmVuY2VTcGFjZSB8fCByZWZlcmVuY2VTcGFjZTtcbiAgICB9O1xuXG4gICAgX3RoaXMyOS5zZXRSZWZlcmVuY2VTcGFjZSA9IGZ1bmN0aW9uIChzcGFjZSkge1xuICAgICAgY3VzdG9tUmVmZXJlbmNlU3BhY2UgPSBzcGFjZTtcbiAgICB9O1xuXG4gICAgX3RoaXMyOS5nZXRCYXNlTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2xQcm9qTGF5ZXIgIT09IG51bGwgPyBnbFByb2pMYXllciA6IGdsQmFzZUxheWVyO1xuICAgIH07XG5cbiAgICBfdGhpczI5LmdldEJpbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2xCaW5kaW5nO1xuICAgIH07XG5cbiAgICBfdGhpczI5LmdldEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHhyRnJhbWU7XG4gICAgfTtcblxuICAgIF90aGlzMjkuZ2V0U2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgIH07XG5cbiAgICBfdGhpczI5LnNldFNlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHZhbHVlKSB7XG4gICAgICAgIHZhciBsYXllckluaXQsIGRlcHRoRm9ybWF0LCBkZXB0aFR5cGUsIGdsRGVwdGhGb3JtYXQsIHByb2plY3Rpb25sYXllckluaXQsIHJlbmRlclRhcmdldFByb3BlcnRpZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQ4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgc2Vzc2lvbiA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoc2Vzc2lvbiAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbml0aWFsUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3QnLCBvblNlc3Npb25FdmVudCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIG9uU2Vzc2lvbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVuZCcsIG9uU2Vzc2lvbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ3NxdWVlemUnLCBvblNlc3Npb25FdmVudCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzcXVlZXplc3RhcnQnLCBvblNlc3Npb25FdmVudCk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdzcXVlZXplZW5kJywgb25TZXNzaW9uRXZlbnQpO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgb25TZXNzaW9uRW5kKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0c291cmNlc2NoYW5nZScsIG9uSW5wdXRTb3VyY2VzQ2hhbmdlKTtcblxuICAgICAgICAgICAgICAgIGlmICghKGF0dHJpYnV0ZXMueHJDb21wYXRpYmxlICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsLm1ha2VYUkNvbXBhdGlibGUoKTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uLnJlbmRlclN0YXRlLmxheWVycyA9PT0gdW5kZWZpbmVkIHx8IHJlbmRlcmVyLmNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIGxheWVySW5pdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYW50aWFsaWFzOiBzZXNzaW9uLnJlbmRlclN0YXRlLmxheWVycyA9PT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5hbnRpYWxpYXMgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTogYXR0cmlidXRlcy5hbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgZGVwdGg6IGF0dHJpYnV0ZXMuZGVwdGgsXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWw6IGF0dHJpYnV0ZXMuc3RlbmNpbCxcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVidWZmZXJTY2FsZUZhY3RvcjogZnJhbWVidWZmZXJTY2FsZUZhY3RvclxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGdsQmFzZUxheWVyID0gbmV3IFhSV2ViR0xMYXllcihzZXNzaW9uLCBnbCwgbGF5ZXJJbml0KTtcbiAgICAgICAgICAgICAgICAgIHNlc3Npb24udXBkYXRlUmVuZGVyU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBiYXNlTGF5ZXI6IGdsQmFzZUxheWVyXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIG5ld1JlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldChnbEJhc2VMYXllci5mcmFtZWJ1ZmZlcldpZHRoLCBnbEJhc2VMYXllci5mcmFtZWJ1ZmZlckhlaWdodCwge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFJHQkFGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFVuc2lnbmVkQnl0ZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nOiByZW5kZXJlci5vdXRwdXRFbmNvZGluZ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRlcHRoRm9ybWF0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGRlcHRoVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBnbERlcHRoRm9ybWF0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xEZXB0aEZvcm1hdCA9IGF0dHJpYnV0ZXMuc3RlbmNpbCA/IDM1MDU2IDogMzMxOTA7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoRm9ybWF0ID0gYXR0cmlidXRlcy5zdGVuY2lsID8gRGVwdGhTdGVuY2lsRm9ybWF0IDogRGVwdGhGb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoVHlwZSA9IGF0dHJpYnV0ZXMuc3RlbmNpbCA/IFVuc2lnbmVkSW50MjQ4VHlwZSA6IFVuc2lnbmVkSW50VHlwZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbmxheWVySW5pdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JGb3JtYXQ6IHJlbmRlcmVyLm91dHB1dEVuY29kaW5nID09PSBzUkdCRW5jb2RpbmcgPyAzNTkwNyA6IDMyODU2LFxuICAgICAgICAgICAgICAgICAgICBkZXB0aEZvcm1hdDogZ2xEZXB0aEZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVGYWN0b3I6IGZyYW1lYnVmZmVyU2NhbGVGYWN0b3JcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBnbEJpbmRpbmcgPSBuZXcgWFJXZWJHTEJpbmRpbmcoc2Vzc2lvbiwgZ2wpO1xuICAgICAgICAgICAgICAgICAgZ2xQcm9qTGF5ZXIgPSBnbEJpbmRpbmcuY3JlYXRlUHJvamVjdGlvbkxheWVyKHByb2plY3Rpb25sYXllckluaXQpO1xuICAgICAgICAgICAgICAgICAgc2Vzc2lvbi51cGRhdGVSZW5kZXJTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyczogW2dsUHJvakxheWVyXVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBuZXdSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoZ2xQcm9qTGF5ZXIudGV4dHVyZVdpZHRoLCBnbFByb2pMYXllci50ZXh0dXJlSGVpZ2h0LCB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogUkdCQUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogVW5zaWduZWRCeXRlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZGVwdGhUZXh0dXJlOiBuZXcgRGVwdGhUZXh0dXJlKGdsUHJvakxheWVyLnRleHR1cmVXaWR0aCwgZ2xQcm9qTGF5ZXIudGV4dHVyZUhlaWdodCwgZGVwdGhUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkZXB0aEZvcm1hdCksXG4gICAgICAgICAgICAgICAgICAgIHN0ZW5jaWxCdWZmZXI6IGF0dHJpYnV0ZXMuc3RlbmNpbCxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6IHJlbmRlcmVyLm91dHB1dEVuY29kaW5nLFxuICAgICAgICAgICAgICAgICAgICBzYW1wbGVzOiBhdHRyaWJ1dGVzLmFudGlhbGlhcyA/IDQgOiAwXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSByZW5kZXJlci5wcm9wZXJ0aWVzLmdldChuZXdSZW5kZXJUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2lnbm9yZURlcHRoVmFsdWVzID0gZ2xQcm9qTGF5ZXIuaWdub3JlRGVwdGhWYWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3UmVuZGVyVGFyZ2V0LmlzWFJSZW5kZXJUYXJnZXQgPSB0cnVlOyAvLyBUT0RPIFJlbW92ZSB0aGlzIHdoZW4gcG9zc2libGUsIHNlZSAjMjMyNzhcbiAgICAgICAgICAgICAgICAvLyBTZXQgZm92ZWF0aW9uIHRvIG1heGltdW0uXG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldEZvdmVhdGlvbigxLjApO1xuICAgICAgICAgICAgICAgIGN1c3RvbVJlZmVyZW5jZVNwYWNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLnJlcXVlc3RSZWZlcmVuY2VTcGFjZShyZWZlcmVuY2VTcGFjZVR5cGUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlU3BhY2UgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uc2V0Q29udGV4dChzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBzY29wZS5pc1ByZXNlbnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3Nlc3Npb25zdGFydCdcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgZnVuY3Rpb24gb25JbnB1dFNvdXJjZXNDaGFuZ2UoZXZlbnQpIHtcbiAgICAgIHZhciBpbnB1dFNvdXJjZXMgPSBzZXNzaW9uLmlucHV0U291cmNlczsgLy8gQXNzaWduIGNvbnRyb2xsZXJzIHRvIGF2YWlsYWJsZSBpbnB1dFNvdXJjZXNcblxuICAgICAgZm9yICh2YXIgX2kxNDYgPSAwOyBfaTE0NiA8IGlucHV0U291cmNlcy5sZW5ndGg7IF9pMTQ2KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5wdXRTb3VyY2VzW19pMTQ2XS5oYW5kZWRuZXNzID09PSAncmlnaHQnID8gMSA6IDA7XG4gICAgICAgIGlucHV0U291cmNlc01hcC5zZXQoaW5wdXRTb3VyY2VzW19pMTQ2XSwgY29udHJvbGxlcnNbaW5kZXhdKTtcbiAgICAgIH0gLy8gTm90aWZ5IGRpc2Nvbm5lY3RlZFxuXG5cbiAgICAgIGZvciAodmFyIF9pMTQ3ID0gMDsgX2kxNDcgPCBldmVudC5yZW1vdmVkLmxlbmd0aDsgX2kxNDcrKykge1xuICAgICAgICB2YXIgaW5wdXRTb3VyY2UgPSBldmVudC5yZW1vdmVkW19pMTQ3XTtcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBpbnB1dFNvdXJjZXNNYXAuZ2V0KGlucHV0U291cmNlKTtcblxuICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIGRhdGE6IGlucHV0U291cmNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5wdXRTb3VyY2VzTWFwLmRlbGV0ZShpbnB1dFNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTm90aWZ5IGNvbm5lY3RlZFxuXG5cbiAgICAgIGZvciAodmFyIF9pMTQ4ID0gMDsgX2kxNDggPCBldmVudC5hZGRlZC5sZW5ndGg7IF9pMTQ4KyspIHtcbiAgICAgICAgdmFyIF9pbnB1dFNvdXJjZSA9IGV2ZW50LmFkZGVkW19pMTQ4XTtcblxuICAgICAgICB2YXIgX2NvbnRyb2xsZXIgPSBpbnB1dFNvdXJjZXNNYXAuZ2V0KF9pbnB1dFNvdXJjZSk7XG5cbiAgICAgICAgaWYgKF9jb250cm9sbGVyKSB7XG4gICAgICAgICAgX2NvbnRyb2xsZXIuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgIGRhdGE6IF9pbnB1dFNvdXJjZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvL1xuXG5cbiAgICB2YXIgY2FtZXJhTFBvcyA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIGNhbWVyYVJQb3MgPSBuZXcgVmVjdG9yMygpO1xuICAgIC8qKlxuICAgICAqIEFzc3VtZXMgMiBjYW1lcmFzIHRoYXQgYXJlIHBhcmFsbGVsIGFuZCBzaGFyZSBhbiBYLWF4aXMsIGFuZCB0aGF0XG4gICAgICogdGhlIGNhbWVyYXMnIHByb2plY3Rpb24gYW5kIHdvcmxkIG1hdHJpY2VzIGhhdmUgYWxyZWFkeSBiZWVuIHNldC5cbiAgICAgKiBBbmQgdGhhdCBuZWFyIGFuZCBmYXIgcGxhbmVzIGFyZSBpZGVudGljYWwgZm9yIGJvdGggY2FtZXJhcy5cbiAgICAgKiBWaXN1YWxpemF0aW9uIG9mIHRoaXMgdGVjaG5pcXVlOiBodHRwczovL2NvbXB1dGVyZ3JhcGhpY3Muc3RhY2tleGNoYW5nZS5jb20vYS80NzY1XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKGNhbWVyYSwgY2FtZXJhTCwgY2FtZXJhUikge1xuICAgICAgY2FtZXJhTFBvcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhTC5tYXRyaXhXb3JsZCk7XG4gICAgICBjYW1lcmFSUG9zLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmFSLm1hdHJpeFdvcmxkKTtcbiAgICAgIHZhciBpcGQgPSBjYW1lcmFMUG9zLmRpc3RhbmNlVG8oY2FtZXJhUlBvcyk7XG4gICAgICB2YXIgcHJvakwgPSBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7XG4gICAgICB2YXIgcHJvalIgPSBjYW1lcmFSLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHM7IC8vIFZSIHN5c3RlbXMgd2lsbCBoYXZlIGlkZW50aWNhbCBmYXIgYW5kIG5lYXIgcGxhbmVzLCBhbmRcbiAgICAgIC8vIG1vc3QgbGlrZWx5IGlkZW50aWNhbCB0b3AgYW5kIGJvdHRvbSBmcnVzdHVtIGV4dGVudHMuXG4gICAgICAvLyBVc2UgdGhlIGxlZnQgY2FtZXJhIGZvciB0aGVzZSB2YWx1ZXMuXG5cbiAgICAgIHZhciBuZWFyID0gcHJvakxbMTRdIC8gKHByb2pMWzEwXSAtIDEpO1xuICAgICAgdmFyIGZhciA9IHByb2pMWzE0XSAvIChwcm9qTFsxMF0gKyAxKTtcbiAgICAgIHZhciB0b3BGb3YgPSAocHJvakxbOV0gKyAxKSAvIHByb2pMWzVdO1xuICAgICAgdmFyIGJvdHRvbUZvdiA9IChwcm9qTFs5XSAtIDEpIC8gcHJvakxbNV07XG4gICAgICB2YXIgbGVmdEZvdiA9IChwcm9qTFs4XSAtIDEpIC8gcHJvakxbMF07XG4gICAgICB2YXIgcmlnaHRGb3YgPSAocHJvalJbOF0gKyAxKSAvIHByb2pSWzBdO1xuICAgICAgdmFyIGxlZnQgPSBuZWFyICogbGVmdEZvdjtcbiAgICAgIHZhciByaWdodCA9IG5lYXIgKiByaWdodEZvdjsgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgY2FtZXJhJ3MgcG9zaXRpb24gb2Zmc2V0IGZyb20gdGhlXG4gICAgICAvLyBsZWZ0IGNhbWVyYS4geE9mZnNldCBzaG91bGQgYmUgcm91Z2hseSBoYWxmIGBpcGRgLlxuXG4gICAgICB2YXIgek9mZnNldCA9IGlwZCAvICgtbGVmdEZvdiArIHJpZ2h0Rm92KTtcbiAgICAgIHZhciB4T2Zmc2V0ID0gek9mZnNldCAqIC1sZWZ0Rm92OyAvLyBUT0RPOiBCZXR0ZXIgd2F5IHRvIGFwcGx5IHRoaXMgb2Zmc2V0P1xuXG4gICAgICBjYW1lcmFMLm1hdHJpeFdvcmxkLmRlY29tcG9zZShjYW1lcmEucG9zaXRpb24sIGNhbWVyYS5xdWF0ZXJuaW9uLCBjYW1lcmEuc2NhbGUpO1xuICAgICAgY2FtZXJhLnRyYW5zbGF0ZVgoeE9mZnNldCk7XG4gICAgICBjYW1lcmEudHJhbnNsYXRlWih6T2Zmc2V0KTtcbiAgICAgIGNhbWVyYS5tYXRyaXhXb3JsZC5jb21wb3NlKGNhbWVyYS5wb3NpdGlvbiwgY2FtZXJhLnF1YXRlcm5pb24sIGNhbWVyYS5zY2FsZSk7XG4gICAgICBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoY2FtZXJhLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTsgLy8gRmluZCB0aGUgdW5pb24gb2YgdGhlIGZydXN0dW0gdmFsdWVzIG9mIHRoZSBjYW1lcmFzIGFuZCBzY2FsZVxuICAgICAgLy8gdGhlIHZhbHVlcyBzbyB0aGF0IHRoZSBuZWFyIHBsYW5lJ3MgcG9zaXRpb24gZG9lcyBub3QgY2hhbmdlIGluIHdvcmxkIHNwYWNlLFxuICAgICAgLy8gYWx0aG91Z2ggbXVzdCBub3cgYmUgcmVsYXRpdmUgdG8gdGhlIG5ldyB1bmlvbiBjYW1lcmEuXG5cbiAgICAgIHZhciBuZWFyMiA9IG5lYXIgKyB6T2Zmc2V0O1xuICAgICAgdmFyIGZhcjIgPSBmYXIgKyB6T2Zmc2V0O1xuICAgICAgdmFyIGxlZnQyID0gbGVmdCAtIHhPZmZzZXQ7XG4gICAgICB2YXIgcmlnaHQyID0gcmlnaHQgKyAoaXBkIC0geE9mZnNldCk7XG4gICAgICB2YXIgdG9wMiA9IHRvcEZvdiAqIGZhciAvIGZhcjIgKiBuZWFyMjtcbiAgICAgIHZhciBib3R0b20yID0gYm90dG9tRm92ICogZmFyIC8gZmFyMiAqIG5lYXIyO1xuICAgICAgY2FtZXJhLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKGxlZnQyLCByaWdodDIsIHRvcDIsIGJvdHRvbTIsIG5lYXIyLCBmYXIyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDYW1lcmEoY2FtZXJhLCBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgY2FtZXJhLm1hdHJpeFdvcmxkLmNvcHkoY2FtZXJhLm1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW1lcmEubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyhwYXJlbnQubWF0cml4V29ybGQsIGNhbWVyYS5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoY2FtZXJhLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICB9XG5cbiAgICBfdGhpczI5LnVwZGF0ZUNhbWVyYSA9IGZ1bmN0aW9uIChjYW1lcmEpIHtcbiAgICAgIGlmIChzZXNzaW9uID09PSBudWxsKSByZXR1cm47XG4gICAgICBjYW1lcmFWUi5uZWFyID0gY2FtZXJhUi5uZWFyID0gY2FtZXJhTC5uZWFyID0gY2FtZXJhLm5lYXI7XG4gICAgICBjYW1lcmFWUi5mYXIgPSBjYW1lcmFSLmZhciA9IGNhbWVyYUwuZmFyID0gY2FtZXJhLmZhcjtcblxuICAgICAgaWYgKF9jdXJyZW50RGVwdGhOZWFyICE9PSBjYW1lcmFWUi5uZWFyIHx8IF9jdXJyZW50RGVwdGhGYXIgIT09IGNhbWVyYVZSLmZhcikge1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIG5ldyByZW5kZXJTdGF0ZSB3b24ndCBhcHBseSB1bnRpbCB0aGUgbmV4dCBmcmFtZS4gU2VlICMxODMyMFxuICAgICAgICBzZXNzaW9uLnVwZGF0ZVJlbmRlclN0YXRlKHtcbiAgICAgICAgICBkZXB0aE5lYXI6IGNhbWVyYVZSLm5lYXIsXG4gICAgICAgICAgZGVwdGhGYXI6IGNhbWVyYVZSLmZhclxuICAgICAgICB9KTtcbiAgICAgICAgX2N1cnJlbnREZXB0aE5lYXIgPSBjYW1lcmFWUi5uZWFyO1xuICAgICAgICBfY3VycmVudERlcHRoRmFyID0gY2FtZXJhVlIuZmFyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gY2FtZXJhLnBhcmVudDtcbiAgICAgIHZhciBjYW1lcmFzID0gY2FtZXJhVlIuY2FtZXJhcztcbiAgICAgIHVwZGF0ZUNhbWVyYShjYW1lcmFWUiwgcGFyZW50KTtcblxuICAgICAgZm9yICh2YXIgX2kxNDkgPSAwOyBfaTE0OSA8IGNhbWVyYXMubGVuZ3RoOyBfaTE0OSsrKSB7XG4gICAgICAgIHVwZGF0ZUNhbWVyYShjYW1lcmFzW19pMTQ5XSwgcGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgY2FtZXJhVlIubWF0cml4V29ybGQuZGVjb21wb3NlKGNhbWVyYVZSLnBvc2l0aW9uLCBjYW1lcmFWUi5xdWF0ZXJuaW9uLCBjYW1lcmFWUi5zY2FsZSk7IC8vIHVwZGF0ZSB1c2VyIGNhbWVyYSBhbmQgaXRzIGNoaWxkcmVuXG5cbiAgICAgIGNhbWVyYS5wb3NpdGlvbi5jb3B5KGNhbWVyYVZSLnBvc2l0aW9uKTtcbiAgICAgIGNhbWVyYS5xdWF0ZXJuaW9uLmNvcHkoY2FtZXJhVlIucXVhdGVybmlvbik7XG4gICAgICBjYW1lcmEuc2NhbGUuY29weShjYW1lcmFWUi5zY2FsZSk7XG4gICAgICBjYW1lcmEubWF0cml4LmNvcHkoY2FtZXJhVlIubWF0cml4KTtcbiAgICAgIGNhbWVyYS5tYXRyaXhXb3JsZC5jb3B5KGNhbWVyYVZSLm1hdHJpeFdvcmxkKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNhbWVyYS5jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgX2kxNTAgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBfaTE1MCA8IGw7IF9pMTUwKyspIHtcbiAgICAgICAgY2hpbGRyZW5bX2kxNTBdLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgICAgfSAvLyB1cGRhdGUgcHJvamVjdGlvbiBtYXRyaXggZm9yIHByb3BlciB2aWV3IGZydXN0dW0gY3VsbGluZ1xuXG5cbiAgICAgIGlmIChjYW1lcmFzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBzZXRQcm9qZWN0aW9uRnJvbVVuaW9uKGNhbWVyYVZSLCBjYW1lcmFMLCBjYW1lcmFSKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFzc3VtZSBzaW5nbGUgY2FtZXJhIHNldHVwIChBUilcbiAgICAgICAgY2FtZXJhVlIucHJvamVjdGlvbk1hdHJpeC5jb3B5KGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzMjkuZ2V0Q2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNhbWVyYVZSO1xuICAgIH07XG5cbiAgICBfdGhpczI5LmdldEZvdmVhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnbFByb2pMYXllciAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2xQcm9qTGF5ZXIuZml4ZWRGb3ZlYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChnbEJhc2VMYXllciAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2xCYXNlTGF5ZXIuZml4ZWRGb3ZlYXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIF90aGlzMjkuc2V0Rm92ZWF0aW9uID0gZnVuY3Rpb24gKGZvdmVhdGlvbikge1xuICAgICAgLy8gMCA9IG5vIGZvdmVhdGlvbiA9IGZ1bGwgcmVzb2x1dGlvblxuICAgICAgLy8gMSA9IG1heGltdW0gZm92ZWF0aW9uID0gdGhlIGVkZ2VzIHJlbmRlciBhdCBsb3dlciByZXNvbHV0aW9uXG4gICAgICBpZiAoZ2xQcm9qTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ2xQcm9qTGF5ZXIuZml4ZWRGb3ZlYXRpb24gPSBmb3ZlYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChnbEJhc2VMYXllciAhPT0gbnVsbCAmJiBnbEJhc2VMYXllci5maXhlZEZvdmVhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdsQmFzZUxheWVyLmZpeGVkRm92ZWF0aW9uID0gZm92ZWF0aW9uO1xuICAgICAgfVxuICAgIH07IC8vIEFuaW1hdGlvbiBMb29wXG5cblxuICAgIHZhciBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gb25BbmltYXRpb25GcmFtZSh0aW1lLCBmcmFtZSkge1xuICAgICAgcG9zZSA9IGZyYW1lLmdldFZpZXdlclBvc2UoY3VzdG9tUmVmZXJlbmNlU3BhY2UgfHwgcmVmZXJlbmNlU3BhY2UpO1xuICAgICAgeHJGcmFtZSA9IGZyYW1lO1xuXG4gICAgICBpZiAocG9zZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdmlld3MgPSBwb3NlLnZpZXdzO1xuXG4gICAgICAgIGlmIChnbEJhc2VMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldEZyYW1lYnVmZmVyKG5ld1JlbmRlclRhcmdldCwgZ2xCYXNlTGF5ZXIuZnJhbWVidWZmZXIpO1xuICAgICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChuZXdSZW5kZXJUYXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbWVyYVZSTmVlZHNVcGRhdGUgPSBmYWxzZTsgLy8gY2hlY2sgaWYgaXQncyBuZWNlc3NhcnkgdG8gcmVidWlsZCBjYW1lcmFWUidzIGNhbWVyYSBsaXN0XG5cbiAgICAgICAgaWYgKHZpZXdzLmxlbmd0aCAhPT0gY2FtZXJhVlIuY2FtZXJhcy5sZW5ndGgpIHtcbiAgICAgICAgICBjYW1lcmFWUi5jYW1lcmFzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgY2FtZXJhVlJOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfaTE1MSA9IDA7IF9pMTUxIDwgdmlld3MubGVuZ3RoOyBfaTE1MSsrKSB7XG4gICAgICAgICAgdmFyIHZpZXcgPSB2aWV3c1tfaTE1MV07XG4gICAgICAgICAgdmFyIHZpZXdwb3J0ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChnbEJhc2VMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld3BvcnQgPSBnbEJhc2VMYXllci5nZXRWaWV3cG9ydCh2aWV3KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGdsU3ViSW1hZ2UgPSBnbEJpbmRpbmcuZ2V0Vmlld1N1YkltYWdlKGdsUHJvakxheWVyLCB2aWV3KTtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gZ2xTdWJJbWFnZS52aWV3cG9ydDsgLy8gRm9yIHNpZGUtYnktc2lkZSBwcm9qZWN0aW9uLCB3ZSBvbmx5IHByb2R1Y2UgYSBzaW5nbGUgdGV4dHVyZSBmb3IgYm90aCBleWVzLlxuXG4gICAgICAgICAgICBpZiAoX2kxNTEgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXMobmV3UmVuZGVyVGFyZ2V0LCBnbFN1YkltYWdlLmNvbG9yVGV4dHVyZSwgZ2xQcm9qTGF5ZXIuaWdub3JlRGVwdGhWYWx1ZXMgPyB1bmRlZmluZWQgOiBnbFN1YkltYWdlLmRlcHRoU3RlbmNpbFRleHR1cmUpO1xuICAgICAgICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobmV3UmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2FtZXJhID0gY2FtZXJhc1tfaTE1MV07XG5cbiAgICAgICAgICBpZiAoY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuICAgICAgICAgICAgY2FtZXJhLmxheWVycy5lbmFibGUoX2kxNTEpO1xuICAgICAgICAgICAgY2FtZXJhLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcbiAgICAgICAgICAgIGNhbWVyYXNbX2kxNTFdID0gY2FtZXJhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbWVyYS5tYXRyaXguZnJvbUFycmF5KHZpZXcudHJhbnNmb3JtLm1hdHJpeCk7XG4gICAgICAgICAgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KHZpZXcucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICAgICAgY2FtZXJhLnZpZXdwb3J0LnNldCh2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0KTtcblxuICAgICAgICAgIGlmIChfaTE1MSA9PT0gMCkge1xuICAgICAgICAgICAgY2FtZXJhVlIubWF0cml4LmNvcHkoY2FtZXJhLm1hdHJpeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhbWVyYVZSTmVlZHNVcGRhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNhbWVyYVZSLmNhbWVyYXMucHVzaChjYW1lcmEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvL1xuXG5cbiAgICAgIHZhciBpbnB1dFNvdXJjZXMgPSBzZXNzaW9uLmlucHV0U291cmNlcztcblxuICAgICAgZm9yICh2YXIgX2kxNTIgPSAwOyBfaTE1MiA8IGNvbnRyb2xsZXJzLmxlbmd0aDsgX2kxNTIrKykge1xuICAgICAgICB2YXIgaW5wdXRTb3VyY2UgPSBpbnB1dFNvdXJjZXNbX2kxNTJdO1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IGlucHV0U291cmNlc01hcC5nZXQoaW5wdXRTb3VyY2UpO1xuXG4gICAgICAgIGlmIChjb250cm9sbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnVwZGF0ZShpbnB1dFNvdXJjZSwgZnJhbWUsIGN1c3RvbVJlZmVyZW5jZVNwYWNlIHx8IHJlZmVyZW5jZVNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob25BbmltYXRpb25GcmFtZUNhbGxiYWNrKSBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sodGltZSwgZnJhbWUpO1xuICAgICAgeHJGcmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdGlvbiA9IG5ldyBXZWJHTEFuaW1hdGlvbigpO1xuICAgIGFuaW1hdGlvbi5zZXRBbmltYXRpb25Mb29wKG9uQW5pbWF0aW9uRnJhbWUpO1xuXG4gICAgX3RoaXMyOS5zZXRBbmltYXRpb25Mb29wID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9O1xuXG4gICAgX3RoaXMyOS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICByZXR1cm4gX3RoaXMyOTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoV2ViWFJNYW5hZ2VyKTtcbn0oRXZlbnREaXNwYXRjaGVyKTtcblxuZnVuY3Rpb24gV2ViR0xNYXRlcmlhbHMocmVuZGVyZXIsIHByb3BlcnRpZXMpIHtcbiAgZnVuY3Rpb24gcmVmcmVzaEZvZ1VuaWZvcm1zKHVuaWZvcm1zLCBmb2cpIHtcbiAgICB1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZS5jb3B5KGZvZy5jb2xvcik7XG5cbiAgICBpZiAoZm9nLmlzRm9nKSB7XG4gICAgICB1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XG4gICAgICB1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xuICAgIH0gZWxzZSBpZiAoZm9nLmlzRm9nRXhwMikge1xuICAgICAgdW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zKHVuaWZvcm1zLCBtYXRlcmlhbCwgcGl4ZWxSYXRpbywgaGVpZ2h0LCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQpIHtcbiAgICBpZiAobWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcmVmcmVzaFVuaWZvcm1zQ29tbW9uKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwpIHtcbiAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoVG9vbk1hdGVyaWFsKSB7XG4gICAgICByZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcbiAgICAgIHJlZnJlc2hVbmlmb3Jtc1Rvb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwpIHtcbiAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuICAgICAgcmVmcmVzaFVuaWZvcm1zUGhvbmcodW5pZm9ybXMsIG1hdGVyaWFsKTtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwpIHtcbiAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuICAgICAgcmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQodW5pZm9ybXMsIG1hdGVyaWFsKTtcblxuICAgICAgaWYgKG1hdGVyaWFsLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwpIHtcbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zUGh5c2ljYWwodW5pZm9ybXMsIG1hdGVyaWFsLCB0cmFuc21pc3Npb25SZW5kZXJUYXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNNZXNoTWF0Y2FwTWF0ZXJpYWwpIHtcbiAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuICAgICAgcmVmcmVzaFVuaWZvcm1zTWF0Y2FwKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsKSB7XG4gICAgICByZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpO1xuICAgICAgcmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UodW5pZm9ybXMsIG1hdGVyaWFsKTtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTWVzaE5vcm1hbE1hdGVyaWFsKSB7XG4gICAgICByZWZyZXNoVW5pZm9ybXNDb21tb24odW5pZm9ybXMsIG1hdGVyaWFsKTtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmlzTGluZUJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHJlZnJlc2hVbmlmb3Jtc0xpbmUodW5pZm9ybXMsIG1hdGVyaWFsKTtcblxuICAgICAgaWYgKG1hdGVyaWFsLmlzTGluZURhc2hlZE1hdGVyaWFsKSB7XG4gICAgICAgIHJlZnJlc2hVbmlmb3Jtc0Rhc2godW5pZm9ybXMsIG1hdGVyaWFsKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmlzUG9pbnRzTWF0ZXJpYWwpIHtcbiAgICAgIHJlZnJlc2hVbmlmb3Jtc1BvaW50cyh1bmlmb3JtcywgbWF0ZXJpYWwsIHBpeGVsUmF0aW8sIGhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5pc1Nwcml0ZU1hdGVyaWFsKSB7XG4gICAgICByZWZyZXNoVW5pZm9ybXNTcHJpdGVzKHVuaWZvcm1zLCBtYXRlcmlhbCk7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5pc1NoYWRvd01hdGVyaWFsKSB7XG4gICAgICB1bmlmb3Jtcy5jb2xvci52YWx1ZS5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCkge1xuICAgICAgbWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID0gZmFsc2U7IC8vICMxNTU4MVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbih1bmlmb3JtcywgbWF0ZXJpYWwpIHtcbiAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgIGlmIChtYXRlcmlhbC5jb2xvcikge1xuICAgICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwuZW1pc3NpdmUpIHtcbiAgICAgIHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkobWF0ZXJpYWwuZW1pc3NpdmUpLm11bHRpcGx5U2NhbGFyKG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5KTtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwubWFwKSB7XG4gICAgICB1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG4gICAgICB1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5idW1wTWFwKSB7XG4gICAgICB1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcbiAgICAgIHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcbiAgICAgIGlmIChtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSkgdW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlICo9IC0xO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXApIHtcbiAgICAgIHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcbiAgICAgIHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgICB1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwuZW1pc3NpdmVNYXApIHtcbiAgICAgIHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsLm5vcm1hbE1hcCkge1xuICAgICAgdW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuICAgICAgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weShtYXRlcmlhbC5ub3JtYWxTY2FsZSk7XG4gICAgICBpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLm5lZ2F0ZSgpO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5zcGVjdWxhck1hcCkge1xuICAgICAgdW5pZm9ybXMuc3BlY3VsYXJNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCkge1xuICAgICAgdW5pZm9ybXMuYWxwaGFUZXN0LnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xuICAgIH1cblxuICAgIHZhciBlbnZNYXAgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCkuZW52TWFwO1xuXG4gICAgaWYgKGVudk1hcCkge1xuICAgICAgdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gZW52TWFwO1xuICAgICAgdW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9IGVudk1hcC5pc0N1YmVUZXh0dXJlICYmIGVudk1hcC5pc1JlbmRlclRhcmdldFRleHR1cmUgPT09IGZhbHNlID8gLTEgOiAxO1xuICAgICAgdW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuICAgICAgdW5pZm9ybXMuaW9yLnZhbHVlID0gbWF0ZXJpYWwuaW9yO1xuICAgICAgdW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5saWdodE1hcCkge1xuICAgICAgdW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDsgLy8gYXJ0aXN0LWZyaWVuZGx5IGxpZ2h0IGludGVuc2l0eSBzY2FsaW5nIGZhY3RvclxuXG4gICAgICB2YXIgc2NhbGVGYWN0b3IgPSByZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyAhPT0gdHJ1ZSA/IE1hdGguUEkgOiAxO1xuICAgICAgdW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSAqIHNjYWxlRmFjdG9yO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5hb01hcCkge1xuICAgICAgdW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcbiAgICAgIHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XG4gICAgfSAvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcbiAgICAvLyAxLiBjb2xvciBtYXBcbiAgICAvLyAyLiBzcGVjdWxhciBtYXBcbiAgICAvLyAzLiBkaXNwbGFjZW1lbnRNYXAgbWFwXG4gICAgLy8gNC4gbm9ybWFsIG1hcFxuICAgIC8vIDUuIGJ1bXAgbWFwXG4gICAgLy8gNi4gcm91Z2huZXNzTWFwIG1hcFxuICAgIC8vIDcuIG1ldGFsbmVzc01hcCBtYXBcbiAgICAvLyA4LiBhbHBoYU1hcCBtYXBcbiAgICAvLyA5LiBlbWlzc2l2ZU1hcCBtYXBcbiAgICAvLyAxMC4gY2xlYXJjb2F0IG1hcFxuICAgIC8vIDExLiBjbGVhcmNvYXQgbm9ybWFsIG1hcFxuICAgIC8vIDEyLiBjbGVhcmNvYXQgcm91Z2huZXNzTWFwIG1hcFxuICAgIC8vIDEzLiBpcmlkZXNjZW5jZSBtYXBcbiAgICAvLyAxNC4gaXJpZGVzY2VuY2UgdGhpY2tuZXNzIG1hcFxuICAgIC8vIDE1LiBzcGVjdWxhciBpbnRlbnNpdHkgbWFwXG4gICAgLy8gMTYuIHNwZWN1bGFyIHRpbnQgbWFwXG4gICAgLy8gMTcuIHRyYW5zbWlzc2lvbiBtYXBcbiAgICAvLyAxOC4gdGhpY2tuZXNzIG1hcFxuXG5cbiAgICB2YXIgdXZTY2FsZU1hcDtcblxuICAgIGlmIChtYXRlcmlhbC5tYXApIHtcbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5zcGVjdWxhck1hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwKSB7XG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwubm9ybWFsTWFwKSB7XG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuYnVtcE1hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5yb3VnaG5lc3NNYXApIHtcbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5tZXRhbG5lc3NNYXApIHtcbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5hbHBoYU1hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuZW1pc3NpdmVNYXApIHtcbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmNsZWFyY29hdE1hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmNsZWFyY29hdE1hcDtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcDtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcDtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwKSB7XG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VNYXA7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXApIHtcbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcDtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXApIHtcbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwKSB7XG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwudGhpY2tuZXNzTWFwKSB7XG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwudGhpY2tuZXNzTWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuc2hlZW5Db2xvck1hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNoZWVuQ29sb3JNYXA7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwO1xuICAgIH1cblxuICAgIGlmICh1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICBpZiAodXZTY2FsZU1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgIHV2U2NhbGVNYXAgPSB1dlNjYWxlTWFwLnRleHR1cmU7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcbiAgICAgICAgdXZTY2FsZU1hcC51cGRhdGVNYXRyaXgoKTtcbiAgICAgIH1cblxuICAgICAgdW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weSh1dlNjYWxlTWFwLm1hdHJpeCk7XG4gICAgfSAvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXMgZm9yIHV2MlxuICAgIC8vIDEuIGFvIG1hcFxuICAgIC8vIDIuIGxpZ2h0IG1hcFxuXG5cbiAgICB2YXIgdXYyU2NhbGVNYXA7XG5cbiAgICBpZiAobWF0ZXJpYWwuYW9NYXApIHtcbiAgICAgIHV2MlNjYWxlTWFwID0gbWF0ZXJpYWwuYW9NYXA7XG4gICAgfSBlbHNlIGlmIChtYXRlcmlhbC5saWdodE1hcCkge1xuICAgICAgdXYyU2NhbGVNYXAgPSBtYXRlcmlhbC5saWdodE1hcDtcbiAgICB9XG5cbiAgICBpZiAodXYyU2NhbGVNYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIGlmICh1djJTY2FsZU1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgIHV2MlNjYWxlTWFwID0gdXYyU2NhbGVNYXAudGV4dHVyZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV2MlNjYWxlTWFwLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcbiAgICAgICAgdXYyU2NhbGVNYXAudXBkYXRlTWF0cml4KCk7XG4gICAgICB9XG5cbiAgICAgIHVuaWZvcm1zLnV2MlRyYW5zZm9ybS52YWx1ZS5jb3B5KHV2MlNjYWxlTWFwLm1hdHJpeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcbiAgICB1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcbiAgICB1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuICAgIHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcbiAgICB1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUG9pbnRzKHVuaWZvcm1zLCBtYXRlcmlhbCwgcGl4ZWxSYXRpbywgaGVpZ2h0KSB7XG4gICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcbiAgICB1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZSAqIHBpeGVsUmF0aW87XG4gICAgdW5pZm9ybXMuc2NhbGUudmFsdWUgPSBoZWlnaHQgKiAwLjU7XG5cbiAgICBpZiAobWF0ZXJpYWwubWFwKSB7XG4gICAgICB1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG4gICAgICB1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5hbHBoYVRlc3QgPiAwKSB7XG4gICAgICB1bmlmb3Jtcy5hbHBoYVRlc3QudmFsdWUgPSBtYXRlcmlhbC5hbHBoYVRlc3Q7XG4gICAgfSAvLyB1diByZXBlYXQgYW5kIG9mZnNldCBzZXR0aW5nIHByaW9yaXRpZXNcbiAgICAvLyAxLiBjb2xvciBtYXBcbiAgICAvLyAyLiBhbHBoYSBtYXBcblxuXG4gICAgdmFyIHV2U2NhbGVNYXA7XG5cbiAgICBpZiAobWF0ZXJpYWwubWFwKSB7XG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWFwO1xuICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuYWxwaGFNYXApIHtcbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcbiAgICB9XG5cbiAgICBpZiAodXZTY2FsZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodXZTY2FsZU1hcC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICAgIHV2U2NhbGVNYXAudXBkYXRlTWF0cml4KCk7XG4gICAgICB9XG5cbiAgICAgIHVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkodXZTY2FsZU1hcC5tYXRyaXgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Nwcml0ZXModW5pZm9ybXMsIG1hdGVyaWFsKSB7XG4gICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZS5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcbiAgICB1bmlmb3Jtcy5yb3RhdGlvbi52YWx1ZSA9IG1hdGVyaWFsLnJvdGF0aW9uO1xuXG4gICAgaWYgKG1hdGVyaWFsLm1hcCkge1xuICAgICAgdW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5hbHBoYU1hcCkge1xuICAgICAgdW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwuYWxwaGFUZXN0ID4gMCkge1xuICAgICAgdW5pZm9ybXMuYWxwaGFUZXN0LnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFUZXN0O1xuICAgIH0gLy8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG4gICAgLy8gMS4gY29sb3IgbWFwXG4gICAgLy8gMi4gYWxwaGEgbWFwXG5cblxuICAgIHZhciB1dlNjYWxlTWFwO1xuXG4gICAgaWYgKG1hdGVyaWFsLm1hcCkge1xuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICB9IGVsc2UgaWYgKG1hdGVyaWFsLmFscGhhTWFwKSB7XG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG4gICAgfVxuXG4gICAgaWYgKHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHV2U2NhbGVNYXAubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB1dlNjYWxlTWFwLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgfVxuXG4gICAgICB1bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KHV2U2NhbGVNYXAubWF0cml4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcbiAgICB1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZS5jb3B5KG1hdGVyaWFsLnNwZWN1bGFyKTtcbiAgICB1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBNYXRoLm1heChtYXRlcmlhbC5zaGluaW5lc3MsIDFlLTQpOyAvLyB0byBwcmV2ZW50IHBvdyggMC4wLCAwLjAgKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zVG9vbih1bmlmb3JtcywgbWF0ZXJpYWwpIHtcbiAgICBpZiAobWF0ZXJpYWwuZ3JhZGllbnRNYXApIHtcbiAgICAgIHVuaWZvcm1zLmdyYWRpZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZ3JhZGllbnRNYXA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQodW5pZm9ybXMsIG1hdGVyaWFsKSB7XG4gICAgdW5pZm9ybXMucm91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzO1xuICAgIHVuaWZvcm1zLm1ldGFsbmVzcy52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzcztcblxuICAgIGlmIChtYXRlcmlhbC5yb3VnaG5lc3NNYXApIHtcbiAgICAgIHVuaWZvcm1zLnJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwubWV0YWxuZXNzTWFwKSB7XG4gICAgICB1bmlmb3Jtcy5tZXRhbG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XG4gICAgfVxuXG4gICAgdmFyIGVudk1hcCA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKS5lbnZNYXA7XG5cbiAgICBpZiAoZW52TWFwKSB7XG4gICAgICAvL3VuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDsgLy8gcGFydCBvZiB1bmlmb3JtcyBjb21tb25cbiAgICAgIHVuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcEludGVuc2l0eTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCh1bmlmb3JtcywgbWF0ZXJpYWwsIHRyYW5zbWlzc2lvblJlbmRlclRhcmdldCkge1xuICAgIHVuaWZvcm1zLmlvci52YWx1ZSA9IG1hdGVyaWFsLmlvcjsgLy8gYWxzbyBwYXJ0IG9mIHVuaWZvcm1zIGNvbW1vblxuXG4gICAgaWYgKG1hdGVyaWFsLnNoZWVuID4gMCkge1xuICAgICAgdW5pZm9ybXMuc2hlZW5Db2xvci52YWx1ZS5jb3B5KG1hdGVyaWFsLnNoZWVuQ29sb3IpLm11bHRpcGx5U2NhbGFyKG1hdGVyaWFsLnNoZWVuKTtcbiAgICAgIHVuaWZvcm1zLnNoZWVuUm91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3M7XG5cbiAgICAgIGlmIChtYXRlcmlhbC5zaGVlbkNvbG9yTWFwKSB7XG4gICAgICAgIHVuaWZvcm1zLnNoZWVuQ29sb3JNYXAudmFsdWUgPSBtYXRlcmlhbC5zaGVlbkNvbG9yTWFwO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0ZXJpYWwuc2hlZW5Sb3VnaG5lc3NNYXApIHtcbiAgICAgICAgdW5pZm9ybXMuc2hlZW5Sb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5zaGVlblJvdWdobmVzc01hcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwuY2xlYXJjb2F0ID4gMCkge1xuICAgICAgdW5pZm9ybXMuY2xlYXJjb2F0LnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0O1xuICAgICAgdW5pZm9ybXMuY2xlYXJjb2F0Um91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJjb2F0Um91Z2huZXNzO1xuXG4gICAgICBpZiAobWF0ZXJpYWwuY2xlYXJjb2F0TWFwKSB7XG4gICAgICAgIHVuaWZvcm1zLmNsZWFyY29hdE1hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdE1hcDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCkge1xuICAgICAgICB1bmlmb3Jtcy5jbGVhcmNvYXRSb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3NNYXA7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxNYXApIHtcbiAgICAgICAgdW5pZm9ybXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUudmFsdWUuY29weShtYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSk7XG4gICAgICAgIHVuaWZvcm1zLmNsZWFyY29hdE5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcDtcblxuICAgICAgICBpZiAobWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUpIHtcbiAgICAgICAgICB1bmlmb3Jtcy5jbGVhcmNvYXROb3JtYWxTY2FsZS52YWx1ZS5uZWdhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5pcmlkZXNjZW5jZSA+IDApIHtcbiAgICAgIHVuaWZvcm1zLmlyaWRlc2NlbmNlLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2U7XG4gICAgICB1bmlmb3Jtcy5pcmlkZXNjZW5jZUlPUi52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SO1xuICAgICAgdW5pZm9ybXMuaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtLnZhbHVlID0gbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXTtcbiAgICAgIHVuaWZvcm1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bS52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV07XG5cbiAgICAgIGlmIChtYXRlcmlhbC5pcmlkZXNjZW5jZU1hcCkge1xuICAgICAgICB1bmlmb3Jtcy5pcmlkZXNjZW5jZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NNYXApIHtcbiAgICAgICAgdW5pZm9ybXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwudHJhbnNtaXNzaW9uID4gMCkge1xuICAgICAgdW5pZm9ybXMudHJhbnNtaXNzaW9uLnZhbHVlID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uO1xuICAgICAgdW5pZm9ybXMudHJhbnNtaXNzaW9uU2FtcGxlck1hcC52YWx1ZSA9IHRyYW5zbWlzc2lvblJlbmRlclRhcmdldC50ZXh0dXJlO1xuICAgICAgdW5pZm9ybXMudHJhbnNtaXNzaW9uU2FtcGxlclNpemUudmFsdWUuc2V0KHRyYW5zbWlzc2lvblJlbmRlclRhcmdldC53aWR0aCwgdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LmhlaWdodCk7XG5cbiAgICAgIGlmIChtYXRlcmlhbC50cmFuc21pc3Npb25NYXApIHtcbiAgICAgICAgdW5pZm9ybXMudHJhbnNtaXNzaW9uTWFwLnZhbHVlID0gbWF0ZXJpYWwudHJhbnNtaXNzaW9uTWFwO1xuICAgICAgfVxuXG4gICAgICB1bmlmb3Jtcy50aGlja25lc3MudmFsdWUgPSBtYXRlcmlhbC50aGlja25lc3M7XG5cbiAgICAgIGlmIChtYXRlcmlhbC50aGlja25lc3NNYXApIHtcbiAgICAgICAgdW5pZm9ybXMudGhpY2tuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwudGhpY2tuZXNzTWFwO1xuICAgICAgfVxuXG4gICAgICB1bmlmb3Jtcy5hdHRlbnVhdGlvbkRpc3RhbmNlLnZhbHVlID0gbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZTtcbiAgICAgIHVuaWZvcm1zLmF0dGVudWF0aW9uQ29sb3IudmFsdWUuY29weShtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yKTtcbiAgICB9XG5cbiAgICB1bmlmb3Jtcy5zcGVjdWxhckludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFySW50ZW5zaXR5O1xuICAgIHVuaWZvcm1zLnNwZWN1bGFyQ29sb3IudmFsdWUuY29weShtYXRlcmlhbC5zcGVjdWxhckNvbG9yKTtcblxuICAgIGlmIChtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcCkge1xuICAgICAgdW5pZm9ybXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhckludGVuc2l0eU1hcDtcbiAgICB9XG5cbiAgICBpZiAobWF0ZXJpYWwuc3BlY3VsYXJDb2xvck1hcCkge1xuICAgICAgdW5pZm9ybXMuc3BlY3VsYXJDb2xvck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyQ29sb3JNYXA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTWF0Y2FwKHVuaWZvcm1zLCBtYXRlcmlhbCkge1xuICAgIGlmIChtYXRlcmlhbC5tYXRjYXApIHtcbiAgICAgIHVuaWZvcm1zLm1hdGNhcC52YWx1ZSA9IG1hdGVyaWFsLm1hdGNhcDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEaXN0YW5jZSh1bmlmb3JtcywgbWF0ZXJpYWwpIHtcbiAgICB1bmlmb3Jtcy5yZWZlcmVuY2VQb3NpdGlvbi52YWx1ZS5jb3B5KG1hdGVyaWFsLnJlZmVyZW5jZVBvc2l0aW9uKTtcbiAgICB1bmlmb3Jtcy5uZWFyRGlzdGFuY2UudmFsdWUgPSBtYXRlcmlhbC5uZWFyRGlzdGFuY2U7XG4gICAgdW5pZm9ybXMuZmFyRGlzdGFuY2UudmFsdWUgPSBtYXRlcmlhbC5mYXJEaXN0YW5jZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcmVmcmVzaEZvZ1VuaWZvcm1zOiByZWZyZXNoRm9nVW5pZm9ybXMsXG4gICAgcmVmcmVzaE1hdGVyaWFsVW5pZm9ybXM6IHJlZnJlc2hNYXRlcmlhbFVuaWZvcm1zXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0VsZW1lbnQoKSB7XG4gIHZhciBjYW52YXMgPSBjcmVhdGVFbGVtZW50TlMoJ2NhbnZhcycpO1xuICBjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIoKSB7XG4gIHZhciBwYXJhbWV0ZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdGhpcy5pc1dlYkdMUmVuZGVyZXIgPSB0cnVlO1xuXG4gIHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgX2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG4gICAgICBfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoIDogdHJ1ZSxcbiAgICAgIF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxuICAgICAgX2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxuICAgICAgX3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXG4gICAgICBfcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyIDogZmFsc2UsXG4gICAgICBfcG93ZXJQcmVmZXJlbmNlID0gcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucG93ZXJQcmVmZXJlbmNlIDogJ2RlZmF1bHQnLFxuICAgICAgX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgPSBwYXJhbWV0ZXJzLmZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdCA6IGZhbHNlO1xuXG4gIHZhciBfYWxwaGE7XG5cbiAgaWYgKF9jb250ZXh0ICE9PSBudWxsKSB7XG4gICAgX2FscGhhID0gX2NvbnRleHQuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKS5hbHBoYTtcbiAgfSBlbHNlIHtcbiAgICBfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2U7XG4gIH1cblxuICB2YXIgY3VycmVudFJlbmRlckxpc3QgPSBudWxsO1xuICB2YXIgY3VycmVudFJlbmRlclN0YXRlID0gbnVsbDsgLy8gcmVuZGVyKCkgY2FuIGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhIGNhbGxiYWNrIHRyaWdnZXJlZCBieSBhbm90aGVyIHJlbmRlci5cbiAgLy8gV2UgdHJhY2sgdGhpcyBzbyB0aGF0IHRoZSBuZXN0ZWQgcmVuZGVyIGNhbGwgZ2V0cyBpdHMgbGlzdCBhbmQgc3RhdGUgaXNvbGF0ZWQgZnJvbSB0aGUgcGFyZW50IHJlbmRlciBjYWxsLlxuXG4gIHZhciByZW5kZXJMaXN0U3RhY2sgPSBbXTtcbiAgdmFyIHJlbmRlclN0YXRlU3RhY2sgPSBbXTsgLy8gcHVibGljIHByb3BlcnRpZXNcblxuICB0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzOyAvLyBEZWJ1ZyBjb25maWd1cmF0aW9uIGNvbnRhaW5lclxuXG4gIHRoaXMuZGVidWcgPSB7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBlcnJvciBjaGVja2luZyBhbmQgcmVwb3J0aW5nIHdoZW4gc2hhZGVyIHByb2dyYW1zIGFyZSBiZWluZyBjb21waWxlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGNoZWNrU2hhZGVyRXJyb3JzOiB0cnVlXG4gIH07IC8vIGNsZWFyaW5nXG5cbiAgdGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuICB0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcbiAgdGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG4gIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7IC8vIHNjZW5lIGdyYXBoXG5cbiAgdGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7IC8vIHVzZXItZGVmaW5lZCBjbGlwcGluZ1xuXG4gIHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXTtcbiAgdGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlOyAvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuICB0aGlzLm91dHB1dEVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7IC8vIHBoeXNpY2FsIGxpZ2h0c1xuXG4gIHRoaXMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPSBmYWxzZTsgLy8gdG9uZSBtYXBwaW5nXG5cbiAgdGhpcy50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG4gIHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDEuMDsgLy9cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgLy8gQGRlcHJlY2F0ZWQgc2luY2UgcjEzNiwgMGUyMTA4ODEwMmI0ZGU3ZTBhMGEzMzE0MDYyMGI3YTM0MjRiOWU2ZFxuICAgIGdhbW1hRmFjdG9yOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2FtbWFGYWN0b3IgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdhbW1hRmFjdG9yIGhhcyBiZWVuIHJlbW92ZWQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gaW50ZXJuYWwgcHJvcGVydGllc1xuXG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7IC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cbiAgdmFyIF9jdXJyZW50QWN0aXZlQ3ViZUZhY2UgPSAwO1xuICB2YXIgX2N1cnJlbnRBY3RpdmVNaXBtYXBMZXZlbCA9IDA7XG4gIHZhciBfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG5cbiAgdmFyIF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xuXG4gIHZhciBfY3VycmVudENhbWVyYSA9IG51bGw7XG5cbiAgdmFyIF9jdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpO1xuXG4gIHZhciBfY3VycmVudFNjaXNzb3IgPSBuZXcgVmVjdG9yNCgpO1xuXG4gIHZhciBfY3VycmVudFNjaXNzb3JUZXN0ID0gbnVsbDsgLy9cblxuICB2YXIgX3dpZHRoID0gX2NhbnZhcy53aWR0aDtcbiAgdmFyIF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodDtcbiAgdmFyIF9waXhlbFJhdGlvID0gMTtcbiAgdmFyIF9vcGFxdWVTb3J0ID0gbnVsbDtcbiAgdmFyIF90cmFuc3BhcmVudFNvcnQgPSBudWxsO1xuXG4gIHZhciBfdmlld3BvcnQgPSBuZXcgVmVjdG9yNCgwLCAwLCBfd2lkdGgsIF9oZWlnaHQpO1xuXG4gIHZhciBfc2Npc3NvciA9IG5ldyBWZWN0b3I0KDAsIDAsIF93aWR0aCwgX2hlaWdodCk7XG5cbiAgdmFyIF9zY2lzc29yVGVzdCA9IGZhbHNlOyAvLyBmcnVzdHVtXG5cbiAgdmFyIF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKTsgLy8gY2xpcHBpbmdcblxuXG4gIHZhciBfY2xpcHBpbmdFbmFibGVkID0gZmFsc2U7XG4gIHZhciBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTsgLy8gdHJhbnNtaXNzaW9uXG5cbiAgdmFyIF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQgPSBudWxsOyAvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcblxuICB2YXIgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG4gIHZhciBfdmVjdG9yMiA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgdmFyIF92ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcblxuICB2YXIgX2VtcHR5U2NlbmUgPSB7XG4gICAgYmFja2dyb3VuZDogbnVsbCxcbiAgICBmb2c6IG51bGwsXG4gICAgZW52aXJvbm1lbnQ6IG51bGwsXG4gICAgb3ZlcnJpZGVNYXRlcmlhbDogbnVsbCxcbiAgICBpc1NjZW5lOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQgPT09IG51bGwgPyBfcGl4ZWxSYXRpbyA6IDE7XG4gIH0gLy8gaW5pdGlhbGl6ZVxuXG5cbiAgdmFyIF9nbCA9IF9jb250ZXh0O1xuXG4gIGZ1bmN0aW9uIGdldENvbnRleHQoY29udGV4dE5hbWVzLCBjb250ZXh0QXR0cmlidXRlcykge1xuICAgIGZvciAodmFyIF9pMTUzID0gMDsgX2kxNTMgPCBjb250ZXh0TmFtZXMubGVuZ3RoOyBfaTE1MysrKSB7XG4gICAgICB2YXIgY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZXNbX2kxNTNdO1xuXG4gICAgICB2YXIgY29udGV4dCA9IF9jYW52YXMuZ2V0Q29udGV4dChjb250ZXh0TmFtZSwgY29udGV4dEF0dHJpYnV0ZXMpO1xuXG4gICAgICBpZiAoY29udGV4dCAhPT0gbnVsbCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBjb250ZXh0QXR0cmlidXRlcyA9IHtcbiAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgZGVwdGg6IF9kZXB0aCxcbiAgICAgIHN0ZW5jaWw6IF9zdGVuY2lsLFxuICAgICAgYW50aWFsaWFzOiBfYW50aWFsaWFzLFxuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxuICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBfcHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuICAgICAgcG93ZXJQcmVmZXJlbmNlOiBfcG93ZXJQcmVmZXJlbmNlLFxuICAgICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogX2ZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXRcbiAgICB9OyAvLyBPZmZzY3JlZW5DYW52YXMgZG9lcyBub3QgaGF2ZSBzZXRBdHRyaWJ1dGUsIHNlZSAjMjI4MTFcblxuICAgIGlmICgnc2V0QXR0cmlidXRlJyBpbiBfY2FudmFzKSBfY2FudmFzLnNldEF0dHJpYnV0ZSgnZGF0YS1lbmdpbmUnLCBcInRocmVlLmpzIHJcIi5jb25jYXQoUkVWSVNJT04pKTsgLy8gZXZlbnQgbGlzdGVuZXJzIG11c3QgYmUgcmVnaXN0ZXJlZCBiZWZvcmUgV2ViR0wgY29udGV4dCBpcyBjcmVhdGVkLCBzZWUgIzEyNzUzXG5cbiAgICBfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSk7XG5cbiAgICBfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UpO1xuXG4gICAgX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yJywgb25Db250ZXh0Q3JlYXRpb25FcnJvciwgZmFsc2UpO1xuXG4gICAgaWYgKF9nbCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGNvbnRleHROYW1lcyA9IFsnd2ViZ2wyJywgJ3dlYmdsJywgJ2V4cGVyaW1lbnRhbC13ZWJnbCddO1xuXG4gICAgICBpZiAoX3RoaXMuaXNXZWJHTDFSZW5kZXJlciA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250ZXh0TmFtZXMuc2hpZnQoKTtcbiAgICAgIH1cblxuICAgICAgX2dsID0gZ2V0Q29udGV4dChjb250ZXh0TmFtZXMsIGNvbnRleHRBdHRyaWJ1dGVzKTtcblxuICAgICAgaWYgKF9nbCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoZ2V0Q29udGV4dChjb250ZXh0TmFtZXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gU29tZSBleHBlcmltZW50YWwtd2ViZ2wgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBoYXZlIGdldFNoYWRlclByZWNpc2lvbkZvcm1hdFxuXG5cbiAgICBpZiAoX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICdyYW5nZU1pbic6IDEsXG4gICAgICAgICAgJ3JhbmdlTWF4JzogMSxcbiAgICAgICAgICAncHJlY2lzaW9uJzogMVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgdmFyIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgc3RhdGUsIGluZm87XG4gIHZhciBwcm9wZXJ0aWVzLCB0ZXh0dXJlcywgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIGF0dHJpYnV0ZXMsIGdlb21ldHJpZXMsIG9iamVjdHM7XG4gIHZhciBwcm9ncmFtQ2FjaGUsIG1hdGVyaWFscywgcmVuZGVyTGlzdHMsIHJlbmRlclN0YXRlcywgY2xpcHBpbmcsIHNoYWRvd01hcDtcbiAgdmFyIGJhY2tncm91bmQsIG1vcnBodGFyZ2V0cywgYnVmZmVyUmVuZGVyZXIsIGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcbiAgdmFyIHV0aWxzLCBiaW5kaW5nU3RhdGVzO1xuXG4gIGZ1bmN0aW9uIGluaXRHTENvbnRleHQoKSB7XG4gICAgZXh0ZW5zaW9ucyA9IG5ldyBXZWJHTEV4dGVuc2lvbnMoX2dsKTtcbiAgICBjYXBhYmlsaXRpZXMgPSBuZXcgV2ViR0xDYXBhYmlsaXRpZXMoX2dsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzKTtcbiAgICBleHRlbnNpb25zLmluaXQoY2FwYWJpbGl0aWVzKTtcbiAgICB1dGlscyA9IG5ldyBXZWJHTFV0aWxzKF9nbCwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcbiAgICBzdGF0ZSA9IG5ldyBXZWJHTFN0YXRlKF9nbCwgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzKTtcbiAgICBpbmZvID0gbmV3IFdlYkdMSW5mbyhfZ2wpO1xuICAgIHByb3BlcnRpZXMgPSBuZXcgV2ViR0xQcm9wZXJ0aWVzKCk7XG4gICAgdGV4dHVyZXMgPSBuZXcgV2ViR0xUZXh0dXJlcyhfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHV0aWxzLCBpbmZvKTtcbiAgICBjdWJlbWFwcyA9IG5ldyBXZWJHTEN1YmVNYXBzKF90aGlzKTtcbiAgICBjdWJldXZtYXBzID0gbmV3IFdlYkdMQ3ViZVVWTWFwcyhfdGhpcyk7XG4gICAgYXR0cmlidXRlcyA9IG5ldyBXZWJHTEF0dHJpYnV0ZXMoX2dsLCBjYXBhYmlsaXRpZXMpO1xuICAgIGJpbmRpbmdTdGF0ZXMgPSBuZXcgV2ViR0xCaW5kaW5nU3RhdGVzKF9nbCwgZXh0ZW5zaW9ucywgYXR0cmlidXRlcywgY2FwYWJpbGl0aWVzKTtcbiAgICBnZW9tZXRyaWVzID0gbmV3IFdlYkdMR2VvbWV0cmllcyhfZ2wsIGF0dHJpYnV0ZXMsIGluZm8sIGJpbmRpbmdTdGF0ZXMpO1xuICAgIG9iamVjdHMgPSBuZXcgV2ViR0xPYmplY3RzKF9nbCwgZ2VvbWV0cmllcywgYXR0cmlidXRlcywgaW5mbyk7XG4gICAgbW9ycGh0YXJnZXRzID0gbmV3IFdlYkdMTW9ycGh0YXJnZXRzKF9nbCwgY2FwYWJpbGl0aWVzLCB0ZXh0dXJlcyk7XG4gICAgY2xpcHBpbmcgPSBuZXcgV2ViR0xDbGlwcGluZyhwcm9wZXJ0aWVzKTtcbiAgICBwcm9ncmFtQ2FjaGUgPSBuZXcgV2ViR0xQcm9ncmFtcyhfdGhpcywgY3ViZW1hcHMsIGN1YmV1dm1hcHMsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgYmluZGluZ1N0YXRlcywgY2xpcHBpbmcpO1xuICAgIG1hdGVyaWFscyA9IG5ldyBXZWJHTE1hdGVyaWFscyhfdGhpcywgcHJvcGVydGllcyk7XG4gICAgcmVuZGVyTGlzdHMgPSBuZXcgV2ViR0xSZW5kZXJMaXN0cygpO1xuICAgIHJlbmRlclN0YXRlcyA9IG5ldyBXZWJHTFJlbmRlclN0YXRlcyhleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMpO1xuICAgIGJhY2tncm91bmQgPSBuZXcgV2ViR0xCYWNrZ3JvdW5kKF90aGlzLCBjdWJlbWFwcywgc3RhdGUsIG9iamVjdHMsIF9hbHBoYSwgX3ByZW11bHRpcGxpZWRBbHBoYSk7XG4gICAgc2hhZG93TWFwID0gbmV3IFdlYkdMU2hhZG93TWFwKF90aGlzLCBvYmplY3RzLCBjYXBhYmlsaXRpZXMpO1xuICAgIGJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMQnVmZmVyUmVuZGVyZXIoX2dsLCBleHRlbnNpb25zLCBpbmZvLCBjYXBhYmlsaXRpZXMpO1xuICAgIGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlcihfZ2wsIGV4dGVuc2lvbnMsIGluZm8sIGNhcGFiaWxpdGllcyk7XG4gICAgaW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcbiAgICBfdGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XG4gICAgX3RoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgX3RoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgX3RoaXMucmVuZGVyTGlzdHMgPSByZW5kZXJMaXN0cztcbiAgICBfdGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XG4gICAgX3RoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICBfdGhpcy5pbmZvID0gaW5mbztcbiAgfVxuXG4gIGluaXRHTENvbnRleHQoKTsgLy8geHJcblxuICB2YXIgeHIgPSBuZXcgV2ViWFJNYW5hZ2VyKF90aGlzLCBfZ2wpO1xuICB0aGlzLnhyID0geHI7IC8vIEFQSVxuXG4gIHRoaXMuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dsO1xuICB9O1xuXG4gIHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICB9O1xuXG4gIHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgIGlmIChleHRlbnNpb24pIGV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICB9O1xuXG4gIHRoaXMuZm9yY2VDb250ZXh0UmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgIGlmIChleHRlbnNpb24pIGV4dGVuc2lvbi5yZXN0b3JlQ29udGV4dCgpO1xuICB9O1xuXG4gIHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3BpeGVsUmF0aW87XG4gIH07XG5cbiAgdGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBfcGl4ZWxSYXRpbyA9IHZhbHVlO1xuICAgIHRoaXMuc2V0U2l6ZShfd2lkdGgsIF9oZWlnaHQsIGZhbHNlKTtcbiAgfTtcblxuICB0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5zZXQoX3dpZHRoLCBfaGVpZ2h0KTtcbiAgfTtcblxuICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUpIHtcbiAgICBpZiAoeHIuaXNQcmVzZW50aW5nKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENhblxcJ3QgY2hhbmdlIHNpemUgd2hpbGUgVlIgZGV2aWNlIGlzIHByZXNlbnRpbmcuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3dpZHRoID0gd2lkdGg7XG4gICAgX2hlaWdodCA9IGhlaWdodDtcbiAgICBfY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIF9waXhlbFJhdGlvKTtcbiAgICBfY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0ICogX3BpeGVsUmF0aW8pO1xuXG4gICAgaWYgKHVwZGF0ZVN0eWxlICE9PSBmYWxzZSkge1xuICAgICAgX2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG5cbiAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuXG4gIHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5zZXQoX3dpZHRoICogX3BpeGVsUmF0aW8sIF9oZWlnaHQgKiBfcGl4ZWxSYXRpbykuZmxvb3IoKTtcbiAgfTtcblxuICB0aGlzLnNldERyYXdpbmdCdWZmZXJTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8pIHtcbiAgICBfd2lkdGggPSB3aWR0aDtcbiAgICBfaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIF9waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBfY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIHBpeGVsUmF0aW8pO1xuICAgIF9jYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuXG4gIHRoaXMuZ2V0Q3VycmVudFZpZXdwb3J0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuY29weShfY3VycmVudFZpZXdwb3J0KTtcbiAgfTtcblxuICB0aGlzLmdldFZpZXdwb3J0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuY29weShfdmlld3BvcnQpO1xuICB9O1xuXG4gIHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh4LmlzVmVjdG9yNCkge1xuICAgICAgX3ZpZXdwb3J0LnNldCh4LngsIHgueSwgeC56LCB4LncpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdmlld3BvcnQuc2V0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIHN0YXRlLnZpZXdwb3J0KF9jdXJyZW50Vmlld3BvcnQuY29weShfdmlld3BvcnQpLm11bHRpcGx5U2NhbGFyKF9waXhlbFJhdGlvKS5mbG9vcigpKTtcbiAgfTtcblxuICB0aGlzLmdldFNjaXNzb3IgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5jb3B5KF9zY2lzc29yKTtcbiAgfTtcblxuICB0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh4LmlzVmVjdG9yNCkge1xuICAgICAgX3NjaXNzb3Iuc2V0KHgueCwgeC55LCB4LnosIHgudyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zY2lzc29yLnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5zY2lzc29yKF9jdXJyZW50U2Npc3Nvci5jb3B5KF9zY2lzc29yKS5tdWx0aXBseVNjYWxhcihfcGl4ZWxSYXRpbykuZmxvb3IoKSk7XG4gIH07XG5cbiAgdGhpcy5nZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3NjaXNzb3JUZXN0O1xuICB9O1xuXG4gIHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoYm9vbGVhbikge1xuICAgIHN0YXRlLnNldFNjaXNzb3JUZXN0KF9zY2lzc29yVGVzdCA9IGJvb2xlYW4pO1xuICB9O1xuXG4gIHRoaXMuc2V0T3BhcXVlU29ydCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICBfb3BhcXVlU29ydCA9IG1ldGhvZDtcbiAgfTtcblxuICB0aGlzLnNldFRyYW5zcGFyZW50U29ydCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICBfdHJhbnNwYXJlbnRTb3J0ID0gbWV0aG9kO1xuICB9OyAvLyBDbGVhcmluZ1xuXG5cbiAgdGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuY29weShiYWNrZ3JvdW5kLmdldENsZWFyQ29sb3IoKSk7XG4gIH07XG5cbiAgdGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuICAgIGJhY2tncm91bmQuc2V0Q2xlYXJDb2xvci5hcHBseShiYWNrZ3JvdW5kLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYmFja2dyb3VuZC5nZXRDbGVhckFscGhhKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuICAgIGJhY2tncm91bmQuc2V0Q2xlYXJBbHBoYS5hcHBseShiYWNrZ3JvdW5kLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgc3RlbmNpbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICB2YXIgYml0cyA9IDA7XG4gICAgaWYgKGNvbG9yKSBiaXRzIHw9IDE2Mzg0O1xuICAgIGlmIChkZXB0aCkgYml0cyB8PSAyNTY7XG4gICAgaWYgKHN0ZW5jaWwpIGJpdHMgfD0gMTAyNDtcblxuICAgIF9nbC5jbGVhcihiaXRzKTtcbiAgfTtcblxuICB0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhcih0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICB9O1xuXG4gIHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFyKGZhbHNlLCB0cnVlLCBmYWxzZSk7XG4gIH07XG5cbiAgdGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhcihmYWxzZSwgZmFsc2UsIHRydWUpO1xuICB9OyAvL1xuXG5cbiAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlKTtcblxuICAgIF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvbkNvbnRleHRSZXN0b3JlLCBmYWxzZSk7XG5cbiAgICBfY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGNyZWF0aW9uZXJyb3InLCBvbkNvbnRleHRDcmVhdGlvbkVycm9yLCBmYWxzZSk7XG5cbiAgICByZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG4gICAgcmVuZGVyU3RhdGVzLmRpc3Bvc2UoKTtcbiAgICBwcm9wZXJ0aWVzLmRpc3Bvc2UoKTtcbiAgICBjdWJlbWFwcy5kaXNwb3NlKCk7XG4gICAgY3ViZXV2bWFwcy5kaXNwb3NlKCk7XG4gICAgb2JqZWN0cy5kaXNwb3NlKCk7XG4gICAgYmluZGluZ1N0YXRlcy5kaXNwb3NlKCk7XG4gICAgcHJvZ3JhbUNhY2hlLmRpc3Bvc2UoKTtcbiAgICB4ci5kaXNwb3NlKCk7XG4gICAgeHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0Jywgb25YUlNlc3Npb25TdGFydCk7XG4gICAgeHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIG9uWFJTZXNzaW9uRW5kKTtcblxuICAgIGlmIChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KSB7XG4gICAgICBfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcblxuICAgICAgX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uLnN0b3AoKTtcbiAgfTsgLy8gRXZlbnRzXG5cblxuICBmdW5jdGlvbiBvbkNvbnRleHRMb3N0KGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zb2xlLmxvZygnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBMb3N0LicpO1xuICAgIF9pc0NvbnRleHRMb3N0ID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uXG4gICAgLyogZXZlbnQgKi9cbiAgb25Db250ZXh0UmVzdG9yZSgpIHtcbiAgICBjb25zb2xlLmxvZygnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4nKTtcbiAgICBfaXNDb250ZXh0TG9zdCA9IGZhbHNlO1xuICAgIHZhciBpbmZvQXV0b1Jlc2V0ID0gaW5mby5hdXRvUmVzZXQ7XG4gICAgdmFyIHNoYWRvd01hcEVuYWJsZWQgPSBzaGFkb3dNYXAuZW5hYmxlZDtcbiAgICB2YXIgc2hhZG93TWFwQXV0b1VwZGF0ZSA9IHNoYWRvd01hcC5hdXRvVXBkYXRlO1xuICAgIHZhciBzaGFkb3dNYXBOZWVkc1VwZGF0ZSA9IHNoYWRvd01hcC5uZWVkc1VwZGF0ZTtcbiAgICB2YXIgc2hhZG93TWFwVHlwZSA9IHNoYWRvd01hcC50eXBlO1xuICAgIGluaXRHTENvbnRleHQoKTtcbiAgICBpbmZvLmF1dG9SZXNldCA9IGluZm9BdXRvUmVzZXQ7XG4gICAgc2hhZG93TWFwLmVuYWJsZWQgPSBzaGFkb3dNYXBFbmFibGVkO1xuICAgIHNoYWRvd01hcC5hdXRvVXBkYXRlID0gc2hhZG93TWFwQXV0b1VwZGF0ZTtcbiAgICBzaGFkb3dNYXAubmVlZHNVcGRhdGUgPSBzaGFkb3dNYXBOZWVkc1VwZGF0ZTtcbiAgICBzaGFkb3dNYXAudHlwZSA9IHNoYWRvd01hcFR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbnRleHRDcmVhdGlvbkVycm9yKGV2ZW50KSB7XG4gICAgY29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlcjogQSBXZWJHTCBjb250ZXh0IGNvdWxkIG5vdCBiZSBjcmVhdGVkLiBSZWFzb246ICcsIGV2ZW50LnN0YXR1c01lc3NhZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoZXZlbnQpIHtcbiAgICB2YXIgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XG4gICAgbWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlKTtcbiAgICBkZWFsbG9jYXRlTWF0ZXJpYWwobWF0ZXJpYWwpO1xuICB9IC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuXG4gIGZ1bmN0aW9uIGRlYWxsb2NhdGVNYXRlcmlhbChtYXRlcmlhbCkge1xuICAgIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2VzKG1hdGVyaWFsKTtcbiAgICBwcm9wZXJ0aWVzLnJlbW92ZShtYXRlcmlhbCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlcyhtYXRlcmlhbCkge1xuICAgIHZhciBwcm9ncmFtcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKS5wcm9ncmFtcztcblxuICAgIGlmIChwcm9ncmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCkge1xuICAgICAgICBwcm9ncmFtQ2FjaGUucmVsZWFzZVNoYWRlckNhY2hlKG1hdGVyaWFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQnVmZmVyIHJlbmRlcmluZ1xuXG5cbiAgdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoY2FtZXJhLCBzY2VuZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwKSB7XG4gICAgaWYgKHNjZW5lID09PSBudWxsKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyByZW5kZXJCdWZmZXJEaXJlY3Qgc2Vjb25kIHBhcmFtZXRlciB1c2VkIHRvIGJlIGZvZyAoY291bGQgYmUgbnVsbClcblxuICAgIHZhciBmcm9udEZhY2VDVyA9IG9iamVjdC5pc01lc2ggJiYgb2JqZWN0Lm1hdHJpeFdvcmxkLmRldGVybWluYW50KCkgPCAwO1xuICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbShjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCk7XG4gICAgc3RhdGUuc2V0TWF0ZXJpYWwobWF0ZXJpYWwsIGZyb250RmFjZUNXKTsgLy9cblxuICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgIHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247IC8vXG5cbiAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9uLmNvdW50ID09PSAwKSByZXR1cm47XG4gICAgfSBlbHNlIGlmIChpbmRleC5jb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy9cblxuXG4gICAgdmFyIHJhbmdlRmFjdG9yID0gMTtcblxuICAgIGlmIChtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUpIHtcbiAgICAgIGluZGV4ID0gZ2VvbWV0cmllcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUoZ2VvbWV0cnkpO1xuICAgICAgcmFuZ2VGYWN0b3IgPSAyO1xuICAgIH1cblxuICAgIGJpbmRpbmdTdGF0ZXMuc2V0dXAob2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIGluZGV4KTtcbiAgICB2YXIgYXR0cmlidXRlO1xuICAgIHZhciByZW5kZXJlciA9IGJ1ZmZlclJlbmRlcmVyO1xuXG4gICAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldChpbmRleCk7XG4gICAgICByZW5kZXJlciA9IGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcbiAgICAgIHJlbmRlcmVyLnNldEluZGV4KGF0dHJpYnV0ZSk7XG4gICAgfSAvL1xuXG5cbiAgICB2YXIgZGF0YUNvdW50ID0gaW5kZXggIT09IG51bGwgPyBpbmRleC5jb3VudCA6IHBvc2l0aW9uLmNvdW50O1xuICAgIHZhciByYW5nZVN0YXJ0ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLnN0YXJ0ICogcmFuZ2VGYWN0b3I7XG4gICAgdmFyIHJhbmdlQ291bnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQgKiByYW5nZUZhY3RvcjtcbiAgICB2YXIgZ3JvdXBTdGFydCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciA6IDA7XG4gICAgdmFyIGdyb3VwQ291bnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLmNvdW50ICogcmFuZ2VGYWN0b3IgOiBJbmZpbml0eTtcbiAgICB2YXIgZHJhd1N0YXJ0ID0gTWF0aC5tYXgocmFuZ2VTdGFydCwgZ3JvdXBTdGFydCk7XG4gICAgdmFyIGRyYXdFbmQgPSBNYXRoLm1pbihkYXRhQ291bnQsIHJhbmdlU3RhcnQgKyByYW5nZUNvdW50LCBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudCkgLSAxO1xuICAgIHZhciBkcmF3Q291bnQgPSBNYXRoLm1heCgwLCBkcmF3RW5kIC0gZHJhd1N0YXJ0ICsgMSk7XG4gICAgaWYgKGRyYXdDb3VudCA9PT0gMCkgcmV0dXJuOyAvL1xuXG4gICAgaWYgKG9iamVjdC5pc01lc2gpIHtcbiAgICAgIGlmIChtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUpIHtcbiAgICAgICAgc3RhdGUuc2V0TGluZVdpZHRoKG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSk7XG4gICAgICAgIHJlbmRlcmVyLnNldE1vZGUoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5zZXRNb2RlKDQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqZWN0LmlzTGluZSkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IG1hdGVyaWFsLmxpbmV3aWR0aDtcbiAgICAgIGlmIChsaW5lV2lkdGggPT09IHVuZGVmaW5lZCkgbGluZVdpZHRoID0gMTsgLy8gTm90IHVzaW5nIExpbmUqTWF0ZXJpYWxcblxuICAgICAgc3RhdGUuc2V0TGluZVdpZHRoKGxpbmVXaWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSk7XG5cbiAgICAgIGlmIChvYmplY3QuaXNMaW5lU2VnbWVudHMpIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSgxKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0LmlzTGluZUxvb3ApIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0TW9kZSgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLnNldE1vZGUoMyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmplY3QuaXNQb2ludHMpIHtcbiAgICAgIHJlbmRlcmVyLnNldE1vZGUoMCk7XG4gICAgfSBlbHNlIGlmIChvYmplY3QuaXNTcHJpdGUpIHtcbiAgICAgIHJlbmRlcmVyLnNldE1vZGUoNCk7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdC5pc0luc3RhbmNlZE1lc2gpIHtcbiAgICAgIHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyhkcmF3U3RhcnQsIGRyYXdDb3VudCwgb2JqZWN0LmNvdW50KTtcbiAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpIHtcbiAgICAgIHZhciBpbnN0YW5jZUNvdW50ID0gTWF0aC5taW4oZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCwgZ2VvbWV0cnkuX21heEluc3RhbmNlQ291bnQpO1xuICAgICAgcmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKGRyYXdTdGFydCwgZHJhd0NvdW50LCBpbnN0YW5jZUNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZXIucmVuZGVyKGRyYXdTdGFydCwgZHJhd0NvdW50KTtcbiAgICB9XG4gIH07IC8vIENvbXBpbGVcblxuXG4gIHRoaXMuY29tcGlsZSA9IGZ1bmN0aW9uIChzY2VuZSwgY2FtZXJhKSB7XG4gICAgY3VycmVudFJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGVzLmdldChzY2VuZSk7XG4gICAgY3VycmVudFJlbmRlclN0YXRlLmluaXQoKTtcbiAgICByZW5kZXJTdGF0ZVN0YWNrLnB1c2goY3VycmVudFJlbmRlclN0YXRlKTtcbiAgICBzY2VuZS50cmF2ZXJzZVZpc2libGUoZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5pc0xpZ2h0ICYmIG9iamVjdC5sYXllcnMudGVzdChjYW1lcmEubGF5ZXJzKSkge1xuICAgICAgICBjdXJyZW50UmVuZGVyU3RhdGUucHVzaExpZ2h0KG9iamVjdCk7XG5cbiAgICAgICAgaWYgKG9iamVjdC5jYXN0U2hhZG93KSB7XG4gICAgICAgICAgY3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3cob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cyhfdGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyk7XG4gICAgc2NlbmUudHJhdmVyc2UoZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICBpZiAobWF0ZXJpYWwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kxNTQgPSAwOyBfaTE1NCA8IG1hdGVyaWFsLmxlbmd0aDsgX2kxNTQrKykge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsMiA9IG1hdGVyaWFsW19pMTU0XTtcbiAgICAgICAgICAgIGdldFByb2dyYW0obWF0ZXJpYWwyLCBzY2VuZSwgb2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2V0UHJvZ3JhbShtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZW5kZXJTdGF0ZVN0YWNrLnBvcCgpO1xuICAgIGN1cnJlbnRSZW5kZXJTdGF0ZSA9IG51bGw7XG4gIH07IC8vIEFuaW1hdGlvbiBMb29wXG5cblxuICB2YXIgb25BbmltYXRpb25GcmFtZUNhbGxiYWNrID0gbnVsbDtcblxuICBmdW5jdGlvbiBvbkFuaW1hdGlvbkZyYW1lKHRpbWUpIHtcbiAgICBpZiAob25BbmltYXRpb25GcmFtZUNhbGxiYWNrKSBvbkFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sodGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblhSU2Vzc2lvblN0YXJ0KCkge1xuICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblhSU2Vzc2lvbkVuZCgpIHtcbiAgICBhbmltYXRpb24uc3RhcnQoKTtcbiAgfVxuXG4gIHZhciBhbmltYXRpb24gPSBuZXcgV2ViR0xBbmltYXRpb24oKTtcbiAgYW5pbWF0aW9uLnNldEFuaW1hdGlvbkxvb3Aob25BbmltYXRpb25GcmFtZSk7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIGFuaW1hdGlvbi5zZXRDb250ZXh0KHNlbGYpO1xuXG4gIHRoaXMuc2V0QW5pbWF0aW9uTG9vcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIG9uQW5pbWF0aW9uRnJhbWVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHhyLnNldEFuaW1hdGlvbkxvb3AoY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrID09PSBudWxsID8gYW5pbWF0aW9uLnN0b3AoKSA6IGFuaW1hdGlvbi5zdGFydCgpO1xuICB9O1xuXG4gIHhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIG9uWFJTZXNzaW9uU3RhcnQpO1xuICB4ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgb25YUlNlc3Npb25FbmQpOyAvLyBSZW5kZXJpbmdcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uIChzY2VuZSwgY2FtZXJhKSB7XG4gICAgaWYgKGNhbWVyYSAhPT0gdW5kZWZpbmVkICYmIGNhbWVyYS5pc0NhbWVyYSAhPT0gdHJ1ZSkge1xuICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXI6IGNhbWVyYSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQ2FtZXJhLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChfaXNDb250ZXh0TG9zdCA9PT0gdHJ1ZSkgcmV0dXJuOyAvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuICAgIGlmIChzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlKSBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpOyAvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cbiAgICBpZiAoY2FtZXJhLnBhcmVudCA9PT0gbnVsbCkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICBpZiAoeHIuZW5hYmxlZCA9PT0gdHJ1ZSAmJiB4ci5pc1ByZXNlbnRpbmcgPT09IHRydWUpIHtcbiAgICAgIGlmICh4ci5jYW1lcmFBdXRvVXBkYXRlID09PSB0cnVlKSB4ci51cGRhdGVDYW1lcmEoY2FtZXJhKTtcbiAgICAgIGNhbWVyYSA9IHhyLmdldENhbWVyYSgpOyAvLyB1c2UgWFIgY2FtZXJhIGZvciByZW5kZXJpbmdcbiAgICB9IC8vXG5cblxuICAgIGlmIChzY2VuZS5pc1NjZW5lID09PSB0cnVlKSBzY2VuZS5vbkJlZm9yZVJlbmRlcihfdGhpcywgc2NlbmUsIGNhbWVyYSwgX2N1cnJlbnRSZW5kZXJUYXJnZXQpO1xuICAgIGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlcy5nZXQoc2NlbmUsIHJlbmRlclN0YXRlU3RhY2subGVuZ3RoKTtcbiAgICBjdXJyZW50UmVuZGVyU3RhdGUuaW5pdCgpO1xuICAgIHJlbmRlclN0YXRlU3RhY2sucHVzaChjdXJyZW50UmVuZGVyU3RhdGUpO1xuXG4gICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG5cbiAgICBfZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChfcHJvalNjcmVlbk1hdHJpeCk7XG5cbiAgICBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSB0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkO1xuICAgIF9jbGlwcGluZ0VuYWJsZWQgPSBjbGlwcGluZy5pbml0KHRoaXMuY2xpcHBpbmdQbGFuZXMsIF9sb2NhbENsaXBwaW5nRW5hYmxlZCwgY2FtZXJhKTtcbiAgICBjdXJyZW50UmVuZGVyTGlzdCA9IHJlbmRlckxpc3RzLmdldChzY2VuZSwgcmVuZGVyTGlzdFN0YWNrLmxlbmd0aCk7XG4gICAgY3VycmVudFJlbmRlckxpc3QuaW5pdCgpO1xuICAgIHJlbmRlckxpc3RTdGFjay5wdXNoKGN1cnJlbnRSZW5kZXJMaXN0KTtcbiAgICBwcm9qZWN0T2JqZWN0KHNjZW5lLCBjYW1lcmEsIDAsIF90aGlzLnNvcnRPYmplY3RzKTtcbiAgICBjdXJyZW50UmVuZGVyTGlzdC5maW5pc2goKTtcblxuICAgIGlmIChfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSkge1xuICAgICAgY3VycmVudFJlbmRlckxpc3Quc29ydChfb3BhcXVlU29ydCwgX3RyYW5zcGFyZW50U29ydCk7XG4gICAgfSAvL1xuXG5cbiAgICBpZiAoX2NsaXBwaW5nRW5hYmxlZCA9PT0gdHJ1ZSkgY2xpcHBpbmcuYmVnaW5TaGFkb3dzKCk7XG4gICAgdmFyIHNoYWRvd3NBcnJheSA9IGN1cnJlbnRSZW5kZXJTdGF0ZS5zdGF0ZS5zaGFkb3dzQXJyYXk7XG4gICAgc2hhZG93TWFwLnJlbmRlcihzaGFkb3dzQXJyYXksIHNjZW5lLCBjYW1lcmEpO1xuICAgIGlmIChfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlKSBjbGlwcGluZy5lbmRTaGFkb3dzKCk7IC8vXG5cbiAgICBpZiAodGhpcy5pbmZvLmF1dG9SZXNldCA9PT0gdHJ1ZSkgdGhpcy5pbmZvLnJlc2V0KCk7IC8vXG5cbiAgICBiYWNrZ3JvdW5kLnJlbmRlcihjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUpOyAvLyByZW5kZXIgc2NlbmVcblxuICAgIGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0cyhfdGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyk7XG5cbiAgICBpZiAoY2FtZXJhLmlzQXJyYXlDYW1lcmEpIHtcbiAgICAgIHZhciBjYW1lcmFzID0gY2FtZXJhLmNhbWVyYXM7XG5cbiAgICAgIGZvciAodmFyIF9pMTU1ID0gMCwgbCA9IGNhbWVyYXMubGVuZ3RoOyBfaTE1NSA8IGw7IF9pMTU1KyspIHtcbiAgICAgICAgdmFyIGNhbWVyYTIgPSBjYW1lcmFzW19pMTU1XTtcbiAgICAgICAgcmVuZGVyU2NlbmUoY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEyLCBjYW1lcmEyLnZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyU2NlbmUoY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEpO1xuICAgIH0gLy9cblxuXG4gICAgaWYgKF9jdXJyZW50UmVuZGVyVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAvLyByZXNvbHZlIG11bHRpc2FtcGxlIHJlbmRlcmJ1ZmZlcnMgdG8gYSBzaW5nbGUtc2FtcGxlIHRleHR1cmUgaWYgbmVjZXNzYXJ5XG4gICAgICB0ZXh0dXJlcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChfY3VycmVudFJlbmRlclRhcmdldCk7IC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXG5cbiAgICAgIHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcChfY3VycmVudFJlbmRlclRhcmdldCk7XG4gICAgfSAvL1xuXG5cbiAgICBpZiAoc2NlbmUuaXNTY2VuZSA9PT0gdHJ1ZSkgc2NlbmUub25BZnRlclJlbmRlcihfdGhpcywgc2NlbmUsIGNhbWVyYSk7IC8vIF9nbC5maW5pc2goKTtcblxuICAgIGJpbmRpbmdTdGF0ZXMucmVzZXREZWZhdWx0U3RhdGUoKTtcbiAgICBfY3VycmVudE1hdGVyaWFsSWQgPSAtMTtcbiAgICBfY3VycmVudENhbWVyYSA9IG51bGw7XG4gICAgcmVuZGVyU3RhdGVTdGFjay5wb3AoKTtcblxuICAgIGlmIChyZW5kZXJTdGF0ZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGN1cnJlbnRSZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlU3RhY2tbcmVuZGVyU3RhdGVTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFJlbmRlclN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZW5kZXJMaXN0U3RhY2sucG9wKCk7XG5cbiAgICBpZiAocmVuZGVyTGlzdFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGN1cnJlbnRSZW5kZXJMaXN0ID0gcmVuZGVyTGlzdFN0YWNrW3JlbmRlckxpc3RTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFJlbmRlckxpc3QgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KG9iamVjdCwgY2FtZXJhLCBncm91cE9yZGVyLCBzb3J0T2JqZWN0cykge1xuICAgIGlmIChvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICB2YXIgdmlzaWJsZSA9IG9iamVjdC5sYXllcnMudGVzdChjYW1lcmEubGF5ZXJzKTtcblxuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICBpZiAob2JqZWN0LmlzR3JvdXApIHtcbiAgICAgICAgZ3JvdXBPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0LmlzTE9EKSB7XG4gICAgICAgIGlmIChvYmplY3QuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSkgb2JqZWN0LnVwZGF0ZShjYW1lcmEpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3QuaXNMaWdodCkge1xuICAgICAgICBjdXJyZW50UmVuZGVyU3RhdGUucHVzaExpZ2h0KG9iamVjdCk7XG5cbiAgICAgICAgaWYgKG9iamVjdC5jYXN0U2hhZG93KSB7XG4gICAgICAgICAgY3VycmVudFJlbmRlclN0YXRlLnB1c2hTaGFkb3cob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvYmplY3QuaXNTcHJpdGUpIHtcbiAgICAgICAgaWYgKCFvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzU3ByaXRlKG9iamVjdCkpIHtcbiAgICAgICAgICBpZiAoc29ydE9iamVjdHMpIHtcbiAgICAgICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbihvYmplY3QubWF0cml4V29ybGQpLmFwcGx5TWF0cml4NChfcHJvalNjcmVlbk1hdHJpeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUob2JqZWN0KTtcbiAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgICBpZiAobWF0ZXJpYWwudmlzaWJsZSkge1xuICAgICAgICAgICAgY3VycmVudFJlbmRlckxpc3QucHVzaChvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzTGluZSB8fCBvYmplY3QuaXNQb2ludHMpIHtcbiAgICAgICAgaWYgKG9iamVjdC5pc1NraW5uZWRNZXNoKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHNrZWxldG9uIG9ubHkgb25jZSBpbiBhIGZyYW1lXG4gICAgICAgICAgaWYgKG9iamVjdC5za2VsZXRvbi5mcmFtZSAhPT0gaW5mby5yZW5kZXIuZnJhbWUpIHtcbiAgICAgICAgICAgIG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcbiAgICAgICAgICAgIG9iamVjdC5za2VsZXRvbi5mcmFtZSA9IGluZm8ucmVuZGVyLmZyYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgaWYgKHNvcnRPYmplY3RzKSB7XG4gICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24ob2JqZWN0Lm1hdHJpeFdvcmxkKS5hcHBseU1hdHJpeDQoX3Byb2pTY3JlZW5NYXRyaXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2VvbWV0cnkyID0gb2JqZWN0cy51cGRhdGUob2JqZWN0KTtcblxuICAgICAgICAgIHZhciBfbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShfbWF0ZXJpYWwpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gX2dlb21ldHJ5Mi5ncm91cHM7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMTU2ID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IF9pMTU2IDwgbDsgX2kxNTYrKykge1xuICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbX2kxNTZdO1xuICAgICAgICAgICAgICB2YXIgZ3JvdXBNYXRlcmlhbCA9IF9tYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcblxuICAgICAgICAgICAgICBpZiAoZ3JvdXBNYXRlcmlhbCAmJiBncm91cE1hdGVyaWFsLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVuZGVyTGlzdC5wdXNoKG9iamVjdCwgX2dlb21ldHJ5MiwgZ3JvdXBNYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgZ3JvdXApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChfbWF0ZXJpYWwudmlzaWJsZSkge1xuICAgICAgICAgICAgY3VycmVudFJlbmRlckxpc3QucHVzaChvYmplY3QsIF9nZW9tZXRyeTIsIF9tYXRlcmlhbCwgZ3JvdXBPcmRlciwgX3ZlY3RvcjMueiwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgX2kxNTcgPSAwLCBfbDYgPSBjaGlsZHJlbi5sZW5ndGg7IF9pMTU3IDwgX2w2OyBfaTE1NysrKSB7XG4gICAgICBwcm9qZWN0T2JqZWN0KGNoaWxkcmVuW19pMTU3XSwgY2FtZXJhLCBncm91cE9yZGVyLCBzb3J0T2JqZWN0cyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyU2NlbmUoY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0KSB7XG4gICAgdmFyIG9wYXF1ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC5vcGFxdWU7XG4gICAgdmFyIHRyYW5zbWlzc2l2ZU9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc21pc3NpdmU7XG4gICAgdmFyIHRyYW5zcGFyZW50T2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0LnRyYW5zcGFyZW50O1xuICAgIGN1cnJlbnRSZW5kZXJTdGF0ZS5zZXR1cExpZ2h0c1ZpZXcoY2FtZXJhKTtcbiAgICBpZiAodHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJUcmFuc21pc3Npb25QYXNzKG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuICAgIGlmICh2aWV3cG9ydCkgc3RhdGUudmlld3BvcnQoX2N1cnJlbnRWaWV3cG9ydC5jb3B5KHZpZXdwb3J0KSk7XG4gICAgaWYgKG9wYXF1ZU9iamVjdHMubGVuZ3RoID4gMCkgcmVuZGVyT2JqZWN0cyhvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhKTtcbiAgICBpZiAodHJhbnNtaXNzaXZlT2JqZWN0cy5sZW5ndGggPiAwKSByZW5kZXJPYmplY3RzKHRyYW5zbWlzc2l2ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpO1xuICAgIGlmICh0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID4gMCkgcmVuZGVyT2JqZWN0cyh0cmFuc3BhcmVudE9iamVjdHMsIHNjZW5lLCBjYW1lcmEpOyAvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG4gICAgc3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KHRydWUpO1xuICAgIHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayh0cnVlKTtcbiAgICBzdGF0ZS5idWZmZXJzLmNvbG9yLnNldE1hc2sodHJ1ZSk7XG4gICAgc3RhdGUuc2V0UG9seWdvbk9mZnNldChmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJUcmFuc21pc3Npb25QYXNzKG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEpIHtcbiAgICB2YXIgaXNXZWJHTDIgPSBjYXBhYmlsaXRpZXMuaXNXZWJHTDI7XG5cbiAgICBpZiAoX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCB7XG4gICAgICAgIGdlbmVyYXRlTWlwbWFwczogdHJ1ZSxcbiAgICAgICAgdHlwZTogZXh0ZW5zaW9ucy5oYXMoJ0VYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdCcpID8gSGFsZkZsb2F0VHlwZSA6IFVuc2lnbmVkQnl0ZVR5cGUsXG4gICAgICAgIG1pbkZpbHRlcjogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLFxuICAgICAgICBzYW1wbGVzOiBpc1dlYkdMMiAmJiBfYW50aWFsaWFzID09PSB0cnVlID8gNCA6IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF90aGlzLmdldERyYXdpbmdCdWZmZXJTaXplKF92ZWN0b3IyKTtcblxuICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldC5zZXRTaXplKF92ZWN0b3IyLngsIF92ZWN0b3IyLnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0LnNldFNpemUoZmxvb3JQb3dlck9mVHdvKF92ZWN0b3IyLngpLCBmbG9vclBvd2VyT2ZUd28oX3ZlY3RvcjIueSkpO1xuICAgIH0gLy9cblxuXG4gICAgdmFyIGN1cnJlbnRSZW5kZXJUYXJnZXQgPSBfdGhpcy5nZXRSZW5kZXJUYXJnZXQoKTtcblxuICAgIF90aGlzLnNldFJlbmRlclRhcmdldChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcblxuICAgIF90aGlzLmNsZWFyKCk7IC8vIFR1cm4gb2ZmIHRoZSBmZWF0dXJlcyB3aGljaCBjYW4gYWZmZWN0IHRoZSBmcmFnIGNvbG9yIGZvciBvcGFxdWUgb2JqZWN0cyBwYXNzLlxuICAgIC8vIE90aGVyd2lzZSB0aGV5IGFyZSBhcHBsaWVkIHR3aWNlIGluIG9wYXF1ZSBvYmplY3RzIHBhc3MgYW5kIHRyYW5zbWlzc2lvbiBvYmplY3RzIHBhc3MuXG5cblxuICAgIHZhciBjdXJyZW50VG9uZU1hcHBpbmcgPSBfdGhpcy50b25lTWFwcGluZztcbiAgICBfdGhpcy50b25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XG4gICAgcmVuZGVyT2JqZWN0cyhvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhKTtcbiAgICBfdGhpcy50b25lTWFwcGluZyA9IGN1cnJlbnRUb25lTWFwcGluZztcbiAgICB0ZXh0dXJlcy51cGRhdGVNdWx0aXNhbXBsZVJlbmRlclRhcmdldChfdHJhbnNtaXNzaW9uUmVuZGVyVGFyZ2V0KTtcbiAgICB0ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoX3RyYW5zbWlzc2lvblJlbmRlclRhcmdldCk7XG5cbiAgICBfdGhpcy5zZXRSZW5kZXJUYXJnZXQoY3VycmVudFJlbmRlclRhcmdldCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJPYmplY3RzKHJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEpIHtcbiAgICB2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLmlzU2NlbmUgPT09IHRydWUgPyBzY2VuZS5vdmVycmlkZU1hdGVyaWFsIDogbnVsbDtcblxuICAgIGZvciAodmFyIF9pMTU4ID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBfaTE1OCA8IGw7IF9pMTU4KyspIHtcbiAgICAgIHZhciByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFtfaTE1OF07XG4gICAgICB2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSByZW5kZXJJdGVtLmdlb21ldHJ5O1xuICAgICAgdmFyIG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gbnVsbCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xuICAgICAgdmFyIGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcblxuICAgICAgaWYgKG9iamVjdC5sYXllcnMudGVzdChjYW1lcmEubGF5ZXJzKSkge1xuICAgICAgICByZW5kZXJPYmplY3Qob2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJPYmplY3Qob2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKSB7XG4gICAgb2JqZWN0Lm9uQmVmb3JlUmVuZGVyKF90aGlzLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKTtcbiAgICBvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkKTtcbiAgICBvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeChvYmplY3QubW9kZWxWaWV3TWF0cml4KTtcbiAgICBtYXRlcmlhbC5vbkJlZm9yZVJlbmRlcihfdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG9iamVjdCwgZ3JvdXApO1xuXG4gICAgaWYgKG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlICYmIG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGUpIHtcbiAgICAgIG1hdGVyaWFsLnNpZGUgPSBCYWNrU2lkZTtcbiAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgX3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCk7XG5cbiAgICAgIG1hdGVyaWFsLnNpZGUgPSBGcm9udFNpZGU7XG4gICAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdChjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXApO1xuXG4gICAgICBtYXRlcmlhbC5zaWRlID0gRG91YmxlU2lkZTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KGNhbWVyYSwgc2NlbmUsIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCk7XG4gICAgfVxuXG4gICAgb2JqZWN0Lm9uQWZ0ZXJSZW5kZXIoX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJvZ3JhbShtYXRlcmlhbCwgc2NlbmUsIG9iamVjdCkge1xuICAgIGlmIChzY2VuZS5pc1NjZW5lICE9PSB0cnVlKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyBzY2VuZSBjb3VsZCBiZSBhIE1lc2gsIExpbmUsIFBvaW50cywgLi4uXG5cbiAgICB2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQobWF0ZXJpYWwpO1xuICAgIHZhciBsaWdodHMgPSBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUubGlnaHRzO1xuICAgIHZhciBzaGFkb3dzQXJyYXkgPSBjdXJyZW50UmVuZGVyU3RhdGUuc3RhdGUuc2hhZG93c0FycmF5O1xuICAgIHZhciBsaWdodHNTdGF0ZVZlcnNpb24gPSBsaWdodHMuc3RhdGUudmVyc2lvbjtcbiAgICB2YXIgcGFyYW1ldGVycyA9IHByb2dyYW1DYWNoZS5nZXRQYXJhbWV0ZXJzKG1hdGVyaWFsLCBsaWdodHMuc3RhdGUsIHNoYWRvd3NBcnJheSwgc2NlbmUsIG9iamVjdCk7XG4gICAgdmFyIHByb2dyYW1DYWNoZUtleSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ2FjaGVLZXkocGFyYW1ldGVycyk7XG4gICAgdmFyIHByb2dyYW1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW1zOyAvLyBhbHdheXMgdXBkYXRlIGVudmlyb25tZW50IGFuZCBmb2cgLSBjaGFuZ2luZyB0aGVzZSB0cmlnZ2VyIGFuIGdldFByb2dyYW0gY2FsbCwgYnV0IGl0J3MgcG9zc2libGUgdGhhdCB0aGUgcHJvZ3JhbSBkb2Vzbid0IGNoYW5nZVxuXG4gICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLmVudmlyb25tZW50ID0gbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IHNjZW5lLmVudmlyb25tZW50IDogbnVsbDtcbiAgICBtYXRlcmlhbFByb3BlcnRpZXMuZm9nID0gc2NlbmUuZm9nO1xuICAgIG1hdGVyaWFsUHJvcGVydGllcy5lbnZNYXAgPSAobWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IGN1YmV1dm1hcHMgOiBjdWJlbWFwcykuZ2V0KG1hdGVyaWFsLmVudk1hcCB8fCBtYXRlcmlhbFByb3BlcnRpZXMuZW52aXJvbm1lbnQpO1xuXG4gICAgaWYgKHByb2dyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG5ldyBtYXRlcmlhbFxuICAgICAgbWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlKTtcbiAgICAgIHByb2dyYW1zID0gbmV3IE1hcCgpO1xuICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW1zID0gcHJvZ3JhbXM7XG4gICAgfVxuXG4gICAgdmFyIHByb2dyYW0gPSBwcm9ncmFtcy5nZXQocHJvZ3JhbUNhY2hlS2V5KTtcblxuICAgIGlmIChwcm9ncmFtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGVhcmx5IG91dCBpZiBwcm9ncmFtIGFuZCBsaWdodCBzdGF0ZSBpcyBpZGVudGljYWxcbiAgICAgIGlmIChtYXRlcmlhbFByb3BlcnRpZXMuY3VycmVudFByb2dyYW0gPT09IHByb2dyYW0gJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c1N0YXRlVmVyc2lvbiA9PT0gbGlnaHRzU3RhdGVWZXJzaW9uKSB7XG4gICAgICAgIHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyhtYXRlcmlhbCwgcGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbWV0ZXJzLnVuaWZvcm1zID0gcHJvZ3JhbUNhY2hlLmdldFVuaWZvcm1zKG1hdGVyaWFsKTtcbiAgICAgIG1hdGVyaWFsLm9uQnVpbGQob2JqZWN0LCBwYXJhbWV0ZXJzLCBfdGhpcyk7XG4gICAgICBtYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUocGFyYW1ldGVycywgX3RoaXMpO1xuICAgICAgcHJvZ3JhbSA9IHByb2dyYW1DYWNoZS5hY3F1aXJlUHJvZ3JhbShwYXJhbWV0ZXJzLCBwcm9ncmFtQ2FjaGVLZXkpO1xuICAgICAgcHJvZ3JhbXMuc2V0KHByb2dyYW1DYWNoZUtleSwgcHJvZ3JhbSk7XG4gICAgICBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXMgPSBwYXJhbWV0ZXJzLnVuaWZvcm1zO1xuICAgIH1cblxuICAgIHZhciB1bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3JtcztcblxuICAgIGlmICghbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiAhbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCB8fCBtYXRlcmlhbC5jbGlwcGluZyA9PT0gdHJ1ZSkge1xuICAgICAgdW5pZm9ybXMuY2xpcHBpbmdQbGFuZXMgPSBjbGlwcGluZy51bmlmb3JtO1xuICAgIH1cblxuICAgIHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyhtYXRlcmlhbCwgcGFyYW1ldGVycyk7IC8vIHN0b3JlIHRoZSBsaWdodCBzZXR1cCBpdCB3YXMgY3JlYXRlZCBmb3JcblxuICAgIG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cyA9IG1hdGVyaWFsTmVlZHNMaWdodHMobWF0ZXJpYWwpO1xuICAgIG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNTdGF0ZVZlcnNpb24gPSBsaWdodHNTdGF0ZVZlcnNpb247XG5cbiAgICBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm5lZWRzTGlnaHRzKSB7XG4gICAgICAvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcbiAgICAgIHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLnN0YXRlLmFtYmllbnQ7XG4gICAgICB1bmlmb3Jtcy5saWdodFByb2JlLnZhbHVlID0gbGlnaHRzLnN0YXRlLnByb2JlO1xuICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWw7XG4gICAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0U2hhZG93cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbFNoYWRvdztcbiAgICAgIHVuaWZvcm1zLnNwb3RMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdDtcbiAgICAgIHVuaWZvcm1zLnNwb3RMaWdodFNoYWRvd3MudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvdztcbiAgICAgIHVuaWZvcm1zLnJlY3RBcmVhTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnJlY3RBcmVhO1xuICAgICAgdW5pZm9ybXMubHRjXzEudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWFMVEMxO1xuICAgICAgdW5pZm9ybXMubHRjXzIudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWFMVEMyO1xuICAgICAgdW5pZm9ybXMucG9pbnRMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnQ7XG4gICAgICB1bmlmb3Jtcy5wb2ludExpZ2h0U2hhZG93cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludFNoYWRvdztcbiAgICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuaGVtaTtcbiAgICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwO1xuICAgICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg7XG4gICAgICB1bmlmb3Jtcy5zcG90U2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXA7XG4gICAgICB1bmlmb3Jtcy5zcG90U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXRyaXg7XG4gICAgICB1bmlmb3Jtcy5wb2ludFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludFNoYWRvd01hcDtcbiAgICAgIHVuaWZvcm1zLnBvaW50U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnBvaW50U2hhZG93TWF0cml4OyAvLyBUT0RPIChhYmVsbmF0aW9uKTogYWRkIGFyZWEgbGlnaHRzIHNoYWRvdyBpbmZvIHRvIHVuaWZvcm1zXG4gICAgfVxuXG4gICAgdmFyIHByb2dVbmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcbiAgICB2YXIgdW5pZm9ybXNMaXN0ID0gV2ViR0xVbmlmb3Jtcy5zZXFXaXRoVmFsdWUocHJvZ1VuaWZvcm1zLnNlcSwgdW5pZm9ybXMpO1xuICAgIG1hdGVyaWFsUHJvcGVydGllcy5jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW07XG4gICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9IHVuaWZvcm1zTGlzdDtcbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbW1vbk1hdGVyaWFsUHJvcGVydGllcyhtYXRlcmlhbCwgcGFyYW1ldGVycykge1xuICAgIHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldChtYXRlcmlhbCk7XG4gICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLm91dHB1dEVuY29kaW5nID0gcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZztcbiAgICBtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZyA9IHBhcmFtZXRlcnMuaW5zdGFuY2luZztcbiAgICBtYXRlcmlhbFByb3BlcnRpZXMuc2tpbm5pbmcgPSBwYXJhbWV0ZXJzLnNraW5uaW5nO1xuICAgIG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHMgPSBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cztcbiAgICBtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhOb3JtYWxzID0gcGFyYW1ldGVycy5tb3JwaE5vcm1hbHM7XG4gICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoQ29sb3JzID0gcGFyYW1ldGVycy5tb3JwaENvbG9ycztcbiAgICBtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhUYXJnZXRzQ291bnQgPSBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0c0NvdW50O1xuICAgIG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyA9IHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXM7XG4gICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiA9IHBhcmFtZXRlcnMubnVtQ2xpcEludGVyc2VjdGlvbjtcbiAgICBtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4QWxwaGFzID0gcGFyYW1ldGVycy52ZXJ0ZXhBbHBoYXM7XG4gICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnZlcnRleFRhbmdlbnRzID0gcGFyYW1ldGVycy52ZXJ0ZXhUYW5nZW50cztcbiAgICBtYXRlcmlhbFByb3BlcnRpZXMudG9uZU1hcHBpbmcgPSBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvZ3JhbShjYW1lcmEsIHNjZW5lLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCkge1xuICAgIGlmIChzY2VuZS5pc1NjZW5lICE9PSB0cnVlKSBzY2VuZSA9IF9lbXB0eVNjZW5lOyAvLyBzY2VuZSBjb3VsZCBiZSBhIE1lc2gsIExpbmUsIFBvaW50cywgLi4uXG5cbiAgICB0ZXh0dXJlcy5yZXNldFRleHR1cmVVbml0cygpO1xuICAgIHZhciBmb2cgPSBzY2VuZS5mb2c7XG4gICAgdmFyIGVudmlyb25tZW50ID0gbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA/IHNjZW5lLmVudmlyb25tZW50IDogbnVsbDtcbiAgICB2YXIgZW5jb2RpbmcgPSBfY3VycmVudFJlbmRlclRhcmdldCA9PT0gbnVsbCA/IF90aGlzLm91dHB1dEVuY29kaW5nIDogX2N1cnJlbnRSZW5kZXJUYXJnZXQuaXNYUlJlbmRlclRhcmdldCA9PT0gdHJ1ZSA/IF9jdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUuZW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcbiAgICB2YXIgZW52TWFwID0gKG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPyBjdWJldXZtYXBzIDogY3ViZW1hcHMpLmdldChtYXRlcmlhbC5lbnZNYXAgfHwgZW52aXJvbm1lbnQpO1xuICAgIHZhciB2ZXJ0ZXhBbHBoYXMgPSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IHRydWUgJiYgISFnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICYmIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuaXRlbVNpemUgPT09IDQ7XG4gICAgdmFyIHZlcnRleFRhbmdlbnRzID0gISFtYXRlcmlhbC5ub3JtYWxNYXAgJiYgISFnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQ7XG4gICAgdmFyIG1vcnBoVGFyZ2V0cyA9ICEhZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgIHZhciBtb3JwaE5vcm1hbHMgPSAhIWdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWw7XG4gICAgdmFyIG1vcnBoQ29sb3JzID0gISFnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XG4gICAgdmFyIHRvbmVNYXBwaW5nID0gbWF0ZXJpYWwudG9uZU1hcHBlZCA/IF90aGlzLnRvbmVNYXBwaW5nIDogTm9Ub25lTWFwcGluZztcbiAgICB2YXIgbW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gfHwgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCB8fCBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3I7XG4gICAgdmFyIG1vcnBoVGFyZ2V0c0NvdW50ID0gbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCA/IG1vcnBoQXR0cmlidXRlLmxlbmd0aCA6IDA7XG4gICAgdmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KG1hdGVyaWFsKTtcbiAgICB2YXIgbGlnaHRzID0gY3VycmVudFJlbmRlclN0YXRlLnN0YXRlLmxpZ2h0cztcblxuICAgIGlmIChfY2xpcHBpbmdFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICBpZiAoX2xvY2FsQ2xpcHBpbmdFbmFibGVkID09PSB0cnVlIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEpIHtcbiAgICAgICAgdmFyIHVzZUNhY2hlID0gY2FtZXJhID09PSBfY3VycmVudENhbWVyYSAmJiBtYXRlcmlhbC5pZCA9PT0gX2N1cnJlbnRNYXRlcmlhbElkOyAvLyB3ZSBtaWdodCB3YW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHNvbWUgQ2xpcHBpbmdHcm91cFxuICAgICAgICAvLyBvYmplY3QgaW5zdGVhZCBvZiB0aGUgbWF0ZXJpYWwsIG9uY2UgaXQgYmVjb21lcyBmZWFzaWJsZVxuICAgICAgICAvLyAoIzg0NjUsICM4Mzc5KVxuXG4gICAgICAgIGNsaXBwaW5nLnNldFN0YXRlKG1hdGVyaWFsLCBjYW1lcmEsIHVzZUNhY2hlKTtcbiAgICAgIH1cbiAgICB9IC8vXG5cblxuICAgIHZhciBuZWVkc1Byb2dyYW1DaGFuZ2UgPSBmYWxzZTtcblxuICAgIGlmIChtYXRlcmlhbC52ZXJzaW9uID09PSBtYXRlcmlhbFByb3BlcnRpZXMuX192ZXJzaW9uKSB7XG4gICAgICBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm5lZWRzTGlnaHRzICYmIG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNTdGF0ZVZlcnNpb24gIT09IGxpZ2h0cy5zdGF0ZS52ZXJzaW9uKSB7XG4gICAgICAgIG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5vdXRwdXRFbmNvZGluZyAhPT0gZW5jb2RpbmcpIHtcbiAgICAgICAgbmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0LmlzSW5zdGFuY2VkTWVzaCAmJiBtYXRlcmlhbFByb3BlcnRpZXMuaW5zdGFuY2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIW9iamVjdC5pc0luc3RhbmNlZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmluc3RhbmNpbmcgPT09IHRydWUpIHtcbiAgICAgICAgbmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID09PSBmYWxzZSkge1xuICAgICAgICBuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLnNraW5uaW5nID09PSB0cnVlKSB7XG4gICAgICAgIG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5lbnZNYXAgIT09IGVudk1hcCkge1xuICAgICAgICBuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtYXRlcmlhbC5mb2cgPT09IHRydWUgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyAhPT0gZm9nKSB7XG4gICAgICAgIG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gdW5kZWZpbmVkICYmIChtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IGNsaXBwaW5nLm51bVBsYW5lcyB8fCBtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uICE9PSBjbGlwcGluZy5udW1JbnRlcnNlY3Rpb24pKSB7XG4gICAgICAgIG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy52ZXJ0ZXhBbHBoYXMgIT09IHZlcnRleEFscGhhcykge1xuICAgICAgICBuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMudmVydGV4VGFuZ2VudHMgIT09IHZlcnRleFRhbmdlbnRzKSB7XG4gICAgICAgIG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5tb3JwaFRhcmdldHMgIT09IG1vcnBoVGFyZ2V0cykge1xuICAgICAgICBuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhOb3JtYWxzICE9PSBtb3JwaE5vcm1hbHMpIHtcbiAgICAgICAgbmVlZHNQcm9ncmFtQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobWF0ZXJpYWxQcm9wZXJ0aWVzLm1vcnBoQ29sb3JzICE9PSBtb3JwaENvbG9ycykge1xuICAgICAgICBuZWVkc1Byb2dyYW1DaGFuZ2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtYXRlcmlhbFByb3BlcnRpZXMudG9uZU1hcHBpbmcgIT09IHRvbmVNYXBwaW5nKSB7XG4gICAgICAgIG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNhcGFiaWxpdGllcy5pc1dlYkdMMiA9PT0gdHJ1ZSAmJiBtYXRlcmlhbFByb3BlcnRpZXMubW9ycGhUYXJnZXRzQ291bnQgIT09IG1vcnBoVGFyZ2V0c0NvdW50KSB7XG4gICAgICAgIG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZWRzUHJvZ3JhbUNoYW5nZSA9IHRydWU7XG4gICAgICBtYXRlcmlhbFByb3BlcnRpZXMuX192ZXJzaW9uID0gbWF0ZXJpYWwudmVyc2lvbjtcbiAgICB9IC8vXG5cblxuICAgIHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLmN1cnJlbnRQcm9ncmFtO1xuXG4gICAgaWYgKG5lZWRzUHJvZ3JhbUNoYW5nZSA9PT0gdHJ1ZSkge1xuICAgICAgcHJvZ3JhbSA9IGdldFByb2dyYW0obWF0ZXJpYWwsIHNjZW5lLCBvYmplY3QpO1xuICAgIH1cblxuICAgIHZhciByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xuICAgIHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcbiAgICB2YXIgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xuICAgIHZhciBwX3VuaWZvcm1zID0gcHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuICAgICAgICBtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zO1xuXG4gICAgaWYgKHN0YXRlLnVzZVByb2dyYW0ocHJvZ3JhbS5wcm9ncmFtKSkge1xuICAgICAgcmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuICAgICAgcmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcbiAgICAgIHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkKSB7XG4gICAgICBfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcbiAgICAgIHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJlZnJlc2hQcm9ncmFtIHx8IF9jdXJyZW50Q2FtZXJhICE9PSBjYW1lcmEpIHtcbiAgICAgIHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAncHJvamVjdGlvbk1hdHJpeCcsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcblxuICAgICAgaWYgKGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyKSB7XG4gICAgICAgIHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnbG9nRGVwdGhCdWZGQycsIDIuMCAvIChNYXRoLmxvZyhjYW1lcmEuZmFyICsgMS4wKSAvIE1hdGguTE4yKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfY3VycmVudENhbWVyYSAhPT0gY2FtZXJhKSB7XG4gICAgICAgIF9jdXJyZW50Q2FtZXJhID0gY2FtZXJhOyAvLyBsaWdodGluZyB1bmlmb3JtcyBkZXBlbmQgb24gdGhlIGNhbWVyYSBzbyBlbmZvcmNlIGFuIHVwZGF0ZVxuICAgICAgICAvLyBub3csIGluIGNhc2UgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBsaWdodHMgLSBvciBsYXRlciwgd2hlblxuICAgICAgICAvLyB0aGUgbmV4dCBtYXRlcmlhbCB0aGF0IGRvZXMgZ2V0cyBhY3RpdmF0ZWQ6XG5cbiAgICAgICAgcmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTsgLy8gc2V0IHRvIHRydWUgb24gbWF0ZXJpYWwgY2hhbmdlXG5cbiAgICAgICAgcmVmcmVzaExpZ2h0cyA9IHRydWU7IC8vIHJlbWFpbnMgc2V0IHVudGlsIHVwZGF0ZSBkb25lXG4gICAgICB9IC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcbiAgICAgIC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cblxuICAgICAgaWYgKG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fCBtYXRlcmlhbC5lbnZNYXApIHtcbiAgICAgICAgdmFyIHVDYW1Qb3MgPSBwX3VuaWZvcm1zLm1hcC5jYW1lcmFQb3NpdGlvbjtcblxuICAgICAgICBpZiAodUNhbVBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdUNhbVBvcy5zZXRWYWx1ZShfZ2wsIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmEubWF0cml4V29ybGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsKSB7XG4gICAgICAgIHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnaXNPcnRob2dyYXBoaWMnLCBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgPT09IHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgfHwgb2JqZWN0LmlzU2tpbm5lZE1lc2gpIHtcbiAgICAgICAgcF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICd2aWV3TWF0cml4JywgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG4gICAgICB9XG4gICAgfSAvLyBza2lubmluZyBhbmQgbW9ycGggdGFyZ2V0IHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxuICAgIC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgYW5kIG1vcnBoIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcbiAgICAvLyBvdGhlcndpc2UgdGV4dHVyZXMgdXNlZCBmb3Igc2tpbm5pbmcgYW5kIG1vcnBoaW5nIGNhbiB0YWtlIG92ZXIgdGV4dHVyZSB1bml0cyByZXNlcnZlZCBmb3Igb3RoZXIgbWF0ZXJpYWwgdGV4dHVyZXNcblxuXG4gICAgaWYgKG9iamVjdC5pc1NraW5uZWRNZXNoKSB7XG4gICAgICBwX3VuaWZvcm1zLnNldE9wdGlvbmFsKF9nbCwgb2JqZWN0LCAnYmluZE1hdHJpeCcpO1xuICAgICAgcF91bmlmb3Jtcy5zZXRPcHRpb25hbChfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXhJbnZlcnNlJyk7XG4gICAgICB2YXIgc2tlbGV0b24gPSBvYmplY3Quc2tlbGV0b247XG5cbiAgICAgIGlmIChza2VsZXRvbikge1xuICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMpIHtcbiAgICAgICAgICBpZiAoc2tlbGV0b24uYm9uZVRleHR1cmUgPT09IG51bGwpIHNrZWxldG9uLmNvbXB1dGVCb25lVGV4dHVyZSgpO1xuICAgICAgICAgIHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnYm9uZVRleHR1cmUnLCBza2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZXMpO1xuICAgICAgICAgIHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnYm9uZVRleHR1cmVTaXplJywgc2tlbGV0b24uYm9uZVRleHR1cmVTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFNraW5uZWRNZXNoIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBXZWJHTCAyLiBXaXRoIFdlYkdMIDEgT0VTX3RleHR1cmVfZmxvYXQgYW5kIHZlcnRleCB0ZXh0dXJlcyBzdXBwb3J0IGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuICAgIGlmIChtb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gIT09IHVuZGVmaW5lZCB8fCBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQgfHwgbW9ycGhBdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgY2FwYWJpbGl0aWVzLmlzV2ViR0wyID09PSB0cnVlKSB7XG4gICAgICBtb3JwaHRhcmdldHMudXBkYXRlKG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBwcm9ncmFtKTtcbiAgICB9XG5cbiAgICBpZiAocmVmcmVzaE1hdGVyaWFsIHx8IG1hdGVyaWFsUHJvcGVydGllcy5yZWNlaXZlU2hhZG93ICE9PSBvYmplY3QucmVjZWl2ZVNoYWRvdykge1xuICAgICAgbWF0ZXJpYWxQcm9wZXJ0aWVzLnJlY2VpdmVTaGFkb3cgPSBvYmplY3QucmVjZWl2ZVNoYWRvdztcbiAgICAgIHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAncmVjZWl2ZVNoYWRvdycsIG9iamVjdC5yZWNlaXZlU2hhZG93KTtcbiAgICB9XG5cbiAgICBpZiAocmVmcmVzaE1hdGVyaWFsKSB7XG4gICAgICBwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLCBfdGhpcy50b25lTWFwcGluZ0V4cG9zdXJlKTtcblxuICAgICAgaWYgKG1hdGVyaWFsUHJvcGVydGllcy5uZWVkc0xpZ2h0cykge1xuICAgICAgICAvLyB0aGUgY3VycmVudCBtYXRlcmlhbCByZXF1aXJlcyBsaWdodGluZyBpbmZvXG4gICAgICAgIC8vIG5vdGU6IGFsbCBsaWdodGluZyB1bmlmb3JtcyBhcmUgYWx3YXlzIHNldCBjb3JyZWN0bHlcbiAgICAgICAgLy8gdGhleSBzaW1wbHkgcmVmZXJlbmNlIHRoZSByZW5kZXJlcidzIHN0YXRlIGZvciB0aGVpclxuICAgICAgICAvLyB2YWx1ZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IG1hdGVyaWFsJ3MgLm5lZWRzVXBkYXRlIGZsYWdzIHRvIHNldFxuICAgICAgICAvLyB0aGUgR0wgc3RhdGUgd2hlbiByZXF1aXJlZFxuICAgICAgICBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZShtX3VuaWZvcm1zLCByZWZyZXNoTGlnaHRzKTtcbiAgICAgIH0gLy8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcblxuXG4gICAgICBpZiAoZm9nICYmIG1hdGVyaWFsLmZvZyA9PT0gdHJ1ZSkge1xuICAgICAgICBtYXRlcmlhbHMucmVmcmVzaEZvZ1VuaWZvcm1zKG1fdW5pZm9ybXMsIGZvZyk7XG4gICAgICB9XG5cbiAgICAgIG1hdGVyaWFscy5yZWZyZXNoTWF0ZXJpYWxVbmlmb3JtcyhtX3VuaWZvcm1zLCBtYXRlcmlhbCwgX3BpeGVsUmF0aW8sIF9oZWlnaHQsIF90cmFuc21pc3Npb25SZW5kZXJUYXJnZXQpO1xuICAgICAgV2ViR0xVbmlmb3Jtcy51cGxvYWQoX2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCB0ZXh0dXJlcyk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgbWF0ZXJpYWwudW5pZm9ybXNOZWVkVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICBXZWJHTFVuaWZvcm1zLnVwbG9hZChfZ2wsIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG1fdW5pZm9ybXMsIHRleHR1cmVzKTtcbiAgICAgIG1hdGVyaWFsLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChtYXRlcmlhbC5pc1Nwcml0ZU1hdGVyaWFsKSB7XG4gICAgICBwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ2NlbnRlcicsIG9iamVjdC5jZW50ZXIpO1xuICAgIH0gLy8gY29tbW9uIG1hdHJpY2VzXG5cblxuICAgIHBfdW5pZm9ybXMuc2V0VmFsdWUoX2dsLCAnbW9kZWxWaWV3TWF0cml4Jywgb2JqZWN0Lm1vZGVsVmlld01hdHJpeCk7XG4gICAgcF91bmlmb3Jtcy5zZXRWYWx1ZShfZ2wsICdub3JtYWxNYXRyaXgnLCBvYmplY3Qubm9ybWFsTWF0cml4KTtcbiAgICBwX3VuaWZvcm1zLnNldFZhbHVlKF9nbCwgJ21vZGVsTWF0cml4Jywgb2JqZWN0Lm1hdHJpeFdvcmxkKTtcbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfSAvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cblxuICBmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSh1bmlmb3JtcywgdmFsdWUpIHtcbiAgICB1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLmxpZ2h0UHJvYmUubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5wb2ludExpZ2h0U2hhZG93cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRTaGFkb3dzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMucmVjdEFyZWFMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRlcmlhbE5lZWRzTGlnaHRzKG1hdGVyaWFsKSB7XG4gICAgcmV0dXJuIG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8IG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgfHwgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJiBtYXRlcmlhbC5saWdodHMgPT09IHRydWU7XG4gIH1cblxuICB0aGlzLmdldEFjdGl2ZUN1YmVGYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3VycmVudEFjdGl2ZUN1YmVGYWNlO1xuICB9O1xuXG4gIHRoaXMuZ2V0QWN0aXZlTWlwbWFwTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWw7XG4gIH07XG5cbiAgdGhpcy5nZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0O1xuICB9O1xuXG4gIHRoaXMuc2V0UmVuZGVyVGFyZ2V0VGV4dHVyZXMgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0LCBjb2xvclRleHR1cmUsIGRlcHRoVGV4dHVyZSkge1xuICAgIHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSA9IGNvbG9yVGV4dHVyZTtcbiAgICBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSA9IGRlcHRoVGV4dHVyZTtcbiAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX2hhc0V4dGVybmFsVGV4dHVyZXMgPSB0cnVlO1xuXG4gICAgaWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX19oYXNFeHRlcm5hbFRleHR1cmVzKSB7XG4gICAgICByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIgPSBkZXB0aFRleHR1cmUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCFyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fYXV0b0FsbG9jYXRlRGVwdGhCdWZmZXIpIHtcbiAgICAgICAgLy8gVGhlIG11bHRpc2FtcGxlX3JlbmRlcl90b190ZXh0dXJlIGV4dGVuc2lvbiBkb2Vzbid0IHdvcmsgcHJvcGVybHkgaWYgdGhlcmVcbiAgICAgICAgLy8gYXJlIG1pZGZyYW1lIGZsdXNoZXMgYW5kIGFuIGV4dGVybmFsIGRlcHRoIGJ1ZmZlci4gRGlzYWJsZSB1c2Ugb2YgdGhlIGV4dGVuc2lvbi5cbiAgICAgICAgaWYgKGV4dGVuc2lvbnMuaGFzKCdXRUJHTF9tdWx0aXNhbXBsZWRfcmVuZGVyX3RvX3RleHR1cmUnKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuV2ViR0xSZW5kZXJlcjogUmVuZGVyLXRvLXRleHR1cmUgZXh0ZW5zaW9uIHdhcyBkaXNhYmxlZCBiZWNhdXNlIGFuIGV4dGVybmFsIHRleHR1cmUgd2FzIHByb3ZpZGVkJyk7XG4gICAgICAgICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3VzZVJlbmRlclRvVGV4dHVyZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc2V0UmVuZGVyVGFyZ2V0RnJhbWVidWZmZXIgPSBmdW5jdGlvbiAocmVuZGVyVGFyZ2V0LCBkZWZhdWx0RnJhbWVidWZmZXIpIHtcbiAgICB2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBkZWZhdWx0RnJhbWVidWZmZXI7XG4gICAgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3VzZURlZmF1bHRGcmFtZWJ1ZmZlciA9IGRlZmF1bHRGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHRoaXMuc2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKHJlbmRlclRhcmdldCkge1xuICAgIHZhciBhY3RpdmVDdWJlRmFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgYWN0aXZlTWlwbWFwTGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgX2N1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgX2N1cnJlbnRBY3RpdmVDdWJlRmFjZSA9IGFjdGl2ZUN1YmVGYWNlO1xuICAgIF9jdXJyZW50QWN0aXZlTWlwbWFwTGV2ZWwgPSBhY3RpdmVNaXBtYXBMZXZlbDtcbiAgICB2YXIgdXNlRGVmYXVsdEZyYW1lYnVmZmVyID0gdHJ1ZTtcblxuICAgIGlmIChyZW5kZXJUYXJnZXQpIHtcbiAgICAgIHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KTtcblxuICAgICAgaWYgKHJlbmRlclRhcmdldFByb3BlcnRpZXMuX191c2VEZWZhdWx0RnJhbWVidWZmZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byByZWJpbmQgdGhlIGZyYW1lYnVmZmVyLlxuICAgICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIG51bGwpO1xuICAgICAgICB1c2VEZWZhdWx0RnJhbWVidWZmZXIgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0ZXh0dXJlcy5zZXR1cFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgICAgfSBlbHNlIGlmIChyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9faGFzRXh0ZXJuYWxUZXh0dXJlcykge1xuICAgICAgICAvLyBDb2xvciBhbmQgZGVwdGggdGV4dHVyZSBtdXN0IGJlIHJlYm91bmQgaW4gb3JkZXIgZm9yIHRoZSBzd2FwY2hhaW4gdG8gdXBkYXRlLlxuICAgICAgICB0ZXh0dXJlcy5yZWJpbmRUZXh0dXJlcyhyZW5kZXJUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKS5fX3dlYmdsVGV4dHVyZSwgcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSkuX193ZWJnbFRleHR1cmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcmFtZWJ1ZmZlciA9IG51bGw7XG4gICAgdmFyIGlzQ3ViZSA9IGZhbHNlO1xuICAgIHZhciBpc1JlbmRlclRhcmdldDNEID0gZmFsc2U7XG5cbiAgICBpZiAocmVuZGVyVGFyZ2V0KSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuXG4gICAgICBpZiAodGV4dHVyZS5pc0RhdGEzRFRleHR1cmUgfHwgdGV4dHVyZS5pc0RhdGFBcnJheVRleHR1cmUpIHtcbiAgICAgICAgaXNSZW5kZXJUYXJnZXQzRCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBfX3dlYmdsRnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuICAgICAgaWYgKHJlbmRlclRhcmdldC5pc1dlYkdMQ3ViZVJlbmRlclRhcmdldCkge1xuICAgICAgICBmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlclthY3RpdmVDdWJlRmFjZV07XG4gICAgICAgIGlzQ3ViZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNhcGFiaWxpdGllcy5pc1dlYkdMMiAmJiByZW5kZXJUYXJnZXQuc2FtcGxlcyA+IDAgJiYgdGV4dHVyZXMudXNlTXVsdGlzYW1wbGVkUlRUKHJlbmRlclRhcmdldCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0KS5fX3dlYmdsTXVsdGlzYW1wbGVkRnJhbWVidWZmZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgX2N1cnJlbnRWaWV3cG9ydC5jb3B5KHJlbmRlclRhcmdldC52aWV3cG9ydCk7XG5cbiAgICAgIF9jdXJyZW50U2Npc3Nvci5jb3B5KHJlbmRlclRhcmdldC5zY2lzc29yKTtcblxuICAgICAgX2N1cnJlbnRTY2lzc29yVGVzdCA9IHJlbmRlclRhcmdldC5zY2lzc29yVGVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2N1cnJlbnRWaWV3cG9ydC5jb3B5KF92aWV3cG9ydCkubXVsdGlwbHlTY2FsYXIoX3BpeGVsUmF0aW8pLmZsb29yKCk7XG5cbiAgICAgIF9jdXJyZW50U2Npc3Nvci5jb3B5KF9zY2lzc29yKS5tdWx0aXBseVNjYWxhcihfcGl4ZWxSYXRpbykuZmxvb3IoKTtcblxuICAgICAgX2N1cnJlbnRTY2lzc29yVGVzdCA9IF9zY2lzc29yVGVzdDtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWVidWZmZXJCb3VuZCA9IHN0YXRlLmJpbmRGcmFtZWJ1ZmZlcigzNjE2MCwgZnJhbWVidWZmZXIpO1xuXG4gICAgaWYgKGZyYW1lYnVmZmVyQm91bmQgJiYgY2FwYWJpbGl0aWVzLmRyYXdCdWZmZXJzICYmIHVzZURlZmF1bHRGcmFtZWJ1ZmZlcikge1xuICAgICAgc3RhdGUuZHJhd0J1ZmZlcnMocmVuZGVyVGFyZ2V0LCBmcmFtZWJ1ZmZlcik7XG4gICAgfVxuXG4gICAgc3RhdGUudmlld3BvcnQoX2N1cnJlbnRWaWV3cG9ydCk7XG4gICAgc3RhdGUuc2Npc3NvcihfY3VycmVudFNjaXNzb3IpO1xuICAgIHN0YXRlLnNldFNjaXNzb3JUZXN0KF9jdXJyZW50U2Npc3NvclRlc3QpO1xuXG4gICAgaWYgKGlzQ3ViZSkge1xuICAgICAgdmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQocmVuZGVyVGFyZ2V0LnRleHR1cmUpO1xuXG4gICAgICBfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoMzYxNjAsIDM2MDY0LCAzNDA2OSArIGFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgYWN0aXZlTWlwbWFwTGV2ZWwpO1xuICAgIH0gZWxzZSBpZiAoaXNSZW5kZXJUYXJnZXQzRCkge1xuICAgICAgdmFyIF90ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KHJlbmRlclRhcmdldC50ZXh0dXJlKTtcblxuICAgICAgdmFyIGxheWVyID0gYWN0aXZlQ3ViZUZhY2UgfHwgMDtcblxuICAgICAgX2dsLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKDM2MTYwLCAzNjA2NCwgX3RleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCBhY3RpdmVNaXBtYXBMZXZlbCB8fCAwLCBsYXllcik7XG4gICAgfVxuXG4gICAgX2N1cnJlbnRNYXRlcmlhbElkID0gLTE7IC8vIHJlc2V0IGN1cnJlbnQgbWF0ZXJpYWwgdG8gZW5zdXJlIGNvcnJlY3QgdW5pZm9ybSBiaW5kaW5nc1xuICB9O1xuXG4gIHRoaXMucmVhZFJlbmRlclRhcmdldFBpeGVscyA9IGZ1bmN0aW9uIChyZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciwgYWN0aXZlQ3ViZUZhY2VJbmRleCkge1xuICAgIGlmICghKHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJhbWVidWZmZXIgPSBwcm9wZXJ0aWVzLmdldChyZW5kZXJUYXJnZXQpLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuICAgIGlmIChyZW5kZXJUYXJnZXQuaXNXZWJHTEN1YmVSZW5kZXJUYXJnZXQgJiYgYWN0aXZlQ3ViZUZhY2VJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcmFtZWJ1ZmZlciA9IGZyYW1lYnVmZmVyW2FjdGl2ZUN1YmVGYWNlSW5kZXhdO1xuICAgIH1cblxuICAgIGlmIChmcmFtZWJ1ZmZlcikge1xuICAgICAgc3RhdGUuYmluZEZyYW1lYnVmZmVyKDM2MTYwLCBmcmFtZWJ1ZmZlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG4gICAgICAgIHZhciB0ZXh0dXJlRm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG4gICAgICAgIHZhciB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcblxuICAgICAgICBpZiAodGV4dHVyZUZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB1dGlscy5jb252ZXJ0KHRleHR1cmVGb3JtYXQpICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKDM1NzM5KSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYWxmRmxvYXRTdXBwb3J0ZWRCeUV4dCA9IHRleHR1cmVUeXBlID09PSBIYWxmRmxvYXRUeXBlICYmIChleHRlbnNpb25zLmhhcygnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JykgfHwgY2FwYWJpbGl0aWVzLmlzV2ViR0wyICYmIGV4dGVuc2lvbnMuaGFzKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykpO1xuXG4gICAgICAgIGlmICh0ZXh0dXJlVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSAmJiB1dGlscy5jb252ZXJ0KHRleHR1cmVUeXBlKSAhPT0gX2dsLmdldFBhcmFtZXRlcigzNTczOCkgJiYgLy8gRWRnZSBhbmQgQ2hyb21lIE1hYyA8IDUyICgjOTUxMylcbiAgICAgICAgISh0ZXh0dXJlVHlwZSA9PT0gRmxvYXRUeXBlICYmIChjYXBhYmlsaXRpZXMuaXNXZWJHTDIgfHwgZXh0ZW5zaW9ucy5oYXMoJ09FU190ZXh0dXJlX2Zsb2F0JykgfHwgZXh0ZW5zaW9ucy5oYXMoJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKSkgJiYgLy8gQ2hyb21lIE1hYyA+PSA1MiBhbmQgRmlyZWZveFxuICAgICAgICAhaGFsZkZsb2F0U3VwcG9ydGVkQnlFeHQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50IGVuc3VyZXMgdmFsaWQgcmVhZCByZXF1ZXN0cyAobm8gb3V0LW9mLWJvdW5kcyBwaXhlbHMsIHNlZSAjODYwNClcblxuXG4gICAgICAgIGlmICh4ID49IDAgJiYgeCA8PSByZW5kZXJUYXJnZXQud2lkdGggLSB3aWR0aCAmJiB5ID49IDAgJiYgeSA8PSByZW5kZXJUYXJnZXQuaGVpZ2h0IC0gaGVpZ2h0KSB7XG4gICAgICAgICAgX2dsLnJlYWRQaXhlbHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgdXRpbHMuY29udmVydCh0ZXh0dXJlRm9ybWF0KSwgdXRpbHMuY29udmVydCh0ZXh0dXJlVHlwZSksIGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIHJlc3RvcmUgZnJhbWVidWZmZXIgb2YgY3VycmVudCByZW5kZXIgdGFyZ2V0IGlmIG5lY2Vzc2FyeVxuICAgICAgICB2YXIgX2ZyYW1lYnVmZmVyID0gX2N1cnJlbnRSZW5kZXJUYXJnZXQgIT09IG51bGwgPyBwcm9wZXJ0aWVzLmdldChfY3VycmVudFJlbmRlclRhcmdldCkuX193ZWJnbEZyYW1lYnVmZmVyIDogbnVsbDtcblxuICAgICAgICBzdGF0ZS5iaW5kRnJhbWVidWZmZXIoMzYxNjAsIF9mcmFtZWJ1ZmZlcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY29weUZyYW1lYnVmZmVyVG9UZXh0dXJlID0gZnVuY3Rpb24gKHBvc2l0aW9uLCB0ZXh0dXJlKSB7XG4gICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciBsZXZlbFNjYWxlID0gTWF0aC5wb3coMiwgLWxldmVsKTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLmZsb29yKHRleHR1cmUuaW1hZ2Uud2lkdGggKiBsZXZlbFNjYWxlKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcih0ZXh0dXJlLmltYWdlLmhlaWdodCAqIGxldmVsU2NhbGUpO1xuICAgIHRleHR1cmVzLnNldFRleHR1cmUyRCh0ZXh0dXJlLCAwKTtcblxuICAgIF9nbC5jb3B5VGV4U3ViSW1hZ2UyRCgzNTUzLCBsZXZlbCwgMCwgMCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBzdGF0ZS51bmJpbmRUZXh0dXJlKCk7XG4gIH07XG5cbiAgdGhpcy5jb3B5VGV4dHVyZVRvVGV4dHVyZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSkge1xuICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICB2YXIgd2lkdGggPSBzcmNUZXh0dXJlLmltYWdlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBzcmNUZXh0dXJlLmltYWdlLmhlaWdodDtcbiAgICB2YXIgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KGRzdFRleHR1cmUuZm9ybWF0KTtcbiAgICB2YXIgZ2xUeXBlID0gdXRpbHMuY29udmVydChkc3RUZXh0dXJlLnR5cGUpO1xuICAgIHRleHR1cmVzLnNldFRleHR1cmUyRChkc3RUZXh0dXJlLCAwKTsgLy8gQXMgYW5vdGhlciB0ZXh0dXJlIHVwbG9hZCBtYXkgaGF2ZSBjaGFuZ2VkIHBpeGVsU3RvcmVpXG4gICAgLy8gcGFyYW1ldGVycywgbWFrZSBzdXJlIHRoZXkgYXJlIGNvcnJlY3QgZm9yIHRoZSBkc3RUZXh0dXJlXG5cbiAgICBfZ2wucGl4ZWxTdG9yZWkoMzc0NDAsIGRzdFRleHR1cmUuZmxpcFkpO1xuXG4gICAgX2dsLnBpeGVsU3RvcmVpKDM3NDQxLCBkc3RUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuXG4gICAgX2dsLnBpeGVsU3RvcmVpKDMzMTcsIGRzdFRleHR1cmUudW5wYWNrQWxpZ25tZW50KTtcblxuICAgIGlmIChzcmNUZXh0dXJlLmlzRGF0YVRleHR1cmUpIHtcbiAgICAgIF9nbC50ZXhTdWJJbWFnZTJEKDM1NTMsIGxldmVsLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB3aWR0aCwgaGVpZ2h0LCBnbEZvcm1hdCwgZ2xUeXBlLCBzcmNUZXh0dXJlLmltYWdlLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3JjVGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlKSB7XG4gICAgICAgIF9nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRCgzNTUzLCBsZXZlbCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgc3JjVGV4dHVyZS5taXBtYXBzWzBdLndpZHRoLCBzcmNUZXh0dXJlLm1pcG1hcHNbMF0uaGVpZ2h0LCBnbEZvcm1hdCwgc3JjVGV4dHVyZS5taXBtYXBzWzBdLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2dsLnRleFN1YkltYWdlMkQoMzU1MywgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIGdsRm9ybWF0LCBnbFR5cGUsIHNyY1RleHR1cmUuaW1hZ2UpO1xuICAgICAgfVxuICAgIH0gLy8gR2VuZXJhdGUgbWlwbWFwcyBvbmx5IHdoZW4gY29weWluZyBsZXZlbCAwXG5cblxuICAgIGlmIChsZXZlbCA9PT0gMCAmJiBkc3RUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcykgX2dsLmdlbmVyYXRlTWlwbWFwKDM1NTMpO1xuICAgIHN0YXRlLnVuYmluZFRleHR1cmUoKTtcbiAgfTtcblxuICB0aGlzLmNvcHlUZXh0dXJlVG9UZXh0dXJlM0QgPSBmdW5jdGlvbiAoc291cmNlQm94LCBwb3NpdGlvbiwgc3JjVGV4dHVyZSwgZHN0VGV4dHVyZSkge1xuICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcblxuICAgIGlmIChfdGhpcy5pc1dlYkdMMVJlbmRlcmVyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXIuY29weVRleHR1cmVUb1RleHR1cmUzRDogY2FuIG9ubHkgYmUgdXNlZCB3aXRoIFdlYkdMMi4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBzb3VyY2VCb3gubWF4LnggLSBzb3VyY2VCb3gubWluLnggKyAxO1xuICAgIHZhciBoZWlnaHQgPSBzb3VyY2VCb3gubWF4LnkgLSBzb3VyY2VCb3gubWluLnkgKyAxO1xuICAgIHZhciBkZXB0aCA9IHNvdXJjZUJveC5tYXgueiAtIHNvdXJjZUJveC5taW4ueiArIDE7XG4gICAgdmFyIGdsRm9ybWF0ID0gdXRpbHMuY29udmVydChkc3RUZXh0dXJlLmZvcm1hdCk7XG4gICAgdmFyIGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoZHN0VGV4dHVyZS50eXBlKTtcbiAgICB2YXIgZ2xUYXJnZXQ7XG5cbiAgICBpZiAoZHN0VGV4dHVyZS5pc0RhdGEzRFRleHR1cmUpIHtcbiAgICAgIHRleHR1cmVzLnNldFRleHR1cmUzRChkc3RUZXh0dXJlLCAwKTtcbiAgICAgIGdsVGFyZ2V0ID0gMzI4Nzk7XG4gICAgfSBlbHNlIGlmIChkc3RUZXh0dXJlLmlzRGF0YUFycmF5VGV4dHVyZSkge1xuICAgICAgdGV4dHVyZXMuc2V0VGV4dHVyZTJEQXJyYXkoZHN0VGV4dHVyZSwgMCk7XG4gICAgICBnbFRhcmdldCA9IDM1ODY2O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXIuY29weVRleHR1cmVUb1RleHR1cmUzRDogb25seSBzdXBwb3J0cyBUSFJFRS5EYXRhVGV4dHVyZTNEIGFuZCBUSFJFRS5EYXRhVGV4dHVyZTJEQXJyYXkuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2dsLnBpeGVsU3RvcmVpKDM3NDQwLCBkc3RUZXh0dXJlLmZsaXBZKTtcblxuICAgIF9nbC5waXhlbFN0b3JlaSgzNzQ0MSwgZHN0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcblxuICAgIF9nbC5waXhlbFN0b3JlaSgzMzE3LCBkc3RUZXh0dXJlLnVucGFja0FsaWdubWVudCk7XG5cbiAgICB2YXIgdW5wYWNrUm93TGVuID0gX2dsLmdldFBhcmFtZXRlcigzMzE0KTtcblxuICAgIHZhciB1bnBhY2tJbWFnZUhlaWdodCA9IF9nbC5nZXRQYXJhbWV0ZXIoMzI4NzgpO1xuXG4gICAgdmFyIHVucGFja1NraXBQaXhlbHMgPSBfZ2wuZ2V0UGFyYW1ldGVyKDMzMTYpO1xuXG4gICAgdmFyIHVucGFja1NraXBSb3dzID0gX2dsLmdldFBhcmFtZXRlcigzMzE1KTtcblxuICAgIHZhciB1bnBhY2tTa2lwSW1hZ2VzID0gX2dsLmdldFBhcmFtZXRlcigzMjg3Nyk7XG5cbiAgICB2YXIgaW1hZ2UgPSBzcmNUZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgPyBzcmNUZXh0dXJlLm1pcG1hcHNbMF0gOiBzcmNUZXh0dXJlLmltYWdlO1xuXG4gICAgX2dsLnBpeGVsU3RvcmVpKDMzMTQsIGltYWdlLndpZHRoKTtcblxuICAgIF9nbC5waXhlbFN0b3JlaSgzMjg3OCwgaW1hZ2UuaGVpZ2h0KTtcblxuICAgIF9nbC5waXhlbFN0b3JlaSgzMzE2LCBzb3VyY2VCb3gubWluLngpO1xuXG4gICAgX2dsLnBpeGVsU3RvcmVpKDMzMTUsIHNvdXJjZUJveC5taW4ueSk7XG5cbiAgICBfZ2wucGl4ZWxTdG9yZWkoMzI4NzcsIHNvdXJjZUJveC5taW4ueik7XG5cbiAgICBpZiAoc3JjVGV4dHVyZS5pc0RhdGFUZXh0dXJlIHx8IHNyY1RleHR1cmUuaXNEYXRhM0RUZXh0dXJlKSB7XG4gICAgICBfZ2wudGV4U3ViSW1hZ2UzRChnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNyY1RleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLldlYkdMUmVuZGVyZXIuY29weVRleHR1cmVUb1RleHR1cmUzRDogdW50ZXN0ZWQgc3VwcG9ydCBmb3IgY29tcHJlc3NlZCBzcmNUZXh0dXJlLicpO1xuXG4gICAgICAgIF9nbC5jb21wcmVzc2VkVGV4U3ViSW1hZ2UzRChnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgaW1hZ2UuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZ2wudGV4U3ViSW1hZ2UzRChnbFRhcmdldCwgbGV2ZWwsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnosIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2dsLnBpeGVsU3RvcmVpKDMzMTQsIHVucGFja1Jvd0xlbik7XG5cbiAgICBfZ2wucGl4ZWxTdG9yZWkoMzI4NzgsIHVucGFja0ltYWdlSGVpZ2h0KTtcblxuICAgIF9nbC5waXhlbFN0b3JlaSgzMzE2LCB1bnBhY2tTa2lwUGl4ZWxzKTtcblxuICAgIF9nbC5waXhlbFN0b3JlaSgzMzE1LCB1bnBhY2tTa2lwUm93cyk7XG5cbiAgICBfZ2wucGl4ZWxTdG9yZWkoMzI4NzcsIHVucGFja1NraXBJbWFnZXMpOyAvLyBHZW5lcmF0ZSBtaXBtYXBzIG9ubHkgd2hlbiBjb3B5aW5nIGxldmVsIDBcblxuXG4gICAgaWYgKGxldmVsID09PSAwICYmIGRzdFRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoZ2xUYXJnZXQpO1xuICAgIHN0YXRlLnVuYmluZFRleHR1cmUoKTtcbiAgfTtcblxuICB0aGlzLmluaXRUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICB0ZXh0dXJlcy5zZXRUZXh0dXJlMkQodGV4dHVyZSwgMCk7XG4gICAgc3RhdGUudW5iaW5kVGV4dHVyZSgpO1xuICB9O1xuXG4gIHRoaXMucmVzZXRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY3VycmVudEFjdGl2ZUN1YmVGYWNlID0gMDtcbiAgICBfY3VycmVudEFjdGl2ZU1pcG1hcExldmVsID0gMDtcbiAgICBfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGw7XG4gICAgc3RhdGUucmVzZXQoKTtcbiAgICBiaW5kaW5nU3RhdGVzLnJlc2V0KCk7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgX19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdvYnNlcnZlJywge1xuICAgICAgZGV0YWlsOiB0aGlzXG4gICAgfSkpO1xuICB9XG59XG5cbnZhciBXZWJHTDFSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1dlYkdMUmVuZGVyZXIpIHtcbiAgX2luaGVyaXRzKFdlYkdMMVJlbmRlcmVyLCBfV2ViR0xSZW5kZXJlcik7XG5cbiAgdmFyIF9zdXBlcjM4ID0gX2NyZWF0ZVN1cGVyKFdlYkdMMVJlbmRlcmVyKTtcblxuICBmdW5jdGlvbiBXZWJHTDFSZW5kZXJlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViR0wxUmVuZGVyZXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjM4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFdlYkdMMVJlbmRlcmVyKTtcbn0oV2ViR0xSZW5kZXJlcik7XG5cbldlYkdMMVJlbmRlcmVyLnByb3RvdHlwZS5pc1dlYkdMMVJlbmRlcmVyID0gdHJ1ZTtcblxudmFyIEZvZ0V4cDIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb2dFeHAyKGNvbG9yKSB7XG4gICAgdmFyIGRlbnNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDAuMDAwMjU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9nRXhwMik7XG5cbiAgICB0aGlzLmlzRm9nRXhwMiA9IHRydWU7XG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy5jb2xvciA9IG5ldyBDb2xvcihjb2xvcik7XG4gICAgdGhpcy5kZW5zaXR5ID0gZGVuc2l0eTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb2dFeHAyLCBbe1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgRm9nRXhwMih0aGlzLmNvbG9yLCB0aGlzLmRlbnNpdHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb25cbiAgICAgIC8qIG1ldGEgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRm9nRXhwMicsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuICAgICAgICBkZW5zaXR5OiB0aGlzLmRlbnNpdHlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvZ0V4cDI7XG59KCk7XG5cbnZhciBGb2cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb2coY29sb3IpIHtcbiAgICB2YXIgbmVhciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICB2YXIgZmFyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvZyk7XG5cbiAgICB0aGlzLmlzRm9nID0gdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSAnJztcbiAgICB0aGlzLmNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcbiAgICB0aGlzLm5lYXIgPSBuZWFyO1xuICAgIHRoaXMuZmFyID0gZmFyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvZywgW3tcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IEZvZyh0aGlzLmNvbG9yLCB0aGlzLm5lYXIsIHRoaXMuZmFyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uXG4gICAgICAvKiBtZXRhICovXG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZvZycsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxuICAgICAgICBuZWFyOiB0aGlzLm5lYXIsXG4gICAgICAgIGZhcjogdGhpcy5mYXJcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvZztcbn0oKTtcblxudmFyIFNjZW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqZWN0M0Q1KSB7XG4gIF9pbmhlcml0cyhTY2VuZSwgX09iamVjdDNENSk7XG5cbiAgdmFyIF9zdXBlcjM5ID0gX2NyZWF0ZVN1cGVyKFNjZW5lKTtcblxuICBmdW5jdGlvbiBTY2VuZSgpIHtcbiAgICB2YXIgX3RoaXMzMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2VuZSk7XG5cbiAgICBfdGhpczMwID0gX3N1cGVyMzkuY2FsbCh0aGlzKTtcbiAgICBfdGhpczMwLmlzU2NlbmUgPSB0cnVlO1xuICAgIF90aGlzMzAudHlwZSA9ICdTY2VuZSc7XG4gICAgX3RoaXMzMC5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICBfdGhpczMwLmVudmlyb25tZW50ID0gbnVsbDtcbiAgICBfdGhpczMwLmZvZyA9IG51bGw7XG4gICAgX3RoaXMzMC5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcbiAgICBfdGhpczMwLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXG4gICAgaWYgKHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ29ic2VydmUnLCB7XG4gICAgICAgIGRldGFpbDogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMwKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpczMwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNjZW5lLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFNjZW5lLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlKTtcblxuICAgICAgaWYgKHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsKSB0aGlzLmJhY2tncm91bmQgPSBzb3VyY2UuYmFja2dyb3VuZC5jbG9uZSgpO1xuICAgICAgaWYgKHNvdXJjZS5lbnZpcm9ubWVudCAhPT0gbnVsbCkgdGhpcy5lbnZpcm9ubWVudCA9IHNvdXJjZS5lbnZpcm9ubWVudC5jbG9uZSgpO1xuICAgICAgaWYgKHNvdXJjZS5mb2cgIT09IG51bGwpIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xuICAgICAgaWYgKHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgdGhpcy5hdXRvVXBkYXRlID0gc291cmNlLmF1dG9VcGRhdGU7XG4gICAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKG1ldGEpIHtcbiAgICAgIHZhciBkYXRhID0gX2dldChfZ2V0UHJvdG90eXBlT2YoU2NlbmUucHJvdG90eXBlKSwgXCJ0b0pTT05cIiwgdGhpcykuY2FsbCh0aGlzLCBtZXRhKTtcblxuICAgICAgaWYgKHRoaXMuZm9nICE9PSBudWxsKSBkYXRhLm9iamVjdC5mb2cgPSB0aGlzLmZvZy50b0pTT04oKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2VuZTtcbn0oT2JqZWN0M0QpO1xuXG52YXIgSW50ZXJsZWF2ZWRCdWZmZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgc3RyaWRlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVybGVhdmVkQnVmZmVyKTtcblxuICAgIHRoaXMuaXNJbnRlcmxlYXZlZEJ1ZmZlciA9IHRydWU7XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgIHRoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgIHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gc3RyaWRlIDogMDtcbiAgICB0aGlzLnVzYWdlID0gU3RhdGljRHJhd1VzYWdlO1xuICAgIHRoaXMudXBkYXRlUmFuZ2UgPSB7XG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBjb3VudDogLTFcbiAgICB9O1xuICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgdGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW50ZXJsZWF2ZWRCdWZmZXIsIFt7XG4gICAga2V5OiBcIm9uVXBsb2FkQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25VcGxvYWRDYWxsYmFjaygpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwibmVlZHNVcGRhdGVcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB0aGlzLnZlcnNpb24rKztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VXNhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXNhZ2UodmFsdWUpIHtcbiAgICAgIHRoaXMudXNhZ2UgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICB0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvcihzb3VyY2UuYXJyYXkpO1xuICAgICAgdGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcbiAgICAgIHRoaXMuc3RyaWRlID0gc291cmNlLnN0cmlkZTtcbiAgICAgIHRoaXMudXNhZ2UgPSBzb3VyY2UudXNhZ2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weUF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlBdChpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyKSB7XG4gICAgICBpbmRleDEgKj0gdGhpcy5zdHJpZGU7XG4gICAgICBpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuICAgICAgZm9yICh2YXIgX2kxNTkgPSAwLCBsID0gdGhpcy5zdHJpZGU7IF9pMTU5IDwgbDsgX2kxNTkrKykge1xuICAgICAgICB0aGlzLmFycmF5W2luZGV4MSArIF9pMTU5XSA9IGF0dHJpYnV0ZS5hcnJheVtpbmRleDIgKyBfaTE1OV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgdGhpcy5hcnJheS5zZXQodmFsdWUsIG9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoZGF0YSkge1xuICAgICAgaWYgKGRhdGEuYXJyYXlCdWZmZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YS5hcnJheUJ1ZmZlcnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5hcnJheS5idWZmZXIuX3V1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9IHRoaXMuYXJyYXkuc2xpY2UoMCkuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyYXkgPSBuZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3RvcihkYXRhLmFycmF5QnVmZmVyc1t0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZF0pO1xuICAgICAgdmFyIGliID0gbmV3IHRoaXMuY29uc3RydWN0b3IoYXJyYXksIHRoaXMuc3RyaWRlKTtcbiAgICAgIGliLnNldFVzYWdlKHRoaXMudXNhZ2UpO1xuICAgICAgcmV0dXJuIGliO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvblVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblVwbG9hZChjYWxsYmFjaykge1xuICAgICAgdGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5hcnJheUJ1ZmZlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhLmFycmF5QnVmZmVycyA9IHt9O1xuICAgICAgfSAvLyBnZW5lcmF0ZSBVVUlEIGZvciBhcnJheSBidWZmZXIgaWYgbmVjZXNzYXJ5XG5cblxuICAgICAgaWYgKHRoaXMuYXJyYXkuYnVmZmVyLl91dWlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5hcnJheS5idWZmZXIuX3V1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGEuYXJyYXlCdWZmZXJzW3RoaXMuYXJyYXkuYnVmZmVyLl91dWlkXSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5ldyBVaW50MzJBcnJheSh0aGlzLmFycmF5LmJ1ZmZlcikpO1xuICAgICAgfSAvL1xuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHV1aWQ6IHRoaXMudXVpZCxcbiAgICAgICAgYnVmZmVyOiB0aGlzLmFycmF5LmJ1ZmZlci5fdXVpZCxcbiAgICAgICAgdHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICBzdHJpZGU6IHRoaXMuc3RyaWRlXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnRlcmxlYXZlZEJ1ZmZlcjtcbn0oKTtcblxudmFyIF92ZWN0b3IkNiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShpbnRlcmxlYXZlZEJ1ZmZlciwgaXRlbVNpemUsIG9mZnNldCkge1xuICAgIHZhciBub3JtYWxpemVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSk7XG5cbiAgICB0aGlzLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xuICAgIHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBbe1xuICAgIGtleTogXCJjb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5jb3VudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXJyYXlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5lZWRzVXBkYXRlXCIsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuZGF0YS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseU1hdHJpeDRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlNYXRyaXg0KG0pIHtcbiAgICAgIGZvciAodmFyIF9pMTYwID0gMCwgbCA9IHRoaXMuZGF0YS5jb3VudDsgX2kxNjAgPCBsOyBfaTE2MCsrKSB7XG4gICAgICAgIF92ZWN0b3IkNi5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIF9pMTYwKTtcblxuICAgICAgICBfdmVjdG9yJDYuYXBwbHlNYXRyaXg0KG0pO1xuXG4gICAgICAgIHRoaXMuc2V0WFlaKF9pMTYwLCBfdmVjdG9yJDYueCwgX3ZlY3RvciQ2LnksIF92ZWN0b3IkNi56KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5Tm9ybWFsTWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5Tm9ybWFsTWF0cml4KG0pIHtcbiAgICAgIGZvciAodmFyIF9pMTYxID0gMCwgbCA9IHRoaXMuY291bnQ7IF9pMTYxIDwgbDsgX2kxNjErKykge1xuICAgICAgICBfdmVjdG9yJDYuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLCBfaTE2MSk7XG5cbiAgICAgICAgX3ZlY3RvciQ2LmFwcGx5Tm9ybWFsTWF0cml4KG0pO1xuXG4gICAgICAgIHRoaXMuc2V0WFlaKF9pMTYxLCBfdmVjdG9yJDYueCwgX3ZlY3RvciQ2LnksIF92ZWN0b3IkNi56KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybURpcmVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1EaXJlY3Rpb24obSkge1xuICAgICAgZm9yICh2YXIgX2kxNjIgPSAwLCBsID0gdGhpcy5jb3VudDsgX2kxNjIgPCBsOyBfaTE2MisrKSB7XG4gICAgICAgIF92ZWN0b3IkNi5mcm9tQnVmZmVyQXR0cmlidXRlKHRoaXMsIF9pMTYyKTtcblxuICAgICAgICBfdmVjdG9yJDYudHJhbnNmb3JtRGlyZWN0aW9uKG0pO1xuXG4gICAgICAgIHRoaXMuc2V0WFlaKF9pMTYyLCBfdmVjdG9yJDYueCwgX3ZlY3RvciQ2LnksIF92ZWN0b3IkNi56KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WChpbmRleCwgeCkge1xuICAgICAgdGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0XSA9IHg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRZKGluZGV4LCB5KSB7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxXSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRaKGluZGV4LCB6KSB7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyXSA9IHo7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0V1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRXKGluZGV4LCB3KSB7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzXSA9IHc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRZKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5W2luZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFpcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVtpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDJdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRXXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFcoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0WFkoaW5kZXgsIHgsIHkpIHtcbiAgICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAxXSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0WFlaXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFhZWihpbmRleCwgeCwgeSwgeikge1xuICAgICAgaW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcbiAgICAgIHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDBdID0geDtcbiAgICAgIHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDFdID0geTtcbiAgICAgIHRoaXMuZGF0YS5hcnJheVtpbmRleCArIDJdID0gejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRYWVpXXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFhZWlcoaW5kZXgsIHgsIHksIHosIHcpIHtcbiAgICAgIGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAwXSA9IHg7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAxXSA9IHk7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAyXSA9IHo7XG4gICAgICB0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyAzXSA9IHc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoZGF0YSkge1xuICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuY2xvbmUoKTogQ2xvbmluZyBhbiBpbnRlcmxhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZWludGVybGVhdmUgYnVmZmVyIGRhdGEuJyk7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pMTYzID0gMDsgX2kxNjMgPCB0aGlzLmNvdW50OyBfaTE2MysrKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gX2kxNjMgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaXRlbVNpemU7IGorKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaCh0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyBqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoYXJyYXkpLCB0aGlzLml0ZW1TaXplLCB0aGlzLm5vcm1hbGl6ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkYXRhLmludGVybGVhdmVkQnVmZmVycyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzW3RoaXMuZGF0YS51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnNbdGhpcy5kYXRhLnV1aWRdID0gdGhpcy5kYXRhLmNsb25lKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShkYXRhLmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0sIHRoaXMuaXRlbVNpemUsIHRoaXMub2Zmc2V0LCB0aGlzLm5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1RIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnRvSlNPTigpOiBTZXJpYWxpemluZyBhbiBpbnRlcmxhdmVkIGJ1ZmZlciBhdHRyaWJ1dGUgd2lsbCBkZWludGVybGVhdmUgYnVmZmVyIGRhdGEuJyk7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pMTY0ID0gMDsgX2kxNjQgPCB0aGlzLmNvdW50OyBfaTE2NCsrKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gX2kxNjQgKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuaXRlbVNpemU7IGorKykge1xuICAgICAgICAgICAgYXJyYXkucHVzaCh0aGlzLmRhdGEuYXJyYXlbaW5kZXggKyBqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGRlaW50ZXJsZWF2ZSBkYXRhIGFuZCBzYXZlIGl0IGFzIGFuIG9yZGluYXJ5IGJ1ZmZlciBhdHRyaWJ1dGUgZm9yIG5vd1xuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpdGVtU2l6ZTogdGhpcy5pdGVtU2l6ZSxcbiAgICAgICAgICB0eXBlOiB0aGlzLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2F2ZSBhcyB0cnVlIGludGVybGF2ZWQgYXR0cmlidHVlXG4gICAgICAgIGlmIChkYXRhLmludGVybGVhdmVkQnVmZmVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGF0YS5pbnRlcmxlYXZlZEJ1ZmZlcnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmludGVybGVhdmVkQnVmZmVyc1t0aGlzLmRhdGEudXVpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRhdGEuaW50ZXJsZWF2ZWRCdWZmZXJzW3RoaXMuZGF0YS51dWlkXSA9IHRoaXMuZGF0YS50b0pTT04oZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXG4gICAgICAgICAgaXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG4gICAgICAgICAgZGF0YTogdGhpcy5kYXRhLnV1aWQsXG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICBub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU7XG59KCk7XG5cbnZhciBTcHJpdGVNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01hdGVyaWFsNSkge1xuICBfaW5oZXJpdHMoU3ByaXRlTWF0ZXJpYWwsIF9NYXRlcmlhbDUpO1xuXG4gIHZhciBfc3VwZXI0MCA9IF9jcmVhdGVTdXBlcihTcHJpdGVNYXRlcmlhbCk7XG5cbiAgZnVuY3Rpb24gU3ByaXRlTWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczMxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwcml0ZU1hdGVyaWFsKTtcblxuICAgIF90aGlzMzEgPSBfc3VwZXI0MC5jYWxsKHRoaXMpO1xuICAgIF90aGlzMzEuaXNTcHJpdGVNYXRlcmlhbCA9IHRydWU7XG4gICAgX3RoaXMzMS50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcbiAgICBfdGhpczMxLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTtcbiAgICBfdGhpczMxLm1hcCA9IG51bGw7XG4gICAgX3RoaXMzMS5hbHBoYU1hcCA9IG51bGw7XG4gICAgX3RoaXMzMS5yb3RhdGlvbiA9IDA7XG4gICAgX3RoaXMzMS5zaXplQXR0ZW51YXRpb24gPSB0cnVlO1xuICAgIF90aGlzMzEudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgIF90aGlzMzEuZm9nID0gdHJ1ZTtcblxuICAgIF90aGlzMzEuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXG4gICAgcmV0dXJuIF90aGlzMzE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3ByaXRlTWF0ZXJpYWwsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuICAgICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuICAgICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcbiAgICAgIHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XG4gICAgICB0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG4gICAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3ByaXRlTWF0ZXJpYWw7XG59KE1hdGVyaWFsKTtcblxudmFyIF9nZW9tZXRyeTtcblxudmFyIF9pbnRlcnNlY3RQb2ludCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3dvcmxkU2NhbGUgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9tdlBvc2l0aW9uID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfYWxpZ25lZFBvc2l0aW9uID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cbnZhciBfcm90YXRlZFBvc2l0aW9uID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cbnZhciBfdmlld1dvcmxkTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfdkEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF92QiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3ZDID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdXZBID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cbnZhciBfdXZCID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cbnZhciBfdXZDID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IyKCk7XG5cbnZhciBTcHJpdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmplY3QzRDYpIHtcbiAgX2luaGVyaXRzKFNwcml0ZSwgX09iamVjdDNENik7XG5cbiAgdmFyIF9zdXBlcjQxID0gX2NyZWF0ZVN1cGVyKFNwcml0ZSk7XG5cbiAgZnVuY3Rpb24gU3ByaXRlKG1hdGVyaWFsKSB7XG4gICAgdmFyIF90aGlzMzI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ByaXRlKTtcblxuICAgIF90aGlzMzIgPSBfc3VwZXI0MS5jYWxsKHRoaXMpO1xuICAgIF90aGlzMzIuaXNTcHJpdGUgPSB0cnVlO1xuICAgIF90aGlzMzIudHlwZSA9ICdTcHJpdGUnO1xuXG4gICAgaWYgKF9nZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBfZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIHZhciBmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KFstMC41LCAtMC41LCAwLCAwLCAwLCAwLjUsIC0wLjUsIDAsIDEsIDAsIDAuNSwgMC41LCAwLCAxLCAxLCAtMC41LCAwLjUsIDAsIDAsIDFdKTtcbiAgICAgIHZhciBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihmbG9hdDMyQXJyYXksIDUpO1xuXG4gICAgICBfZ2VvbWV0cnkuc2V0SW5kZXgoWzAsIDEsIDIsIDAsIDIsIDNdKTtcblxuICAgICAgX2dlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIDMsIDAsIGZhbHNlKSk7XG5cbiAgICAgIF9nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGludGVybGVhdmVkQnVmZmVyLCAyLCAzLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIF90aGlzMzIuZ2VvbWV0cnkgPSBfZ2VvbWV0cnk7XG4gICAgX3RoaXMzMi5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBTcHJpdGVNYXRlcmlhbCgpO1xuICAgIF90aGlzMzIuY2VudGVyID0gbmV3IFZlY3RvcjIoMC41LCAwLjUpO1xuICAgIHJldHVybiBfdGhpczMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNwcml0ZSwgW3tcbiAgICBrZXk6IFwicmF5Y2FzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgICAgaWYgKHJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuU3ByaXRlOiBcIlJheWNhc3Rlci5jYW1lcmFcIiBuZWVkcyB0byBiZSBzZXQgaW4gb3JkZXIgdG8gcmF5Y2FzdCBhZ2FpbnN0IHNwcml0ZXMuJyk7XG4gICAgICB9XG5cbiAgICAgIF93b3JsZFNjYWxlLnNldEZyb21NYXRyaXhTY2FsZSh0aGlzLm1hdHJpeFdvcmxkKTtcblxuICAgICAgX3ZpZXdXb3JsZE1hdHJpeC5jb3B5KHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGQpO1xuXG4gICAgICB0aGlzLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKHJheWNhc3Rlci5jYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCB0aGlzLm1hdHJpeFdvcmxkKTtcblxuICAgICAgX212UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubW9kZWxWaWV3TWF0cml4KTtcblxuICAgICAgaWYgKHJheWNhc3Rlci5jYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSAmJiB0aGlzLm1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgX3dvcmxkU2NhbGUubXVsdGlwbHlTY2FsYXIoLV9tdlBvc2l0aW9uLnopO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm90YXRpb24gPSB0aGlzLm1hdGVyaWFsLnJvdGF0aW9uO1xuICAgICAgdmFyIHNpbiwgY29zO1xuXG4gICAgICBpZiAocm90YXRpb24gIT09IDApIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3Mocm90YXRpb24pO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcbiAgICAgIHRyYW5zZm9ybVZlcnRleChfdkEuc2V0KC0wLjUsIC0wLjUsIDApLCBfbXZQb3NpdGlvbiwgY2VudGVyLCBfd29ybGRTY2FsZSwgc2luLCBjb3MpO1xuICAgICAgdHJhbnNmb3JtVmVydGV4KF92Qi5zZXQoMC41LCAtMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcbiAgICAgIHRyYW5zZm9ybVZlcnRleChfdkMuc2V0KDAuNSwgMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcblxuICAgICAgX3V2QS5zZXQoMCwgMCk7XG5cbiAgICAgIF91dkIuc2V0KDEsIDApO1xuXG4gICAgICBfdXZDLnNldCgxLCAxKTsgLy8gY2hlY2sgZmlyc3QgdHJpYW5nbGVcblxuXG4gICAgICB2YXIgaW50ZXJzZWN0ID0gcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RUcmlhbmdsZShfdkEsIF92QiwgX3ZDLCBmYWxzZSwgX2ludGVyc2VjdFBvaW50KTtcblxuICAgICAgaWYgKGludGVyc2VjdCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBjaGVjayBzZWNvbmQgdHJpYW5nbGVcbiAgICAgICAgdHJhbnNmb3JtVmVydGV4KF92Qi5zZXQoLTAuNSwgMC41LCAwKSwgX212UG9zaXRpb24sIGNlbnRlciwgX3dvcmxkU2NhbGUsIHNpbiwgY29zKTtcblxuICAgICAgICBfdXZCLnNldCgwLCAxKTtcblxuICAgICAgICBpbnRlcnNlY3QgPSByYXljYXN0ZXIucmF5LmludGVyc2VjdFRyaWFuZ2xlKF92QSwgX3ZDLCBfdkIsIGZhbHNlLCBfaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIGlmIChpbnRlcnNlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhfaW50ZXJzZWN0UG9pbnQpO1xuICAgICAgaWYgKGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyKSByZXR1cm47XG4gICAgICBpbnRlcnNlY3RzLnB1c2goe1xuICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgIHBvaW50OiBfaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcbiAgICAgICAgdXY6IFRyaWFuZ2xlLmdldFVWKF9pbnRlcnNlY3RQb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFZlY3RvcjIoKSksXG4gICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgIG9iamVjdDogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU3ByaXRlLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlKTtcblxuICAgICAgaWYgKHNvdXJjZS5jZW50ZXIgIT09IHVuZGVmaW5lZCkgdGhpcy5jZW50ZXIuY29weShzb3VyY2UuY2VudGVyKTtcbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBzb3VyY2UubWF0ZXJpYWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3ByaXRlO1xufShPYmplY3QzRCk7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVZlcnRleCh2ZXJ0ZXhQb3NpdGlvbiwgbXZQb3NpdGlvbiwgY2VudGVyLCBzY2FsZSwgc2luLCBjb3MpIHtcbiAgLy8gY29tcHV0ZSBwb3NpdGlvbiBpbiBjYW1lcmEgc3BhY2VcbiAgX2FsaWduZWRQb3NpdGlvbi5zdWJWZWN0b3JzKHZlcnRleFBvc2l0aW9uLCBjZW50ZXIpLmFkZFNjYWxhcigwLjUpLm11bHRpcGx5KHNjYWxlKTsgLy8gdG8gY2hlY2sgaWYgcm90YXRpb24gaXMgbm90IHplcm9cblxuXG4gIGlmIChzaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIF9yb3RhdGVkUG9zaXRpb24ueCA9IGNvcyAqIF9hbGlnbmVkUG9zaXRpb24ueCAtIHNpbiAqIF9hbGlnbmVkUG9zaXRpb24ueTtcbiAgICBfcm90YXRlZFBvc2l0aW9uLnkgPSBzaW4gKiBfYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MgKiBfYWxpZ25lZFBvc2l0aW9uLnk7XG4gIH0gZWxzZSB7XG4gICAgX3JvdGF0ZWRQb3NpdGlvbi5jb3B5KF9hbGlnbmVkUG9zaXRpb24pO1xuICB9XG5cbiAgdmVydGV4UG9zaXRpb24uY29weShtdlBvc2l0aW9uKTtcbiAgdmVydGV4UG9zaXRpb24ueCArPSBfcm90YXRlZFBvc2l0aW9uLng7XG4gIHZlcnRleFBvc2l0aW9uLnkgKz0gX3JvdGF0ZWRQb3NpdGlvbi55OyAvLyB0cmFuc2Zvcm0gdG8gd29ybGQgc3BhY2VcblxuICB2ZXJ0ZXhQb3NpdGlvbi5hcHBseU1hdHJpeDQoX3ZpZXdXb3JsZE1hdHJpeCk7XG59XG5cbnZhciBfdjEkMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX3YyJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIExPRCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iamVjdDNENykge1xuICBfaW5oZXJpdHMoTE9ELCBfT2JqZWN0M0Q3KTtcblxuICB2YXIgX3N1cGVyNDIgPSBfY3JlYXRlU3VwZXIoTE9EKTtcblxuICBmdW5jdGlvbiBMT0QoKSB7XG4gICAgdmFyIF90aGlzMzM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTE9EKTtcblxuICAgIF90aGlzMzMgPSBfc3VwZXI0Mi5jYWxsKHRoaXMpO1xuICAgIF90aGlzMzMuX2N1cnJlbnRMZXZlbCA9IDA7XG4gICAgX3RoaXMzMy50eXBlID0gJ0xPRCc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMzKSwge1xuICAgICAgbGV2ZWxzOiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbXVxuICAgICAgfSxcbiAgICAgIGlzTE9EOiB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RoaXMzMy5hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXMzMztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMT0QsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKExPRC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UsIGZhbHNlKTtcblxuICAgICAgdmFyIGxldmVscyA9IHNvdXJjZS5sZXZlbHM7XG5cbiAgICAgIGZvciAodmFyIF9pMTY1ID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IF9pMTY1IDwgbDsgX2kxNjUrKykge1xuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbX2kxNjVdO1xuICAgICAgICB0aGlzLmFkZExldmVsKGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHNvdXJjZS5hdXRvVXBkYXRlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZExldmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZExldmVsKG9iamVjdCkge1xuICAgICAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZSk7XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICB2YXIgbDtcblxuICAgICAgZm9yIChsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwrKykge1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCBsZXZlbHNbbF0uZGlzdGFuY2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXZlbHMuc3BsaWNlKGwsIDAsIHtcbiAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZChvYmplY3QpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnJlbnRMZXZlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJyZW50TGV2ZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudExldmVsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPYmplY3RGb3JEaXN0YW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPYmplY3RGb3JEaXN0YW5jZShkaXN0YW5jZSkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF9pMTY2LCBsO1xuXG4gICAgICAgIGZvciAoX2kxNjYgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgX2kxNjYgPCBsOyBfaTE2NisrKSB7XG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbGV2ZWxzW19pMTY2XS5kaXN0YW5jZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxldmVsc1tfaTE2NiAtIDFdLm9iamVjdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJheWNhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICAgIHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcblxuICAgICAgaWYgKGxldmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIF92MSQyLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLm1hdHJpeFdvcmxkKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKF92MSQyKTtcbiAgICAgICAgdGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZShkaXN0YW5jZSkucmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGNhbWVyYSkge1xuICAgICAgdmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgX3YxJDIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG5cbiAgICAgICAgX3YyJDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IF92MSQyLmRpc3RhbmNlVG8oX3YyJDEpIC8gY2FtZXJhLnpvb207XG4gICAgICAgIGxldmVsc1swXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgdmFyIF9pMTY3LCBsO1xuXG4gICAgICAgIGZvciAoX2kxNjcgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgX2kxNjcgPCBsOyBfaTE2NysrKSB7XG4gICAgICAgICAgaWYgKGRpc3RhbmNlID49IGxldmVsc1tfaTE2N10uZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGxldmVsc1tfaTE2NyAtIDFdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXZlbHNbX2kxNjddLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3VycmVudExldmVsID0gX2kxNjcgLSAxO1xuXG4gICAgICAgIGZvciAoOyBfaTE2NyA8IGw7IF9pMTY3KyspIHtcbiAgICAgICAgICBsZXZlbHNbX2kxNjddLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihtZXRhKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKExPRC5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMsIG1ldGEpO1xuXG4gICAgICBpZiAodGhpcy5hdXRvVXBkYXRlID09PSBmYWxzZSkgZGF0YS5vYmplY3QuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgZGF0YS5vYmplY3QubGV2ZWxzID0gW107XG4gICAgICB2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cbiAgICAgIGZvciAodmFyIF9pMTY4ID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IF9pMTY4IDwgbDsgX2kxNjgrKykge1xuICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbX2kxNjhdO1xuICAgICAgICBkYXRhLm9iamVjdC5sZXZlbHMucHVzaCh7XG4gICAgICAgICAgb2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcbiAgICAgICAgICBkaXN0YW5jZTogbGV2ZWwuZGlzdGFuY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMT0Q7XG59KE9iamVjdDNEKTtcblxudmFyIF9iYXNlUG9zaXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9za2luSW5kZXggPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjQoKTtcblxudmFyIF9za2luV2VpZ2h0ID0gLypAX19QVVJFX18qL25ldyBWZWN0b3I0KCk7XG5cbnZhciBfdmVjdG9yJDUgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9tYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxudmFyIFNraW5uZWRNZXNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWVzaCkge1xuICBfaW5oZXJpdHMoU2tpbm5lZE1lc2gsIF9NZXNoKTtcblxuICB2YXIgX3N1cGVyNDMgPSBfY3JlYXRlU3VwZXIoU2tpbm5lZE1lc2gpO1xuXG4gIGZ1bmN0aW9uIFNraW5uZWRNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuICAgIHZhciBfdGhpczM0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNraW5uZWRNZXNoKTtcblxuICAgIF90aGlzMzQgPSBfc3VwZXI0My5jYWxsKHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgX3RoaXMzNC5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcbiAgICBfdGhpczM0LnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xuICAgIF90aGlzMzQuYmluZE1vZGUgPSAnYXR0YWNoZWQnO1xuICAgIF90aGlzMzQuYmluZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgX3RoaXMzNC5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgcmV0dXJuIF90aGlzMzQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2tpbm5lZE1lc2gsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU2tpbm5lZE1lc2gucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlLCByZWN1cnNpdmUpO1xuXG4gICAgICB0aGlzLmJpbmRNb2RlID0gc291cmNlLmJpbmRNb2RlO1xuICAgICAgdGhpcy5iaW5kTWF0cml4LmNvcHkoc291cmNlLmJpbmRNYXRyaXgpO1xuICAgICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KHNvdXJjZS5iaW5kTWF0cml4SW52ZXJzZSk7XG4gICAgICB0aGlzLnNrZWxldG9uID0gc291cmNlLnNrZWxldG9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZChza2VsZXRvbiwgYmluZE1hdHJpeCkge1xuICAgICAgdGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xuXG4gICAgICBpZiAoYmluZE1hdHJpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcbiAgICAgICAgYmluZE1hdHJpeCA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmluZE1hdHJpeC5jb3B5KGJpbmRNYXRyaXgpO1xuICAgICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KGJpbmRNYXRyaXgpLmludmVydCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2UoKSB7XG4gICAgICB0aGlzLnNrZWxldG9uLnBvc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9ybWFsaXplU2tpbldlaWdodHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplU2tpbldlaWdodHMoKSB7XG4gICAgICB2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjQoKTtcbiAgICAgIHZhciBza2luV2VpZ2h0ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQ7XG5cbiAgICAgIGZvciAodmFyIF9pMTY5ID0gMCwgbCA9IHNraW5XZWlnaHQuY291bnQ7IF9pMTY5IDwgbDsgX2kxNjkrKykge1xuICAgICAgICB2ZWN0b3IuZnJvbUJ1ZmZlckF0dHJpYnV0ZShza2luV2VpZ2h0LCBfaTE2OSk7XG4gICAgICAgIHZhciBzY2FsZSA9IDEuMCAvIHZlY3Rvci5tYW5oYXR0YW5MZW5ndGgoKTtcblxuICAgICAgICBpZiAoc2NhbGUgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgdmVjdG9yLm11bHRpcGx5U2NhbGFyKHNjYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZWN0b3Iuc2V0KDEsIDAsIDAsIDApOyAvLyBkbyBzb21ldGhpbmcgcmVhc29uYWJsZVxuICAgICAgICB9XG5cbiAgICAgICAgc2tpbldlaWdodC5zZXRYWVpXKF9pMTY5LCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56LCB2ZWN0b3Iudyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU1hdHJpeFdvcmxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTa2lubmVkTWVzaC5wcm90b3R5cGUpLCBcInVwZGF0ZU1hdHJpeFdvcmxkXCIsIHRoaXMpLmNhbGwodGhpcywgZm9yY2UpO1xuXG4gICAgICBpZiAodGhpcy5iaW5kTW9kZSA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYmluZE1vZGUgPT09ICdkZXRhY2hlZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMuYmluZE1hdHJpeCkuaW52ZXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlNraW5uZWRNZXNoOiBVbnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYm9uZVRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBib25lVHJhbnNmb3JtKGluZGV4LCB0YXJnZXQpIHtcbiAgICAgIHZhciBza2VsZXRvbiA9IHRoaXMuc2tlbGV0b247XG4gICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gICAgICBfc2tpbkluZGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luSW5kZXgsIGluZGV4KTtcblxuICAgICAgX3NraW5XZWlnaHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShnZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQsIGluZGV4KTtcblxuICAgICAgX2Jhc2VQb3NpdGlvbi5jb3B5KHRhcmdldCkuYXBwbHlNYXRyaXg0KHRoaXMuYmluZE1hdHJpeCk7XG5cbiAgICAgIHRhcmdldC5zZXQoMCwgMCwgMCk7XG5cbiAgICAgIGZvciAodmFyIF9pMTcwID0gMDsgX2kxNzAgPCA0OyBfaTE3MCsrKSB7XG4gICAgICAgIHZhciB3ZWlnaHQgPSBfc2tpbldlaWdodC5nZXRDb21wb25lbnQoX2kxNzApO1xuXG4gICAgICAgIGlmICh3ZWlnaHQgIT09IDApIHtcbiAgICAgICAgICB2YXIgYm9uZUluZGV4ID0gX3NraW5JbmRleC5nZXRDb21wb25lbnQoX2kxNzApO1xuXG4gICAgICAgICAgX21hdHJpeC5tdWx0aXBseU1hdHJpY2VzKHNrZWxldG9uLmJvbmVzW2JvbmVJbmRleF0ubWF0cml4V29ybGQsIHNrZWxldG9uLmJvbmVJbnZlcnNlc1tib25lSW5kZXhdKTtcblxuICAgICAgICAgIHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoX3ZlY3RvciQ1LmNvcHkoX2Jhc2VQb3NpdGlvbikuYXBwbHlNYXRyaXg0KF9tYXRyaXgpLCB3ZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQuYXBwbHlNYXRyaXg0KHRoaXMuYmluZE1hdHJpeEludmVyc2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTa2lubmVkTWVzaDtcbn0oTWVzaCk7XG5cbnZhciBCb25lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqZWN0M0Q4KSB7XG4gIF9pbmhlcml0cyhCb25lLCBfT2JqZWN0M0Q4KTtcblxuICB2YXIgX3N1cGVyNDQgPSBfY3JlYXRlU3VwZXIoQm9uZSk7XG5cbiAgZnVuY3Rpb24gQm9uZSgpIHtcbiAgICB2YXIgX3RoaXMzNTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb25lKTtcblxuICAgIF90aGlzMzUgPSBfc3VwZXI0NC5jYWxsKHRoaXMpO1xuICAgIF90aGlzMzUuaXNCb25lID0gdHJ1ZTtcbiAgICBfdGhpczM1LnR5cGUgPSAnQm9uZSc7XG4gICAgcmV0dXJuIF90aGlzMzU7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJvbmUpO1xufShPYmplY3QzRCk7XG5cbnZhciBEYXRhVGV4dHVyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RleHR1cmU1KSB7XG4gIF9pbmhlcml0cyhEYXRhVGV4dHVyZSwgX1RleHR1cmU1KTtcblxuICB2YXIgX3N1cGVyNDUgPSBfY3JlYXRlU3VwZXIoRGF0YVRleHR1cmUpO1xuXG4gIGZ1bmN0aW9uIERhdGFUZXh0dXJlKCkge1xuICAgIHZhciBfdGhpczM2O1xuXG4gICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgdmFyIHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgdmFyIGZvcm1hdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgd3JhcFMgPSBhcmd1bWVudHMubGVuZ3RoID4gNiA/IGFyZ3VtZW50c1s2XSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgd3JhcFQgPSBhcmd1bWVudHMubGVuZ3RoID4gNyA/IGFyZ3VtZW50c1s3XSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbWFnRmlsdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDggJiYgYXJndW1lbnRzWzhdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbOF0gOiBOZWFyZXN0RmlsdGVyO1xuICAgIHZhciBtaW5GaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gOSAmJiBhcmd1bWVudHNbOV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s5XSA6IE5lYXJlc3RGaWx0ZXI7XG4gICAgdmFyIGFuaXNvdHJvcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMTAgPyBhcmd1bWVudHNbMTBdIDogdW5kZWZpbmVkO1xuICAgIHZhciBlbmNvZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxMSA/IGFyZ3VtZW50c1sxMV0gOiB1bmRlZmluZWQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVRleHR1cmUpO1xuXG4gICAgX3RoaXMzNiA9IF9zdXBlcjQ1LmNhbGwodGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyk7XG4gICAgX3RoaXMzNi5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcbiAgICBfdGhpczM2LmltYWdlID0ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgICBfdGhpczM2LmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIF90aGlzMzYuZmxpcFkgPSBmYWxzZTtcbiAgICBfdGhpczM2LnVucGFja0FsaWdubWVudCA9IDE7XG4gICAgcmV0dXJuIF90aGlzMzY7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERhdGFUZXh0dXJlKTtcbn0oVGV4dHVyZSk7XG5cbnZhciBfb2Zmc2V0TWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfaWRlbnRpdHlNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxudmFyIFNrZWxldG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2tlbGV0b24oKSB7XG4gICAgdmFyIGJvbmVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICB2YXIgYm9uZUludmVyc2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTa2VsZXRvbik7XG5cbiAgICB0aGlzLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcbiAgICB0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoMCk7XG4gICAgdGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXM7XG4gICAgdGhpcy5ib25lTWF0cmljZXMgPSBudWxsO1xuICAgIHRoaXMuYm9uZVRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuYm9uZVRleHR1cmVTaXplID0gMDtcbiAgICB0aGlzLmZyYW1lID0gLTE7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2tlbGV0b24sIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICB2YXIgYm9uZUludmVyc2VzID0gdGhpcy5ib25lSW52ZXJzZXM7XG4gICAgICB0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYm9uZXMubGVuZ3RoICogMTYpOyAvLyBjYWxjdWxhdGUgaW52ZXJzZSBib25lIG1hdHJpY2VzIGlmIG5lY2Vzc2FyeVxuXG4gICAgICBpZiAoYm9uZUludmVyc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlXG4gICAgICAgIGlmIChib25lcy5sZW5ndGggIT09IGJvbmVJbnZlcnNlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlNrZWxldG9uOiBOdW1iZXIgb2YgaW52ZXJzZSBib25lIG1hdHJpY2VzIGRvZXMgbm90IG1hdGNoIGFtb3VudCBvZiBib25lcy4nKTtcbiAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kxNzEgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBfaTE3MSA8IGlsOyBfaTE3MSsrKSB7XG4gICAgICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKG5ldyBNYXRyaXg0KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVJbnZlcnNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnZlcnNlcygpIHtcbiAgICAgIHRoaXMuYm9uZUludmVyc2VzLmxlbmd0aCA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pMTcyID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgX2kxNzIgPCBpbDsgX2kxNzIrKykge1xuICAgICAgICB2YXIgaW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYm9uZXNbX2kxNzJdKSB7XG4gICAgICAgICAgaW52ZXJzZS5jb3B5KHRoaXMuYm9uZXNbX2kxNzJdLm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm9uZUludmVyc2VzLnB1c2goaW52ZXJzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zZSgpIHtcbiAgICAgIC8vIHJlY292ZXIgdGhlIGJpbmQtdGltZSB3b3JsZCBtYXRyaWNlc1xuICAgICAgZm9yICh2YXIgX2kxNzMgPSAwLCBpbCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBfaTE3MyA8IGlsOyBfaTE3MysrKSB7XG4gICAgICAgIHZhciBib25lID0gdGhpcy5ib25lc1tfaTE3M107XG5cbiAgICAgICAgaWYgKGJvbmUpIHtcbiAgICAgICAgICBib25lLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5ib25lSW52ZXJzZXNbX2kxNzNdKS5pbnZlcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG5cbiAgICAgIGZvciAodmFyIF9pMTc0ID0gMCwgX2lsMTIgPSB0aGlzLmJvbmVzLmxlbmd0aDsgX2kxNzQgPCBfaWwxMjsgX2kxNzQrKykge1xuICAgICAgICB2YXIgX2JvbmUgPSB0aGlzLmJvbmVzW19pMTc0XTtcblxuICAgICAgICBpZiAoX2JvbmUpIHtcbiAgICAgICAgICBpZiAoX2JvbmUucGFyZW50ICYmIF9ib25lLnBhcmVudC5pc0JvbmUpIHtcbiAgICAgICAgICAgIF9ib25lLm1hdHJpeC5jb3B5KF9ib25lLnBhcmVudC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cbiAgICAgICAgICAgIF9ib25lLm1hdHJpeC5tdWx0aXBseShfYm9uZS5tYXRyaXhXb3JsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9ib25lLm1hdHJpeC5jb3B5KF9ib25lLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfYm9uZS5tYXRyaXguZGVjb21wb3NlKF9ib25lLnBvc2l0aW9uLCBfYm9uZS5xdWF0ZXJuaW9uLCBfYm9uZS5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICB2YXIgYm9uZUludmVyc2VzID0gdGhpcy5ib25lSW52ZXJzZXM7XG4gICAgICB2YXIgYm9uZU1hdHJpY2VzID0gdGhpcy5ib25lTWF0cmljZXM7XG4gICAgICB2YXIgYm9uZVRleHR1cmUgPSB0aGlzLmJvbmVUZXh0dXJlOyAvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcblxuICAgICAgZm9yICh2YXIgX2kxNzUgPSAwLCBpbCA9IGJvbmVzLmxlbmd0aDsgX2kxNzUgPCBpbDsgX2kxNzUrKykge1xuICAgICAgICAvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuICAgICAgICB2YXIgbWF0cml4ID0gYm9uZXNbX2kxNzVdID8gYm9uZXNbX2kxNzVdLm1hdHJpeFdvcmxkIDogX2lkZW50aXR5TWF0cml4O1xuXG4gICAgICAgIF9vZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhtYXRyaXgsIGJvbmVJbnZlcnNlc1tfaTE3NV0pO1xuXG4gICAgICAgIF9vZmZzZXRNYXRyaXgudG9BcnJheShib25lTWF0cmljZXMsIF9pMTc1ICogMTYpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm9uZVRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgU2tlbGV0b24odGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21wdXRlQm9uZVRleHR1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUJvbmVUZXh0dXJlKCkge1xuICAgICAgLy8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuICAgICAgLy8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuICAgICAgLy8gIHdpdGggIDh4OCAgcGl4ZWwgdGV4dHVyZSBtYXggICAxNiBib25lcyAqIDQgcGl4ZWxzID0gICg4ICogOClcbiAgICAgIC8vICAgICAgIDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgYm9uZXMgKiA0IHBpeGVscyA9ICgxNiAqIDE2KVxuICAgICAgLy8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG4gICAgICAvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICogNCBwaXhlbHMgPSAoNjQgKiA2NClcbiAgICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KHRoaXMuYm9uZXMubGVuZ3RoICogNCk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcblxuICAgICAgc2l6ZSA9IGNlaWxQb3dlck9mVHdvKHNpemUpO1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KHNpemUsIDQpO1xuICAgICAgdmFyIGJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIHNpemUgKiA0KTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcblxuICAgICAgYm9uZU1hdHJpY2VzLnNldCh0aGlzLmJvbmVNYXRyaWNlcyk7IC8vIGNvcHkgY3VycmVudCB2YWx1ZXNcblxuICAgICAgdmFyIGJvbmVUZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKGJvbmVNYXRyaWNlcywgc2l6ZSwgc2l6ZSwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlKTtcbiAgICAgIGJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuYm9uZU1hdHJpY2VzID0gYm9uZU1hdHJpY2VzO1xuICAgICAgdGhpcy5ib25lVGV4dHVyZSA9IGJvbmVUZXh0dXJlO1xuICAgICAgdGhpcy5ib25lVGV4dHVyZVNpemUgPSBzaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvbmVCeU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9uZUJ5TmFtZShuYW1lKSB7XG4gICAgICBmb3IgKHZhciBfaTE3NiA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IF9pMTc2IDwgaWw7IF9pMTc2KyspIHtcbiAgICAgICAgdmFyIGJvbmUgPSB0aGlzLmJvbmVzW19pMTc2XTtcblxuICAgICAgICBpZiAoYm9uZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGJvbmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgaWYgKHRoaXMuYm9uZVRleHR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5ib25lVGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYm9uZVRleHR1cmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihqc29uLCBib25lcykge1xuICAgICAgdGhpcy51dWlkID0ganNvbi51dWlkO1xuXG4gICAgICBmb3IgKHZhciBfaTE3NyA9IDAsIGwgPSBqc29uLmJvbmVzLmxlbmd0aDsgX2kxNzcgPCBsOyBfaTE3NysrKSB7XG4gICAgICAgIHZhciB1dWlkID0ganNvbi5ib25lc1tfaTE3N107XG4gICAgICAgIHZhciBib25lID0gYm9uZXNbdXVpZF07XG5cbiAgICAgICAgaWYgKGJvbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuU2tlbGV0b246IE5vIGJvbmUgZm91bmQgd2l0aCBVVUlEOicsIHV1aWQpO1xuICAgICAgICAgIGJvbmUgPSBuZXcgQm9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib25lcy5wdXNoKGJvbmUpO1xuICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KGpzb24uYm9uZUludmVyc2VzW19pMTc3XSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluaXQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgdmVyc2lvbjogNC41LFxuICAgICAgICAgIHR5cGU6ICdTa2VsZXRvbicsXG4gICAgICAgICAgZ2VuZXJhdG9yOiAnU2tlbGV0b24udG9KU09OJ1xuICAgICAgICB9LFxuICAgICAgICBib25lczogW10sXG4gICAgICAgIGJvbmVJbnZlcnNlczogW11cbiAgICAgIH07XG4gICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgICB2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xuICAgICAgdmFyIGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xuXG4gICAgICBmb3IgKHZhciBfaTE3OCA9IDAsIGwgPSBib25lcy5sZW5ndGg7IF9pMTc4IDwgbDsgX2kxNzgrKykge1xuICAgICAgICB2YXIgYm9uZSA9IGJvbmVzW19pMTc4XTtcbiAgICAgICAgZGF0YS5ib25lcy5wdXNoKGJvbmUudXVpZCk7XG4gICAgICAgIHZhciBib25lSW52ZXJzZSA9IGJvbmVJbnZlcnNlc1tfaTE3OF07XG4gICAgICAgIGRhdGEuYm9uZUludmVyc2VzLnB1c2goYm9uZUludmVyc2UudG9BcnJheSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNrZWxldG9uO1xufSgpO1xuXG52YXIgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyQXR0cmlidXRlMTEpIHtcbiAgX2luaGVyaXRzKEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgX0J1ZmZlckF0dHJpYnV0ZTExKTtcblxuICB2YXIgX3N1cGVyNDYgPSBfY3JlYXRlU3VwZXIoSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKTtcblxuICBmdW5jdGlvbiBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKSB7XG4gICAgdmFyIF90aGlzMzc7XG5cbiAgICB2YXIgbWVzaFBlckF0dHJpYnV0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUpO1xuXG4gICAgaWYgKHR5cGVvZiBub3JtYWxpemVkID09PSAnbnVtYmVyJykge1xuICAgICAgbWVzaFBlckF0dHJpYnV0ZSA9IG5vcm1hbGl6ZWQ7XG4gICAgICBub3JtYWxpemVkID0gZmFsc2U7XG4gICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU6IFRoZSBjb25zdHJ1Y3RvciBub3cgZXhwZWN0cyBub3JtYWxpemVkIGFzIHRoZSB0aGlyZCBhcmd1bWVudC4nKTtcbiAgICB9XG5cbiAgICBfdGhpczM3ID0gX3N1cGVyNDYuY2FsbCh0aGlzLCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICAgIF90aGlzMzcuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuICAgIF90aGlzMzcubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG4gICAgcmV0dXJuIF90aGlzMzc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBkYXRhID0gX2dldChfZ2V0UHJvdG90eXBlT2YoSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGRhdGEubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcbiAgICAgIGRhdGEuaXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcbn0oQnVmZmVyQXR0cmlidXRlKTtcblxudmFyIF9pbnN0YW5jZUxvY2FsTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfaW5zdGFuY2VXb3JsZE1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG52YXIgX2luc3RhbmNlSW50ZXJzZWN0cyA9IFtdO1xuXG52YXIgX21lc2ggPSAvKkBfX1BVUkVfXyovbmV3IE1lc2goKTtcblxudmFyIEluc3RhbmNlZE1lc2ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NZXNoMikge1xuICBfaW5oZXJpdHMoSW5zdGFuY2VkTWVzaCwgX01lc2gyKTtcblxuICB2YXIgX3N1cGVyNDcgPSBfY3JlYXRlU3VwZXIoSW5zdGFuY2VkTWVzaCk7XG5cbiAgZnVuY3Rpb24gSW5zdGFuY2VkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwsIGNvdW50KSB7XG4gICAgdmFyIF90aGlzMzg7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5zdGFuY2VkTWVzaCk7XG5cbiAgICBfdGhpczM4ID0gX3N1cGVyNDcuY2FsbCh0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgIF90aGlzMzguaXNJbnN0YW5jZWRNZXNoID0gdHJ1ZTtcbiAgICBfdGhpczM4Lmluc3RhbmNlTWF0cml4ID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGNvdW50ICogMTYpLCAxNik7XG4gICAgX3RoaXMzOC5pbnN0YW5jZUNvbG9yID0gbnVsbDtcbiAgICBfdGhpczM4LmNvdW50ID0gY291bnQ7XG4gICAgX3RoaXMzOC5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzMzg7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW5zdGFuY2VkTWVzaCwgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihJbnN0YW5jZWRNZXNoLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlKTtcblxuICAgICAgdGhpcy5pbnN0YW5jZU1hdHJpeC5jb3B5KHNvdXJjZS5pbnN0YW5jZU1hdHJpeCk7XG4gICAgICBpZiAoc291cmNlLmluc3RhbmNlQ29sb3IgIT09IG51bGwpIHRoaXMuaW5zdGFuY2VDb2xvciA9IHNvdXJjZS5pbnN0YW5jZUNvbG9yLmNsb25lKCk7XG4gICAgICB0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbG9yQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sb3JBdChpbmRleCwgY29sb3IpIHtcbiAgICAgIGNvbG9yLmZyb21BcnJheSh0aGlzLmluc3RhbmNlQ29sb3IuYXJyYXksIGluZGV4ICogMyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1hdHJpeEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hdHJpeEF0KGluZGV4LCBtYXRyaXgpIHtcbiAgICAgIG1hdHJpeC5mcm9tQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5hcnJheSwgaW5kZXggKiAxNik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJheWNhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICAgIHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgICB2YXIgcmF5Y2FzdFRpbWVzID0gdGhpcy5jb3VudDtcbiAgICAgIF9tZXNoLmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgIF9tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICAgIGlmIChfbWVzaC5tYXRlcmlhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgPSAwOyBpbnN0YW5jZUlkIDwgcmF5Y2FzdFRpbWVzOyBpbnN0YW5jZUlkKyspIHtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB3b3JsZCBtYXRyaXggZm9yIGVhY2ggaW5zdGFuY2VcbiAgICAgICAgdGhpcy5nZXRNYXRyaXhBdChpbnN0YW5jZUlkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCk7XG5cbiAgICAgICAgX2luc3RhbmNlV29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhtYXRyaXhXb3JsZCwgX2luc3RhbmNlTG9jYWxNYXRyaXgpOyAvLyB0aGUgbWVzaCByZXByZXNlbnRzIHRoaXMgc2luZ2xlIGluc3RhbmNlXG5cblxuICAgICAgICBfbWVzaC5tYXRyaXhXb3JsZCA9IF9pbnN0YW5jZVdvcmxkTWF0cml4O1xuXG4gICAgICAgIF9tZXNoLnJheWNhc3QocmF5Y2FzdGVyLCBfaW5zdGFuY2VJbnRlcnNlY3RzKTsgLy8gcHJvY2VzcyB0aGUgcmVzdWx0IG9mIHJheWNhc3RcblxuXG4gICAgICAgIGZvciAodmFyIF9pMTc5ID0gMCwgbCA9IF9pbnN0YW5jZUludGVyc2VjdHMubGVuZ3RoOyBfaTE3OSA8IGw7IF9pMTc5KyspIHtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gX2luc3RhbmNlSW50ZXJzZWN0c1tfaTE3OV07XG4gICAgICAgICAgaW50ZXJzZWN0Lmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkO1xuICAgICAgICAgIGludGVyc2VjdC5vYmplY3QgPSB0aGlzO1xuICAgICAgICAgIGludGVyc2VjdHMucHVzaChpbnRlcnNlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2luc3RhbmNlSW50ZXJzZWN0cy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDb2xvckF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbG9yQXQoaW5kZXgsIGNvbG9yKSB7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZUNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VDb2xvciA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheSh0aGlzLmluc3RhbmNlTWF0cml4LmNvdW50ICogMyksIDMpO1xuICAgICAgfVxuXG4gICAgICBjb2xvci50b0FycmF5KHRoaXMuaW5zdGFuY2VDb2xvci5hcnJheSwgaW5kZXggKiAzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TWF0cml4QXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWF0cml4QXQoaW5kZXgsIG1hdHJpeCkge1xuICAgICAgbWF0cml4LnRvQXJyYXkodGhpcy5pbnN0YW5jZU1hdHJpeC5hcnJheSwgaW5kZXggKiAxNik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU1vcnBoVGFyZ2V0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNb3JwaFRhcmdldHMoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6ICdkaXNwb3NlJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEluc3RhbmNlZE1lc2g7XG59KE1lc2gpO1xuXG52YXIgTGluZUJhc2ljTWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NYXRlcmlhbDYpIHtcbiAgX2luaGVyaXRzKExpbmVCYXNpY01hdGVyaWFsLCBfTWF0ZXJpYWw2KTtcblxuICB2YXIgX3N1cGVyNDggPSBfY3JlYXRlU3VwZXIoTGluZUJhc2ljTWF0ZXJpYWwpO1xuXG4gIGZ1bmN0aW9uIExpbmVCYXNpY01hdGVyaWFsKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgX3RoaXMzOTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lQmFzaWNNYXRlcmlhbCk7XG5cbiAgICBfdGhpczM5ID0gX3N1cGVyNDguY2FsbCh0aGlzKTtcbiAgICBfdGhpczM5LmlzTGluZUJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuICAgIF90aGlzMzkudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG4gICAgX3RoaXMzOS5jb2xvciA9IG5ldyBDb2xvcigweGZmZmZmZik7XG4gICAgX3RoaXMzOS5saW5ld2lkdGggPSAxO1xuICAgIF90aGlzMzkubGluZWNhcCA9ICdyb3VuZCc7XG4gICAgX3RoaXMzOS5saW5lam9pbiA9ICdyb3VuZCc7XG4gICAgX3RoaXMzOS5mb2cgPSB0cnVlO1xuXG4gICAgX3RoaXMzOS5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cbiAgICByZXR1cm4gX3RoaXMzOTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5lQmFzaWNNYXRlcmlhbCwgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG4gICAgICB0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XG4gICAgICB0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcbiAgICAgIHRoaXMubGluZWpvaW4gPSBzb3VyY2UubGluZWpvaW47XG4gICAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZUJhc2ljTWF0ZXJpYWw7XG59KE1hdGVyaWFsKTtcblxudmFyIF9zdGFydCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfZW5kJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9pbnZlcnNlTWF0cml4JDEgPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxudmFyIF9yYXkkMSA9IC8qQF9fUFVSRV9fKi9uZXcgUmF5KCk7XG5cbnZhciBfc3BoZXJlJDEgPSAvKkBfX1BVUkVfXyovbmV3IFNwaGVyZSgpO1xuXG52YXIgTGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iamVjdDNEOSkge1xuICBfaW5oZXJpdHMoTGluZSwgX09iamVjdDNEOSk7XG5cbiAgdmFyIF9zdXBlcjQ5ID0gX2NyZWF0ZVN1cGVyKExpbmUpO1xuXG4gIGZ1bmN0aW9uIExpbmUoKSB7XG4gICAgdmFyIF90aGlzNDA7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIHZhciBtYXRlcmlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZSk7XG5cbiAgICBfdGhpczQwID0gX3N1cGVyNDkuY2FsbCh0aGlzKTtcbiAgICBfdGhpczQwLmlzTGluZSA9IHRydWU7XG4gICAgX3RoaXM0MC50eXBlID0gJ0xpbmUnO1xuICAgIF90aGlzNDAuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICBfdGhpczQwLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG5cbiAgICBfdGhpczQwLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXG4gICAgcmV0dXJuIF90aGlzNDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGluZSwgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaW5lLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlKTtcblxuICAgICAgdGhpcy5tYXRlcmlhbCA9IHNvdXJjZS5tYXRlcmlhbDtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBzb3VyY2UuZ2VvbWV0cnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZUxpbmVEaXN0YW5jZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUxpbmVEaXN0YW5jZXMoKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5OyAvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuICAgICAgaWYgKGdlb21ldHJ5LmluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICAgIHZhciBsaW5lRGlzdGFuY2VzID0gWzBdO1xuXG4gICAgICAgIGZvciAodmFyIF9pMTgwID0gMSwgbCA9IHBvc2l0aW9uQXR0cmlidXRlLmNvdW50OyBfaTE4MCA8IGw7IF9pMTgwKyspIHtcbiAgICAgICAgICBfc3RhcnQkMS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBfaTE4MCAtIDEpO1xuXG4gICAgICAgICAgX2VuZCQxLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIF9pMTgwKTtcblxuICAgICAgICAgIGxpbmVEaXN0YW5jZXNbX2kxODBdID0gbGluZURpc3RhbmNlc1tfaTE4MCAtIDFdO1xuICAgICAgICAgIGxpbmVEaXN0YW5jZXNbX2kxODBdICs9IF9zdGFydCQxLmRpc3RhbmNlVG8oX2VuZCQxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbGluZURpc3RhbmNlJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobGluZURpc3RhbmNlcywgMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5MaW5lLmNvbXB1dGVMaW5lRGlzdGFuY2VzKCk6IENvbXB1dGF0aW9uIG9ubHkgcG9zc2libGUgd2l0aCBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeS4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJheWNhc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgICB2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuICAgICAgdmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuTGluZS50aHJlc2hvbGQ7XG4gICAgICB2YXIgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlOyAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuICAgICAgaWYgKGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgX3NwaGVyZSQxLmNvcHkoZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpO1xuXG4gICAgICBfc3BoZXJlJDEuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcblxuICAgICAgX3NwaGVyZSQxLnJhZGl1cyArPSB0aHJlc2hvbGQ7XG4gICAgICBpZiAocmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKF9zcGhlcmUkMSkgPT09IGZhbHNlKSByZXR1cm47IC8vXG5cbiAgICAgIF9pbnZlcnNlTWF0cml4JDEuY29weShtYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG5cbiAgICAgIF9yYXkkMS5jb3B5KHJheWNhc3Rlci5yYXkpLmFwcGx5TWF0cml4NChfaW52ZXJzZU1hdHJpeCQxKTtcblxuICAgICAgdmFyIGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCh0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnopIC8gMyk7XG4gICAgICB2YXIgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG4gICAgICB2YXIgdlN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciB2RW5kID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBpbnRlclNlZ21lbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdmFyIGludGVyUmF5ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5pc0xpbmVTZWdtZW50cyA/IDIgOiAxO1xuICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMTgxID0gc3RhcnQsIGwgPSBlbmQgLSAxOyBfaTE4MSA8IGw7IF9pMTgxICs9IHN0ZXApIHtcbiAgICAgICAgICB2YXIgYSA9IGluZGV4LmdldFgoX2kxODEpO1xuICAgICAgICAgIHZhciBiID0gaW5kZXguZ2V0WChfaTE4MSArIDEpO1xuICAgICAgICAgIHZTdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBhKTtcbiAgICAgICAgICB2RW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGIpO1xuXG4gICAgICAgICAgdmFyIGRpc3RTcSA9IF9yYXkkMS5kaXN0YW5jZVNxVG9TZWdtZW50KHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCk7XG5cbiAgICAgICAgICBpZiAoZGlzdFNxID4gbG9jYWxUaHJlc2hvbGRTcSkgY29udGludWU7XG4gICAgICAgICAgaW50ZXJSYXkuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oaW50ZXJSYXkpO1xuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhcikgY29udGludWU7XG4gICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgICAgICAgICAgLy8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG4gICAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpLFxuICAgICAgICAgICAgaW5kZXg6IF9pMTgxLFxuICAgICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcbiAgICAgICAgICAgIG9iamVjdDogdGhpc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3N0YXJ0NiA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG5cbiAgICAgICAgdmFyIF9lbmQ1ID0gTWF0aC5taW4ocG9zaXRpb25BdHRyaWJ1dGUuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kxODIgPSBfc3RhcnQ2LCBfbDcgPSBfZW5kNSAtIDE7IF9pMTgyIDwgX2w3OyBfaTE4MiArPSBzdGVwKSB7XG4gICAgICAgICAgdlN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIF9pMTgyKTtcbiAgICAgICAgICB2RW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIF9pMTgyICsgMSk7XG5cbiAgICAgICAgICB2YXIgX2Rpc3RTcSA9IF9yYXkkMS5kaXN0YW5jZVNxVG9TZWdtZW50KHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCk7XG5cbiAgICAgICAgICBpZiAoX2Rpc3RTcSA+IGxvY2FsVGhyZXNob2xkU3EpIGNvbnRpbnVlO1xuICAgICAgICAgIGludGVyUmF5LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cbiAgICAgICAgICB2YXIgX2Rpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhpbnRlclJheSk7XG5cbiAgICAgICAgICBpZiAoX2Rpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgX2Rpc3RhbmNlID4gcmF5Y2FzdGVyLmZhcikgY29udGludWU7XG4gICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKHtcbiAgICAgICAgICAgIGRpc3RhbmNlOiBfZGlzdGFuY2UsXG4gICAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKSxcbiAgICAgICAgICAgIGluZGV4OiBfaTE4MixcbiAgICAgICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgICBvYmplY3Q6IHRoaXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVNb3JwaFRhcmdldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgIHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vcnBoQXR0cmlidXRlcyk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW2tleXNbMF1dO1xuXG4gICAgICAgIGlmIChtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVttXS5uYW1lIHx8IFN0cmluZyhtKTtcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtuYW1lXSA9IG07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmU7XG59KE9iamVjdDNEKTtcblxudmFyIF9zdGFydCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX2VuZCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgTGluZVNlZ21lbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGluZSkge1xuICBfaW5oZXJpdHMoTGluZVNlZ21lbnRzLCBfTGluZSk7XG5cbiAgdmFyIF9zdXBlcjUwID0gX2NyZWF0ZVN1cGVyKExpbmVTZWdtZW50cyk7XG5cbiAgZnVuY3Rpb24gTGluZVNlZ21lbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCkge1xuICAgIHZhciBfdGhpczQxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmVTZWdtZW50cyk7XG5cbiAgICBfdGhpczQxID0gX3N1cGVyNTAuY2FsbCh0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgIF90aGlzNDEuaXNMaW5lU2VnbWVudHMgPSB0cnVlO1xuICAgIF90aGlzNDEudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xuICAgIHJldHVybiBfdGhpczQxO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmVTZWdtZW50cywgW3tcbiAgICBrZXk6IFwiY29tcHV0ZUxpbmVEaXN0YW5jZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUxpbmVEaXN0YW5jZXMoKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5OyAvLyB3ZSBhc3N1bWUgbm9uLWluZGV4ZWQgZ2VvbWV0cnlcblxuICAgICAgaWYgKGdlb21ldHJ5LmluZGV4ID09PSBudWxsKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICAgIHZhciBsaW5lRGlzdGFuY2VzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kxODMgPSAwLCBsID0gcG9zaXRpb25BdHRyaWJ1dGUuY291bnQ7IF9pMTgzIDwgbDsgX2kxODMgKz0gMikge1xuICAgICAgICAgIF9zdGFydC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBfaTE4Myk7XG5cbiAgICAgICAgICBfZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIF9pMTgzICsgMSk7XG5cbiAgICAgICAgICBsaW5lRGlzdGFuY2VzW19pMTgzXSA9IF9pMTgzID09PSAwID8gMCA6IGxpbmVEaXN0YW5jZXNbX2kxODMgLSAxXTtcbiAgICAgICAgICBsaW5lRGlzdGFuY2VzW19pMTgzICsgMV0gPSBsaW5lRGlzdGFuY2VzW19pMTgzXSArIF9zdGFydC5kaXN0YW5jZVRvKF9lbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdsaW5lRGlzdGFuY2UnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShsaW5lRGlzdGFuY2VzLCAxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkxpbmVTZWdtZW50cy5jb21wdXRlTGluZURpc3RhbmNlcygpOiBDb21wdXRhdGlvbiBvbmx5IHBvc3NpYmxlIHdpdGggbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnkuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lU2VnbWVudHM7XG59KExpbmUpO1xuXG52YXIgTGluZUxvb3AgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaW5lMikge1xuICBfaW5oZXJpdHMoTGluZUxvb3AsIF9MaW5lMik7XG5cbiAgdmFyIF9zdXBlcjUxID0gX2NyZWF0ZVN1cGVyKExpbmVMb29wKTtcblxuICBmdW5jdGlvbiBMaW5lTG9vcChnZW9tZXRyeSwgbWF0ZXJpYWwpIHtcbiAgICB2YXIgX3RoaXM0MjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lTG9vcCk7XG5cbiAgICBfdGhpczQyID0gX3N1cGVyNTEuY2FsbCh0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgIF90aGlzNDIuaXNMaW5lTG9vcCA9IHRydWU7XG4gICAgX3RoaXM0Mi50eXBlID0gJ0xpbmVMb29wJztcbiAgICByZXR1cm4gX3RoaXM0MjtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTGluZUxvb3ApO1xufShMaW5lKTtcblxudmFyIFBvaW50c01hdGVyaWFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWF0ZXJpYWw3KSB7XG4gIF9pbmhlcml0cyhQb2ludHNNYXRlcmlhbCwgX01hdGVyaWFsNyk7XG5cbiAgdmFyIF9zdXBlcjUyID0gX2NyZWF0ZVN1cGVyKFBvaW50c01hdGVyaWFsKTtcblxuICBmdW5jdGlvbiBQb2ludHNNYXRlcmlhbChwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF90aGlzNDM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9pbnRzTWF0ZXJpYWwpO1xuXG4gICAgX3RoaXM0MyA9IF9zdXBlcjUyLmNhbGwodGhpcyk7XG4gICAgX3RoaXM0My5pc1BvaW50c01hdGVyaWFsID0gdHJ1ZTtcbiAgICBfdGhpczQzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xuICAgIF90aGlzNDMuY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmZmYpO1xuICAgIF90aGlzNDMubWFwID0gbnVsbDtcbiAgICBfdGhpczQzLmFscGhhTWFwID0gbnVsbDtcbiAgICBfdGhpczQzLnNpemUgPSAxO1xuICAgIF90aGlzNDMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcbiAgICBfdGhpczQzLmZvZyA9IHRydWU7XG5cbiAgICBfdGhpczQzLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblxuICAgIHJldHVybiBfdGhpczQzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvaW50c01hdGVyaWFsLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcbiAgICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcbiAgICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG4gICAgICB0aGlzLnNpemUgPSBzb3VyY2Uuc2l6ZTtcbiAgICAgIHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gc291cmNlLnNpemVBdHRlbnVhdGlvbjtcbiAgICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb2ludHNNYXRlcmlhbDtcbn0oTWF0ZXJpYWwpO1xuXG52YXIgX2ludmVyc2VNYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxudmFyIF9yYXkgPSAvKkBfX1BVUkVfXyovbmV3IFJheSgpO1xuXG52YXIgX3NwaGVyZSA9IC8qQF9fUFVSRV9fKi9uZXcgU3BoZXJlKCk7XG5cbnZhciBfcG9zaXRpb24kMiA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgUG9pbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqZWN0M0QxMCkge1xuICBfaW5oZXJpdHMoUG9pbnRzLCBfT2JqZWN0M0QxMCk7XG5cbiAgdmFyIF9zdXBlcjUzID0gX2NyZWF0ZVN1cGVyKFBvaW50cyk7XG5cbiAgZnVuY3Rpb24gUG9pbnRzKCkge1xuICAgIHZhciBfdGhpczQ0O1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICB2YXIgbWF0ZXJpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyBQb2ludHNNYXRlcmlhbCgpO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvaW50cyk7XG5cbiAgICBfdGhpczQ0ID0gX3N1cGVyNTMuY2FsbCh0aGlzKTtcbiAgICBfdGhpczQ0LmlzUG9pbnRzID0gdHJ1ZTtcbiAgICBfdGhpczQ0LnR5cGUgPSAnUG9pbnRzJztcbiAgICBfdGhpczQ0Lmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgX3RoaXM0NC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXG4gICAgX3RoaXM0NC51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxuICAgIHJldHVybiBfdGhpczQ0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvaW50cywgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihQb2ludHMucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlLCByZWN1cnNpdmUpO1xuXG4gICAgICB0aGlzLm1hdGVyaWFsID0gc291cmNlLm1hdGVyaWFsO1xuICAgICAgdGhpcy5nZW9tZXRyeSA9IHNvdXJjZS5nZW9tZXRyeTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyYXljYXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSByYXljYXN0ZXIucGFyYW1zLlBvaW50cy50aHJlc2hvbGQ7XG4gICAgICB2YXIgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlOyAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuICAgICAgaWYgKGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgICAgX3NwaGVyZS5jb3B5KGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKTtcblxuICAgICAgX3NwaGVyZS5hcHBseU1hdHJpeDQobWF0cml4V29ybGQpO1xuXG4gICAgICBfc3BoZXJlLnJhZGl1cyArPSB0aHJlc2hvbGQ7XG4gICAgICBpZiAocmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKF9zcGhlcmUpID09PSBmYWxzZSkgcmV0dXJuOyAvL1xuXG4gICAgICBfaW52ZXJzZU1hdHJpeC5jb3B5KG1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcblxuICAgICAgX3JheS5jb3B5KHJheWNhc3Rlci5yYXkpLmFwcGx5TWF0cml4NChfaW52ZXJzZU1hdHJpeCk7XG5cbiAgICAgIHZhciBsb2NhbFRocmVzaG9sZCA9IHRocmVzaG9sZCAvICgodGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56KSAvIDMpO1xuICAgICAgdmFyIGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuICAgICAgdmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICB2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICBpZiAoaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMTg0ID0gc3RhcnQsIGlsID0gZW5kOyBfaTE4NCA8IGlsOyBfaTE4NCsrKSB7XG4gICAgICAgICAgdmFyIGEgPSBpbmRleC5nZXRYKF9pMTg0KTtcblxuICAgICAgICAgIF9wb3NpdGlvbiQyLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyaWJ1dGUsIGEpO1xuXG4gICAgICAgICAgdGVzdFBvaW50KF9wb3NpdGlvbiQyLCBhLCBsb2NhbFRocmVzaG9sZFNxLCBtYXRyaXhXb3JsZCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9zdGFydDcgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuXG4gICAgICAgIHZhciBfZW5kNiA9IE1hdGgubWluKHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMTg1ID0gX3N0YXJ0NywgbCA9IF9lbmQ2OyBfaTE4NSA8IGw7IF9pMTg1KyspIHtcbiAgICAgICAgICBfcG9zaXRpb24kMi5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0cmlidXRlLCBfaTE4NSk7XG5cbiAgICAgICAgICB0ZXN0UG9pbnQoX3Bvc2l0aW9uJDIsIF9pMTg1LCBsb2NhbFRocmVzaG9sZFNxLCBtYXRyaXhXb3JsZCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVNb3JwaFRhcmdldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTW9ycGhUYXJnZXRzKCkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgIHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vcnBoQXR0cmlidXRlcyk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzW2tleXNbMF1dO1xuXG4gICAgICAgIGlmIChtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIgbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBtb3JwaEF0dHJpYnV0ZVttXS5uYW1lIHx8IFN0cmluZyhtKTtcbiAgICAgICAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVtuYW1lXSA9IG07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvaW50cztcbn0oT2JqZWN0M0QpO1xuXG5mdW5jdGlvbiB0ZXN0UG9pbnQocG9pbnQsIGluZGV4LCBsb2NhbFRocmVzaG9sZFNxLCBtYXRyaXhXb3JsZCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCBvYmplY3QpIHtcbiAgdmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IF9yYXkuZGlzdGFuY2VTcVRvUG9pbnQocG9pbnQpO1xuXG4gIGlmIChyYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxKSB7XG4gICAgdmFyIGludGVyc2VjdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIF9yYXkuY2xvc2VzdFBvaW50VG9Qb2ludChwb2ludCwgaW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgaW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KG1hdHJpeFdvcmxkKTtcbiAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKGludGVyc2VjdFBvaW50KTtcbiAgICBpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIHJldHVybjtcbiAgICBpbnRlcnNlY3RzLnB1c2goe1xuICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KHJheVBvaW50RGlzdGFuY2VTcSksXG4gICAgICBwb2ludDogaW50ZXJzZWN0UG9pbnQsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBmYWNlOiBudWxsLFxuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgVmlkZW9UZXh0dXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dHVyZTYpIHtcbiAgX2luaGVyaXRzKFZpZGVvVGV4dHVyZSwgX1RleHR1cmU2KTtcblxuICB2YXIgX3N1cGVyNTQgPSBfY3JlYXRlU3VwZXIoVmlkZW9UZXh0dXJlKTtcblxuICBmdW5jdGlvbiBWaWRlb1RleHR1cmUodmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSkge1xuICAgIHZhciBfdGhpczQ1O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVGV4dHVyZSk7XG5cbiAgICBfdGhpczQ1ID0gX3N1cGVyNTQuY2FsbCh0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5KTtcbiAgICBfdGhpczQ1LmlzVmlkZW9UZXh0dXJlID0gdHJ1ZTtcbiAgICBfdGhpczQ1Lm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuICAgIF90aGlzNDUubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XG4gICAgX3RoaXM0NS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgIHZhciBzY29wZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM0NSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVWaWRlbygpIHtcbiAgICAgIHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHZpZGVvLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sodXBkYXRlVmlkZW8pO1xuICAgIH1cblxuICAgIGlmICgncmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaycgaW4gdmlkZW8pIHtcbiAgICAgIHZpZGVvLnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2sodXBkYXRlVmlkZW8pO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpczQ1O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZpZGVvVGV4dHVyZSwgW3tcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5pbWFnZSkuY29weSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciB2aWRlbyA9IHRoaXMuaW1hZ2U7XG4gICAgICB2YXIgaGFzVmlkZW9GcmFtZUNhbGxiYWNrID0gKCdyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrJyBpbiB2aWRlbyk7XG5cbiAgICAgIGlmIChoYXNWaWRlb0ZyYW1lQ2FsbGJhY2sgPT09IGZhbHNlICYmIHZpZGVvLnJlYWR5U3RhdGUgPj0gdmlkZW8uSEFWRV9DVVJSRU5UX0RBVEEpIHtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZGVvVGV4dHVyZTtcbn0oVGV4dHVyZSk7XG5cbnZhciBGcmFtZWJ1ZmZlclRleHR1cmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UZXh0dXJlNykge1xuICBfaW5oZXJpdHMoRnJhbWVidWZmZXJUZXh0dXJlLCBfVGV4dHVyZTcpO1xuXG4gIHZhciBfc3VwZXI1NSA9IF9jcmVhdGVTdXBlcihGcmFtZWJ1ZmZlclRleHR1cmUpO1xuXG4gIGZ1bmN0aW9uIEZyYW1lYnVmZmVyVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCBmb3JtYXQpIHtcbiAgICB2YXIgX3RoaXM0NjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFtZWJ1ZmZlclRleHR1cmUpO1xuXG4gICAgX3RoaXM0NiA9IF9zdXBlcjU1LmNhbGwodGhpcywge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KTtcbiAgICBfdGhpczQ2LmlzRnJhbWVidWZmZXJUZXh0dXJlID0gdHJ1ZTtcbiAgICBfdGhpczQ2LmZvcm1hdCA9IGZvcm1hdDtcbiAgICBfdGhpczQ2Lm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG4gICAgX3RoaXM0Ni5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuICAgIF90aGlzNDYuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgX3RoaXM0Ni5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzNDY7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEZyYW1lYnVmZmVyVGV4dHVyZSk7XG59KFRleHR1cmUpO1xuXG52YXIgQ29tcHJlc3NlZFRleHR1cmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UZXh0dXJlOCkge1xuICBfaW5oZXJpdHMoQ29tcHJlc3NlZFRleHR1cmUsIF9UZXh0dXJlOCk7XG5cbiAgdmFyIF9zdXBlcjU2ID0gX2NyZWF0ZVN1cGVyKENvbXByZXNzZWRUZXh0dXJlKTtcblxuICBmdW5jdGlvbiBDb21wcmVzc2VkVGV4dHVyZShtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nKSB7XG4gICAgdmFyIF90aGlzNDc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcHJlc3NlZFRleHR1cmUpO1xuXG4gICAgX3RoaXM0NyA9IF9zdXBlcjU2LmNhbGwodGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyk7XG4gICAgX3RoaXM0Ny5pc0NvbXByZXNzZWRUZXh0dXJlID0gdHJ1ZTtcbiAgICBfdGhpczQ3LmltYWdlID0ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICAgIF90aGlzNDcubWlwbWFwcyA9IG1pcG1hcHM7IC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXG4gICAgLy8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcblxuICAgIF90aGlzNDcuZmxpcFkgPSBmYWxzZTsgLy8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuICAgIC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcblxuICAgIF90aGlzNDcuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzNDc7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbXByZXNzZWRUZXh0dXJlKTtcbn0oVGV4dHVyZSk7XG5cbnZhciBDYW52YXNUZXh0dXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dHVyZTkpIHtcbiAgX2luaGVyaXRzKENhbnZhc1RleHR1cmUsIF9UZXh0dXJlOSk7XG5cbiAgdmFyIF9zdXBlcjU3ID0gX2NyZWF0ZVN1cGVyKENhbnZhc1RleHR1cmUpO1xuXG4gIGZ1bmN0aW9uIENhbnZhc1RleHR1cmUoY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkpIHtcbiAgICB2YXIgX3RoaXM0ODtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNUZXh0dXJlKTtcblxuICAgIF90aGlzNDggPSBfc3VwZXI1Ny5jYWxsKHRoaXMsIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5KTtcbiAgICBfdGhpczQ4LmlzQ2FudmFzVGV4dHVyZSA9IHRydWU7XG4gICAgX3RoaXM0OC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzNDg7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENhbnZhc1RleHR1cmUpO1xufShUZXh0dXJlKTtcbi8qKlxuICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3QuXG4gKlxuICogU29tZSBjb21tb24gb2YgY3VydmUgbWV0aG9kczpcbiAqIC5nZXRQb2ludCggdCwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnQoIHQsIG9wdGlvbmFsVGFyZ2V0IClcbiAqIC5nZXRQb2ludEF0KCB1LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudEF0KCB1LCBvcHRpb25hbFRhcmdldCApXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY3VydmVzIGluaGVyaXQgZnJvbSBUSFJFRS5DdXJ2ZTpcbiAqXG4gKiAtLSAyRCBjdXJ2ZXMgLS1cbiAqIFRIUkVFLkFyY0N1cnZlXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXG4gKiBUSFJFRS5FbGxpcHNlQ3VydmVcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKlxuICogLS0gM0QgY3VydmVzIC0tXG4gKiBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKlxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aC5cbiAqXG4gKiovXG5cblxudmFyIEN1cnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3VydmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnZlKTtcblxuICAgIHRoaXMudHlwZSA9ICdDdXJ2ZSc7XG4gICAgdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSAyMDA7XG4gIH0gLy8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXG4gIC8vXHQtIHQgWzAgLi4gMV1cblxuXG4gIF9jcmVhdGVDbGFzcyhDdXJ2ZSwgW3tcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb25cbiAgICAgIC8qIHQsIG9wdGlvbmFsVGFyZ2V0ICovXG4gICAgZ2V0UG9pbnQoKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkN1cnZlOiAuZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuICAgIC8vIC0gdSBbMCAuLiAxXVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludEF0KHUsIG9wdGlvbmFsVGFyZ2V0KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcodSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCk7XG4gICAgfSAvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludHMoKSB7XG4gICAgICB2YXIgZGl2aXNpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiA1O1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQrKykge1xuICAgICAgICBwb2ludHMucHVzaCh0aGlzLmdldFBvaW50KGQgLyBkaXZpc2lvbnMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9IC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRTcGFjZWRQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3BhY2VkUG9pbnRzKCkge1xuICAgICAgdmFyIGRpdmlzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogNTtcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2godGhpcy5nZXRQb2ludEF0KGQgLyBkaXZpc2lvbnMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9IC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xuICAgICAgdmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcbiAgICAgIHJldHVybiBsZW5ndGhzW2xlbmd0aHMubGVuZ3RoIC0gMV07XG4gICAgfSAvLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGVuZ3Roc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZW5ndGhzKCkge1xuICAgICAgdmFyIGRpdmlzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlQXJjTGVuZ3RocyAmJiB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgJiYgIXRoaXMubmVlZHNVcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICB2YXIgY2FjaGUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50LFxuICAgICAgICAgIGxhc3QgPSB0aGlzLmdldFBvaW50KDApO1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICBjYWNoZS5wdXNoKDApO1xuXG4gICAgICBmb3IgKHZhciBwID0gMTsgcCA8PSBkaXZpc2lvbnM7IHArKykge1xuICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXRQb2ludChwIC8gZGl2aXNpb25zKTtcbiAgICAgICAgc3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyhsYXN0KTtcbiAgICAgICAgY2FjaGUucHVzaChzdW0pO1xuICAgICAgICBsYXN0ID0gY3VycmVudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcbiAgICAgIHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOiBzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUFyY0xlbmd0aHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQXJjTGVuZ3RocygpIHtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgdGhpcy5nZXRMZW5ndGhzKCk7XG4gICAgfSAvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRVdG9UbWFwcGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVdG9UbWFwcGluZyh1LCBkaXN0YW5jZSkge1xuICAgICAgdmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xuICAgICAgdmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XG5cbiAgICAgIGlmIChkaXN0YW5jZSkge1xuICAgICAgICB0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzW2lsIC0gMV07XG4gICAgICB9IC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXG5cblxuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGlsIC0gMSxcbiAgICAgICAgICBjb21wYXJpc29uO1xuXG4gICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgaSA9IE1hdGguZmxvb3IobG93ICsgKGhpZ2ggLSBsb3cpIC8gMik7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuICAgICAgICBjb21wYXJpc29uID0gYXJjTGVuZ3Roc1tpXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuICAgICAgICBpZiAoY29tcGFyaXNvbiA8IDApIHtcbiAgICAgICAgICBsb3cgPSBpICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wYXJpc29uID4gMCkge1xuICAgICAgICAgIGhpZ2ggPSBpIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gaTtcbiAgICAgICAgICBicmVhazsgLy8gRE9ORVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkgPSBoaWdoO1xuXG4gICAgICBpZiAoYXJjTGVuZ3Roc1tpXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpIC8gKGlsIC0gMSk7XG4gICAgICB9IC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cblxuICAgICAgdmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbaV07XG4gICAgICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzW2kgKyAxXTtcbiAgICAgIHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7IC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cbiAgICAgIHZhciBzZWdtZW50RnJhY3Rpb24gPSAodGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlKSAvIHNlZ21lbnRMZW5ndGg7IC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcblxuICAgICAgdmFyIHQgPSAoaSArIHNlZ21lbnRGcmFjdGlvbikgLyAoaWwgLSAxKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH0gLy8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxuICAgIC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcbiAgICAvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuICAgIC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cblxuICB9LCB7XG4gICAga2V5OiBcImdldFRhbmdlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFuZ2VudCh0LCBvcHRpb25hbFRhcmdldCkge1xuICAgICAgdmFyIGRlbHRhID0gMC4wMDAxO1xuICAgICAgdmFyIHQxID0gdCAtIGRlbHRhO1xuICAgICAgdmFyIHQyID0gdCArIGRlbHRhOyAvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXG5cbiAgICAgIGlmICh0MSA8IDApIHQxID0gMDtcbiAgICAgIGlmICh0MiA+IDEpIHQyID0gMTtcbiAgICAgIHZhciBwdDEgPSB0aGlzLmdldFBvaW50KHQxKTtcbiAgICAgIHZhciBwdDIgPSB0aGlzLmdldFBvaW50KHQyKTtcbiAgICAgIHZhciB0YW5nZW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgKHB0MS5pc1ZlY3RvcjIgPyBuZXcgVmVjdG9yMigpIDogbmV3IFZlY3RvcjMoKSk7XG4gICAgICB0YW5nZW50LmNvcHkocHQyKS5zdWIocHQxKS5ub3JtYWxpemUoKTtcbiAgICAgIHJldHVybiB0YW5nZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUYW5nZW50QXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFuZ2VudEF0KHUsIG9wdGlvbmFsVGFyZ2V0KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcodSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUYW5nZW50KHQsIG9wdGlvbmFsVGFyZ2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZUZyZW5ldEZyYW1lc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlRnJlbmV0RnJhbWVzKHNlZ21lbnRzLCBjbG9zZWQpIHtcbiAgICAgIC8vIHNlZSBodHRwOi8vd3d3LmNzLmluZGlhbmEuZWR1L3B1Yi90ZWNocmVwb3J0cy9UUjQyNS5wZGZcbiAgICAgIHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdmFyIHRhbmdlbnRzID0gW107XG4gICAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgICAgdmFyIGJpbm9ybWFscyA9IFtdO1xuICAgICAgdmFyIHZlYyA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB2YXIgbWF0ID0gbmV3IE1hdHJpeDQoKTsgLy8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIGN1cnZlXG5cbiAgICAgIGZvciAodmFyIF9pMTg2ID0gMDsgX2kxODYgPD0gc2VnbWVudHM7IF9pMTg2KyspIHtcbiAgICAgICAgdmFyIHUgPSBfaTE4NiAvIHNlZ21lbnRzO1xuICAgICAgICB0YW5nZW50c1tfaTE4Nl0gPSB0aGlzLmdldFRhbmdlbnRBdCh1LCBuZXcgVmVjdG9yMygpKTtcbiAgICAgIH0gLy8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3RvcixcbiAgICAgIC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtaW5pbXVtIHRhbmdlbnQgeHl6IGNvbXBvbmVudFxuXG5cbiAgICAgIG5vcm1hbHNbMF0gPSBuZXcgVmVjdG9yMygpO1xuICAgICAgYmlub3JtYWxzWzBdID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgdmFyIHR4ID0gTWF0aC5hYnModGFuZ2VudHNbMF0ueCk7XG4gICAgICB2YXIgdHkgPSBNYXRoLmFicyh0YW5nZW50c1swXS55KTtcbiAgICAgIHZhciB0eiA9IE1hdGguYWJzKHRhbmdlbnRzWzBdLnopO1xuXG4gICAgICBpZiAodHggPD0gbWluKSB7XG4gICAgICAgIG1pbiA9IHR4O1xuICAgICAgICBub3JtYWwuc2V0KDEsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHkgPD0gbWluKSB7XG4gICAgICAgIG1pbiA9IHR5O1xuICAgICAgICBub3JtYWwuc2V0KDAsIDEsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHogPD0gbWluKSB7XG4gICAgICAgIG5vcm1hbC5zZXQoMCwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZlYy5jcm9zc1ZlY3RvcnModGFuZ2VudHNbMF0sIG5vcm1hbCkubm9ybWFsaXplKCk7XG4gICAgICBub3JtYWxzWzBdLmNyb3NzVmVjdG9ycyh0YW5nZW50c1swXSwgdmVjKTtcbiAgICAgIGJpbm9ybWFsc1swXS5jcm9zc1ZlY3RvcnModGFuZ2VudHNbMF0sIG5vcm1hbHNbMF0pOyAvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgY3VydmVcblxuICAgICAgZm9yICh2YXIgX2kxODcgPSAxOyBfaTE4NyA8PSBzZWdtZW50czsgX2kxODcrKykge1xuICAgICAgICBub3JtYWxzW19pMTg3XSA9IG5vcm1hbHNbX2kxODcgLSAxXS5jbG9uZSgpO1xuICAgICAgICBiaW5vcm1hbHNbX2kxODddID0gYmlub3JtYWxzW19pMTg3IC0gMV0uY2xvbmUoKTtcbiAgICAgICAgdmVjLmNyb3NzVmVjdG9ycyh0YW5nZW50c1tfaTE4NyAtIDFdLCB0YW5nZW50c1tfaTE4N10pO1xuXG4gICAgICAgIGlmICh2ZWMubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgIHZlYy5ub3JtYWxpemUoKTtcbiAgICAgICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoY2xhbXAodGFuZ2VudHNbX2kxODcgLSAxXS5kb3QodGFuZ2VudHNbX2kxODddKSwgLTEsIDEpKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG4gICAgICAgICAgbm9ybWFsc1tfaTE4N10uYXBwbHlNYXRyaXg0KG1hdC5tYWtlUm90YXRpb25BeGlzKHZlYywgdGhldGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbm9ybWFsc1tfaTE4N10uY3Jvc3NWZWN0b3JzKHRhbmdlbnRzW19pMTg3XSwgbm9ybWFsc1tfaTE4N10pO1xuICAgICAgfSAvLyBpZiB0aGUgY3VydmUgaXMgY2xvc2VkLCBwb3N0cHJvY2VzcyB0aGUgdmVjdG9ycyBzbyB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9ybWFsIHZlY3RvcnMgYXJlIHRoZSBzYW1lXG5cblxuICAgICAgaWYgKGNsb3NlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX3RoZXRhID0gTWF0aC5hY29zKGNsYW1wKG5vcm1hbHNbMF0uZG90KG5vcm1hbHNbc2VnbWVudHNdKSwgLTEsIDEpKTtcblxuICAgICAgICBfdGhldGEgLz0gc2VnbWVudHM7XG5cbiAgICAgICAgaWYgKHRhbmdlbnRzWzBdLmRvdCh2ZWMuY3Jvc3NWZWN0b3JzKG5vcm1hbHNbMF0sIG5vcm1hbHNbc2VnbWVudHNdKSkgPiAwKSB7XG4gICAgICAgICAgX3RoZXRhID0gLV90aGV0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9pMTg4ID0gMTsgX2kxODggPD0gc2VnbWVudHM7IF9pMTg4KyspIHtcbiAgICAgICAgICAvLyB0d2lzdCBhIGxpdHRsZS4uLlxuICAgICAgICAgIG5vcm1hbHNbX2kxODhdLmFwcGx5TWF0cml4NChtYXQubWFrZVJvdGF0aW9uQXhpcyh0YW5nZW50c1tfaTE4OF0sIF90aGV0YSAqIF9pMTg4KSk7XG5cbiAgICAgICAgICBiaW5vcm1hbHNbX2kxODhdLmNyb3NzVmVjdG9ycyh0YW5nZW50c1tfaTE4OF0sIG5vcm1hbHNbX2kxODhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YW5nZW50czogdGFuZ2VudHMsXG4gICAgICAgIG5vcm1hbHM6IG5vcm1hbHMsXG4gICAgICAgIGJpbm9ybWFsczogYmlub3JtYWxzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gc291cmNlLmFyY0xlbmd0aERpdmlzaW9ucztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgdmVyc2lvbjogNC41LFxuICAgICAgICAgIHR5cGU6ICdDdXJ2ZScsXG4gICAgICAgICAgZ2VuZXJhdG9yOiAnQ3VydmUudG9KU09OJ1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZGF0YS5hcmNMZW5ndGhEaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcbiAgICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihqc29uKSB7XG4gICAgICB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IGpzb24uYXJjTGVuZ3RoRGl2aXNpb25zO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1cnZlO1xufSgpO1xuXG52YXIgRWxsaXBzZUN1cnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ3VydmUpIHtcbiAgX2luaGVyaXRzKEVsbGlwc2VDdXJ2ZSwgX0N1cnZlKTtcblxuICB2YXIgX3N1cGVyNTggPSBfY3JlYXRlU3VwZXIoRWxsaXBzZUN1cnZlKTtcblxuICBmdW5jdGlvbiBFbGxpcHNlQ3VydmUoKSB7XG4gICAgdmFyIF90aGlzNDk7XG5cbiAgICB2YXIgYVggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgdmFyIGFZID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciB4UmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgIHZhciB5UmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxO1xuICAgIHZhciBhU3RhcnRBbmdsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICB2YXIgYUVuZEFuZ2xlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBNYXRoLlBJICogMjtcbiAgICB2YXIgYUNsb2Nrd2lzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG4gICAgdmFyIGFSb3RhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGxpcHNlQ3VydmUpO1xuXG4gICAgX3RoaXM0OSA9IF9zdXBlcjU4LmNhbGwodGhpcyk7XG4gICAgX3RoaXM0OS5pc0VsbGlwc2VDdXJ2ZSA9IHRydWU7XG4gICAgX3RoaXM0OS50eXBlID0gJ0VsbGlwc2VDdXJ2ZSc7XG4gICAgX3RoaXM0OS5hWCA9IGFYO1xuICAgIF90aGlzNDkuYVkgPSBhWTtcbiAgICBfdGhpczQ5LnhSYWRpdXMgPSB4UmFkaXVzO1xuICAgIF90aGlzNDkueVJhZGl1cyA9IHlSYWRpdXM7XG4gICAgX3RoaXM0OS5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xuICAgIF90aGlzNDkuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xuICAgIF90aGlzNDkuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XG4gICAgX3RoaXM0OS5hUm90YXRpb24gPSBhUm90YXRpb247XG4gICAgcmV0dXJuIF90aGlzNDk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRWxsaXBzZUN1cnZlLCBbe1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCkge1xuICAgICAgdmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcbiAgICAgIHZhciB0d29QaSA9IE1hdGguUEkgKiAyO1xuICAgICAgdmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XG4gICAgICB2YXIgc2FtZVBvaW50cyA9IE1hdGguYWJzKGRlbHRhQW5nbGUpIDwgTnVtYmVyLkVQU0lMT047IC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxuXG4gICAgICB3aGlsZSAoZGVsdGFBbmdsZSA8IDApIHtcbiAgICAgICAgZGVsdGFBbmdsZSArPSB0d29QaTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGRlbHRhQW5nbGUgPiB0d29QaSkge1xuICAgICAgICBkZWx0YUFuZ2xlIC09IHR3b1BpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgIGlmIChzYW1lUG9pbnRzKSB7XG4gICAgICAgICAgZGVsdGFBbmdsZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFBbmdsZSA9IHR3b1BpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFDbG9ja3dpc2UgPT09IHRydWUgJiYgIXNhbWVQb2ludHMpIHtcbiAgICAgICAgaWYgKGRlbHRhQW5nbGUgPT09IHR3b1BpKSB7XG4gICAgICAgICAgZGVsdGFBbmdsZSA9IC10d29QaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcbiAgICAgIHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgaWYgKHRoaXMuYVJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGlzLmFSb3RhdGlvbik7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGlzLmFSb3RhdGlvbik7XG4gICAgICAgIHZhciB0eCA9IHggLSB0aGlzLmFYO1xuICAgICAgICB2YXIgdHkgPSB5IC0gdGhpcy5hWTsgLy8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuXG4gICAgICAgIHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgdGhpcy5hWDtcbiAgICAgICAgeSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyB0aGlzLmFZO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnQuc2V0KHgsIHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihFbGxpcHNlQ3VydmUucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5hWCA9IHNvdXJjZS5hWDtcbiAgICAgIHRoaXMuYVkgPSBzb3VyY2UuYVk7XG4gICAgICB0aGlzLnhSYWRpdXMgPSBzb3VyY2UueFJhZGl1cztcbiAgICAgIHRoaXMueVJhZGl1cyA9IHNvdXJjZS55UmFkaXVzO1xuICAgICAgdGhpcy5hU3RhcnRBbmdsZSA9IHNvdXJjZS5hU3RhcnRBbmdsZTtcbiAgICAgIHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcbiAgICAgIHRoaXMuYUNsb2Nrd2lzZSA9IHNvdXJjZS5hQ2xvY2t3aXNlO1xuICAgICAgdGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBkYXRhLmFYID0gdGhpcy5hWDtcbiAgICAgIGRhdGEuYVkgPSB0aGlzLmFZO1xuICAgICAgZGF0YS54UmFkaXVzID0gdGhpcy54UmFkaXVzO1xuICAgICAgZGF0YS55UmFkaXVzID0gdGhpcy55UmFkaXVzO1xuICAgICAgZGF0YS5hU3RhcnRBbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGU7XG4gICAgICBkYXRhLmFFbmRBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlO1xuICAgICAgZGF0YS5hQ2xvY2t3aXNlID0gdGhpcy5hQ2xvY2t3aXNlO1xuICAgICAgZGF0YS5hUm90YXRpb24gPSB0aGlzLmFSb3RhdGlvbjtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihqc29uKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihFbGxpcHNlQ3VydmUucHJvdG90eXBlKSwgXCJmcm9tSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMsIGpzb24pO1xuXG4gICAgICB0aGlzLmFYID0ganNvbi5hWDtcbiAgICAgIHRoaXMuYVkgPSBqc29uLmFZO1xuICAgICAgdGhpcy54UmFkaXVzID0ganNvbi54UmFkaXVzO1xuICAgICAgdGhpcy55UmFkaXVzID0ganNvbi55UmFkaXVzO1xuICAgICAgdGhpcy5hU3RhcnRBbmdsZSA9IGpzb24uYVN0YXJ0QW5nbGU7XG4gICAgICB0aGlzLmFFbmRBbmdsZSA9IGpzb24uYUVuZEFuZ2xlO1xuICAgICAgdGhpcy5hQ2xvY2t3aXNlID0ganNvbi5hQ2xvY2t3aXNlO1xuICAgICAgdGhpcy5hUm90YXRpb24gPSBqc29uLmFSb3RhdGlvbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFbGxpcHNlQ3VydmU7XG59KEN1cnZlKTtcblxudmFyIEFyY0N1cnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxsaXBzZUN1cnZlKSB7XG4gIF9pbmhlcml0cyhBcmNDdXJ2ZSwgX0VsbGlwc2VDdXJ2ZSk7XG5cbiAgdmFyIF9zdXBlcjU5ID0gX2NyZWF0ZVN1cGVyKEFyY0N1cnZlKTtcblxuICBmdW5jdGlvbiBBcmNDdXJ2ZShhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpIHtcbiAgICB2YXIgX3RoaXM1MDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcmNDdXJ2ZSk7XG5cbiAgICBfdGhpczUwID0gX3N1cGVyNTkuY2FsbCh0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UpO1xuICAgIF90aGlzNTAuaXNBcmNDdXJ2ZSA9IHRydWU7XG4gICAgX3RoaXM1MC50eXBlID0gJ0FyY0N1cnZlJztcbiAgICByZXR1cm4gX3RoaXM1MDtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXJjQ3VydmUpO1xufShFbGxpcHNlQ3VydmUpO1xuLyoqXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXG4gKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxuICpcbiAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxuICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxuICovXG5cbi8qXG5CYXNlZCBvbiBhbiBvcHRpbWl6ZWQgYysrIHNvbHV0aW9uIGluXG4gLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuIC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXG5cblRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcbmJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxud2hpY2ggY2FuIGJlIHBsYWNlZCBpbiBDdXJ2ZVV0aWxzLlxuKi9cblxuXG5mdW5jdGlvbiBDdWJpY1BvbHkoKSB7XG4gIHZhciBjMCA9IDAsXG4gICAgICBjMSA9IDAsXG4gICAgICBjMiA9IDAsXG4gICAgICBjMyA9IDA7XG4gIC8qXG4gICAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcbiAgICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG4gICAqIHN1Y2ggdGhhdFxuICAgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXG4gICAqICBhbmRcbiAgICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxuICAgKi9cblxuICBmdW5jdGlvbiBpbml0KHgwLCB4MSwgdDAsIHQxKSB7XG4gICAgYzAgPSB4MDtcbiAgICBjMSA9IHQwO1xuICAgIGMyID0gLTMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xuICAgIGMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaW5pdENhdG11bGxSb206IGZ1bmN0aW9uIGluaXRDYXRtdWxsUm9tKHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uKSB7XG4gICAgICBpbml0KHgxLCB4MiwgdGVuc2lvbiAqICh4MiAtIHgwKSwgdGVuc2lvbiAqICh4MyAtIHgxKSk7XG4gICAgfSxcbiAgICBpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uIGluaXROb251bmlmb3JtQ2F0bXVsbFJvbSh4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0Mikge1xuICAgICAgLy8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxuICAgICAgdmFyIHQxID0gKHgxIC0geDApIC8gZHQwIC0gKHgyIC0geDApIC8gKGR0MCArIGR0MSkgKyAoeDIgLSB4MSkgLyBkdDE7XG4gICAgICB2YXIgdDIgPSAoeDIgLSB4MSkgLyBkdDEgLSAoeDMgLSB4MSkgLyAoZHQxICsgZHQyKSArICh4MyAtIHgyKSAvIGR0MjsgLy8gcmVzY2FsZSB0YW5nZW50cyBmb3IgcGFyYW1ldHJpemF0aW9uIGluIFswLDFdXG5cbiAgICAgIHQxICo9IGR0MTtcbiAgICAgIHQyICo9IGR0MTtcbiAgICAgIGluaXQoeDEsIHgyLCB0MSwgdDIpO1xuICAgIH0sXG4gICAgY2FsYzogZnVuY3Rpb24gY2FsYyh0KSB7XG4gICAgICB2YXIgdDIgPSB0ICogdDtcbiAgICAgIHZhciB0MyA9IHQyICogdDtcbiAgICAgIHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xuICAgIH1cbiAgfTtcbn0gLy9cblxuXG52YXIgdG1wID0gbmV3IFZlY3RvcjMoKTtcbnZhciBweCA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICBweSA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICBweiA9IG5ldyBDdWJpY1BvbHkoKTtcblxudmFyIENhdG11bGxSb21DdXJ2ZTMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdXJ2ZTIpIHtcbiAgX2luaGVyaXRzKENhdG11bGxSb21DdXJ2ZTMsIF9DdXJ2ZTIpO1xuXG4gIHZhciBfc3VwZXI2MCA9IF9jcmVhdGVTdXBlcihDYXRtdWxsUm9tQ3VydmUzKTtcblxuICBmdW5jdGlvbiBDYXRtdWxsUm9tQ3VydmUzKCkge1xuICAgIHZhciBfdGhpczUxO1xuXG4gICAgdmFyIHBvaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gICAgdmFyIGNsb3NlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIGN1cnZlVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ2NlbnRyaXBldGFsJztcbiAgICB2YXIgdGVuc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMC41O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhdG11bGxSb21DdXJ2ZTMpO1xuXG4gICAgX3RoaXM1MSA9IF9zdXBlcjYwLmNhbGwodGhpcyk7XG4gICAgX3RoaXM1MS5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xuICAgIF90aGlzNTEudHlwZSA9ICdDYXRtdWxsUm9tQ3VydmUzJztcbiAgICBfdGhpczUxLnBvaW50cyA9IHBvaW50cztcbiAgICBfdGhpczUxLmNsb3NlZCA9IGNsb3NlZDtcbiAgICBfdGhpczUxLmN1cnZlVHlwZSA9IGN1cnZlVHlwZTtcbiAgICBfdGhpczUxLnRlbnNpb24gPSB0ZW5zaW9uO1xuICAgIHJldHVybiBfdGhpczUxO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhdG11bGxSb21DdXJ2ZTMsIFt7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHQpIHtcbiAgICAgIHZhciBvcHRpb25hbFRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgdmFyIGwgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgdmFyIHAgPSAobCAtICh0aGlzLmNsb3NlZCA/IDAgOiAxKSkgKiB0O1xuICAgICAgdmFyIGludFBvaW50ID0gTWF0aC5mbG9vcihwKTtcbiAgICAgIHZhciB3ZWlnaHQgPSBwIC0gaW50UG9pbnQ7XG5cbiAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICBpbnRQb2ludCArPSBpbnRQb2ludCA+IDAgPyAwIDogKE1hdGguZmxvb3IoTWF0aC5hYnMoaW50UG9pbnQpIC8gbCkgKyAxKSAqIGw7XG4gICAgICB9IGVsc2UgaWYgKHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEpIHtcbiAgICAgICAgaW50UG9pbnQgPSBsIC0gMjtcbiAgICAgICAgd2VpZ2h0ID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHAwLCBwMzsgLy8gNCBwb2ludHMgKHAxICYgcDIgZGVmaW5lZCBiZWxvdylcblxuICAgICAgaWYgKHRoaXMuY2xvc2VkIHx8IGludFBvaW50ID4gMCkge1xuICAgICAgICBwMCA9IHBvaW50c1soaW50UG9pbnQgLSAxKSAlIGxdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcbiAgICAgICAgdG1wLnN1YlZlY3RvcnMocG9pbnRzWzBdLCBwb2ludHNbMV0pLmFkZChwb2ludHNbMF0pO1xuICAgICAgICBwMCA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgdmFyIHAxID0gcG9pbnRzW2ludFBvaW50ICUgbF07XG4gICAgICB2YXIgcDIgPSBwb2ludHNbKGludFBvaW50ICsgMSkgJSBsXTtcblxuICAgICAgaWYgKHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwpIHtcbiAgICAgICAgcDMgPSBwb2ludHNbKGludFBvaW50ICsgMikgJSBsXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcbiAgICAgICAgdG1wLnN1YlZlY3RvcnMocG9pbnRzW2wgLSAxXSwgcG9pbnRzW2wgLSAyXSkuYWRkKHBvaW50c1tsIC0gMV0pO1xuICAgICAgICBwMyA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VydmVUeXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcpIHtcbiAgICAgICAgLy8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cbiAgICAgICAgdmFyIHBvdyA9IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xuICAgICAgICB2YXIgZHQwID0gTWF0aC5wb3cocDAuZGlzdGFuY2VUb1NxdWFyZWQocDEpLCBwb3cpO1xuICAgICAgICB2YXIgZHQxID0gTWF0aC5wb3cocDEuZGlzdGFuY2VUb1NxdWFyZWQocDIpLCBwb3cpO1xuICAgICAgICB2YXIgZHQyID0gTWF0aC5wb3cocDIuZGlzdGFuY2VUb1NxdWFyZWQocDMpLCBwb3cpOyAvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xuXG4gICAgICAgIGlmIChkdDEgPCAxZS00KSBkdDEgPSAxLjA7XG4gICAgICAgIGlmIChkdDAgPCAxZS00KSBkdDAgPSBkdDE7XG4gICAgICAgIGlmIChkdDIgPCAxZS00KSBkdDIgPSBkdDE7XG4gICAgICAgIHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbShwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyKTtcbiAgICAgICAgcHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIpO1xuICAgICAgICBwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20ocDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0Mik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScpIHtcbiAgICAgICAgcHguaW5pdENhdG11bGxSb20ocDAueCwgcDEueCwgcDIueCwgcDMueCwgdGhpcy50ZW5zaW9uKTtcbiAgICAgICAgcHkuaW5pdENhdG11bGxSb20ocDAueSwgcDEueSwgcDIueSwgcDMueSwgdGhpcy50ZW5zaW9uKTtcbiAgICAgICAgcHouaW5pdENhdG11bGxSb20ocDAueiwgcDEueiwgcDIueiwgcDMueiwgdGhpcy50ZW5zaW9uKTtcbiAgICAgIH1cblxuICAgICAgcG9pbnQuc2V0KHB4LmNhbGMod2VpZ2h0KSwgcHkuY2FsYyh3ZWlnaHQpLCBwei5jYWxjKHdlaWdodCkpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMucG9pbnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pMTg5ID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBfaTE4OSA8IGw7IF9pMTg5KyspIHtcbiAgICAgICAgdmFyIHBvaW50ID0gc291cmNlLnBvaW50c1tfaTE4OV07XG4gICAgICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQuY2xvbmUoKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcbiAgICAgIHRoaXMuY3VydmVUeXBlID0gc291cmNlLmN1cnZlVHlwZTtcbiAgICAgIHRoaXMudGVuc2lvbiA9IHNvdXJjZS50ZW5zaW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlKSwgXCJ0b0pTT05cIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgZGF0YS5wb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kxOTAgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBfaTE5MCA8IGw7IF9pMTkwKyspIHtcbiAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5wb2ludHNbX2kxOTBdO1xuICAgICAgICBkYXRhLnBvaW50cy5wdXNoKHBvaW50LnRvQXJyYXkoKSk7XG4gICAgICB9XG5cbiAgICAgIGRhdGEuY2xvc2VkID0gdGhpcy5jbG9zZWQ7XG4gICAgICBkYXRhLmN1cnZlVHlwZSA9IHRoaXMuY3VydmVUeXBlO1xuICAgICAgZGF0YS50ZW5zaW9uID0gdGhpcy50ZW5zaW9uO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlKSwgXCJmcm9tSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMsIGpzb24pO1xuXG4gICAgICB0aGlzLnBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTE5MSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IF9pMTkxIDwgbDsgX2kxOTErKykge1xuICAgICAgICB2YXIgcG9pbnQgPSBqc29uLnBvaW50c1tfaTE5MV07XG4gICAgICAgIHRoaXMucG9pbnRzLnB1c2gobmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkocG9pbnQpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbG9zZWQgPSBqc29uLmNsb3NlZDtcbiAgICAgIHRoaXMuY3VydmVUeXBlID0ganNvbi5jdXJ2ZVR5cGU7XG4gICAgICB0aGlzLnRlbnNpb24gPSBqc29uLnRlbnNpb247XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2F0bXVsbFJvbUN1cnZlMztcbn0oQ3VydmUpO1xuLyoqXG4gKiBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG4gKi9cblxuXG5mdW5jdGlvbiBDYXRtdWxsUm9tKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICB2YXIgdDIgPSB0ICogdDtcbiAgdmFyIHQzID0gdCAqIHQyO1xuICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59IC8vXG5cblxuZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDAodCwgcCkge1xuICB2YXIgayA9IDEgLSB0O1xuICByZXR1cm4gayAqIGsgKiBwO1xufVxuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMSh0LCBwKSB7XG4gIHJldHVybiAyICogKDEgLSB0KSAqIHQgKiBwO1xufVxuXG5mdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMih0LCBwKSB7XG4gIHJldHVybiB0ICogdCAqIHA7XG59XG5cbmZ1bmN0aW9uIFF1YWRyYXRpY0Jlemllcih0LCBwMCwgcDEsIHAyKSB7XG4gIHJldHVybiBRdWFkcmF0aWNCZXppZXJQMCh0LCBwMCkgKyBRdWFkcmF0aWNCZXppZXJQMSh0LCBwMSkgKyBRdWFkcmF0aWNCZXppZXJQMih0LCBwMik7XG59IC8vXG5cblxuZnVuY3Rpb24gQ3ViaWNCZXppZXJQMCh0LCBwKSB7XG4gIHZhciBrID0gMSAtIHQ7XG4gIHJldHVybiBrICogayAqIGsgKiBwO1xufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllclAxKHQsIHApIHtcbiAgdmFyIGsgPSAxIC0gdDtcbiAgcmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllclAyKHQsIHApIHtcbiAgcmV0dXJuIDMgKiAoMSAtIHQpICogdCAqIHQgKiBwO1xufVxuXG5mdW5jdGlvbiBDdWJpY0JlemllclAzKHQsIHApIHtcbiAgcmV0dXJuIHQgKiB0ICogdCAqIHA7XG59XG5cbmZ1bmN0aW9uIEN1YmljQmV6aWVyKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gIHJldHVybiBDdWJpY0JlemllclAwKHQsIHAwKSArIEN1YmljQmV6aWVyUDEodCwgcDEpICsgQ3ViaWNCZXppZXJQMih0LCBwMikgKyBDdWJpY0JlemllclAzKHQsIHAzKTtcbn1cblxudmFyIEN1YmljQmV6aWVyQ3VydmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdXJ2ZTMpIHtcbiAgX2luaGVyaXRzKEN1YmljQmV6aWVyQ3VydmUsIF9DdXJ2ZTMpO1xuXG4gIHZhciBfc3VwZXI2MSA9IF9jcmVhdGVTdXBlcihDdWJpY0JlemllckN1cnZlKTtcblxuICBmdW5jdGlvbiBDdWJpY0JlemllckN1cnZlKCkge1xuICAgIHZhciBfdGhpczUyO1xuXG4gICAgdmFyIHYwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgVmVjdG9yMigpO1xuICAgIHZhciB2MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjIoKTtcbiAgICB2YXIgdjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG5ldyBWZWN0b3IyKCk7XG4gICAgdmFyIHYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBuZXcgVmVjdG9yMigpO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmljQmV6aWVyQ3VydmUpO1xuXG4gICAgX3RoaXM1MiA9IF9zdXBlcjYxLmNhbGwodGhpcyk7XG4gICAgX3RoaXM1Mi5pc0N1YmljQmV6aWVyQ3VydmUgPSB0cnVlO1xuICAgIF90aGlzNTIudHlwZSA9ICdDdWJpY0JlemllckN1cnZlJztcbiAgICBfdGhpczUyLnYwID0gdjA7XG4gICAgX3RoaXM1Mi52MSA9IHYxO1xuICAgIF90aGlzNTIudjIgPSB2MjtcbiAgICBfdGhpczUyLnYzID0gdjM7XG4gICAgcmV0dXJuIF90aGlzNTI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3ViaWNCZXppZXJDdXJ2ZSwgW3tcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQodCkge1xuICAgICAgdmFyIG9wdGlvbmFsVGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBuZXcgVmVjdG9yMigpO1xuICAgICAgdmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQ7XG4gICAgICB2YXIgdjAgPSB0aGlzLnYwLFxuICAgICAgICAgIHYxID0gdGhpcy52MSxcbiAgICAgICAgICB2MiA9IHRoaXMudjIsXG4gICAgICAgICAgdjMgPSB0aGlzLnYzO1xuICAgICAgcG9pbnQuc2V0KEN1YmljQmV6aWVyKHQsIHYwLngsIHYxLngsIHYyLngsIHYzLngpLCBDdWJpY0Jlemllcih0LCB2MC55LCB2MS55LCB2Mi55LCB2My55KSk7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy52MC5jb3B5KHNvdXJjZS52MCk7XG4gICAgICB0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcbiAgICAgIHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuICAgICAgdGhpcy52My5jb3B5KHNvdXJjZS52Myk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBkYXRhID0gX2dldChfZ2V0UHJvdG90eXBlT2YoQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG4gICAgICBkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG4gICAgICBkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG4gICAgICBkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUpLCBcImZyb21KU09OXCIsIHRoaXMpLmNhbGwodGhpcywganNvbik7XG5cbiAgICAgIHRoaXMudjAuZnJvbUFycmF5KGpzb24udjApO1xuICAgICAgdGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG4gICAgICB0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcbiAgICAgIHRoaXMudjMuZnJvbUFycmF5KGpzb24udjMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1YmljQmV6aWVyQ3VydmU7XG59KEN1cnZlKTtcblxudmFyIEN1YmljQmV6aWVyQ3VydmUzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ3VydmU0KSB7XG4gIF9pbmhlcml0cyhDdWJpY0JlemllckN1cnZlMywgX0N1cnZlNCk7XG5cbiAgdmFyIF9zdXBlcjYyID0gX2NyZWF0ZVN1cGVyKEN1YmljQmV6aWVyQ3VydmUzKTtcblxuICBmdW5jdGlvbiBDdWJpY0JlemllckN1cnZlMygpIHtcbiAgICB2YXIgX3RoaXM1MztcblxuICAgIHZhciB2MCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgdjEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBuZXcgVmVjdG9yMygpO1xuICAgIHZhciB2MyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbmV3IFZlY3RvcjMoKTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDdWJpY0JlemllckN1cnZlMyk7XG5cbiAgICBfdGhpczUzID0gX3N1cGVyNjIuY2FsbCh0aGlzKTtcbiAgICBfdGhpczUzLmlzQ3ViaWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xuICAgIF90aGlzNTMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlMyc7XG4gICAgX3RoaXM1My52MCA9IHYwO1xuICAgIF90aGlzNTMudjEgPSB2MTtcbiAgICBfdGhpczUzLnYyID0gdjI7XG4gICAgX3RoaXM1My52MyA9IHYzO1xuICAgIHJldHVybiBfdGhpczUzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEN1YmljQmV6aWVyQ3VydmUzLCBbe1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludCh0KSB7XG4gICAgICB2YXIgb3B0aW9uYWxUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyBWZWN0b3IzKCk7XG4gICAgICB2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcbiAgICAgIHZhciB2MCA9IHRoaXMudjAsXG4gICAgICAgICAgdjEgPSB0aGlzLnYxLFxuICAgICAgICAgIHYyID0gdGhpcy52MixcbiAgICAgICAgICB2MyA9IHRoaXMudjM7XG4gICAgICBwb2ludC5zZXQoQ3ViaWNCZXppZXIodCwgdjAueCwgdjEueCwgdjIueCwgdjMueCksIEN1YmljQmV6aWVyKHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkpLCBDdWJpY0Jlemllcih0LCB2MC56LCB2MS56LCB2Mi56LCB2My56KSk7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMudjAuY29weShzb3VyY2UudjApO1xuICAgICAgdGhpcy52MS5jb3B5KHNvdXJjZS52MSk7XG4gICAgICB0aGlzLnYyLmNvcHkoc291cmNlLnYyKTtcbiAgICAgIHRoaXMudjMuY29weShzb3VyY2UudjMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcbiAgICAgIGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcbiAgICAgIGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcbiAgICAgIGRhdGEudjMgPSB0aGlzLnYzLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihqc29uKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUpLCBcImZyb21KU09OXCIsIHRoaXMpLmNhbGwodGhpcywganNvbik7XG5cbiAgICAgIHRoaXMudjAuZnJvbUFycmF5KGpzb24udjApO1xuICAgICAgdGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG4gICAgICB0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcbiAgICAgIHRoaXMudjMuZnJvbUFycmF5KGpzb24udjMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1YmljQmV6aWVyQ3VydmUzO1xufShDdXJ2ZSk7XG5cbnZhciBMaW5lQ3VydmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdXJ2ZTUpIHtcbiAgX2luaGVyaXRzKExpbmVDdXJ2ZSwgX0N1cnZlNSk7XG5cbiAgdmFyIF9zdXBlcjYzID0gX2NyZWF0ZVN1cGVyKExpbmVDdXJ2ZSk7XG5cbiAgZnVuY3Rpb24gTGluZUN1cnZlKCkge1xuICAgIHZhciBfdGhpczU0O1xuXG4gICAgdmFyIHYxID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgVmVjdG9yMigpO1xuICAgIHZhciB2MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjIoKTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lQ3VydmUpO1xuXG4gICAgX3RoaXM1NCA9IF9zdXBlcjYzLmNhbGwodGhpcyk7XG4gICAgX3RoaXM1NC5pc0xpbmVDdXJ2ZSA9IHRydWU7XG4gICAgX3RoaXM1NC50eXBlID0gJ0xpbmVDdXJ2ZSc7XG4gICAgX3RoaXM1NC52MSA9IHYxO1xuICAgIF90aGlzNTQudjIgPSB2MjtcbiAgICByZXR1cm4gX3RoaXM1NDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5lQ3VydmUsIFt7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHQpIHtcbiAgICAgIHZhciBvcHRpb25hbFRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjIoKTtcbiAgICAgIHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuXG4gICAgICBpZiAodCA9PT0gMSkge1xuICAgICAgICBwb2ludC5jb3B5KHRoaXMudjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnQuY29weSh0aGlzLnYyKS5zdWIodGhpcy52MSk7XG4gICAgICAgIHBvaW50Lm11bHRpcGx5U2NhbGFyKHQpLmFkZCh0aGlzLnYxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0gLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50QXQodSwgb3B0aW9uYWxUYXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBvaW50KHUsIG9wdGlvbmFsVGFyZ2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGFuZ2VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYW5nZW50KHQsIG9wdGlvbmFsVGFyZ2V0KSB7XG4gICAgICB2YXIgdGFuZ2VudCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XG4gICAgICB0YW5nZW50LmNvcHkodGhpcy52Mikuc3ViKHRoaXMudjEpLm5vcm1hbGl6ZSgpO1xuICAgICAgcmV0dXJuIHRhbmdlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKExpbmVDdXJ2ZS5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcbiAgICAgIHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKExpbmVDdXJ2ZS5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG4gICAgICBkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTGluZUN1cnZlLnByb3RvdHlwZSksIFwiZnJvbUpTT05cIiwgdGhpcykuY2FsbCh0aGlzLCBqc29uKTtcblxuICAgICAgdGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG4gICAgICB0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lQ3VydmU7XG59KEN1cnZlKTtcblxudmFyIExpbmVDdXJ2ZTMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdXJ2ZTYpIHtcbiAgX2luaGVyaXRzKExpbmVDdXJ2ZTMsIF9DdXJ2ZTYpO1xuXG4gIHZhciBfc3VwZXI2NCA9IF9jcmVhdGVTdXBlcihMaW5lQ3VydmUzKTtcblxuICBmdW5jdGlvbiBMaW5lQ3VydmUzKCkge1xuICAgIHZhciBfdGhpczU1O1xuXG4gICAgdmFyIHYxID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjMoKTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lQ3VydmUzKTtcblxuICAgIF90aGlzNTUgPSBfc3VwZXI2NC5jYWxsKHRoaXMpO1xuICAgIF90aGlzNTUuaXNMaW5lQ3VydmUzID0gdHJ1ZTtcbiAgICBfdGhpczU1LnR5cGUgPSAnTGluZUN1cnZlMyc7XG4gICAgX3RoaXM1NS52MSA9IHYxO1xuICAgIF90aGlzNTUudjIgPSB2MjtcbiAgICByZXR1cm4gX3RoaXM1NTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5lQ3VydmUzLCBbe1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludCh0KSB7XG4gICAgICB2YXIgb3B0aW9uYWxUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyBWZWN0b3IzKCk7XG4gICAgICB2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcblxuICAgICAgaWYgKHQgPT09IDEpIHtcbiAgICAgICAgcG9pbnQuY29weSh0aGlzLnYyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50LmNvcHkodGhpcy52Mikuc3ViKHRoaXMudjEpO1xuICAgICAgICBwb2ludC5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy52MSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9IC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludEF0KHUsIG9wdGlvbmFsVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRQb2ludCh1LCBvcHRpb25hbFRhcmdldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKExpbmVDdXJ2ZTMucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy52MS5jb3B5KHNvdXJjZS52MSk7XG4gICAgICB0aGlzLnYyLmNvcHkoc291cmNlLnYyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGRhdGEgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaW5lQ3VydmUzLnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcbiAgICAgIGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihqc29uKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaW5lQ3VydmUzLnByb3RvdHlwZSksIFwiZnJvbUpTT05cIiwgdGhpcykuY2FsbCh0aGlzLCBqc29uKTtcblxuICAgICAgdGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG4gICAgICB0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lQ3VydmUzO1xufShDdXJ2ZSk7XG5cbnZhciBRdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0N1cnZlNykge1xuICBfaW5oZXJpdHMoUXVhZHJhdGljQmV6aWVyQ3VydmUsIF9DdXJ2ZTcpO1xuXG4gIHZhciBfc3VwZXI2NSA9IF9jcmVhdGVTdXBlcihRdWFkcmF0aWNCZXppZXJDdXJ2ZSk7XG5cbiAgZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyQ3VydmUoKSB7XG4gICAgdmFyIF90aGlzNTY7XG5cbiAgICB2YXIgdjAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBWZWN0b3IyKCk7XG4gICAgdmFyIHYxID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBuZXcgVmVjdG9yMigpO1xuICAgIHZhciB2MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbmV3IFZlY3RvcjIoKTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWFkcmF0aWNCZXppZXJDdXJ2ZSk7XG5cbiAgICBfdGhpczU2ID0gX3N1cGVyNjUuY2FsbCh0aGlzKTtcbiAgICBfdGhpczU2LmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgPSB0cnVlO1xuICAgIF90aGlzNTYudHlwZSA9ICdRdWFkcmF0aWNCZXppZXJDdXJ2ZSc7XG4gICAgX3RoaXM1Ni52MCA9IHYwO1xuICAgIF90aGlzNTYudjEgPSB2MTtcbiAgICBfdGhpczU2LnYyID0gdjI7XG4gICAgcmV0dXJuIF90aGlzNTY7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUXVhZHJhdGljQmV6aWVyQ3VydmUsIFt7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHQpIHtcbiAgICAgIHZhciBvcHRpb25hbFRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjIoKTtcbiAgICAgIHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuICAgICAgdmFyIHYwID0gdGhpcy52MCxcbiAgICAgICAgICB2MSA9IHRoaXMudjEsXG4gICAgICAgICAgdjIgPSB0aGlzLnYyO1xuICAgICAgcG9pbnQuc2V0KFF1YWRyYXRpY0Jlemllcih0LCB2MC54LCB2MS54LCB2Mi54KSwgUXVhZHJhdGljQmV6aWVyKHQsIHYwLnksIHYxLnksIHYyLnkpKTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy52MC5jb3B5KHNvdXJjZS52MCk7XG4gICAgICB0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcbiAgICAgIHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGRhdGEudjAgPSB0aGlzLnYwLnRvQXJyYXkoKTtcbiAgICAgIGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcbiAgICAgIGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihqc29uKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUpLCBcImZyb21KU09OXCIsIHRoaXMpLmNhbGwodGhpcywganNvbik7XG5cbiAgICAgIHRoaXMudjAuZnJvbUFycmF5KGpzb24udjApO1xuICAgICAgdGhpcy52MS5mcm9tQXJyYXkoanNvbi52MSk7XG4gICAgICB0aGlzLnYyLmZyb21BcnJheShqc29uLnYyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWFkcmF0aWNCZXppZXJDdXJ2ZTtcbn0oQ3VydmUpO1xuXG52YXIgUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ3VydmU4KSB7XG4gIF9pbmhlcml0cyhRdWFkcmF0aWNCZXppZXJDdXJ2ZTMsIF9DdXJ2ZTgpO1xuXG4gIHZhciBfc3VwZXI2NiA9IF9jcmVhdGVTdXBlcihRdWFkcmF0aWNCZXppZXJDdXJ2ZTMpO1xuXG4gIGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllckN1cnZlMygpIHtcbiAgICB2YXIgX3RoaXM1NztcblxuICAgIHZhciB2MCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgdjEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIHYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBuZXcgVmVjdG9yMygpO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1YWRyYXRpY0JlemllckN1cnZlMyk7XG5cbiAgICBfdGhpczU3ID0gX3N1cGVyNjYuY2FsbCh0aGlzKTtcbiAgICBfdGhpczU3LmlzUXVhZHJhdGljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcbiAgICBfdGhpczU3LnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcbiAgICBfdGhpczU3LnYwID0gdjA7XG4gICAgX3RoaXM1Ny52MSA9IHYxO1xuICAgIF90aGlzNTcudjIgPSB2MjtcbiAgICByZXR1cm4gX3RoaXM1NztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRdWFkcmF0aWNCZXppZXJDdXJ2ZTMsIFt7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHQpIHtcbiAgICAgIHZhciBvcHRpb25hbFRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0O1xuICAgICAgdmFyIHYwID0gdGhpcy52MCxcbiAgICAgICAgICB2MSA9IHRoaXMudjEsXG4gICAgICAgICAgdjIgPSB0aGlzLnYyO1xuICAgICAgcG9pbnQuc2V0KFF1YWRyYXRpY0Jlemllcih0LCB2MC54LCB2MS54LCB2Mi54KSwgUXVhZHJhdGljQmV6aWVyKHQsIHYwLnksIHYxLnksIHYyLnkpLCBRdWFkcmF0aWNCZXppZXIodCwgdjAueiwgdjEueiwgdjIueikpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy52MC5jb3B5KHNvdXJjZS52MCk7XG4gICAgICB0aGlzLnYxLmNvcHkoc291cmNlLnYxKTtcbiAgICAgIHRoaXMudjIuY29weShzb3VyY2UudjIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XG4gICAgICBkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XG4gICAgICBkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoUXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSksIFwiZnJvbUpTT05cIiwgdGhpcykuY2FsbCh0aGlzLCBqc29uKTtcblxuICAgICAgdGhpcy52MC5mcm9tQXJyYXkoanNvbi52MCk7XG4gICAgICB0aGlzLnYxLmZyb21BcnJheShqc29uLnYxKTtcbiAgICAgIHRoaXMudjIuZnJvbUFycmF5KGpzb24udjIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFF1YWRyYXRpY0JlemllckN1cnZlMztcbn0oQ3VydmUpO1xuXG52YXIgU3BsaW5lQ3VydmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdXJ2ZTkpIHtcbiAgX2luaGVyaXRzKFNwbGluZUN1cnZlLCBfQ3VydmU5KTtcblxuICB2YXIgX3N1cGVyNjcgPSBfY3JlYXRlU3VwZXIoU3BsaW5lQ3VydmUpO1xuXG4gIGZ1bmN0aW9uIFNwbGluZUN1cnZlKCkge1xuICAgIHZhciBfdGhpczU4O1xuXG4gICAgdmFyIHBvaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BsaW5lQ3VydmUpO1xuXG4gICAgX3RoaXM1OCA9IF9zdXBlcjY3LmNhbGwodGhpcyk7XG4gICAgX3RoaXM1OC5pc1NwbGluZUN1cnZlID0gdHJ1ZTtcbiAgICBfdGhpczU4LnR5cGUgPSAnU3BsaW5lQ3VydmUnO1xuICAgIF90aGlzNTgucG9pbnRzID0gcG9pbnRzO1xuICAgIHJldHVybiBfdGhpczU4O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNwbGluZUN1cnZlLCBbe1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludCh0KSB7XG4gICAgICB2YXIgb3B0aW9uYWxUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyBWZWN0b3IyKCk7XG4gICAgICB2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldDtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgIHZhciBwID0gKHBvaW50cy5sZW5ndGggLSAxKSAqIHQ7XG4gICAgICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKHApO1xuICAgICAgdmFyIHdlaWdodCA9IHAgLSBpbnRQb2ludDtcbiAgICAgIHZhciBwMCA9IHBvaW50c1tpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxXTtcbiAgICAgIHZhciBwMSA9IHBvaW50c1tpbnRQb2ludF07XG4gICAgICB2YXIgcDIgPSBwb2ludHNbaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxXTtcbiAgICAgIHZhciBwMyA9IHBvaW50c1tpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDJdO1xuICAgICAgcG9pbnQuc2V0KENhdG11bGxSb20od2VpZ2h0LCBwMC54LCBwMS54LCBwMi54LCBwMy54KSwgQ2F0bXVsbFJvbSh3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkpKTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU3BsaW5lQ3VydmUucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5wb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kxOTIgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IF9pMTkyIDwgbDsgX2kxOTIrKykge1xuICAgICAgICB2YXIgcG9pbnQgPSBzb3VyY2UucG9pbnRzW19pMTkyXTtcbiAgICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludC5jbG9uZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFNwbGluZUN1cnZlLnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGRhdGEucG9pbnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pMTkzID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgX2kxOTMgPCBsOyBfaTE5MysrKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHRoaXMucG9pbnRzW19pMTkzXTtcbiAgICAgICAgZGF0YS5wb2ludHMucHVzaChwb2ludC50b0FycmF5KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU3BsaW5lQ3VydmUucHJvdG90eXBlKSwgXCJmcm9tSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMsIGpzb24pO1xuXG4gICAgICB0aGlzLnBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTE5NCA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IF9pMTk0IDwgbDsgX2kxOTQrKykge1xuICAgICAgICB2YXIgcG9pbnQgPSBqc29uLnBvaW50c1tfaTE5NF07XG4gICAgICAgIHRoaXMucG9pbnRzLnB1c2gobmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkocG9pbnQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNwbGluZUN1cnZlO1xufShDdXJ2ZSk7XG5cbnZhciBDdXJ2ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQXJjQ3VydmU6IEFyY0N1cnZlLFxuICBDYXRtdWxsUm9tQ3VydmUzOiBDYXRtdWxsUm9tQ3VydmUzLFxuICBDdWJpY0JlemllckN1cnZlOiBDdWJpY0JlemllckN1cnZlLFxuICBDdWJpY0JlemllckN1cnZlMzogQ3ViaWNCZXppZXJDdXJ2ZTMsXG4gIEVsbGlwc2VDdXJ2ZTogRWxsaXBzZUN1cnZlLFxuICBMaW5lQ3VydmU6IExpbmVDdXJ2ZSxcbiAgTGluZUN1cnZlMzogTGluZUN1cnZlMyxcbiAgUXVhZHJhdGljQmV6aWVyQ3VydmU6IFF1YWRyYXRpY0JlemllckN1cnZlLFxuICBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM6IFF1YWRyYXRpY0JlemllckN1cnZlMyxcbiAgU3BsaW5lQ3VydmU6IFNwbGluZUN1cnZlXG59KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBDdXJ2ZVBhdGggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdXJ2ZTEwKSB7XG4gIF9pbmhlcml0cyhDdXJ2ZVBhdGgsIF9DdXJ2ZTEwKTtcblxuICB2YXIgX3N1cGVyNjggPSBfY3JlYXRlU3VwZXIoQ3VydmVQYXRoKTtcblxuICBmdW5jdGlvbiBDdXJ2ZVBhdGgoKSB7XG4gICAgdmFyIF90aGlzNTk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VydmVQYXRoKTtcblxuICAgIF90aGlzNTkgPSBfc3VwZXI2OC5jYWxsKHRoaXMpO1xuICAgIF90aGlzNTkudHlwZSA9ICdDdXJ2ZVBhdGgnO1xuICAgIF90aGlzNTkuY3VydmVzID0gW107XG4gICAgX3RoaXM1OS5hdXRvQ2xvc2UgPSBmYWxzZTsgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcblxuICAgIHJldHVybiBfdGhpczU5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEN1cnZlUGF0aCwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChjdXJ2ZSkge1xuICAgICAgdGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZVBhdGgoKSB7XG4gICAgICAvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcbiAgICAgIHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbMF0uZ2V0UG9pbnQoMCk7XG4gICAgICB2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGggLSAxXS5nZXRQb2ludCgxKTtcblxuICAgICAgaWYgKCFzdGFydFBvaW50LmVxdWFscyhlbmRQb2ludCkpIHtcbiAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaChuZXcgTGluZUN1cnZlKGVuZFBvaW50LCBzdGFydFBvaW50KSk7XG4gICAgICB9XG4gICAgfSAvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cbiAgICAvLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXG4gICAgLy8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxuICAgIC8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cbiAgICAvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcbiAgICAvLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG4gICAgLy8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludCh0LCBvcHRpb25hbFRhcmdldCkge1xuICAgICAgdmFyIGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcbiAgICAgIHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICAgICAgdmFyIGkgPSAwOyAvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuICAgICAgd2hpbGUgKGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjdXJ2ZUxlbmd0aHNbaV0gPj0gZCkge1xuICAgICAgICAgIHZhciBkaWZmID0gY3VydmVMZW5ndGhzW2ldIC0gZDtcbiAgICAgICAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1tpXTtcbiAgICAgICAgICB2YXIgc2VnbWVudExlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuICAgICAgICAgIHZhciB1ID0gc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAxIC0gZGlmZiAvIHNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGN1cnZlLmdldFBvaW50QXQodSwgb3B0aW9uYWxUYXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDsgLy8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXG4gICAgfSAvLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXG4gICAgLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG4gICAgLy8gZ2V0UG9pbnQoKSBkZXBlbmRzIG9uIGdldExlbmd0aFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICAgIHZhciBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcbiAgICAgIHJldHVybiBsZW5zW2xlbnMubGVuZ3RoIC0gMV07XG4gICAgfSAvLyBjYWNoZUxlbmd0aHMgbXVzdCBiZSByZWNhbGN1bGF0ZWQuXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVBcmNMZW5ndGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUFyY0xlbmd0aHMoKSB7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FjaGVMZW5ndGhzID0gbnVsbDtcbiAgICAgIHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG4gICAgfSAvLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cbiAgICAvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q3VydmVMZW5ndGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnZlTGVuZ3RocygpIHtcbiAgICAgIC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcbiAgICAgIGlmICh0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XG4gICAgICB9IC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG4gICAgICAvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcblxuXG4gICAgICB2YXIgbGVuZ3RocyA9IFtdO1xuICAgICAgdmFyIHN1bXMgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTE5NSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IF9pMTk1IDwgbDsgX2kxOTUrKykge1xuICAgICAgICBzdW1zICs9IHRoaXMuY3VydmVzW19pMTk1XS5nZXRMZW5ndGgoKTtcbiAgICAgICAgbGVuZ3Rocy5wdXNoKHN1bXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XG4gICAgICByZXR1cm4gbGVuZ3RocztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3BhY2VkUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNwYWNlZFBvaW50cygpIHtcbiAgICAgIHZhciBkaXZpc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDQwO1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTE5NiA9IDA7IF9pMTk2IDw9IGRpdmlzaW9uczsgX2kxOTYrKykge1xuICAgICAgICBwb2ludHMucHVzaCh0aGlzLmdldFBvaW50KF9pMTk2IC8gZGl2aXNpb25zKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnRzKCkge1xuICAgICAgdmFyIGRpdmlzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTI7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICB2YXIgbGFzdDtcblxuICAgICAgZm9yICh2YXIgX2kxOTcgPSAwLCBjdXJ2ZXMgPSB0aGlzLmN1cnZlczsgX2kxOTcgPCBjdXJ2ZXMubGVuZ3RoOyBfaTE5NysrKSB7XG4gICAgICAgIHZhciBjdXJ2ZSA9IGN1cnZlc1tfaTE5N107XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gY3VydmUuaXNFbGxpcHNlQ3VydmUgPyBkaXZpc2lvbnMgKiAyIDogY3VydmUuaXNMaW5lQ3VydmUgfHwgY3VydmUuaXNMaW5lQ3VydmUzID8gMSA6IGN1cnZlLmlzU3BsaW5lQ3VydmUgPyBkaXZpc2lvbnMgKiBjdXJ2ZS5wb2ludHMubGVuZ3RoIDogZGl2aXNpb25zO1xuICAgICAgICB2YXIgcHRzID0gY3VydmUuZ2V0UG9pbnRzKHJlc29sdXRpb24pO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gcHRzW2pdO1xuICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QuZXF1YWxzKHBvaW50KSkgY29udGludWU7IC8vIGVuc3VyZXMgbm8gY29uc2VjdXRpdmUgcG9pbnRzIGFyZSBkdXBsaWNhdGVzXG5cbiAgICAgICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgbGFzdCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiAhcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5lcXVhbHMocG9pbnRzWzBdKSkge1xuICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihDdXJ2ZVBhdGgucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5jdXJ2ZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kxOTggPSAwLCBsID0gc291cmNlLmN1cnZlcy5sZW5ndGg7IF9pMTk4IDwgbDsgX2kxOTgrKykge1xuICAgICAgICB2YXIgY3VydmUgPSBzb3VyY2UuY3VydmVzW19pMTk4XTtcbiAgICAgICAgdGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZS5jbG9uZSgpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBzb3VyY2UuYXV0b0Nsb3NlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEN1cnZlUGF0aC5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBkYXRhLmF1dG9DbG9zZSA9IHRoaXMuYXV0b0Nsb3NlO1xuICAgICAgZGF0YS5jdXJ2ZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kxOTkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBfaTE5OSA8IGw7IF9pMTk5KyspIHtcbiAgICAgICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbX2kxOTldO1xuICAgICAgICBkYXRhLmN1cnZlcy5wdXNoKGN1cnZlLnRvSlNPTigpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEN1cnZlUGF0aC5wcm90b3R5cGUpLCBcImZyb21KU09OXCIsIHRoaXMpLmNhbGwodGhpcywganNvbik7XG5cbiAgICAgIHRoaXMuYXV0b0Nsb3NlID0ganNvbi5hdXRvQ2xvc2U7XG4gICAgICB0aGlzLmN1cnZlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTIwMCA9IDAsIGwgPSBqc29uLmN1cnZlcy5sZW5ndGg7IF9pMjAwIDwgbDsgX2kyMDArKykge1xuICAgICAgICB2YXIgY3VydmUgPSBqc29uLmN1cnZlc1tfaTIwMF07XG4gICAgICAgIHRoaXMuY3VydmVzLnB1c2gobmV3IEN1cnZlc1tjdXJ2ZS50eXBlXSgpLmZyb21KU09OKGN1cnZlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDdXJ2ZVBhdGg7XG59KEN1cnZlKTtcblxudmFyIFBhdGggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DdXJ2ZVBhdGgpIHtcbiAgX2luaGVyaXRzKFBhdGgsIF9DdXJ2ZVBhdGgpO1xuXG4gIHZhciBfc3VwZXI2OSA9IF9jcmVhdGVTdXBlcihQYXRoKTtcblxuICBmdW5jdGlvbiBQYXRoKHBvaW50cykge1xuICAgIHZhciBfdGhpczYwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdGgpO1xuXG4gICAgX3RoaXM2MCA9IF9zdXBlcjY5LmNhbGwodGhpcyk7XG4gICAgX3RoaXM2MC50eXBlID0gJ1BhdGgnO1xuICAgIF90aGlzNjAuY3VycmVudFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIGlmIChwb2ludHMpIHtcbiAgICAgIF90aGlzNjAuc2V0RnJvbVBvaW50cyhwb2ludHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpczYwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdGgsIFt7XG4gICAga2V5OiBcInNldEZyb21Qb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVBvaW50cyhwb2ludHMpIHtcbiAgICAgIHRoaXMubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG5cbiAgICAgIGZvciAodmFyIF9pMjAxID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IF9pMjAxIDwgbDsgX2kyMDErKykge1xuICAgICAgICB0aGlzLmxpbmVUbyhwb2ludHNbX2kyMDFdLngsIHBvaW50c1tfaTIwMV0ueSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtb3ZlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKHgsIHkpIHtcbiAgICAgIHRoaXMuY3VycmVudFBvaW50LnNldCh4LCB5KTsgLy8gVE9ETyBjb25zaWRlciByZWZlcmVuY2luZyB2ZWN0b3JzIGluc3RlYWQgb2YgY29weWluZz9cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpbmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lVG8oeCwgeSkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IExpbmVDdXJ2ZSh0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMih4LCB5KSk7XG4gICAgICB0aGlzLmN1cnZlcy5wdXNoKGN1cnZlKTtcbiAgICAgIHRoaXMuY3VycmVudFBvaW50LnNldCh4LCB5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJxdWFkcmF0aWNDdXJ2ZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1YWRyYXRpY0N1cnZlVG8oYUNQeCwgYUNQeSwgYVgsIGFZKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUodGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoYUNQeCwgYUNQeSksIG5ldyBWZWN0b3IyKGFYLCBhWSkpO1xuICAgICAgdGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG4gICAgICB0aGlzLmN1cnJlbnRQb2ludC5zZXQoYVgsIGFZKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiZXppZXJDdXJ2ZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlemllckN1cnZlVG8oYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IEN1YmljQmV6aWVyQ3VydmUodGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoYUNQMXgsIGFDUDF5KSwgbmV3IFZlY3RvcjIoYUNQMngsIGFDUDJ5KSwgbmV3IFZlY3RvcjIoYVgsIGFZKSk7XG4gICAgICB0aGlzLmN1cnZlcy5wdXNoKGN1cnZlKTtcbiAgICAgIHRoaXMuY3VycmVudFBvaW50LnNldChhWCwgYVkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNwbGluZVRocnVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3BsaW5lVGhydShwdHNcbiAgICAvKkFycmF5IG9mIFZlY3RvciovXG4gICAgKSB7XG4gICAgICB2YXIgbnB0cyA9IFt0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpXS5jb25jYXQocHRzKTtcbiAgICAgIHZhciBjdXJ2ZSA9IG5ldyBTcGxpbmVDdXJ2ZShucHRzKTtcbiAgICAgIHRoaXMuY3VydmVzLnB1c2goY3VydmUpO1xuICAgICAgdGhpcy5jdXJyZW50UG9pbnQuY29weShwdHNbcHRzLmxlbmd0aCAtIDFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJjKGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSkge1xuICAgICAgdmFyIHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcbiAgICAgIHZhciB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XG4gICAgICB0aGlzLmFic2FyYyhhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhYnNhcmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJzYXJjKGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSkge1xuICAgICAgdGhpcy5hYnNlbGxpcHNlKGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWxsaXBzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGxpcHNlKGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uKSB7XG4gICAgICB2YXIgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xuICAgICAgdmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcbiAgICAgIHRoaXMuYWJzZWxsaXBzZShhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFic2VsbGlwc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJzZWxsaXBzZShhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbikge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZShhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLmN1cnZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGlmIGEgcHJldmlvdXMgY3VydmUgaXMgcHJlc2VudCwgYXR0ZW1wdCB0byBqb2luXG4gICAgICAgIHZhciBmaXJzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoMCk7XG5cbiAgICAgICAgaWYgKCFmaXJzdFBvaW50LmVxdWFscyh0aGlzLmN1cnJlbnRQb2ludCkpIHtcbiAgICAgICAgICB0aGlzLmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJ2ZXMucHVzaChjdXJ2ZSk7XG4gICAgICB2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoMSk7XG4gICAgICB0aGlzLmN1cnJlbnRQb2ludC5jb3B5KGxhc3RQb2ludCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoUGF0aC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLmN1cnJlbnRQb2ludC5jb3B5KHNvdXJjZS5jdXJyZW50UG9pbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFBhdGgucHJvdG90eXBlKSwgXCJ0b0pTT05cIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgZGF0YS5jdXJyZW50UG9pbnQgPSB0aGlzLmN1cnJlbnRQb2ludC50b0FycmF5KCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoUGF0aC5wcm90b3R5cGUpLCBcImZyb21KU09OXCIsIHRoaXMpLmNhbGwodGhpcywganNvbik7XG5cbiAgICAgIHRoaXMuY3VycmVudFBvaW50LmZyb21BcnJheShqc29uLmN1cnJlbnRQb2ludCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGF0aDtcbn0oQ3VydmVQYXRoKTtcblxudmFyIExhdGhlR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CdWZmZXJHZW9tZXRyeTMpIHtcbiAgX2luaGVyaXRzKExhdGhlR2VvbWV0cnksIF9CdWZmZXJHZW9tZXRyeTMpO1xuXG4gIHZhciBfc3VwZXI3MCA9IF9jcmVhdGVTdXBlcihMYXRoZUdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBMYXRoZUdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczYxO1xuXG4gICAgdmFyIHBvaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW25ldyBWZWN0b3IyKDAsIDAuNSksIG5ldyBWZWN0b3IyKDAuNSwgMCksIG5ldyBWZWN0b3IyKDAsIC0wLjUpXTtcbiAgICB2YXIgc2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDEyO1xuICAgIHZhciBwaGlTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgcGhpTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBNYXRoLlBJICogMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXRoZUdlb21ldHJ5KTtcblxuICAgIF90aGlzNjEgPSBfc3VwZXI3MC5jYWxsKHRoaXMpO1xuICAgIF90aGlzNjEudHlwZSA9ICdMYXRoZUdlb21ldHJ5JztcbiAgICBfdGhpczYxLnBhcmFtZXRlcnMgPSB7XG4gICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICAgIHBoaVN0YXJ0OiBwaGlTdGFydCxcbiAgICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoXG4gICAgfTtcbiAgICBzZWdtZW50cyA9IE1hdGguZmxvb3Ioc2VnbWVudHMpOyAvLyBjbGFtcCBwaGlMZW5ndGggc28gaXQncyBpbiByYW5nZSBvZiBbIDAsIDJQSSBdXG5cbiAgICBwaGlMZW5ndGggPSBjbGFtcChwaGlMZW5ndGgsIDAsIE1hdGguUEkgKiAyKTsgLy8gYnVmZmVyc1xuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgdXZzID0gW107XG4gICAgdmFyIGluaXROb3JtYWxzID0gW107XG4gICAgdmFyIG5vcm1hbHMgPSBbXTsgLy8gaGVscGVyIHZhcmlhYmxlc1xuXG4gICAgdmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuICAgIHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuICAgIHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XG4gICAgdmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIGN1ck5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIHByZXZOb3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuICAgIHZhciBkeCA9IDA7XG4gICAgdmFyIGR5ID0gMDsgLy8gcHJlLWNvbXB1dGUgbm9ybWFscyBmb3IgaW5pdGlhbCBcIm1lcmlkaWFuXCJcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IHBvaW50cy5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgIHN3aXRjaCAoaikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgMXN0IHZlcnRleCBvbiBwYXRoXG4gICAgICAgICAgZHggPSBwb2ludHNbaiArIDFdLnggLSBwb2ludHNbal0ueDtcbiAgICAgICAgICBkeSA9IHBvaW50c1tqICsgMV0ueSAtIHBvaW50c1tqXS55O1xuICAgICAgICAgIG5vcm1hbC54ID0gZHkgKiAxLjA7XG4gICAgICAgICAgbm9ybWFsLnkgPSAtZHg7XG4gICAgICAgICAgbm9ybWFsLnogPSBkeSAqIDAuMDtcbiAgICAgICAgICBwcmV2Tm9ybWFsLmNvcHkobm9ybWFsKTtcbiAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgaW5pdE5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHBvaW50cy5sZW5ndGggLSAxOlxuICAgICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGxhc3QgVmVydGV4IG9uIHBhdGhcbiAgICAgICAgICBpbml0Tm9ybWFscy5wdXNoKHByZXZOb3JtYWwueCwgcHJldk5vcm1hbC55LCBwcmV2Tm9ybWFsLnopO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gZGVmYXVsdCBoYW5kbGluZyBmb3IgYWxsIHZlcnRpY2VzIGluIGJldHdlZW5cbiAgICAgICAgICBkeCA9IHBvaW50c1tqICsgMV0ueCAtIHBvaW50c1tqXS54O1xuICAgICAgICAgIGR5ID0gcG9pbnRzW2ogKyAxXS55IC0gcG9pbnRzW2pdLnk7XG4gICAgICAgICAgbm9ybWFsLnggPSBkeSAqIDEuMDtcbiAgICAgICAgICBub3JtYWwueSA9IC1keDtcbiAgICAgICAgICBub3JtYWwueiA9IGR5ICogMC4wO1xuICAgICAgICAgIGN1ck5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICAgICAgbm9ybWFsLnggKz0gcHJldk5vcm1hbC54O1xuICAgICAgICAgIG5vcm1hbC55ICs9IHByZXZOb3JtYWwueTtcbiAgICAgICAgICBub3JtYWwueiArPSBwcmV2Tm9ybWFsLno7XG4gICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgIGluaXROb3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7XG4gICAgICAgICAgcHJldk5vcm1hbC5jb3B5KGN1ck5vcm1hbCk7XG4gICAgICB9XG4gICAgfSAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgdXZzIGFuZCBub3JtYWxzXG5cblxuICAgIGZvciAodmFyIF9pMjAyID0gMDsgX2kyMDIgPD0gc2VnbWVudHM7IF9pMjAyKyspIHtcbiAgICAgIHZhciBwaGkgPSBwaGlTdGFydCArIF9pMjAyICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHBoaSk7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3MocGhpKTtcblxuICAgICAgZm9yICh2YXIgX2o1ID0gMDsgX2o1IDw9IHBvaW50cy5sZW5ndGggLSAxOyBfajUrKykge1xuICAgICAgICAvLyB2ZXJ0ZXhcbiAgICAgICAgdmVydGV4LnggPSBwb2ludHNbX2o1XS54ICogc2luO1xuICAgICAgICB2ZXJ0ZXgueSA9IHBvaW50c1tfajVdLnk7XG4gICAgICAgIHZlcnRleC56ID0gcG9pbnRzW19qNV0ueCAqIGNvcztcbiAgICAgICAgdmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTsgLy8gdXZcblxuICAgICAgICB1di54ID0gX2kyMDIgLyBzZWdtZW50cztcbiAgICAgICAgdXYueSA9IF9qNSAvIChwb2ludHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHV2cy5wdXNoKHV2LngsIHV2LnkpOyAvLyBub3JtYWxcblxuICAgICAgICB2YXIgeCA9IGluaXROb3JtYWxzWzMgKiBfajUgKyAwXSAqIHNpbjtcbiAgICAgICAgdmFyIHkgPSBpbml0Tm9ybWFsc1szICogX2o1ICsgMV07XG4gICAgICAgIHZhciB6ID0gaW5pdE5vcm1hbHNbMyAqIF9qNSArIDBdICogY29zO1xuICAgICAgICBub3JtYWxzLnB1c2goeCwgeSwgeik7XG4gICAgICB9XG4gICAgfSAvLyBpbmRpY2VzXG5cblxuICAgIGZvciAodmFyIF9pMjAzID0gMDsgX2kyMDMgPCBzZWdtZW50czsgX2kyMDMrKykge1xuICAgICAgZm9yICh2YXIgX2o2ID0gMDsgX2o2IDwgcG9pbnRzLmxlbmd0aCAtIDE7IF9qNisrKSB7XG4gICAgICAgIHZhciBiYXNlID0gX2o2ICsgX2kyMDMgKiBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgYSA9IGJhc2U7XG4gICAgICAgIHZhciBiID0gYmFzZSArIHBvaW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xuICAgICAgICB2YXIgZCA9IGJhc2UgKyAxOyAvLyBmYWNlc1xuXG4gICAgICAgIGluZGljZXMucHVzaChhLCBiLCBkKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGMsIGQsIGIpO1xuICAgICAgfVxuICAgIH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG4gICAgX3RoaXM2MS5zZXRJbmRleChpbmRpY2VzKTtcblxuICAgIF90aGlzNjEuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cbiAgICBfdGhpczYxLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblxuICAgIF90aGlzNjEuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM2MTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMYXRoZUdlb21ldHJ5LCBudWxsLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IExhdGhlR2VvbWV0cnkoZGF0YS5wb2ludHMsIGRhdGEuc2VnbWVudHMsIGRhdGEucGhpU3RhcnQsIGRhdGEucGhpTGVuZ3RoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGF0aGVHZW9tZXRyeTtcbn0oQnVmZmVyR2VvbWV0cnkpO1xuXG52YXIgQ2Fwc3VsZUdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGF0aGVHZW9tZXRyeSkge1xuICBfaW5oZXJpdHMoQ2Fwc3VsZUdlb21ldHJ5LCBfTGF0aGVHZW9tZXRyeSk7XG5cbiAgdmFyIF9zdXBlcjcxID0gX2NyZWF0ZVN1cGVyKENhcHN1bGVHZW9tZXRyeSk7XG5cbiAgZnVuY3Rpb24gQ2Fwc3VsZUdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczYyO1xuXG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHZhciBjYXBTZWdtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNDtcbiAgICB2YXIgcmFkaWFsU2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDg7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2Fwc3VsZUdlb21ldHJ5KTtcblxuICAgIHZhciBwYXRoID0gbmV3IFBhdGgoKTtcbiAgICBwYXRoLmFic2FyYygwLCAtbGVuZ3RoIC8gMiwgcmFkaXVzLCBNYXRoLlBJICogMS41LCAwKTtcbiAgICBwYXRoLmFic2FyYygwLCBsZW5ndGggLyAyLCByYWRpdXMsIDAsIE1hdGguUEkgKiAwLjUpO1xuICAgIF90aGlzNjIgPSBfc3VwZXI3MS5jYWxsKHRoaXMsIHBhdGguZ2V0UG9pbnRzKGNhcFNlZ21lbnRzKSwgcmFkaWFsU2VnbWVudHMpO1xuICAgIF90aGlzNjIudHlwZSA9ICdDYXBzdWxlR2VvbWV0cnknO1xuICAgIF90aGlzNjIucGFyYW1ldGVycyA9IHtcbiAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgaGVpZ2h0OiBsZW5ndGgsXG4gICAgICBjYXBTZWdtZW50czogY2FwU2VnbWVudHMsXG4gICAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHNcbiAgICB9O1xuICAgIHJldHVybiBfdGhpczYyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhcHN1bGVHZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBDYXBzdWxlR2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEubGVuZ3RoLCBkYXRhLmNhcFNlZ21lbnRzLCBkYXRhLnJhZGlhbFNlZ21lbnRzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2Fwc3VsZUdlb21ldHJ5O1xufShMYXRoZUdlb21ldHJ5KTtcblxudmFyIENpcmNsZUdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyR2VvbWV0cnk0KSB7XG4gIF9pbmhlcml0cyhDaXJjbGVHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5NCk7XG5cbiAgdmFyIF9zdXBlcjcyID0gX2NyZWF0ZVN1cGVyKENpcmNsZUdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBDaXJjbGVHZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXM2MztcblxuICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgdmFyIHNlZ21lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA4O1xuICAgIHZhciB0aGV0YVN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciB0aGV0YUxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogTWF0aC5QSSAqIDI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlR2VvbWV0cnkpO1xuXG4gICAgX3RoaXM2MyA9IF9zdXBlcjcyLmNhbGwodGhpcyk7XG4gICAgX3RoaXM2My50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcbiAgICBfdGhpczYzLnBhcmFtZXRlcnMgPSB7XG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuICAgIHNlZ21lbnRzID0gTWF0aC5tYXgoMywgc2VnbWVudHMpOyAvLyBidWZmZXJzXG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBub3JtYWxzID0gW107XG4gICAgdmFyIHV2cyA9IFtdOyAvLyBoZWxwZXIgdmFyaWFibGVzXG5cbiAgICB2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgdXYgPSBuZXcgVmVjdG9yMigpOyAvLyBjZW50ZXIgcG9pbnRcblxuICAgIHZlcnRpY2VzLnB1c2goMCwgMCwgMCk7XG4gICAgbm9ybWFscy5wdXNoKDAsIDAsIDEpO1xuICAgIHV2cy5wdXNoKDAuNSwgMC41KTtcblxuICAgIGZvciAodmFyIHMgPSAwLCBfaTIwNCA9IDM7IHMgPD0gc2VnbWVudHM7IHMrKywgX2kyMDQgKz0gMykge1xuICAgICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7IC8vIHZlcnRleFxuXG4gICAgICB2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKHNlZ21lbnQpO1xuICAgICAgdmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbihzZWdtZW50KTtcbiAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbFxuXG4gICAgICBub3JtYWxzLnB1c2goMCwgMCwgMSk7IC8vIHV2c1xuXG4gICAgICB1di54ID0gKHZlcnRpY2VzW19pMjA0XSAvIHJhZGl1cyArIDEpIC8gMjtcbiAgICAgIHV2LnkgPSAodmVydGljZXNbX2kyMDQgKyAxXSAvIHJhZGl1cyArIDEpIC8gMjtcbiAgICAgIHV2cy5wdXNoKHV2LngsIHV2LnkpO1xuICAgIH0gLy8gaW5kaWNlc1xuXG5cbiAgICBmb3IgKHZhciBfaTIwNSA9IDE7IF9pMjA1IDw9IHNlZ21lbnRzOyBfaTIwNSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goX2kyMDUsIF9pMjA1ICsgMSwgMCk7XG4gICAgfSAvLyBidWlsZCBnZW9tZXRyeVxuXG5cbiAgICBfdGhpczYzLnNldEluZGV4KGluZGljZXMpO1xuXG4gICAgX3RoaXM2My5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblxuICAgIF90aGlzNjMuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cbiAgICBfdGhpczYzLnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblxuICAgIHJldHVybiBfdGhpczYzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENpcmNsZUdlb21ldHJ5LCBudWxsLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IENpcmNsZUdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLnNlZ21lbnRzLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDaXJjbGVHZW9tZXRyeTtcbn0oQnVmZmVyR2VvbWV0cnkpO1xuXG52YXIgQ3lsaW5kZXJHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckdlb21ldHJ5NSkge1xuICBfaW5oZXJpdHMoQ3lsaW5kZXJHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5NSk7XG5cbiAgdmFyIF9zdXBlcjczID0gX2NyZWF0ZVN1cGVyKEN5bGluZGVyR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIEN5bGluZGVyR2VvbWV0cnkoKSB7XG4gICAgdmFyIF90aGlzNjQ7XG5cbiAgICB2YXIgcmFkaXVzVG9wID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIHZhciByYWRpdXNCb3R0b20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICB2YXIgcmFkaWFsU2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDg7XG4gICAgdmFyIGhlaWdodFNlZ21lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAxO1xuICAgIHZhciBvcGVuRW5kZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IGZhbHNlO1xuICAgIHZhciB0aGV0YVN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiAwO1xuICAgIHZhciB0aGV0YUxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogTWF0aC5QSSAqIDI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3lsaW5kZXJHZW9tZXRyeSk7XG5cbiAgICBfdGhpczY0ID0gX3N1cGVyNzMuY2FsbCh0aGlzKTtcbiAgICBfdGhpczY0LnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XG4gICAgX3RoaXM2NC5wYXJhbWV0ZXJzID0ge1xuICAgICAgcmFkaXVzVG9wOiByYWRpdXNUb3AsXG4gICAgICByYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgICAgb3BlbkVuZGVkOiBvcGVuRW5kZWQsXG4gICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgfTtcblxuICAgIHZhciBzY29wZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM2NCk7XG5cbiAgICByYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IocmFkaWFsU2VnbWVudHMpO1xuICAgIGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vcihoZWlnaHRTZWdtZW50cyk7IC8vIGJ1ZmZlcnNcblxuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICB2YXIgdXZzID0gW107IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGluZGV4QXJyYXkgPSBbXTtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGdyb3VwU3RhcnQgPSAwOyAvLyBnZW5lcmF0ZSBnZW9tZXRyeVxuXG4gICAgZ2VuZXJhdGVUb3JzbygpO1xuXG4gICAgaWYgKG9wZW5FbmRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChyYWRpdXNUb3AgPiAwKSBnZW5lcmF0ZUNhcCh0cnVlKTtcbiAgICAgIGlmIChyYWRpdXNCb3R0b20gPiAwKSBnZW5lcmF0ZUNhcChmYWxzZSk7XG4gICAgfSAvLyBidWlsZCBnZW9tZXRyeVxuXG5cbiAgICBfdGhpczY0LnNldEluZGV4KGluZGljZXMpO1xuXG4gICAgX3RoaXM2NC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblxuICAgIF90aGlzNjQuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cbiAgICBfdGhpczY0LnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XG4gICAgICB2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuICAgICAgdmFyIGdyb3VwQ291bnQgPSAwOyAvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuXG4gICAgICB2YXIgc2xvcGUgPSAocmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wKSAvIGhlaWdodDsgLy8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSsrKSB7XG4gICAgICAgIHZhciBpbmRleFJvdyA9IFtdO1xuICAgICAgICB2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50czsgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XG5cbiAgICAgICAgdmFyIHJhZGl1cyA9IHYgKiAocmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wKSArIHJhZGl1c1RvcDtcblxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCsrKSB7XG4gICAgICAgICAgdmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG4gICAgICAgICAgdmFyIHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcbiAgICAgICAgICB2YXIgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgdmFyIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpOyAvLyB2ZXJ0ZXhcblxuICAgICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG4gICAgICAgICAgdmVydGV4LnkgPSAtdiAqIGhlaWdodCArIGhhbGZIZWlnaHQ7XG4gICAgICAgICAgdmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyBub3JtYWxcblxuICAgICAgICAgIG5vcm1hbC5zZXQoc2luVGhldGEsIHNsb3BlLCBjb3NUaGV0YSkubm9ybWFsaXplKCk7XG4gICAgICAgICAgbm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopOyAvLyB1dlxuXG4gICAgICAgICAgdXZzLnB1c2godSwgMSAtIHYpOyAvLyBzYXZlIGluZGV4IG9mIHZlcnRleCBpbiByZXNwZWN0aXZlIHJvd1xuXG4gICAgICAgICAgaW5kZXhSb3cucHVzaChpbmRleCsrKTtcbiAgICAgICAgfSAvLyBub3cgc2F2ZSB2ZXJ0aWNlcyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxuXG5cbiAgICAgICAgaW5kZXhBcnJheS5wdXNoKGluZGV4Um93KTtcbiAgICAgIH0gLy8gZ2VuZXJhdGUgaW5kaWNlc1xuXG5cbiAgICAgIGZvciAodmFyIF94NCA9IDA7IF94NCA8IHJhZGlhbFNlZ21lbnRzOyBfeDQrKykge1xuICAgICAgICBmb3IgKHZhciBfeTIgPSAwOyBfeTIgPCBoZWlnaHRTZWdtZW50czsgX3kyKyspIHtcbiAgICAgICAgICAvLyB3ZSB1c2UgdGhlIGluZGV4IGFycmF5IHRvIGFjY2VzcyB0aGUgY29ycmVjdCBpbmRpY2VzXG4gICAgICAgICAgdmFyIGEgPSBpbmRleEFycmF5W195Ml1bX3g0XTtcbiAgICAgICAgICB2YXIgYiA9IGluZGV4QXJyYXlbX3kyICsgMV1bX3g0XTtcbiAgICAgICAgICB2YXIgYyA9IGluZGV4QXJyYXlbX3kyICsgMV1bX3g0ICsgMV07XG4gICAgICAgICAgdmFyIGQgPSBpbmRleEFycmF5W195Ml1bX3g0ICsgMV07IC8vIGZhY2VzXG5cbiAgICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpOyAvLyB1cGRhdGUgZ3JvdXAgY291bnRlclxuXG4gICAgICAgICAgZ3JvdXBDb3VudCArPSA2O1xuICAgICAgICB9XG4gICAgICB9IC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XG5cblxuICAgICAgc2NvcGUuYWRkR3JvdXAoZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgMCk7IC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG4gICAgICBncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDYXAodG9wKSB7XG4gICAgICAvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2VudGVyIHZlcnRleFxuICAgICAgdmFyIGNlbnRlckluZGV4U3RhcnQgPSBpbmRleDtcbiAgICAgIHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICB2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBncm91cENvdW50ID0gMDtcbiAgICAgIHZhciByYWRpdXMgPSB0b3AgPT09IHRydWUgPyByYWRpdXNUb3AgOiByYWRpdXNCb3R0b207XG4gICAgICB2YXIgc2lnbiA9IHRvcCA9PT0gdHJ1ZSA/IDEgOiAtMTsgLy8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxuICAgICAgLy8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXG4gICAgICAvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cbiAgICAgIGZvciAodmFyIHggPSAxOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4KyspIHtcbiAgICAgICAgLy8gdmVydGV4XG4gICAgICAgIHZlcnRpY2VzLnB1c2goMCwgaGFsZkhlaWdodCAqIHNpZ24sIDApOyAvLyBub3JtYWxcblxuICAgICAgICBub3JtYWxzLnB1c2goMCwgc2lnbiwgMCk7IC8vIHV2XG5cbiAgICAgICAgdXZzLnB1c2goMC41LCAwLjUpOyAvLyBpbmNyZWFzZSBpbmRleFxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNlbnRlciB2ZXJ0ZXhcblxuXG4gICAgICB2YXIgY2VudGVySW5kZXhFbmQgPSBpbmRleDsgLy8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cbiAgICAgIGZvciAodmFyIF94NSA9IDA7IF94NSA8PSByYWRpYWxTZWdtZW50czsgX3g1KyspIHtcbiAgICAgICAgdmFyIHUgPSBfeDUgLyByYWRpYWxTZWdtZW50cztcbiAgICAgICAgdmFyIHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcbiAgICAgICAgdmFyIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICB2YXIgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7IC8vIHZlcnRleFxuXG4gICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG4gICAgICAgIHZlcnRleC55ID0gaGFsZkhlaWdodCAqIHNpZ247XG4gICAgICAgIHZlcnRleC56ID0gcmFkaXVzICogY29zVGhldGE7XG4gICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbFxuXG4gICAgICAgIG5vcm1hbHMucHVzaCgwLCBzaWduLCAwKTsgLy8gdXZcblxuICAgICAgICB1di54ID0gY29zVGhldGEgKiAwLjUgKyAwLjU7XG4gICAgICAgIHV2LnkgPSBzaW5UaGV0YSAqIDAuNSAqIHNpZ24gKyAwLjU7XG4gICAgICAgIHV2cy5wdXNoKHV2LngsIHV2LnkpOyAvLyBpbmNyZWFzZSBpbmRleFxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IC8vIGdlbmVyYXRlIGluZGljZXNcblxuXG4gICAgICBmb3IgKHZhciBfeDYgPSAwOyBfeDYgPCByYWRpYWxTZWdtZW50czsgX3g2KyspIHtcbiAgICAgICAgdmFyIGMgPSBjZW50ZXJJbmRleFN0YXJ0ICsgX3g2O1xuXG4gICAgICAgIHZhciBfaTIwNiA9IGNlbnRlckluZGV4RW5kICsgX3g2O1xuXG4gICAgICAgIGlmICh0b3AgPT09IHRydWUpIHtcbiAgICAgICAgICAvLyBmYWNlIHRvcFxuICAgICAgICAgIGluZGljZXMucHVzaChfaTIwNiwgX2kyMDYgKyAxLCBjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmYWNlIGJvdHRvbVxuICAgICAgICAgIGluZGljZXMucHVzaChfaTIwNiArIDEsIF9pMjA2LCBjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyb3VwQ291bnQgKz0gMztcbiAgICAgIH0gLy8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcblxuXG4gICAgICBzY29wZS5hZGRHcm91cChncm91cFN0YXJ0LCBncm91cENvdW50LCB0b3AgPT09IHRydWUgPyAxIDogMik7IC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuXG4gICAgICBncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzNjQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3lsaW5kZXJHZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBDeWxpbmRlckdlb21ldHJ5KGRhdGEucmFkaXVzVG9wLCBkYXRhLnJhZGl1c0JvdHRvbSwgZGF0YS5oZWlnaHQsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuaGVpZ2h0U2VnbWVudHMsIGRhdGEub3BlbkVuZGVkLCBkYXRhLnRoZXRhU3RhcnQsIGRhdGEudGhldGFMZW5ndGgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDeWxpbmRlckdlb21ldHJ5O1xufShCdWZmZXJHZW9tZXRyeSk7XG5cbnZhciBDb25lR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DeWxpbmRlckdlb21ldHJ5KSB7XG4gIF9pbmhlcml0cyhDb25lR2VvbWV0cnksIF9DeWxpbmRlckdlb21ldHJ5KTtcblxuICB2YXIgX3N1cGVyNzQgPSBfY3JlYXRlU3VwZXIoQ29uZUdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBDb25lR2VvbWV0cnkoKSB7XG4gICAgdmFyIF90aGlzNjU7XG5cbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgdmFyIHJhZGlhbFNlZ21lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiA4O1xuICAgIHZhciBoZWlnaHRTZWdtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcbiAgICB2YXIgb3BlbkVuZGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcbiAgICB2YXIgdGhldGFTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgICB2YXIgdGhldGFMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IE1hdGguUEkgKiAyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmVHZW9tZXRyeSk7XG5cbiAgICBfdGhpczY1ID0gX3N1cGVyNzQuY2FsbCh0aGlzLCAwLCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoKTtcbiAgICBfdGhpczY1LnR5cGUgPSAnQ29uZUdlb21ldHJ5JztcbiAgICBfdGhpczY1LnBhcmFtZXRlcnMgPSB7XG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgICAgb3BlbkVuZGVkOiBvcGVuRW5kZWQsXG4gICAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM2NTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb25lR2VvbWV0cnksIG51bGwsIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgQ29uZUdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmhlaWdodCwgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5oZWlnaHRTZWdtZW50cywgZGF0YS5vcGVuRW5kZWQsIGRhdGEudGhldGFTdGFydCwgZGF0YS50aGV0YUxlbmd0aCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbmVHZW9tZXRyeTtcbn0oQ3lsaW5kZXJHZW9tZXRyeSk7XG5cbnZhciBQb2x5aGVkcm9uR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CdWZmZXJHZW9tZXRyeTYpIHtcbiAgX2luaGVyaXRzKFBvbHloZWRyb25HZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5Nik7XG5cbiAgdmFyIF9zdXBlcjc1ID0gX2NyZWF0ZVN1cGVyKFBvbHloZWRyb25HZW9tZXRyeSk7XG5cbiAgZnVuY3Rpb24gUG9seWhlZHJvbkdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczY2O1xuXG4gICAgdmFyIHZlcnRpY2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICB2YXIgaW5kaWNlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICB2YXIgZGV0YWlsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbHloZWRyb25HZW9tZXRyeSk7XG5cbiAgICBfdGhpczY2ID0gX3N1cGVyNzUuY2FsbCh0aGlzKTtcbiAgICBfdGhpczY2LnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5JztcbiAgICBfdGhpczY2LnBhcmFtZXRlcnMgPSB7XG4gICAgICB2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgICBpbmRpY2VzOiBpbmRpY2VzLFxuICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICBkZXRhaWw6IGRldGFpbFxuICAgIH07IC8vIGRlZmF1bHQgYnVmZmVyIGRhdGFcblxuICAgIHZhciB2ZXJ0ZXhCdWZmZXIgPSBbXTtcbiAgICB2YXIgdXZCdWZmZXIgPSBbXTsgLy8gdGhlIHN1YmRpdmlzaW9uIGNyZWF0ZXMgdGhlIHZlcnRleCBidWZmZXIgZGF0YVxuXG4gICAgc3ViZGl2aWRlKGRldGFpbCk7IC8vIGFsbCB2ZXJ0aWNlcyBzaG91bGQgbGllIG9uIGEgY29uY2VwdHVhbCBzcGhlcmUgd2l0aCBhIGdpdmVuIHJhZGl1c1xuXG4gICAgYXBwbHlSYWRpdXMocmFkaXVzKTsgLy8gZmluYWxseSwgY3JlYXRlIHRoZSB1diBkYXRhXG5cbiAgICBnZW5lcmF0ZVVWcygpOyAvLyBidWlsZCBub24taW5kZXhlZCBnZW9tZXRyeVxuXG4gICAgX3RoaXM2Ni5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGV4QnVmZmVyLCAzKSk7XG5cbiAgICBfdGhpczY2LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGV4QnVmZmVyLnNsaWNlKCksIDMpKTtcblxuICAgIF90aGlzNjYuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2QnVmZmVyLCAyKSk7XG5cbiAgICBpZiAoZGV0YWlsID09PSAwKSB7XG4gICAgICBfdGhpczY2LmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7IC8vIGZsYXQgbm9ybWFsc1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzNjYubm9ybWFsaXplTm9ybWFscygpOyAvLyBzbW9vdGggbm9ybWFsc1xuXG4gICAgfSAvLyBoZWxwZXIgZnVuY3Rpb25zXG5cblxuICAgIGZ1bmN0aW9uIHN1YmRpdmlkZShkZXRhaWwpIHtcbiAgICAgIHZhciBhID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBiID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBjID0gbmV3IFZlY3RvcjMoKTsgLy8gaXRlcmF0ZSBvdmVyIGFsbCBmYWNlcyBhbmQgYXBwbHkgYSBzdWJkaXZpc29uIHdpdGggdGhlIGdpdmVuIGRldGFpbCB2YWx1ZVxuXG4gICAgICBmb3IgKHZhciBfaTIwNyA9IDA7IF9pMjA3IDwgaW5kaWNlcy5sZW5ndGg7IF9pMjA3ICs9IDMpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSB2ZXJ0aWNlcyBvZiB0aGUgZmFjZVxuICAgICAgICBnZXRWZXJ0ZXhCeUluZGV4KGluZGljZXNbX2kyMDcgKyAwXSwgYSk7XG4gICAgICAgIGdldFZlcnRleEJ5SW5kZXgoaW5kaWNlc1tfaTIwNyArIDFdLCBiKTtcbiAgICAgICAgZ2V0VmVydGV4QnlJbmRleChpbmRpY2VzW19pMjA3ICsgMl0sIGMpOyAvLyBwZXJmb3JtIHN1YmRpdmlzaW9uXG5cbiAgICAgICAgc3ViZGl2aWRlRmFjZShhLCBiLCBjLCBkZXRhaWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YmRpdmlkZUZhY2UoYSwgYiwgYywgZGV0YWlsKSB7XG4gICAgICB2YXIgY29scyA9IGRldGFpbCArIDE7IC8vIHdlIHVzZSB0aGlzIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgYXMgYSBkYXRhIHN0cnVjdHVyZSBmb3IgY3JlYXRpbmcgdGhlIHN1YmRpdmlzaW9uXG5cbiAgICAgIHZhciB2ID0gW107IC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uXG5cbiAgICAgIGZvciAodmFyIF9pMjA4ID0gMDsgX2kyMDggPD0gY29sczsgX2kyMDgrKykge1xuICAgICAgICB2W19pMjA4XSA9IFtdO1xuICAgICAgICB2YXIgYWogPSBhLmNsb25lKCkubGVycChjLCBfaTIwOCAvIGNvbHMpO1xuICAgICAgICB2YXIgYmogPSBiLmNsb25lKCkubGVycChjLCBfaTIwOCAvIGNvbHMpO1xuICAgICAgICB2YXIgcm93cyA9IGNvbHMgLSBfaTIwODtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSByb3dzOyBqKyspIHtcbiAgICAgICAgICBpZiAoaiA9PT0gMCAmJiBfaTIwOCA9PT0gY29scykge1xuICAgICAgICAgICAgdltfaTIwOF1bal0gPSBhajtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdltfaTIwOF1bal0gPSBhai5jbG9uZSgpLmxlcnAoYmosIGogLyByb3dzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXNcblxuXG4gICAgICBmb3IgKHZhciBfaTIwOSA9IDA7IF9pMjA5IDwgY29sczsgX2kyMDkrKykge1xuICAgICAgICBmb3IgKHZhciBfajcgPSAwOyBfajcgPCAyICogKGNvbHMgLSBfaTIwOSkgLSAxOyBfajcrKykge1xuICAgICAgICAgIHZhciBrID0gTWF0aC5mbG9vcihfajcgLyAyKTtcblxuICAgICAgICAgIGlmIChfajcgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBwdXNoVmVydGV4KHZbX2kyMDldW2sgKyAxXSk7XG4gICAgICAgICAgICBwdXNoVmVydGV4KHZbX2kyMDkgKyAxXVtrXSk7XG4gICAgICAgICAgICBwdXNoVmVydGV4KHZbX2kyMDldW2tdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHVzaFZlcnRleCh2W19pMjA5XVtrICsgMV0pO1xuICAgICAgICAgICAgcHVzaFZlcnRleCh2W19pMjA5ICsgMV1bayArIDFdKTtcbiAgICAgICAgICAgIHB1c2hWZXJ0ZXgodltfaTIwOSArIDFdW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVJhZGl1cyhyYWRpdXMpIHtcbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpOyAvLyBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBidWZmZXIgYW5kIGFwcGx5IHRoZSByYWRpdXMgdG8gZWFjaCB2ZXJ0ZXhcblxuICAgICAgZm9yICh2YXIgX2kyMTAgPSAwOyBfaTIxMCA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IF9pMjEwICs9IDMpIHtcbiAgICAgICAgdmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbX2kyMTAgKyAwXTtcbiAgICAgICAgdmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbX2kyMTAgKyAxXTtcbiAgICAgICAgdmVydGV4LnogPSB2ZXJ0ZXhCdWZmZXJbX2kyMTAgKyAyXTtcbiAgICAgICAgdmVydGV4Lm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHJhZGl1cyk7XG4gICAgICAgIHZlcnRleEJ1ZmZlcltfaTIxMCArIDBdID0gdmVydGV4Lng7XG4gICAgICAgIHZlcnRleEJ1ZmZlcltfaTIxMCArIDFdID0gdmVydGV4Lnk7XG4gICAgICAgIHZlcnRleEJ1ZmZlcltfaTIxMCArIDJdID0gdmVydGV4Lno7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XG4gICAgICB2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgICAgZm9yICh2YXIgX2kyMTEgPSAwOyBfaTIxMSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IF9pMjExICs9IDMpIHtcbiAgICAgICAgdmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbX2kyMTEgKyAwXTtcbiAgICAgICAgdmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbX2kyMTEgKyAxXTtcbiAgICAgICAgdmVydGV4LnogPSB2ZXJ0ZXhCdWZmZXJbX2kyMTEgKyAyXTtcbiAgICAgICAgdmFyIHUgPSBhemltdXRoKHZlcnRleCkgLyAyIC8gTWF0aC5QSSArIDAuNTtcbiAgICAgICAgdmFyIHYgPSBpbmNsaW5hdGlvbih2ZXJ0ZXgpIC8gTWF0aC5QSSArIDAuNTtcbiAgICAgICAgdXZCdWZmZXIucHVzaCh1LCAxIC0gdik7XG4gICAgICB9XG5cbiAgICAgIGNvcnJlY3RVVnMoKTtcbiAgICAgIGNvcnJlY3RTZWFtKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29ycmVjdFNlYW0oKSB7XG4gICAgICAvLyBoYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtLCBzZWUgIzMyNjlcbiAgICAgIGZvciAodmFyIF9pMjEyID0gMDsgX2kyMTIgPCB1dkJ1ZmZlci5sZW5ndGg7IF9pMjEyICs9IDYpIHtcbiAgICAgICAgLy8gdXYgZGF0YSBvZiBhIHNpbmdsZSBmYWNlXG4gICAgICAgIHZhciB4MCA9IHV2QnVmZmVyW19pMjEyICsgMF07XG4gICAgICAgIHZhciB4MSA9IHV2QnVmZmVyW19pMjEyICsgMl07XG4gICAgICAgIHZhciB4MiA9IHV2QnVmZmVyW19pMjEyICsgNF07XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heCh4MCwgeDEsIHgyKTtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHgwLCB4MSwgeDIpOyAvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cbiAgICAgICAgaWYgKG1heCA+IDAuOSAmJiBtaW4gPCAwLjEpIHtcbiAgICAgICAgICBpZiAoeDAgPCAwLjIpIHV2QnVmZmVyW19pMjEyICsgMF0gKz0gMTtcbiAgICAgICAgICBpZiAoeDEgPCAwLjIpIHV2QnVmZmVyW19pMjEyICsgMl0gKz0gMTtcbiAgICAgICAgICBpZiAoeDIgPCAwLjIpIHV2QnVmZmVyW19pMjEyICsgNF0gKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2hWZXJ0ZXgodmVydGV4KSB7XG4gICAgICB2ZXJ0ZXhCdWZmZXIucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRWZXJ0ZXhCeUluZGV4KGluZGV4LCB2ZXJ0ZXgpIHtcbiAgICAgIHZhciBzdHJpZGUgPSBpbmRleCAqIDM7XG4gICAgICB2ZXJ0ZXgueCA9IHZlcnRpY2VzW3N0cmlkZSArIDBdO1xuICAgICAgdmVydGV4LnkgPSB2ZXJ0aWNlc1tzdHJpZGUgKyAxXTtcbiAgICAgIHZlcnRleC56ID0gdmVydGljZXNbc3RyaWRlICsgMl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29ycmVjdFVWcygpIHtcbiAgICAgIHZhciBhID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBiID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBjID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBjZW50cm9pZCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB2YXIgdXZBID0gbmV3IFZlY3RvcjIoKTtcbiAgICAgIHZhciB1dkIgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgdmFyIHV2QyA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgICAgIGZvciAodmFyIF9pMjEzID0gMCwgaiA9IDA7IF9pMjEzIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgX2kyMTMgKz0gOSwgaiArPSA2KSB7XG4gICAgICAgIGEuc2V0KHZlcnRleEJ1ZmZlcltfaTIxMyArIDBdLCB2ZXJ0ZXhCdWZmZXJbX2kyMTMgKyAxXSwgdmVydGV4QnVmZmVyW19pMjEzICsgMl0pO1xuICAgICAgICBiLnNldCh2ZXJ0ZXhCdWZmZXJbX2kyMTMgKyAzXSwgdmVydGV4QnVmZmVyW19pMjEzICsgNF0sIHZlcnRleEJ1ZmZlcltfaTIxMyArIDVdKTtcbiAgICAgICAgYy5zZXQodmVydGV4QnVmZmVyW19pMjEzICsgNl0sIHZlcnRleEJ1ZmZlcltfaTIxMyArIDddLCB2ZXJ0ZXhCdWZmZXJbX2kyMTMgKyA4XSk7XG4gICAgICAgIHV2QS5zZXQodXZCdWZmZXJbaiArIDBdLCB1dkJ1ZmZlcltqICsgMV0pO1xuICAgICAgICB1dkIuc2V0KHV2QnVmZmVyW2ogKyAyXSwgdXZCdWZmZXJbaiArIDNdKTtcbiAgICAgICAgdXZDLnNldCh1dkJ1ZmZlcltqICsgNF0sIHV2QnVmZmVyW2ogKyA1XSk7XG4gICAgICAgIGNlbnRyb2lkLmNvcHkoYSkuYWRkKGIpLmFkZChjKS5kaXZpZGVTY2FsYXIoMyk7XG4gICAgICAgIHZhciBhemkgPSBhemltdXRoKGNlbnRyb2lkKTtcbiAgICAgICAgY29ycmVjdFVWKHV2QSwgaiArIDAsIGEsIGF6aSk7XG4gICAgICAgIGNvcnJlY3RVVih1dkIsIGogKyAyLCBiLCBhemkpO1xuICAgICAgICBjb3JyZWN0VVYodXZDLCBqICsgNCwgYywgYXppKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3JyZWN0VVYodXYsIHN0cmlkZSwgdmVjdG9yLCBhemltdXRoKSB7XG4gICAgICBpZiAoYXppbXV0aCA8IDAgJiYgdXYueCA9PT0gMSkge1xuICAgICAgICB1dkJ1ZmZlcltzdHJpZGVdID0gdXYueCAtIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZWN0b3IueCA9PT0gMCAmJiB2ZWN0b3IueiA9PT0gMCkge1xuICAgICAgICB1dkJ1ZmZlcltzdHJpZGVdID0gYXppbXV0aCAvIDIgLyBNYXRoLlBJICsgMC41O1xuICAgICAgfVxuICAgIH0gLy8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxuXG5cbiAgICBmdW5jdGlvbiBhemltdXRoKHZlY3Rvcikge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodmVjdG9yLnosIC12ZWN0b3IueCk7XG4gICAgfSAvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXG5cblxuICAgIGZ1bmN0aW9uIGluY2xpbmF0aW9uKHZlY3Rvcikge1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIoLXZlY3Rvci55LCBNYXRoLnNxcnQodmVjdG9yLnggKiB2ZWN0b3IueCArIHZlY3Rvci56ICogdmVjdG9yLnopKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM2NjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb2x5aGVkcm9uR2VvbWV0cnksIG51bGwsIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgUG9seWhlZHJvbkdlb21ldHJ5KGRhdGEudmVydGljZXMsIGRhdGEuaW5kaWNlcywgZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlscyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbHloZWRyb25HZW9tZXRyeTtcbn0oQnVmZmVyR2VvbWV0cnkpO1xuXG52YXIgRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Qb2x5aGVkcm9uR2VvbWV0cnkpIHtcbiAgX2luaGVyaXRzKERvZGVjYWhlZHJvbkdlb21ldHJ5LCBfUG9seWhlZHJvbkdlb21ldHJ5KTtcblxuICB2YXIgX3N1cGVyNzYgPSBfY3JlYXRlU3VwZXIoRG9kZWNhaGVkcm9uR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIERvZGVjYWhlZHJvbkdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczY3O1xuXG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICB2YXIgZGV0YWlsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvZGVjYWhlZHJvbkdlb21ldHJ5KTtcblxuICAgIHZhciB0ID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcbiAgICB2YXIgciA9IDEgLyB0O1xuICAgIHZhciB2ZXJ0aWNlcyA9IFsvLyAowrExLCDCsTEsIMKxMSlcbiAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIDEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIDEsIC0xLCAxLCAxLCAxLCAvLyAoMCwgwrExL8+GLCDCsc+GKVxuICAgIDAsIC1yLCAtdCwgMCwgLXIsIHQsIDAsIHIsIC10LCAwLCByLCB0LCAvLyAowrExL8+GLCDCsc+GLCAwKVxuICAgIC1yLCAtdCwgMCwgLXIsIHQsIDAsIHIsIC10LCAwLCByLCB0LCAwLCAvLyAowrHPhiwgMCwgwrExL8+GKVxuICAgIC10LCAwLCAtciwgdCwgMCwgLXIsIC10LCAwLCByLCB0LCAwLCByXTtcbiAgICB2YXIgaW5kaWNlcyA9IFszLCAxMSwgNywgMywgNywgMTUsIDMsIDE1LCAxMywgNywgMTksIDE3LCA3LCAxNywgNiwgNywgNiwgMTUsIDE3LCA0LCA4LCAxNywgOCwgMTAsIDE3LCAxMCwgNiwgOCwgMCwgMTYsIDgsIDE2LCAyLCA4LCAyLCAxMCwgMCwgMTIsIDEsIDAsIDEsIDE4LCAwLCAxOCwgMTYsIDYsIDEwLCAyLCA2LCAyLCAxMywgNiwgMTMsIDE1LCAyLCAxNiwgMTgsIDIsIDE4LCAzLCAyLCAzLCAxMywgMTgsIDEsIDksIDE4LCA5LCAxMSwgMTgsIDExLCAzLCA0LCAxNCwgMTIsIDQsIDEyLCAwLCA0LCAwLCA4LCAxMSwgOSwgNSwgMTEsIDUsIDE5LCAxMSwgMTksIDcsIDE5LCA1LCAxNCwgMTksIDE0LCA0LCAxOSwgNCwgMTcsIDEsIDEyLCAxNCwgMSwgMTQsIDUsIDEsIDUsIDldO1xuICAgIF90aGlzNjcgPSBfc3VwZXI3Ni5jYWxsKHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCk7XG4gICAgX3RoaXM2Ny50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcbiAgICBfdGhpczY3LnBhcmFtZXRlcnMgPSB7XG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM2NztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEb2RlY2FoZWRyb25HZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBEb2RlY2FoZWRyb25HZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS5kZXRhaWwpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEb2RlY2FoZWRyb25HZW9tZXRyeTtcbn0oUG9seWhlZHJvbkdlb21ldHJ5KTtcblxudmFyIF92MCA9IG5ldyBWZWN0b3IzKCk7XG5cbnZhciBfdjEkMSA9IG5ldyBWZWN0b3IzKCk7XG5cbnZhciBfbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxudmFyIF90cmlhbmdsZSA9IG5ldyBUcmlhbmdsZSgpO1xuXG52YXIgRWRnZXNHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckdlb21ldHJ5Nykge1xuICBfaW5oZXJpdHMoRWRnZXNHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5Nyk7XG5cbiAgdmFyIF9zdXBlcjc3ID0gX2NyZWF0ZVN1cGVyKEVkZ2VzR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIEVkZ2VzR2VvbWV0cnkoKSB7XG4gICAgdmFyIF90aGlzNjg7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgdmFyIHRocmVzaG9sZEFuZ2xlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VzR2VvbWV0cnkpO1xuXG4gICAgX3RoaXM2OCA9IF9zdXBlcjc3LmNhbGwodGhpcyk7XG4gICAgX3RoaXM2OC50eXBlID0gJ0VkZ2VzR2VvbWV0cnknO1xuICAgIF90aGlzNjgucGFyYW1ldGVycyA9IHtcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIHRocmVzaG9sZEFuZ2xlOiB0aHJlc2hvbGRBbmdsZVxuICAgIH07XG5cbiAgICBpZiAoZ2VvbWV0cnkgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmVjaXNpb25Qb2ludHMgPSA0O1xuICAgICAgdmFyIHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBwcmVjaXNpb25Qb2ludHMpO1xuICAgICAgdmFyIHRocmVzaG9sZERvdCA9IE1hdGguY29zKERFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSk7XG4gICAgICB2YXIgaW5kZXhBdHRyID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgICAgIHZhciBwb3NpdGlvbkF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgICB2YXIgaW5kZXhDb3VudCA9IGluZGV4QXR0ciA/IGluZGV4QXR0ci5jb3VudCA6IHBvc2l0aW9uQXR0ci5jb3VudDtcbiAgICAgIHZhciBpbmRleEFyciA9IFswLCAwLCAwXTtcbiAgICAgIHZhciB2ZXJ0S2V5cyA9IFsnYScsICdiJywgJ2MnXTtcbiAgICAgIHZhciBoYXNoZXMgPSBuZXcgQXJyYXkoMyk7XG4gICAgICB2YXIgZWRnZURhdGEgPSB7fTtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTIxNCA9IDA7IF9pMjE0IDwgaW5kZXhDb3VudDsgX2kyMTQgKz0gMykge1xuICAgICAgICBpZiAoaW5kZXhBdHRyKSB7XG4gICAgICAgICAgaW5kZXhBcnJbMF0gPSBpbmRleEF0dHIuZ2V0WChfaTIxNCk7XG4gICAgICAgICAgaW5kZXhBcnJbMV0gPSBpbmRleEF0dHIuZ2V0WChfaTIxNCArIDEpO1xuICAgICAgICAgIGluZGV4QXJyWzJdID0gaW5kZXhBdHRyLmdldFgoX2kyMTQgKyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleEFyclswXSA9IF9pMjE0O1xuICAgICAgICAgIGluZGV4QXJyWzFdID0gX2kyMTQgKyAxO1xuICAgICAgICAgIGluZGV4QXJyWzJdID0gX2kyMTQgKyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBfdHJpYW5nbGUuYSxcbiAgICAgICAgICAgIGIgPSBfdHJpYW5nbGUuYixcbiAgICAgICAgICAgIGMgPSBfdHJpYW5nbGUuYztcbiAgICAgICAgYS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uQXR0ciwgaW5kZXhBcnJbMF0pO1xuICAgICAgICBiLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyLCBpbmRleEFyclsxXSk7XG4gICAgICAgIGMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHIsIGluZGV4QXJyWzJdKTtcblxuICAgICAgICBfdHJpYW5nbGUuZ2V0Tm9ybWFsKF9ub3JtYWwpOyAvLyBjcmVhdGUgaGFzaGVzIGZvciB0aGUgZWRnZSBmcm9tIHRoZSB2ZXJ0aWNlc1xuXG5cbiAgICAgICAgaGFzaGVzWzBdID0gXCJcIi5jb25jYXQoTWF0aC5yb3VuZChhLnggKiBwcmVjaXNpb24pLCBcIixcIikuY29uY2F0KE1hdGgucm91bmQoYS55ICogcHJlY2lzaW9uKSwgXCIsXCIpLmNvbmNhdChNYXRoLnJvdW5kKGEueiAqIHByZWNpc2lvbikpO1xuICAgICAgICBoYXNoZXNbMV0gPSBcIlwiLmNvbmNhdChNYXRoLnJvdW5kKGIueCAqIHByZWNpc2lvbiksIFwiLFwiKS5jb25jYXQoTWF0aC5yb3VuZChiLnkgKiBwcmVjaXNpb24pLCBcIixcIikuY29uY2F0KE1hdGgucm91bmQoYi56ICogcHJlY2lzaW9uKSk7XG4gICAgICAgIGhhc2hlc1syXSA9IFwiXCIuY29uY2F0KE1hdGgucm91bmQoYy54ICogcHJlY2lzaW9uKSwgXCIsXCIpLmNvbmNhdChNYXRoLnJvdW5kKGMueSAqIHByZWNpc2lvbiksIFwiLFwiKS5jb25jYXQoTWF0aC5yb3VuZChjLnogKiBwcmVjaXNpb24pKTsgLy8gc2tpcCBkZWdlbmVyYXRlIHRyaWFuZ2xlc1xuXG4gICAgICAgIGlmIChoYXNoZXNbMF0gPT09IGhhc2hlc1sxXSB8fCBoYXNoZXNbMV0gPT09IGhhc2hlc1syXSB8fCBoYXNoZXNbMl0gPT09IGhhc2hlc1swXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGl0ZXJhdGUgb3ZlciBldmVyeSBlZGdlXG5cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgIC8vIGdldCB0aGUgZmlyc3QgYW5kIG5leHQgdmVydGV4IG1ha2luZyB1cCB0aGUgZWRnZVxuICAgICAgICAgIHZhciBqTmV4dCA9IChqICsgMSkgJSAzO1xuICAgICAgICAgIHZhciB2ZWNIYXNoMCA9IGhhc2hlc1tqXTtcbiAgICAgICAgICB2YXIgdmVjSGFzaDEgPSBoYXNoZXNbak5leHRdO1xuICAgICAgICAgIHZhciB2MCA9IF90cmlhbmdsZVt2ZXJ0S2V5c1tqXV07XG4gICAgICAgICAgdmFyIHYxID0gX3RyaWFuZ2xlW3ZlcnRLZXlzW2pOZXh0XV07XG4gICAgICAgICAgdmFyIGhhc2ggPSBcIlwiLmNvbmNhdCh2ZWNIYXNoMCwgXCJfXCIpLmNvbmNhdCh2ZWNIYXNoMSk7XG4gICAgICAgICAgdmFyIHJldmVyc2VIYXNoID0gXCJcIi5jb25jYXQodmVjSGFzaDEsIFwiX1wiKS5jb25jYXQodmVjSGFzaDApO1xuXG4gICAgICAgICAgaWYgKHJldmVyc2VIYXNoIGluIGVkZ2VEYXRhICYmIGVkZ2VEYXRhW3JldmVyc2VIYXNoXSkge1xuICAgICAgICAgICAgLy8gaWYgd2UgZm91bmQgYSBzaWJsaW5nIGVkZ2UgYWRkIGl0IGludG8gdGhlIHZlcnRleCBhcnJheSBpZlxuICAgICAgICAgICAgLy8gaXQgbWVldHMgdGhlIGFuZ2xlIHRocmVzaG9sZCBhbmQgZGVsZXRlIHRoZSBlZGdlIGZyb20gdGhlIG1hcC5cbiAgICAgICAgICAgIGlmIChfbm9ybWFsLmRvdChlZGdlRGF0YVtyZXZlcnNlSGFzaF0ubm9ybWFsKSA8PSB0aHJlc2hvbGREb3QpIHtcbiAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh2MC54LCB2MC55LCB2MC56KTtcbiAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh2MS54LCB2MS55LCB2MS56KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWRnZURhdGFbcmV2ZXJzZUhhc2hdID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEoaGFzaCBpbiBlZGdlRGF0YSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGVkZ2UgaGVyZSB0aGVuIHNraXAgYWRkaW5nIGEgbmV3IG9uZVxuICAgICAgICAgICAgZWRnZURhdGFbaGFzaF0gPSB7XG4gICAgICAgICAgICAgIGluZGV4MDogaW5kZXhBcnJbal0sXG4gICAgICAgICAgICAgIGluZGV4MTogaW5kZXhBcnJbak5leHRdLFxuICAgICAgICAgICAgICBub3JtYWw6IF9ub3JtYWwuY2xvbmUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaXRlcmF0ZSBvdmVyIGFsbCByZW1haW5pbmcsIHVubWF0Y2hlZCBlZGdlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIHZlcnRleCBhcnJheVxuXG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBlZGdlRGF0YSkge1xuICAgICAgICBpZiAoZWRnZURhdGFba2V5XSkge1xuICAgICAgICAgIHZhciBfZWRnZURhdGEka2V5ID0gZWRnZURhdGFba2V5XSxcbiAgICAgICAgICAgICAgaW5kZXgwID0gX2VkZ2VEYXRhJGtleS5pbmRleDAsXG4gICAgICAgICAgICAgIGluZGV4MSA9IF9lZGdlRGF0YSRrZXkuaW5kZXgxO1xuXG4gICAgICAgICAgX3YwLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25BdHRyLCBpbmRleDApO1xuXG4gICAgICAgICAgX3YxJDEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbkF0dHIsIGluZGV4MSk7XG5cbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKF92MC54LCBfdjAueSwgX3YwLnopO1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2goX3YxJDEueCwgX3YxJDEueSwgX3YxJDEueik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXM2OC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM2ODtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWRnZXNHZW9tZXRyeSk7XG59KEJ1ZmZlckdlb21ldHJ5KTtcblxudmFyIFNoYXBlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHMoU2hhcGUsIF9QYXRoKTtcblxuICB2YXIgX3N1cGVyNzggPSBfY3JlYXRlU3VwZXIoU2hhcGUpO1xuXG4gIGZ1bmN0aW9uIFNoYXBlKHBvaW50cykge1xuICAgIHZhciBfdGhpczY5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYXBlKTtcblxuICAgIF90aGlzNjkgPSBfc3VwZXI3OC5jYWxsKHRoaXMsIHBvaW50cyk7XG4gICAgX3RoaXM2OS51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgX3RoaXM2OS50eXBlID0gJ1NoYXBlJztcbiAgICBfdGhpczY5LmhvbGVzID0gW107XG4gICAgcmV0dXJuIF90aGlzNjk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2hhcGUsIFt7XG4gICAga2V5OiBcImdldFBvaW50c0hvbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50c0hvbGVzKGRpdmlzaW9ucykge1xuICAgICAgdmFyIGhvbGVzUHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pMjE1ID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBfaTIxNSA8IGw7IF9pMjE1KyspIHtcbiAgICAgICAgaG9sZXNQdHNbX2kyMTVdID0gdGhpcy5ob2xlc1tfaTIxNV0uZ2V0UG9pbnRzKGRpdmlzaW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBob2xlc1B0cztcbiAgICB9IC8vIGdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdFBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0UG9pbnRzKGRpdmlzaW9ucykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hhcGU6IHRoaXMuZ2V0UG9pbnRzKGRpdmlzaW9ucyksXG4gICAgICAgIGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKGRpdmlzaW9ucylcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFNoYXBlLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMuaG9sZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kyMTYgPSAwLCBsID0gc291cmNlLmhvbGVzLmxlbmd0aDsgX2kyMTYgPCBsOyBfaTIxNisrKSB7XG4gICAgICAgIHZhciBob2xlID0gc291cmNlLmhvbGVzW19pMjE2XTtcbiAgICAgICAgdGhpcy5ob2xlcy5wdXNoKGhvbGUuY2xvbmUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGRhdGEgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihTaGFwZS5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICBkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgICBkYXRhLmhvbGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pMjE3ID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBfaTIxNyA8IGw7IF9pMjE3KyspIHtcbiAgICAgICAgdmFyIGhvbGUgPSB0aGlzLmhvbGVzW19pMjE3XTtcbiAgICAgICAgZGF0YS5ob2xlcy5wdXNoKGhvbGUudG9KU09OKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oanNvbikge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU2hhcGUucHJvdG90eXBlKSwgXCJmcm9tSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMsIGpzb24pO1xuXG4gICAgICB0aGlzLnV1aWQgPSBqc29uLnV1aWQ7XG4gICAgICB0aGlzLmhvbGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pMjE4ID0gMCwgbCA9IGpzb24uaG9sZXMubGVuZ3RoOyBfaTIxOCA8IGw7IF9pMjE4KyspIHtcbiAgICAgICAgdmFyIGhvbGUgPSBqc29uLmhvbGVzW19pMjE4XTtcbiAgICAgICAgdGhpcy5ob2xlcy5wdXNoKG5ldyBQYXRoKCkuZnJvbUpTT04oaG9sZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hhcGU7XG59KFBhdGgpO1xuLyoqXG4gKiBQb3J0IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9lYXJjdXQgKHYyLjIuMilcbiAqL1xuXG5cbnZhciBFYXJjdXQgPSB7XG4gIHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiB0cmlhbmd1bGF0ZShkYXRhLCBob2xlSW5kaWNlcykge1xuICAgIHZhciBkaW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDI7XG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoO1xuICAgIHZhciBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKTtcbiAgICB2YXIgdHJpYW5nbGVzID0gW107XG4gICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTsgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICBmb3IgKHZhciBfaTIxOSA9IGRpbTsgX2kyMTkgPCBvdXRlckxlbjsgX2kyMTkgKz0gZGltKSB7XG4gICAgICAgIHggPSBkYXRhW19pMjE5XTtcbiAgICAgICAgeSA9IGRhdGFbX2kyMTkgKyAxXTtcbiAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgIH0gLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cblxuXG4gICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgIGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMSAvIGludlNpemUgOiAwO1xuICAgIH1cblxuICAgIGVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICByZXR1cm4gdHJpYW5nbGVzO1xuICB9XG59OyAvLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcblxuZnVuY3Rpb24gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSkge1xuICB2YXIgaSwgbGFzdDtcblxuICBpZiAoY2xvY2t3aXNlID09PSBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIHtcbiAgICAgIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9XG4gIH1cblxuICBpZiAobGFzdCAmJiBlcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgfVxuXG4gIHJldHVybiBsYXN0O1xufSAvLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xuXG5cbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgaWYgKCFlbmQpIGVuZCA9IHN0YXJ0O1xuICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgYWdhaW47XG5cbiAgZG8ge1xuICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgIGlmIChwID09PSBwLm5leHQpIGJyZWFrO1xuICAgICAgYWdhaW4gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICByZXR1cm4gZW5kO1xufSAvLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcblxuXG5mdW5jdGlvbiBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcykge1xuICBpZiAoIWVhcikgcmV0dXJuOyAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5cbiAgaWYgKCFwYXNzICYmIGludlNpemUpIGluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICBwcmV2LFxuICAgICAgbmV4dDsgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG5cbiAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgIHByZXYgPSBlYXIucHJldjtcbiAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICBpZiAoaW52U2l6ZSA/IGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBpc0VhcihlYXIpKSB7XG4gICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgdHJpYW5nbGVzLnB1c2gocHJldi5pIC8gZGltKTtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XG4gICAgICByZW1vdmVOb2RlKGVhcik7IC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcblxuICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgc3RvcCA9IG5leHQubmV4dDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVhciA9IG5leHQ7IC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG5cbiAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpOyAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpOyAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgIHNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn0gLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG5cblxuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gIHZhciBhID0gZWFyLnByZXYsXG4gICAgICBiID0gZWFyLFxuICAgICAgYyA9IGVhci5uZXh0O1xuICBpZiAoYXJlYShhLCBiLCBjKSA+PSAwKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG4gIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG5cbiAgdmFyIHAgPSBlYXIubmV4dC5uZXh0O1xuXG4gIHdoaWxlIChwICE9PSBlYXIucHJldikge1xuICAgIGlmIChwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICB2YXIgYSA9IGVhci5wcmV2LFxuICAgICAgYiA9IGVhcixcbiAgICAgIGMgPSBlYXIubmV4dDtcbiAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuXG4gIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IGEueCA8IGMueCA/IGEueCA6IGMueCA6IGIueCA8IGMueCA/IGIueCA6IGMueCxcbiAgICAgIG1pblRZID0gYS55IDwgYi55ID8gYS55IDwgYy55ID8gYS55IDogYy55IDogYi55IDwgYy55ID8gYi55IDogYy55LFxuICAgICAgbWF4VFggPSBhLnggPiBiLnggPyBhLnggPiBjLnggPyBhLnggOiBjLnggOiBiLnggPiBjLnggPyBiLnggOiBjLngsXG4gICAgICBtYXhUWSA9IGEueSA+IGIueSA/IGEueSA+IGMueSA/IGEueSA6IGMueSA6IGIueSA+IGMueSA/IGIueSA6IGMueTsgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcblxuICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIGludlNpemUpLFxuICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIGludlNpemUpO1xuICB2YXIgcCA9IGVhci5wcmV2WixcbiAgICAgIG4gPSBlYXIubmV4dFo7IC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuXG4gIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiYgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJiBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgcCA9IHAucHJldlo7XG4gICAgaWYgKG4gIT09IGVhci5wcmV2ICYmIG4gIT09IGVhci5uZXh0ICYmIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBuLngsIG4ueSkgJiYgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIG4gPSBuLm5leHRaO1xuICB9IC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG5cblxuICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJiBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICBwID0gcC5wcmV2WjtcbiAgfSAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuXG5cbiAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcbiAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiYgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJiBhcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgbiA9IG4ubmV4dFo7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0gLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcblxuXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICB2YXIgcCA9IHN0YXJ0O1xuXG4gIGRvIHtcbiAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgaWYgKCFlcXVhbHMoYSwgYikgJiYgaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSkge1xuICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltKTtcbiAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XG4gICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pOyAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG5cbiAgICAgIHJlbW92ZU5vZGUocCk7XG4gICAgICByZW1vdmVOb2RlKHAubmV4dCk7XG4gICAgICBwID0gc3RhcnQgPSBiO1xuICAgIH1cblxuICAgIHAgPSBwLm5leHQ7XG4gIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICByZXR1cm4gZmlsdGVyUG9pbnRzKHApO1xufSAvLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuXG5cbmZ1bmN0aW9uIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICB2YXIgYSA9IHN0YXJ0O1xuXG4gIGRvIHtcbiAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuXG4gICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAvLyBzcGxpdCB0aGUgcG9seWdvbiBpbiB0d28gYnkgdGhlIGRpYWdvbmFsXG4gICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpOyAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuXG4gICAgICAgIGEgPSBmaWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpOyAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuXG4gICAgICAgIGVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYiA9IGIubmV4dDtcbiAgICB9XG5cbiAgICBhID0gYS5uZXh0O1xuICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59IC8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcblxuXG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgbGlzdCA9IGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSk7XG4gICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgfVxuXG4gIHF1ZXVlLnNvcnQoY29tcGFyZVgpOyAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuXG4gIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgb3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICB9XG5cbiAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICByZXR1cm4gYS54IC0gYi54O1xufSAvLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgbGluayBpdFxuXG5cbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG5cbiAgaWYgKG91dGVyTm9kZSkge1xuICAgIHZhciBiID0gc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7IC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuXG4gICAgZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xuICB9XG59IC8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cblxuXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgdmFyIHAgPSBvdXRlck5vZGU7XG4gIHZhciBoeCA9IGhvbGUueDtcbiAgdmFyIGh5ID0gaG9sZS55O1xuICB2YXIgcXggPSAtSW5maW5pdHksXG4gICAgICBtOyAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcblxuICBkbyB7XG4gICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG4gICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcblxuICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgIHF4ID0geDtcblxuICAgICAgICBpZiAoeCA9PT0gaHgpIHtcbiAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG4gICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICBpZiAoIW0pIHJldHVybiBudWxsO1xuICBpZiAoaHggPT09IHF4KSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcbiAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICB2YXIgc3RvcCA9IG0sXG4gICAgICBteCA9IG0ueCxcbiAgICAgIG15ID0gbS55O1xuICB2YXIgdGFuTWluID0gSW5maW5pdHksXG4gICAgICB0YW47XG4gIHAgPSBtO1xuXG4gIGRvIHtcbiAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcbiAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgaWYgKGxvY2FsbHlJbnNpZGUocCwgaG9sZSkgJiYgKHRhbiA8IHRhbk1pbiB8fCB0YW4gPT09IHRhbk1pbiAmJiAocC54ID4gbS54IHx8IHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApKSkpIHtcbiAgICAgICAgbSA9IHA7XG4gICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwID0gcC5uZXh0O1xuICB9IHdoaWxlIChwICE9PSBzdG9wKTtcblxuICByZXR1cm4gbTtcbn0gLy8gd2hldGhlciBzZWN0b3IgaW4gdmVydGV4IG0gY29udGFpbnMgc2VjdG9yIGluIHZlcnRleCBwIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5cblxuZnVuY3Rpb24gc2VjdG9yQ29udGFpbnNTZWN0b3IobSwgcCkge1xuICByZXR1cm4gYXJlYShtLnByZXYsIG0sIHAucHJldikgPCAwICYmIGFyZWEocC5uZXh0LCBtLCBtLm5leHQpIDwgMDtcbn0gLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuXG5cbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgdmFyIHAgPSBzdGFydDtcblxuICBkbyB7XG4gICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gIHAucHJldloubmV4dFogPSBudWxsO1xuICBwLnByZXZaID0gbnVsbDtcbiAgc29ydExpbmtlZChwKTtcbn0gLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbi8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXG5cblxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gIHZhciBpLFxuICAgICAgcCxcbiAgICAgIHEsXG4gICAgICBlLFxuICAgICAgdGFpbCxcbiAgICAgIG51bU1lcmdlcyxcbiAgICAgIHBTaXplLFxuICAgICAgcVNpemUsXG4gICAgICBpblNpemUgPSAxO1xuXG4gIGRvIHtcbiAgICBwID0gbGlzdDtcbiAgICBsaXN0ID0gbnVsbDtcbiAgICB0YWlsID0gbnVsbDtcbiAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgd2hpbGUgKHApIHtcbiAgICAgIG51bU1lcmdlcysrO1xuICAgICAgcSA9IHA7XG4gICAgICBwU2l6ZSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICBwU2l6ZSsrO1xuICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgcVNpemUgPiAwICYmIHEpIHtcbiAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgIGUgPSBwO1xuICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgIHBTaXplLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtlbHNlIGxpc3QgPSBlO1xuICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgdGFpbCA9IGU7XG4gICAgICB9XG5cbiAgICAgIHAgPSBxO1xuICAgIH1cblxuICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgIGluU2l6ZSAqPSAyO1xuICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcblxuICByZXR1cm4gbGlzdDtcbn0gLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5cblxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxuICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpICogaW52U2l6ZTtcbiAgeSA9IDMyNzY3ICogKHkgLSBtaW5ZKSAqIGludlNpemU7XG4gIHggPSAoeCB8IHggPDwgOCkgJiAweDAwRkYwMEZGO1xuICB4ID0gKHggfCB4IDw8IDQpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgeCA8PCAyKSAmIDB4MzMzMzMzMzM7XG4gIHggPSAoeCB8IHggPDwgMSkgJiAweDU1NTU1NTU1O1xuICB5ID0gKHkgfCB5IDw8IDgpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgeSA8PCA0KSAmIDB4MEYwRjBGMEY7XG4gIHkgPSAoeSB8IHkgPDwgMikgJiAweDMzMzMzMzMzO1xuICB5ID0gKHkgfCB5IDw8IDEpICYgMHg1NTU1NTU1NTtcbiAgcmV0dXJuIHggfCB5IDw8IDE7XG59IC8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcblxuXG5mdW5jdGlvbiBnZXRMZWZ0bW9zdChzdGFydCkge1xuICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgbGVmdG1vc3QgPSBzdGFydDtcblxuICBkbyB7XG4gICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgcC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpIGxlZnRtb3N0ID0gcDtcbiAgICBwID0gcC5uZXh0O1xuICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgcmV0dXJuIGxlZnRtb3N0O1xufSAvLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5cblxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiYgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiYgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XG59IC8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuXG5cbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmICggLy8gZG9lc24ndCBpbnRlcnNlY3Qgb3RoZXIgZWRnZXNcbiAgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKSAmJiAoIC8vIGxvY2FsbHkgdmlzaWJsZVxuICBhcmVhKGEucHJldiwgYSwgYi5wcmV2KSB8fCBhcmVhKGEsIGIucHJldiwgYikpIHx8IC8vIGRvZXMgbm90IGNyZWF0ZSBvcHBvc2l0ZS1mYWNpbmcgc2VjdG9yc1xuICBlcXVhbHMoYSwgYikgJiYgYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPiAwICYmIGFyZWEoYi5wcmV2LCBiLCBiLm5leHQpID4gMCk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxufSAvLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5cblxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn0gLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcblxuXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59IC8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcblxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gIHZhciBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG4gIHZhciBvMiA9IHNpZ24oYXJlYShwMSwgcTEsIHEyKSk7XG4gIHZhciBvMyA9IHNpZ24oYXJlYShwMiwgcTIsIHAxKSk7XG4gIHZhciBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG4gIGlmIChvMSAhPT0gbzIgJiYgbzMgIT09IG80KSByZXR1cm4gdHJ1ZTsgLy8gZ2VuZXJhbCBjYXNlXG5cbiAgaWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG5cbiAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG5cbiAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG5cbiAgaWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBmb3IgY29sbGluZWFyIHBvaW50cyBwLCBxLCByLCBjaGVjayBpZiBwb2ludCBxIGxpZXMgb24gc2VnbWVudCBwclxuXG5cbmZ1bmN0aW9uIG9uU2VnbWVudChwLCBxLCByKSB7XG4gIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICByZXR1cm4gbnVtID4gMCA/IDEgOiBudW0gPCAwID8gLTEgOiAwO1xufSAvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuXG5cbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgdmFyIHAgPSBhO1xuXG4gIGRvIHtcbiAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgcCA9IHAubmV4dDtcbiAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cblxuXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/IGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDogYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufSAvLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cblxuXG5mdW5jdGlvbiBtaWRkbGVJbnNpZGUoYSwgYikge1xuICB2YXIgcCA9IGEsXG4gICAgICBpbnNpZGUgPSBmYWxzZTtcbiAgdmFyIHB4ID0gKGEueCArIGIueCkgLyAyLFxuICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG5cbiAgZG8ge1xuICAgIGlmIChwLnkgPiBweSAhPT0gcC5uZXh0LnkgPiBweSAmJiBwLm5leHQueSAhPT0gcC55ICYmIHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSBpbnNpZGUgPSAhaW5zaWRlO1xuICAgIHAgPSBwLm5leHQ7XG4gIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gIHJldHVybiBpbnNpZGU7XG59IC8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuXG5cbmZ1bmN0aW9uIHNwbGl0UG9seWdvbihhLCBiKSB7XG4gIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgIGFuID0gYS5uZXh0LFxuICAgICAgYnAgPSBiLnByZXY7XG4gIGEubmV4dCA9IGI7XG4gIGIucHJldiA9IGE7XG4gIGEyLm5leHQgPSBhbjtcbiAgYW4ucHJldiA9IGEyO1xuICBiMi5uZXh0ID0gYTI7XG4gIGEyLnByZXYgPSBiMjtcbiAgYnAubmV4dCA9IGIyO1xuICBiMi5wcmV2ID0gYnA7XG4gIHJldHVybiBiMjtcbn0gLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcblxuXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICBpZiAoIWxhc3QpIHtcbiAgICBwLnByZXYgPSBwO1xuICAgIHAubmV4dCA9IHA7XG4gIH0gZWxzZSB7XG4gICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgIHAucHJldiA9IGxhc3Q7XG4gICAgbGFzdC5uZXh0LnByZXYgPSBwO1xuICAgIGxhc3QubmV4dCA9IHA7XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShwKSB7XG4gIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICBwLnByZXYubmV4dCA9IHAubmV4dDtcbiAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgdGhpcy5pID0gaTsgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG5cbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTsgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGV4IG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDsgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuXG4gIHRoaXMueiA9IG51bGw7IC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcblxuICB0aGlzLnByZXZaID0gbnVsbDtcbiAgdGhpcy5uZXh0WiA9IG51bGw7IC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG5cbiAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gIHZhciBzdW0gPSAwO1xuXG4gIGZvciAodmFyIF9pMjIwID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IF9pMjIwIDwgZW5kOyBfaTIyMCArPSBkaW0pIHtcbiAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW19pMjIwXSkgKiAoZGF0YVtfaTIyMCArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgIGogPSBfaTIyMDtcbiAgfVxuXG4gIHJldHVybiBzdW07XG59XG5cbnZhciBTaGFwZVV0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hhcGVVdGlscygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhcGVVdGlscyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2hhcGVVdGlscywgbnVsbCwgW3tcbiAgICBrZXk6IFwiYXJlYVwiLFxuICAgIHZhbHVlOiAvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG4gICAgZnVuY3Rpb24gYXJlYShjb250b3VyKSB7XG4gICAgICB2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuICAgICAgdmFyIGEgPSAwLjA7XG5cbiAgICAgIGZvciAodmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSsrKSB7XG4gICAgICAgIGEgKz0gY29udG91cltwXS54ICogY29udG91cltxXS55IC0gY29udG91cltxXS54ICogY29udG91cltwXS55O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYSAqIDAuNTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDbG9ja1dpc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNDbG9ja1dpc2UocHRzKSB7XG4gICAgICByZXR1cm4gU2hhcGVVdGlscy5hcmVhKHB0cykgPCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmlhbmd1bGF0ZVNoYXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlU2hhcGUoY29udG91ciwgaG9sZXMpIHtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIHZlcnRpY2VzIGxpa2UgWyB4MCx5MCwgeDEseTEsIHgyLHkyLCAuLi4gXVxuXG4gICAgICB2YXIgaG9sZUluZGljZXMgPSBbXTsgLy8gYXJyYXkgb2YgaG9sZSBpbmRpY2VzXG5cbiAgICAgIHZhciBmYWNlcyA9IFtdOyAvLyBmaW5hbCBhcnJheSBvZiB2ZXJ0ZXggaW5kaWNlcyBsaWtlIFsgWyBhLGIsZCBdLCBbIGIsYyxkIF0gXVxuXG4gICAgICByZW1vdmVEdXBFbmRQdHMoY29udG91cik7XG4gICAgICBhZGRDb250b3VyKHZlcnRpY2VzLCBjb250b3VyKTsgLy9cblxuICAgICAgdmFyIGhvbGVJbmRleCA9IGNvbnRvdXIubGVuZ3RoO1xuICAgICAgaG9sZXMuZm9yRWFjaChyZW1vdmVEdXBFbmRQdHMpO1xuXG4gICAgICBmb3IgKHZhciBfaTIyMSA9IDA7IF9pMjIxIDwgaG9sZXMubGVuZ3RoOyBfaTIyMSsrKSB7XG4gICAgICAgIGhvbGVJbmRpY2VzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgaG9sZUluZGV4ICs9IGhvbGVzW19pMjIxXS5sZW5ndGg7XG4gICAgICAgIGFkZENvbnRvdXIodmVydGljZXMsIGhvbGVzW19pMjIxXSk7XG4gICAgICB9IC8vXG5cblxuICAgICAgdmFyIHRyaWFuZ2xlcyA9IEVhcmN1dC50cmlhbmd1bGF0ZSh2ZXJ0aWNlcywgaG9sZUluZGljZXMpOyAvL1xuXG4gICAgICBmb3IgKHZhciBfaTIyMiA9IDA7IF9pMjIyIDwgdHJpYW5nbGVzLmxlbmd0aDsgX2kyMjIgKz0gMykge1xuICAgICAgICBmYWNlcy5wdXNoKHRyaWFuZ2xlcy5zbGljZShfaTIyMiwgX2kyMjIgKyAzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWNlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hhcGVVdGlscztcbn0oKTtcblxuZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKHBvaW50cykge1xuICB2YXIgbCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgaWYgKGwgPiAyICYmIHBvaW50c1tsIC0gMV0uZXF1YWxzKHBvaW50c1swXSkpIHtcbiAgICBwb2ludHMucG9wKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ29udG91cih2ZXJ0aWNlcywgY29udG91cikge1xuICBmb3IgKHZhciBfaTIyMyA9IDA7IF9pMjIzIDwgY29udG91ci5sZW5ndGg7IF9pMjIzKyspIHtcbiAgICB2ZXJ0aWNlcy5wdXNoKGNvbnRvdXJbX2kyMjNdLngpO1xuICAgIHZlcnRpY2VzLnB1c2goY29udG91cltfaTIyM10ueSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXG4gKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xuICogIGRlcHRoOiA8ZmxvYXQ+LCAvLyBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRoZSBvcmlnaW5hbCBzaGFwZSBiZXZlbCBnb2VzXG4gKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSAoaW5jbHVkaW5nIGJldmVsT2Zmc2V0KSBpcyBiZXZlbFxuICogIGJldmVsT2Zmc2V0OiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBkb2VzIGJldmVsIHN0YXJ0XG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcbiAqXG4gKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZT4gLy8gY3VydmUgdG8gZXh0cnVkZSBzaGFwZSBhbG9uZ1xuICpcbiAqICBVVkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqL1xuXG5cbnZhciBFeHRydWRlR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CdWZmZXJHZW9tZXRyeTgpIHtcbiAgX2luaGVyaXRzKEV4dHJ1ZGVHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5OCk7XG5cbiAgdmFyIF9zdXBlcjc5ID0gX2NyZWF0ZVN1cGVyKEV4dHJ1ZGVHZW9tZXRyeSk7XG5cbiAgZnVuY3Rpb24gRXh0cnVkZUdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczcwO1xuXG4gICAgdmFyIHNoYXBlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFNoYXBlKFtuZXcgVmVjdG9yMigwLjUsIDAuNSksIG5ldyBWZWN0b3IyKC0wLjUsIDAuNSksIG5ldyBWZWN0b3IyKC0wLjUsIC0wLjUpLCBuZXcgVmVjdG9yMigwLjUsIC0wLjUpXSk7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4dHJ1ZGVHZW9tZXRyeSk7XG5cbiAgICBfdGhpczcwID0gX3N1cGVyNzkuY2FsbCh0aGlzKTtcbiAgICBfdGhpczcwLnR5cGUgPSAnRXh0cnVkZUdlb21ldHJ5JztcbiAgICBfdGhpczcwLnBhcmFtZXRlcnMgPSB7XG4gICAgICBzaGFwZXM6IHNoYXBlcyxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICAgIHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoc2hhcGVzKSA/IHNoYXBlcyA6IFtzaGFwZXNdO1xuXG4gICAgdmFyIHNjb3BlID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczcwKTtcblxuICAgIHZhciB2ZXJ0aWNlc0FycmF5ID0gW107XG4gICAgdmFyIHV2QXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIF9pMjI0ID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IF9pMjI0IDwgbDsgX2kyMjQrKykge1xuICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW19pMjI0XTtcbiAgICAgIGFkZFNoYXBlKHNoYXBlKTtcbiAgICB9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuICAgIF90aGlzNzAuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzQXJyYXksIDMpKTtcblxuICAgIF90aGlzNzAuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2QXJyYXksIDIpKTtcblxuICAgIF90aGlzNzAuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsgLy8gZnVuY3Rpb25zXG5cblxuICAgIGZ1bmN0aW9uIGFkZFNoYXBlKHNoYXBlKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSBbXTsgLy8gb3B0aW9uc1xuXG4gICAgICB2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG4gICAgICB2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcbiAgICAgIHZhciBkZXB0aCA9IG9wdGlvbnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGggOiAxO1xuICAgICAgdmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7XG4gICAgICB2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogMC4yO1xuICAgICAgdmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMC4xO1xuICAgICAgdmFyIGJldmVsT2Zmc2V0ID0gb3B0aW9ucy5iZXZlbE9mZnNldCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbE9mZnNldCA6IDA7XG4gICAgICB2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcbiAgICAgIHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XG4gICAgICB2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogV29ybGRVVkdlbmVyYXRvcjsgLy8gZGVwcmVjYXRlZCBvcHRpb25zXG5cbiAgICAgIGlmIChvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuRXh0cnVkZUJ1ZmZlckdlb21ldHJ5OiBhbW91bnQgaGFzIGJlZW4gcmVuYW1lZCB0byBkZXB0aC4nKTtcbiAgICAgICAgZGVwdGggPSBvcHRpb25zLmFtb3VudDtcbiAgICAgIH0gLy9cblxuXG4gICAgICB2YXIgZXh0cnVkZVB0cyxcbiAgICAgICAgICBleHRydWRlQnlQYXRoID0gZmFsc2U7XG4gICAgICB2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xuXG4gICAgICBpZiAoZXh0cnVkZVBhdGgpIHtcbiAgICAgICAgZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyhzdGVwcyk7XG4gICAgICAgIGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xuICAgICAgICBiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXG4gICAgICAgIC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcbiAgICAgICAgLy8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cblxuICAgICAgICBzcGxpbmVUdWJlID0gZXh0cnVkZVBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyhzdGVwcywgZmFsc2UpOyAvLyBjb25zb2xlLmxvZyhzcGxpbmVUdWJlLCAnc3BsaW5lVHViZScsIHNwbGluZVR1YmUubm9ybWFscy5sZW5ndGgsICdzdGVwcycsIHN0ZXBzLCAnZXh0cnVkZVB0cycsIGV4dHJ1ZGVQdHMubGVuZ3RoKTtcblxuICAgICAgICBiaW5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICAgIHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICB9IC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxuXG5cbiAgICAgIGlmICghYmV2ZWxFbmFibGVkKSB7XG4gICAgICAgIGJldmVsU2VnbWVudHMgPSAwO1xuICAgICAgICBiZXZlbFRoaWNrbmVzcyA9IDA7XG4gICAgICAgIGJldmVsU2l6ZSA9IDA7XG4gICAgICAgIGJldmVsT2Zmc2V0ID0gMDtcbiAgICAgIH0gLy8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXG5cblxuICAgICAgdmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyhjdXJ2ZVNlZ21lbnRzKTtcbiAgICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xuICAgICAgdmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG4gICAgICB2YXIgcmV2ZXJzZSA9ICFTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKHZlcnRpY2VzKTtcblxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7IC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXG5cbiAgICAgICAgZm9yICh2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGgrKykge1xuICAgICAgICAgIHZhciBhaG9sZSA9IGhvbGVzW2hdO1xuXG4gICAgICAgICAgaWYgKFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoYWhvbGUpKSB7XG4gICAgICAgICAgICBob2xlc1toXSA9IGFob2xlLnJldmVyc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKHZlcnRpY2VzLCBob2xlcyk7XG4gICAgICAvKiBWZXJ0aWNlcyAqL1xuXG4gICAgICB2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxuXG4gICAgICBmb3IgKHZhciBfaCA9IDAsIF9obCA9IGhvbGVzLmxlbmd0aDsgX2ggPCBfaGw7IF9oKyspIHtcbiAgICAgICAgdmFyIF9haG9sZSA9IGhvbGVzW19oXTtcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoX2Fob2xlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2NhbGVQdDIocHQsIHZlYywgc2l6ZSkge1xuICAgICAgICBpZiAoIXZlYykgY29uc29sZS5lcnJvcignVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgcmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHNpemUpLmFkZChwdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2bGVuID0gdmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgIGZsZW4gPSBmYWNlcy5sZW5ndGg7IC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuICAgICAgZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoaW5QdCwgaW5QcmV2LCBpbk5leHQpIHtcbiAgICAgICAgLy8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuICAgICAgICAvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XG4gICAgICAgIC8vIGlmIHdlIHdhbGsgYWxvbmcgY29udG91ciBjbG9ja3dpc2UsIHRoaXMgbmV3IGNvbnRvdXIgaXMgb3V0c2lkZSB0aGUgb2xkIG9uZVxuICAgICAgICAvL1xuICAgICAgICAvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xuICAgICAgICAvLyAgYWRqYWNlbnQgZWRnZXMgb2YgaW5QdCBhdCBhIGRpc3RhbmNlIG9mIDEgdW5pdCBvbiB0aGUgbGVmdCBzaWRlLlxuICAgICAgICB2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieTsgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuICAgICAgICAvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXG4gICAgICAgIC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXG5cbiAgICAgICAgdmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsXG4gICAgICAgICAgICB2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xuICAgICAgICB2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCxcbiAgICAgICAgICAgIHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG4gICAgICAgIHZhciB2X3ByZXZfbGVuc3EgPSB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeTsgLy8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuXG4gICAgICAgIHZhciBjb2xsaW5lYXIwID0gdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3g7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGNvbGxpbmVhcjApID4gTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICAvLyBub3QgY29sbGluZWFyXG4gICAgICAgICAgLy8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG4gICAgICAgICAgdmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQodl9wcmV2X2xlbnNxKTtcbiAgICAgICAgICB2YXIgdl9uZXh0X2xlbiA9IE1hdGguc3FydCh2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSk7IC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcblxuICAgICAgICAgIHZhciBwdFByZXZTaGlmdF94ID0gaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW47XG4gICAgICAgICAgdmFyIHB0UHJldlNoaWZ0X3kgPSBpblByZXYueSArIHZfcHJldl94IC8gdl9wcmV2X2xlbjtcbiAgICAgICAgICB2YXIgcHROZXh0U2hpZnRfeCA9IGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuO1xuICAgICAgICAgIHZhciBwdE5leHRTaGlmdF95ID0gaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW47IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cbiAgICAgICAgICB2YXIgc2YgPSAoKHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94KSAqIHZfbmV4dF95IC0gKHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95KSAqIHZfbmV4dF94KSAvICh2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCk7IC8vIHZlY3RvciBmcm9tIGluUHQgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cbiAgICAgICAgICB2X3RyYW5zX3ggPSBwdFByZXZTaGlmdF94ICsgdl9wcmV2X3ggKiBzZiAtIGluUHQueDtcbiAgICAgICAgICB2X3RyYW5zX3kgPSBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueTsgLy8gRG9uJ3Qgbm9ybWFsaXplISwgb3RoZXJ3aXNlIHNoYXJwIGNvcm5lcnMgYmVjb21lIHVnbHlcbiAgICAgICAgICAvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cbiAgICAgICAgICB2YXIgdl90cmFuc19sZW5zcSA9IHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeTtcblxuICAgICAgICAgIGlmICh2X3RyYW5zX2xlbnNxIDw9IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih2X3RyYW5zX3gsIHZfdHJhbnNfeSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCh2X3RyYW5zX2xlbnNxIC8gMik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXG4gICAgICAgICAgdmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuXG4gICAgICAgICAgaWYgKHZfcHJldl94ID4gTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICAgIGlmICh2X25leHRfeCA+IE51bWJlci5FUFNJTE9OKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGlvbl9lcSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2X3ByZXZfeCA8IC1OdW1iZXIuRVBTSUxPTikge1xuICAgICAgICAgICAgICBpZiAodl9uZXh0X3ggPCAtTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25fZXEgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoTWF0aC5zaWduKHZfcHJldl95KSA9PT0gTWF0aC5zaWduKHZfbmV4dF95KSkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbl9lcSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uX2VxKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuICAgICAgICAgICAgdl90cmFuc194ID0gLXZfcHJldl95O1xuICAgICAgICAgICAgdl90cmFuc195ID0gdl9wcmV2X3g7XG4gICAgICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQodl9wcmV2X2xlbnNxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzcGlrZVwiKTtcbiAgICAgICAgICAgIHZfdHJhbnNfeCA9IHZfcHJldl94O1xuICAgICAgICAgICAgdl90cmFuc195ID0gdl9wcmV2X3k7XG4gICAgICAgICAgICBzaHJpbmtfYnkgPSBNYXRoLnNxcnQodl9wcmV2X2xlbnNxIC8gMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kyMjUgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gX2kyMjUgKyAxOyBfaTIyNSA8IGlsOyBfaTIyNSsrLCBqKyssIGsrKykge1xuICAgICAgICBpZiAoaiA9PT0gaWwpIGogPSAwO1xuICAgICAgICBpZiAoayA9PT0gaWwpIGsgPSAwOyAvLyAgKGopLS0tKGkpLS0tKGspXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG4gICAgICAgIGNvbnRvdXJNb3ZlbWVudHNbX2kyMjVdID0gZ2V0QmV2ZWxWZWMoY29udG91cltfaTIyNV0sIGNvbnRvdXJbal0sIGNvbnRvdXJba10pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXTtcbiAgICAgIHZhciBvbmVIb2xlTW92ZW1lbnRzLFxuICAgICAgICAgIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuICAgICAgZm9yICh2YXIgX2gyID0gMCwgX2hsMiA9IGhvbGVzLmxlbmd0aDsgX2gyIDwgX2hsMjsgX2gyKyspIHtcbiAgICAgICAgdmFyIF9haG9sZTIgPSBob2xlc1tfaDJdO1xuICAgICAgICBvbmVIb2xlTW92ZW1lbnRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgX2kyMjYgPSAwLCBfaWwxMyA9IF9haG9sZTIubGVuZ3RoLCBfajggPSBfaWwxMyAtIDEsIF9rID0gX2kyMjYgKyAxOyBfaTIyNiA8IF9pbDEzOyBfaTIyNisrLCBfajgrKywgX2srKykge1xuICAgICAgICAgIGlmIChfajggPT09IF9pbDEzKSBfajggPSAwO1xuICAgICAgICAgIGlmIChfayA9PT0gX2lsMTMpIF9rID0gMDsgLy8gIChqKS0tLShpKS0tLShrKVxuXG4gICAgICAgICAgb25lSG9sZU1vdmVtZW50c1tfaTIyNl0gPSBnZXRCZXZlbFZlYyhfYWhvbGUyW19pMjI2XSwgX2Fob2xlMltfajhdLCBfYWhvbGUyW19rXSk7XG4gICAgICAgIH1cblxuICAgICAgICBob2xlc01vdmVtZW50cy5wdXNoKG9uZUhvbGVNb3ZlbWVudHMpO1xuICAgICAgICB2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdChvbmVIb2xlTW92ZW1lbnRzKTtcbiAgICAgIH0gLy8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cblxuICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiKyspIHtcbiAgICAgICAgLy9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG4gICAgICAgIHZhciB0ID0gYiAvIGJldmVsU2VnbWVudHM7XG4gICAgICAgIHZhciB6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpO1xuXG4gICAgICAgIHZhciBfYnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbih0ICogTWF0aC5QSSAvIDIpICsgYmV2ZWxPZmZzZXQ7IC8vIGNvbnRyYWN0IHNoYXBlXG5cblxuICAgICAgICBmb3IgKHZhciBfaTIyNyA9IDAsIF9pbDE0ID0gY29udG91ci5sZW5ndGg7IF9pMjI3IDwgX2lsMTQ7IF9pMjI3KyspIHtcbiAgICAgICAgICB2YXIgdmVydCA9IHNjYWxlUHQyKGNvbnRvdXJbX2kyMjddLCBjb250b3VyTW92ZW1lbnRzW19pMjI3XSwgX2JzKTtcbiAgICAgICAgICB2KHZlcnQueCwgdmVydC55LCAteik7XG4gICAgICAgIH0gLy8gZXhwYW5kIGhvbGVzXG5cblxuICAgICAgICBmb3IgKHZhciBfaDMgPSAwLCBfaGwzID0gaG9sZXMubGVuZ3RoOyBfaDMgPCBfaGwzOyBfaDMrKykge1xuICAgICAgICAgIHZhciBfYWhvbGUzID0gaG9sZXNbX2gzXTtcbiAgICAgICAgICBvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbX2gzXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMjI4ID0gMCwgX2lsMTUgPSBfYWhvbGUzLmxlbmd0aDsgX2kyMjggPCBfaWwxNTsgX2kyMjgrKykge1xuICAgICAgICAgICAgdmFyIF92ZXJ0ID0gc2NhbGVQdDIoX2Fob2xlM1tfaTIyOF0sIG9uZUhvbGVNb3ZlbWVudHNbX2kyMjhdLCBfYnMpO1xuXG4gICAgICAgICAgICB2KF92ZXJ0LngsIF92ZXJ0LnksIC16KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJzID0gYmV2ZWxTaXplICsgYmV2ZWxPZmZzZXQ7IC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXG5cbiAgICAgIGZvciAodmFyIF9pMjI5ID0gMDsgX2kyMjkgPCB2bGVuOyBfaTIyOSsrKSB7XG4gICAgICAgIHZhciBfdmVydDIgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0Mih2ZXJ0aWNlc1tfaTIyOV0sIHZlcnRpY2VzTW92ZW1lbnRzW19pMjI5XSwgYnMpIDogdmVydGljZXNbX2kyMjldO1xuXG4gICAgICAgIGlmICghZXh0cnVkZUJ5UGF0aCkge1xuICAgICAgICAgIHYoX3ZlcnQyLngsIF92ZXJ0Mi55LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xuICAgICAgICAgIG5vcm1hbC5jb3B5KHNwbGluZVR1YmUubm9ybWFsc1swXSkubXVsdGlwbHlTY2FsYXIoX3ZlcnQyLngpO1xuICAgICAgICAgIGJpbm9ybWFsLmNvcHkoc3BsaW5lVHViZS5iaW5vcm1hbHNbMF0pLm11bHRpcGx5U2NhbGFyKF92ZXJ0Mi55KTtcbiAgICAgICAgICBwb3NpdGlvbjIuY29weShleHRydWRlUHRzWzBdKS5hZGQobm9ybWFsKS5hZGQoYmlub3JtYWwpO1xuICAgICAgICAgIHYocG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cbiAgICAgIC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcblxuXG4gICAgICBmb3IgKHZhciBzID0gMTsgcyA8PSBzdGVwczsgcysrKSB7XG4gICAgICAgIGZvciAodmFyIF9pMjMwID0gMDsgX2kyMzAgPCB2bGVuOyBfaTIzMCsrKSB7XG4gICAgICAgICAgdmFyIF92ZXJ0MyA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKHZlcnRpY2VzW19pMjMwXSwgdmVydGljZXNNb3ZlbWVudHNbX2kyMzBdLCBicykgOiB2ZXJ0aWNlc1tfaTIzMF07XG5cbiAgICAgICAgICBpZiAoIWV4dHJ1ZGVCeVBhdGgpIHtcbiAgICAgICAgICAgIHYoX3ZlcnQzLngsIF92ZXJ0My55LCBkZXB0aCAvIHN0ZXBzICogcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgcyAtIDEgXS55LCBleHRydWRlUHRzWyBzIC0gMSBdLnggKTtcbiAgICAgICAgICAgIG5vcm1hbC5jb3B5KHNwbGluZVR1YmUubm9ybWFsc1tzXSkubXVsdGlwbHlTY2FsYXIoX3ZlcnQzLngpO1xuICAgICAgICAgICAgYmlub3JtYWwuY29weShzcGxpbmVUdWJlLmJpbm9ybWFsc1tzXSkubXVsdGlwbHlTY2FsYXIoX3ZlcnQzLnkpO1xuICAgICAgICAgICAgcG9zaXRpb24yLmNvcHkoZXh0cnVkZVB0c1tzXSkuYWRkKG5vcm1hbCkuYWRkKGJpbm9ybWFsKTtcbiAgICAgICAgICAgIHYocG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcbiAgICAgIC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcblxuXG4gICAgICBmb3IgKHZhciBfYjUgPSBiZXZlbFNlZ21lbnRzIC0gMTsgX2I1ID49IDA7IF9iNS0tKSB7XG4gICAgICAgIHZhciBfdCA9IF9iNSAvIGJldmVsU2VnbWVudHM7XG5cbiAgICAgICAgdmFyIF96MiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoX3QgKiBNYXRoLlBJIC8gMik7XG5cbiAgICAgICAgdmFyIF9iczIgPSBiZXZlbFNpemUgKiBNYXRoLnNpbihfdCAqIE1hdGguUEkgLyAyKSArIGJldmVsT2Zmc2V0OyAvLyBjb250cmFjdCBzaGFwZVxuXG5cbiAgICAgICAgZm9yICh2YXIgX2kyMzEgPSAwLCBfaWwxNiA9IGNvbnRvdXIubGVuZ3RoOyBfaTIzMSA8IF9pbDE2OyBfaTIzMSsrKSB7XG4gICAgICAgICAgdmFyIF92ZXJ0NCA9IHNjYWxlUHQyKGNvbnRvdXJbX2kyMzFdLCBjb250b3VyTW92ZW1lbnRzW19pMjMxXSwgX2JzMik7XG5cbiAgICAgICAgICB2KF92ZXJ0NC54LCBfdmVydDQueSwgZGVwdGggKyBfejIpO1xuICAgICAgICB9IC8vIGV4cGFuZCBob2xlc1xuXG5cbiAgICAgICAgZm9yICh2YXIgX2g0ID0gMCwgX2hsNCA9IGhvbGVzLmxlbmd0aDsgX2g0IDwgX2hsNDsgX2g0KyspIHtcbiAgICAgICAgICB2YXIgX2Fob2xlNCA9IGhvbGVzW19oNF07XG4gICAgICAgICAgb25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzW19oNF07XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIzMiA9IDAsIF9pbDE3ID0gX2Fob2xlNC5sZW5ndGg7IF9pMjMyIDwgX2lsMTc7IF9pMjMyKyspIHtcbiAgICAgICAgICAgIHZhciBfdmVydDUgPSBzY2FsZVB0MihfYWhvbGU0W19pMjMyXSwgb25lSG9sZU1vdmVtZW50c1tfaTIzMl0sIF9iczIpO1xuXG4gICAgICAgICAgICBpZiAoIWV4dHJ1ZGVCeVBhdGgpIHtcbiAgICAgICAgICAgICAgdihfdmVydDUueCwgX3ZlcnQ1LnksIGRlcHRoICsgX3oyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHYoX3ZlcnQ1LngsIF92ZXJ0NS55ICsgZXh0cnVkZVB0c1tzdGVwcyAtIDFdLnksIGV4dHJ1ZGVQdHNbc3RlcHMgLSAxXS54ICsgX3oyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIEZhY2VzICovXG4gICAgICAvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xuXG5cbiAgICAgIGJ1aWxkTGlkRmFjZXMoKTsgLy8gU2lkZXMgZmFjZXNcblxuICAgICAgYnVpbGRTaWRlRmFjZXMoKTsgLy8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG4gICAgICBmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG5cbiAgICAgICAgaWYgKGJldmVsRW5hYmxlZCkge1xuICAgICAgICAgIHZhciBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxuXG4gICAgICAgICAgdmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjsgLy8gQm90dG9tIGZhY2VzXG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIzMyA9IDA7IF9pMjMzIDwgZmxlbjsgX2kyMzMrKykge1xuICAgICAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tfaTIzM107XG4gICAgICAgICAgICBmMyhmYWNlWzJdICsgb2Zmc2V0LCBmYWNlWzFdICsgb2Zmc2V0LCBmYWNlWzBdICsgb2Zmc2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG4gICAgICAgICAgb2Zmc2V0ID0gdmxlbiAqIGxheWVyOyAvLyBUb3AgZmFjZXNcblxuICAgICAgICAgIGZvciAodmFyIF9pMjM0ID0gMDsgX2kyMzQgPCBmbGVuOyBfaTIzNCsrKSB7XG4gICAgICAgICAgICB2YXIgX2ZhY2UgPSBmYWNlc1tfaTIzNF07XG4gICAgICAgICAgICBmMyhfZmFjZVswXSArIG9mZnNldCwgX2ZhY2VbMV0gKyBvZmZzZXQsIF9mYWNlWzJdICsgb2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQm90dG9tIGZhY2VzXG4gICAgICAgICAgZm9yICh2YXIgX2kyMzUgPSAwOyBfaTIzNSA8IGZsZW47IF9pMjM1KyspIHtcbiAgICAgICAgICAgIHZhciBfZmFjZTIgPSBmYWNlc1tfaTIzNV07XG4gICAgICAgICAgICBmMyhfZmFjZTJbMl0sIF9mYWNlMlsxXSwgX2ZhY2UyWzBdKTtcbiAgICAgICAgICB9IC8vIFRvcCBmYWNlc1xuXG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIzNiA9IDA7IF9pMjM2IDwgZmxlbjsgX2kyMzYrKykge1xuICAgICAgICAgICAgdmFyIF9mYWNlMyA9IGZhY2VzW19pMjM2XTtcbiAgICAgICAgICAgIGYzKF9mYWNlM1swXSArIHZsZW4gKiBzdGVwcywgX2ZhY2UzWzFdICsgdmxlbiAqIHN0ZXBzLCBfZmFjZTNbMl0gKyB2bGVuICogc3RlcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLmFkZEdyb3VwKHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgMCk7XG4gICAgICB9IC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cblxuICAgICAgZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcbiAgICAgICAgdmFyIGxheWVyb2Zmc2V0ID0gMDtcbiAgICAgICAgc2lkZXdhbGxzKGNvbnRvdXIsIGxheWVyb2Zmc2V0KTtcbiAgICAgICAgbGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgX2g1ID0gMCwgX2hsNSA9IGhvbGVzLmxlbmd0aDsgX2g1IDwgX2hsNTsgX2g1KyspIHtcbiAgICAgICAgICB2YXIgX2Fob2xlNSA9IGhvbGVzW19oNV07XG4gICAgICAgICAgc2lkZXdhbGxzKF9haG9sZTUsIGxheWVyb2Zmc2V0KTsgLy8sIHRydWVcblxuICAgICAgICAgIGxheWVyb2Zmc2V0ICs9IF9haG9sZTUubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUuYWRkR3JvdXAoc3RhcnQsIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyAtIHN0YXJ0LCAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2lkZXdhbGxzKGNvbnRvdXIsIGxheWVyb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpID0gY29udG91ci5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgdmFyIF9qOSA9IGk7XG5cbiAgICAgICAgICB2YXIgX2syID0gaSAtIDE7XG5cbiAgICAgICAgICBpZiAoX2syIDwgMCkgX2syID0gY29udG91ci5sZW5ndGggLSAxOyAvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuICAgICAgICAgIGZvciAodmFyIF9zNCA9IDAsIHNsID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjsgX3M0IDwgc2w7IF9zNCsrKSB7XG4gICAgICAgICAgICB2YXIgc2xlbjEgPSB2bGVuICogX3M0O1xuICAgICAgICAgICAgdmFyIHNsZW4yID0gdmxlbiAqIChfczQgKyAxKTtcblxuICAgICAgICAgICAgdmFyIGEgPSBsYXllcm9mZnNldCArIF9qOSArIHNsZW4xLFxuICAgICAgICAgICAgICAgIF9iNiA9IGxheWVyb2Zmc2V0ICsgX2syICsgc2xlbjEsXG4gICAgICAgICAgICAgICAgYyA9IGxheWVyb2Zmc2V0ICsgX2syICsgc2xlbjIsXG4gICAgICAgICAgICAgICAgZCA9IGxheWVyb2Zmc2V0ICsgX2o5ICsgc2xlbjI7XG5cbiAgICAgICAgICAgIGY0KGEsIF9iNiwgYywgZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHYoeCwgeSwgeikge1xuICAgICAgICBwbGFjZWhvbGRlci5wdXNoKHgpO1xuICAgICAgICBwbGFjZWhvbGRlci5wdXNoKHkpO1xuICAgICAgICBwbGFjZWhvbGRlci5wdXNoKHopO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmMyhhLCBiLCBjKSB7XG4gICAgICAgIGFkZFZlcnRleChhKTtcbiAgICAgICAgYWRkVmVydGV4KGIpO1xuICAgICAgICBhZGRWZXJ0ZXgoYyk7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XG4gICAgICAgIHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxKTtcbiAgICAgICAgYWRkVVYodXZzWzBdKTtcbiAgICAgICAgYWRkVVYodXZzWzFdKTtcbiAgICAgICAgYWRkVVYodXZzWzJdKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZjQoYSwgYiwgYywgZCkge1xuICAgICAgICBhZGRWZXJ0ZXgoYSk7XG4gICAgICAgIGFkZFZlcnRleChiKTtcbiAgICAgICAgYWRkVmVydGV4KGQpO1xuICAgICAgICBhZGRWZXJ0ZXgoYik7XG4gICAgICAgIGFkZFZlcnRleChjKTtcbiAgICAgICAgYWRkVmVydGV4KGQpO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xuICAgICAgICB2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSA2LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxKTtcbiAgICAgICAgYWRkVVYodXZzWzBdKTtcbiAgICAgICAgYWRkVVYodXZzWzFdKTtcbiAgICAgICAgYWRkVVYodXZzWzNdKTtcbiAgICAgICAgYWRkVVYodXZzWzFdKTtcbiAgICAgICAgYWRkVVYodXZzWzJdKTtcbiAgICAgICAgYWRkVVYodXZzWzNdKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkVmVydGV4KGluZGV4KSB7XG4gICAgICAgIHZlcnRpY2VzQXJyYXkucHVzaChwbGFjZWhvbGRlcltpbmRleCAqIDMgKyAwXSk7XG4gICAgICAgIHZlcnRpY2VzQXJyYXkucHVzaChwbGFjZWhvbGRlcltpbmRleCAqIDMgKyAxXSk7XG4gICAgICAgIHZlcnRpY2VzQXJyYXkucHVzaChwbGFjZWhvbGRlcltpbmRleCAqIDMgKyAyXSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFVWKHZlY3RvcjIpIHtcbiAgICAgICAgdXZBcnJheS5wdXNoKHZlY3RvcjIueCk7XG4gICAgICAgIHV2QXJyYXkucHVzaCh2ZWN0b3IyLnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdGhpczcwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEV4dHJ1ZGVHZW9tZXRyeSwgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBkYXRhID0gX2dldChfZ2V0UHJvdG90eXBlT2YoRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLnBhcmFtZXRlcnMub3B0aW9ucztcbiAgICAgIHJldHVybiB0b0pTT04kMShzaGFwZXMsIG9wdGlvbnMsIGRhdGEpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRhdGEsIHNoYXBlcykge1xuICAgICAgdmFyIGdlb21ldHJ5U2hhcGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2RhdGEuc2hhcGVzW2pdXTtcbiAgICAgICAgZ2VvbWV0cnlTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHRydWRlUGF0aCA9IGRhdGEub3B0aW9ucy5leHRydWRlUGF0aDtcblxuICAgICAgaWYgKGV4dHJ1ZGVQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoID0gbmV3IEN1cnZlc1tleHRydWRlUGF0aC50eXBlXSgpLmZyb21KU09OKGV4dHJ1ZGVQYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBFeHRydWRlR2VvbWV0cnkoZ2VvbWV0cnlTaGFwZXMsIGRhdGEub3B0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV4dHJ1ZGVHZW9tZXRyeTtcbn0oQnVmZmVyR2VvbWV0cnkpO1xuXG52YXIgV29ybGRVVkdlbmVyYXRvciA9IHtcbiAgZ2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gZ2VuZXJhdGVUb3BVVihnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMpIHtcbiAgICB2YXIgYV94ID0gdmVydGljZXNbaW5kZXhBICogM107XG4gICAgdmFyIGFfeSA9IHZlcnRpY2VzW2luZGV4QSAqIDMgKyAxXTtcbiAgICB2YXIgYl94ID0gdmVydGljZXNbaW5kZXhCICogM107XG4gICAgdmFyIGJfeSA9IHZlcnRpY2VzW2luZGV4QiAqIDMgKyAxXTtcbiAgICB2YXIgY194ID0gdmVydGljZXNbaW5kZXhDICogM107XG4gICAgdmFyIGNfeSA9IHZlcnRpY2VzW2luZGV4QyAqIDMgKyAxXTtcbiAgICByZXR1cm4gW25ldyBWZWN0b3IyKGFfeCwgYV95KSwgbmV3IFZlY3RvcjIoYl94LCBiX3kpLCBuZXcgVmVjdG9yMihjX3gsIGNfeSldO1xuICB9LFxuICBnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uIGdlbmVyYXRlU2lkZVdhbGxVVihnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCkge1xuICAgIHZhciBhX3ggPSB2ZXJ0aWNlc1tpbmRleEEgKiAzXTtcbiAgICB2YXIgYV95ID0gdmVydGljZXNbaW5kZXhBICogMyArIDFdO1xuICAgIHZhciBhX3ogPSB2ZXJ0aWNlc1tpbmRleEEgKiAzICsgMl07XG4gICAgdmFyIGJfeCA9IHZlcnRpY2VzW2luZGV4QiAqIDNdO1xuICAgIHZhciBiX3kgPSB2ZXJ0aWNlc1tpbmRleEIgKiAzICsgMV07XG4gICAgdmFyIGJfeiA9IHZlcnRpY2VzW2luZGV4QiAqIDMgKyAyXTtcbiAgICB2YXIgY194ID0gdmVydGljZXNbaW5kZXhDICogM107XG4gICAgdmFyIGNfeSA9IHZlcnRpY2VzW2luZGV4QyAqIDMgKyAxXTtcbiAgICB2YXIgY196ID0gdmVydGljZXNbaW5kZXhDICogMyArIDJdO1xuICAgIHZhciBkX3ggPSB2ZXJ0aWNlc1tpbmRleEQgKiAzXTtcbiAgICB2YXIgZF95ID0gdmVydGljZXNbaW5kZXhEICogMyArIDFdO1xuICAgIHZhciBkX3ogPSB2ZXJ0aWNlc1tpbmRleEQgKiAzICsgMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoYV95IC0gYl95KSA8IE1hdGguYWJzKGFfeCAtIGJfeCkpIHtcbiAgICAgIHJldHVybiBbbmV3IFZlY3RvcjIoYV94LCAxIC0gYV96KSwgbmV3IFZlY3RvcjIoYl94LCAxIC0gYl96KSwgbmV3IFZlY3RvcjIoY194LCAxIC0gY196KSwgbmV3IFZlY3RvcjIoZF94LCAxIC0gZF96KV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbbmV3IFZlY3RvcjIoYV95LCAxIC0gYV96KSwgbmV3IFZlY3RvcjIoYl95LCAxIC0gYl96KSwgbmV3IFZlY3RvcjIoY195LCAxIC0gY196KSwgbmV3IFZlY3RvcjIoZF95LCAxIC0gZF96KV07XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiB0b0pTT04kMShzaGFwZXMsIG9wdGlvbnMsIGRhdGEpIHtcbiAgZGF0YS5zaGFwZXMgPSBbXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG4gICAgZm9yICh2YXIgX2kyMzcgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgX2kyMzcgPCBsOyBfaTIzNysrKSB7XG4gICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbX2kyMzddO1xuICAgICAgZGF0YS5zaGFwZXMucHVzaChzaGFwZS51dWlkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5zaGFwZXMucHVzaChzaGFwZXMudXVpZCk7XG4gIH1cblxuICBkYXRhLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuZXh0cnVkZVBhdGggIT09IHVuZGVmaW5lZCkgZGF0YS5vcHRpb25zLmV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aC50b0pTT04oKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbnZhciBJY29zYWhlZHJvbkdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUG9seWhlZHJvbkdlb21ldHJ5Mikge1xuICBfaW5oZXJpdHMoSWNvc2FoZWRyb25HZW9tZXRyeSwgX1BvbHloZWRyb25HZW9tZXRyeTIpO1xuXG4gIHZhciBfc3VwZXI4MCA9IF9jcmVhdGVTdXBlcihJY29zYWhlZHJvbkdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBJY29zYWhlZHJvbkdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczcxO1xuXG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICB2YXIgZGV0YWlsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEljb3NhaGVkcm9uR2VvbWV0cnkpO1xuXG4gICAgdmFyIHQgPSAoMSArIE1hdGguc3FydCg1KSkgLyAyO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFstMSwgdCwgMCwgMSwgdCwgMCwgLTEsIC10LCAwLCAxLCAtdCwgMCwgMCwgLTEsIHQsIDAsIDEsIHQsIDAsIC0xLCAtdCwgMCwgMSwgLXQsIHQsIDAsIC0xLCB0LCAwLCAxLCAtdCwgMCwgLTEsIC10LCAwLCAxXTtcbiAgICB2YXIgaW5kaWNlcyA9IFswLCAxMSwgNSwgMCwgNSwgMSwgMCwgMSwgNywgMCwgNywgMTAsIDAsIDEwLCAxMSwgMSwgNSwgOSwgNSwgMTEsIDQsIDExLCAxMCwgMiwgMTAsIDcsIDYsIDcsIDEsIDgsIDMsIDksIDQsIDMsIDQsIDIsIDMsIDIsIDYsIDMsIDYsIDgsIDMsIDgsIDksIDQsIDksIDUsIDIsIDQsIDExLCA2LCAyLCAxMCwgOCwgNiwgNywgOSwgOCwgMV07XG4gICAgX3RoaXM3MSA9IF9zdXBlcjgwLmNhbGwodGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcbiAgICBfdGhpczcxLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG4gICAgX3RoaXM3MS5wYXJhbWV0ZXJzID0ge1xuICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICBkZXRhaWw6IGRldGFpbFxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzNzE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSWNvc2FoZWRyb25HZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBJY29zYWhlZHJvbkdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEljb3NhaGVkcm9uR2VvbWV0cnk7XG59KFBvbHloZWRyb25HZW9tZXRyeSk7XG5cbnZhciBPY3RhaGVkcm9uR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Qb2x5aGVkcm9uR2VvbWV0cnkzKSB7XG4gIF9pbmhlcml0cyhPY3RhaGVkcm9uR2VvbWV0cnksIF9Qb2x5aGVkcm9uR2VvbWV0cnkzKTtcblxuICB2YXIgX3N1cGVyODEgPSBfY3JlYXRlU3VwZXIoT2N0YWhlZHJvbkdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBPY3RhaGVkcm9uR2VvbWV0cnkoKSB7XG4gICAgdmFyIF90aGlzNzI7XG5cbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIHZhciBkZXRhaWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2N0YWhlZHJvbkdlb21ldHJ5KTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IFsxLCAwLCAwLCAtMSwgMCwgMCwgMCwgMSwgMCwgMCwgLTEsIDAsIDAsIDAsIDEsIDAsIDAsIC0xXTtcbiAgICB2YXIgaW5kaWNlcyA9IFswLCAyLCA0LCAwLCA0LCAzLCAwLCAzLCA1LCAwLCA1LCAyLCAxLCAyLCA1LCAxLCA1LCAzLCAxLCAzLCA0LCAxLCA0LCAyXTtcbiAgICBfdGhpczcyID0gX3N1cGVyODEuY2FsbCh0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwpO1xuICAgIF90aGlzNzIudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xuICAgIF90aGlzNzIucGFyYW1ldGVycyA9IHtcbiAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICB9O1xuICAgIHJldHVybiBfdGhpczcyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9jdGFoZWRyb25HZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBPY3RhaGVkcm9uR2VvbWV0cnkoZGF0YS5yYWRpdXMsIGRhdGEuZGV0YWlsKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2N0YWhlZHJvbkdlb21ldHJ5O1xufShQb2x5aGVkcm9uR2VvbWV0cnkpO1xuXG52YXIgUmluZ0dlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyR2VvbWV0cnk5KSB7XG4gIF9pbmhlcml0cyhSaW5nR2VvbWV0cnksIF9CdWZmZXJHZW9tZXRyeTkpO1xuXG4gIHZhciBfc3VwZXI4MiA9IF9jcmVhdGVTdXBlcihSaW5nR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIFJpbmdHZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXM3MztcblxuICAgIHZhciBpbm5lclJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMC41O1xuICAgIHZhciBvdXRlclJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcbiAgICB2YXIgdGhldGFTZWdtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogODtcbiAgICB2YXIgcGhpU2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG4gICAgdmFyIHRoZXRhU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgdmFyIHRoZXRhTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBNYXRoLlBJICogMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSaW5nR2VvbWV0cnkpO1xuXG4gICAgX3RoaXM3MyA9IF9zdXBlcjgyLmNhbGwodGhpcyk7XG4gICAgX3RoaXM3My50eXBlID0gJ1JpbmdHZW9tZXRyeSc7XG4gICAgX3RoaXM3My5wYXJhbWV0ZXJzID0ge1xuICAgICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgICAgdGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcbiAgICAgIHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcbiAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuICAgIHRoZXRhU2VnbWVudHMgPSBNYXRoLm1heCgzLCB0aGV0YVNlZ21lbnRzKTtcbiAgICBwaGlTZWdtZW50cyA9IE1hdGgubWF4KDEsIHBoaVNlZ21lbnRzKTsgLy8gYnVmZmVyc1xuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgIHZhciB1dnMgPSBbXTsgLy8gc29tZSBoZWxwZXIgdmFyaWFibGVzXG5cbiAgICB2YXIgcmFkaXVzID0gaW5uZXJSYWRpdXM7XG4gICAgdmFyIHJhZGl1c1N0ZXAgPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBwaGlTZWdtZW50cztcbiAgICB2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgdXYgPSBuZXcgVmVjdG9yMigpOyAvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBwaGlTZWdtZW50czsgaisrKSB7XG4gICAgICBmb3IgKHZhciBfaTIzOCA9IDA7IF9pMjM4IDw9IHRoZXRhU2VnbWVudHM7IF9pMjM4KyspIHtcbiAgICAgICAgLy8gdmFsdWVzIGFyZSBnZW5lcmF0ZSBmcm9tIHRoZSBpbnNpZGUgb2YgdGhlIHJpbmcgdG8gdGhlIG91dHNpZGVcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgX2kyMzggLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7IC8vIHZlcnRleFxuXG4gICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3Moc2VnbWVudCk7XG4gICAgICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oc2VnbWVudCk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbFxuXG4gICAgICAgIG5vcm1hbHMucHVzaCgwLCAwLCAxKTsgLy8gdXZcblxuICAgICAgICB1di54ID0gKHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxKSAvIDI7XG4gICAgICAgIHV2LnkgPSAodmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEpIC8gMjtcbiAgICAgICAgdXZzLnB1c2godXYueCwgdXYueSk7XG4gICAgICB9IC8vIGluY3JlYXNlIHRoZSByYWRpdXMgZm9yIG5leHQgcm93IG9mIHZlcnRpY2VzXG5cblxuICAgICAgcmFkaXVzICs9IHJhZGl1c1N0ZXA7XG4gICAgfSAvLyBpbmRpY2VzXG5cblxuICAgIGZvciAodmFyIF9qMTAgPSAwOyBfajEwIDwgcGhpU2VnbWVudHM7IF9qMTArKykge1xuICAgICAgdmFyIHRoZXRhU2VnbWVudExldmVsID0gX2oxMCAqICh0aGV0YVNlZ21lbnRzICsgMSk7XG5cbiAgICAgIGZvciAodmFyIF9pMjM5ID0gMDsgX2kyMzkgPCB0aGV0YVNlZ21lbnRzOyBfaTIzOSsrKSB7XG4gICAgICAgIHZhciBfc2VnbWVudCA9IF9pMjM5ICsgdGhldGFTZWdtZW50TGV2ZWw7XG5cbiAgICAgICAgdmFyIGEgPSBfc2VnbWVudDtcbiAgICAgICAgdmFyIGIgPSBfc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xuICAgICAgICB2YXIgYyA9IF9zZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG4gICAgICAgIHZhciBkID0gX3NlZ21lbnQgKyAxOyAvLyBmYWNlc1xuXG4gICAgICAgIGluZGljZXMucHVzaChhLCBiLCBkKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuICAgICAgfVxuICAgIH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG4gICAgX3RoaXM3My5zZXRJbmRleChpbmRpY2VzKTtcblxuICAgIF90aGlzNzMuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cbiAgICBfdGhpczczLnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXG4gICAgX3RoaXM3My5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cbiAgICByZXR1cm4gX3RoaXM3MztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSaW5nR2VvbWV0cnksIG51bGwsIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgUmluZ0dlb21ldHJ5KGRhdGEuaW5uZXJSYWRpdXMsIGRhdGEub3V0ZXJSYWRpdXMsIGRhdGEudGhldGFTZWdtZW50cywgZGF0YS5waGlTZWdtZW50cywgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmluZ0dlb21ldHJ5O1xufShCdWZmZXJHZW9tZXRyeSk7XG5cbnZhciBTaGFwZUdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyR2VvbWV0cnkxMCkge1xuICBfaW5oZXJpdHMoU2hhcGVHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5MTApO1xuXG4gIHZhciBfc3VwZXI4MyA9IF9jcmVhdGVTdXBlcihTaGFwZUdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBTaGFwZUdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczc0O1xuXG4gICAgdmFyIHNoYXBlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFNoYXBlKFtuZXcgVmVjdG9yMigwLCAwLjUpLCBuZXcgVmVjdG9yMigtMC41LCAtMC41KSwgbmV3IFZlY3RvcjIoMC41LCAtMC41KV0pO1xuICAgIHZhciBjdXJ2ZVNlZ21lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGFwZUdlb21ldHJ5KTtcblxuICAgIF90aGlzNzQgPSBfc3VwZXI4My5jYWxsKHRoaXMpO1xuICAgIF90aGlzNzQudHlwZSA9ICdTaGFwZUdlb21ldHJ5JztcbiAgICBfdGhpczc0LnBhcmFtZXRlcnMgPSB7XG4gICAgICBzaGFwZXM6IHNoYXBlcyxcbiAgICAgIGN1cnZlU2VnbWVudHM6IGN1cnZlU2VnbWVudHNcbiAgICB9OyAvLyBidWZmZXJzXG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBub3JtYWxzID0gW107XG4gICAgdmFyIHV2cyA9IFtdOyAvLyBoZWxwZXIgdmFyaWFibGVzXG5cbiAgICB2YXIgZ3JvdXBTdGFydCA9IDA7XG4gICAgdmFyIGdyb3VwQ291bnQgPSAwOyAvLyBhbGxvdyBzaW5nbGUgYW5kIGFycmF5IHZhbHVlcyBmb3IgXCJzaGFwZXNcIiBwYXJhbWV0ZXJcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNoYXBlcykgPT09IGZhbHNlKSB7XG4gICAgICBhZGRTaGFwZShzaGFwZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBfaTI0MCA9IDA7IF9pMjQwIDwgc2hhcGVzLmxlbmd0aDsgX2kyNDArKykge1xuICAgICAgICBhZGRTaGFwZShzaGFwZXNbX2kyNDBdKTtcblxuICAgICAgICBfdGhpczc0LmFkZEdyb3VwKGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIF9pMjQwKTsgLy8gZW5hYmxlcyBNdWx0aU1hdGVyaWFsIHN1cHBvcnRcblxuXG4gICAgICAgIGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcbiAgICAgICAgZ3JvdXBDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfSAvLyBidWlsZCBnZW9tZXRyeVxuXG5cbiAgICBfdGhpczc0LnNldEluZGV4KGluZGljZXMpO1xuXG4gICAgX3RoaXM3NC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcblxuICAgIF90aGlzNzQuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShub3JtYWxzLCAzKSk7XG5cbiAgICBfdGhpczc0LnNldEF0dHJpYnV0ZSgndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh1dnMsIDIpKTsgLy8gaGVscGVyIGZ1bmN0aW9uc1xuXG5cbiAgICBmdW5jdGlvbiBhZGRTaGFwZShzaGFwZSkge1xuICAgICAgdmFyIGluZGV4T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMztcbiAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKGN1cnZlU2VnbWVudHMpO1xuICAgICAgdmFyIHNoYXBlVmVydGljZXMgPSBwb2ludHMuc2hhcGU7XG4gICAgICB2YXIgc2hhcGVIb2xlcyA9IHBvaW50cy5ob2xlczsgLy8gY2hlY2sgZGlyZWN0aW9uIG9mIHZlcnRpY2VzXG5cbiAgICAgIGlmIChTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKHNoYXBlVmVydGljZXMpID09PSBmYWxzZSkge1xuICAgICAgICBzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5yZXZlcnNlKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMjQxID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBfaTI0MSA8IGw7IF9pMjQxKyspIHtcbiAgICAgICAgdmFyIHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbX2kyNDFdO1xuXG4gICAgICAgIGlmIChTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKHNoYXBlSG9sZSkgPT09IHRydWUpIHtcbiAgICAgICAgICBzaGFwZUhvbGVzW19pMjQxXSA9IHNoYXBlSG9sZS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKHNoYXBlVmVydGljZXMsIHNoYXBlSG9sZXMpOyAvLyBqb2luIHZlcnRpY2VzIG9mIGlubmVyIGFuZCBvdXRlciBwYXRocyB0byBhIHNpbmdsZSBhcnJheVxuXG4gICAgICBmb3IgKHZhciBfaTI0MiA9IDAsIF9sOCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBfaTI0MiA8IF9sODsgX2kyNDIrKykge1xuICAgICAgICB2YXIgX3NoYXBlSG9sZSA9IHNoYXBlSG9sZXNbX2kyNDJdO1xuICAgICAgICBzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5jb25jYXQoX3NoYXBlSG9sZSk7XG4gICAgICB9IC8vIHZlcnRpY2VzLCBub3JtYWxzLCB1dnNcblxuXG4gICAgICBmb3IgKHZhciBfaTI0MyA9IDAsIF9sOSA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBfaTI0MyA8IF9sOTsgX2kyNDMrKykge1xuICAgICAgICB2YXIgX3ZlcnRleCA9IHNoYXBlVmVydGljZXNbX2kyNDNdO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKF92ZXJ0ZXgueCwgX3ZlcnRleC55LCAwKTtcbiAgICAgICAgbm9ybWFscy5wdXNoKDAsIDAsIDEpO1xuICAgICAgICB1dnMucHVzaChfdmVydGV4LngsIF92ZXJ0ZXgueSk7IC8vIHdvcmxkIHV2c1xuICAgICAgfSAvLyBpbmNpZGVzXG5cblxuICAgICAgZm9yICh2YXIgX2kyNDQgPSAwLCBfbDEwID0gZmFjZXMubGVuZ3RoOyBfaTI0NCA8IF9sMTA7IF9pMjQ0KyspIHtcbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tfaTI0NF07XG4gICAgICAgIHZhciBhID0gZmFjZVswXSArIGluZGV4T2Zmc2V0O1xuICAgICAgICB2YXIgYiA9IGZhY2VbMV0gKyBpbmRleE9mZnNldDtcbiAgICAgICAgdmFyIGMgPSBmYWNlWzJdICsgaW5kZXhPZmZzZXQ7XG4gICAgICAgIGluZGljZXMucHVzaChhLCBiLCBjKTtcbiAgICAgICAgZ3JvdXBDb3VudCArPSAzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdGhpczc0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNoYXBlR2VvbWV0cnksIFt7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKFNoYXBlR2VvbWV0cnkucHJvdG90eXBlKSwgXCJ0b0pTT05cIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdmFyIHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XG4gICAgICByZXR1cm4gX3RvSlNPTihzaGFwZXMsIGRhdGEpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGRhdGEsIHNoYXBlcykge1xuICAgICAgdmFyIGdlb21ldHJ5U2hhcGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGRhdGEuc2hhcGVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2RhdGEuc2hhcGVzW2pdXTtcbiAgICAgICAgZ2VvbWV0cnlTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU2hhcGVHZW9tZXRyeShnZW9tZXRyeVNoYXBlcywgZGF0YS5jdXJ2ZVNlZ21lbnRzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hhcGVHZW9tZXRyeTtcbn0oQnVmZmVyR2VvbWV0cnkpO1xuXG5mdW5jdGlvbiBfdG9KU09OKHNoYXBlcywgZGF0YSkge1xuICBkYXRhLnNoYXBlcyA9IFtdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHNoYXBlcykpIHtcbiAgICBmb3IgKHZhciBfaTI0NSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBfaTI0NSA8IGw7IF9pMjQ1KyspIHtcbiAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tfaTI0NV07XG4gICAgICBkYXRhLnNoYXBlcy5wdXNoKHNoYXBlLnV1aWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkYXRhLnNoYXBlcy5wdXNoKHNoYXBlcy51dWlkKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG52YXIgU3BoZXJlR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CdWZmZXJHZW9tZXRyeTExKSB7XG4gIF9pbmhlcml0cyhTcGhlcmVHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5MTEpO1xuXG4gIHZhciBfc3VwZXI4NCA9IF9jcmVhdGVTdXBlcihTcGhlcmVHZW9tZXRyeSk7XG5cbiAgZnVuY3Rpb24gU3BoZXJlR2VvbWV0cnkoKSB7XG4gICAgdmFyIF90aGlzNzU7XG5cbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIHZhciB3aWR0aFNlZ21lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAzMjtcbiAgICB2YXIgaGVpZ2h0U2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE2O1xuICAgIHZhciBwaGlTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcbiAgICB2YXIgcGhpTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBNYXRoLlBJICogMjtcbiAgICB2YXIgdGhldGFTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgICB2YXIgdGhldGFMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IE1hdGguUEk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BoZXJlR2VvbWV0cnkpO1xuXG4gICAgX3RoaXM3NSA9IF9zdXBlcjg0LmNhbGwodGhpcyk7XG4gICAgX3RoaXM3NS50eXBlID0gJ1NwaGVyZUdlb21ldHJ5JztcbiAgICBfdGhpczc1LnBhcmFtZXRlcnMgPSB7XG4gICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgICBwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgICBwaGlMZW5ndGg6IHBoaUxlbmd0aCxcbiAgICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgICB0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICB9O1xuICAgIHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCgzLCBNYXRoLmZsb29yKHdpZHRoU2VnbWVudHMpKTtcbiAgICBoZWlnaHRTZWdtZW50cyA9IE1hdGgubWF4KDIsIE1hdGguZmxvb3IoaGVpZ2h0U2VnbWVudHMpKTtcbiAgICB2YXIgdGhldGFFbmQgPSBNYXRoLm1pbih0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGgsIE1hdGguUEkpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGdyaWQgPSBbXTtcbiAgICB2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTsgLy8gYnVmZmVyc1xuXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgbm9ybWFscyA9IFtdO1xuICAgIHZhciB1dnMgPSBbXTsgLy8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgZm9yICh2YXIgaXkgPSAwOyBpeSA8PSBoZWlnaHRTZWdtZW50czsgaXkrKykge1xuICAgICAgdmFyIHZlcnRpY2VzUm93ID0gW107XG4gICAgICB2YXIgdiA9IGl5IC8gaGVpZ2h0U2VnbWVudHM7IC8vIHNwZWNpYWwgY2FzZSBmb3IgdGhlIHBvbGVzXG5cbiAgICAgIHZhciB1T2Zmc2V0ID0gMDtcblxuICAgICAgaWYgKGl5ID09IDAgJiYgdGhldGFTdGFydCA9PSAwKSB7XG4gICAgICAgIHVPZmZzZXQgPSAwLjUgLyB3aWR0aFNlZ21lbnRzO1xuICAgICAgfSBlbHNlIGlmIChpeSA9PSBoZWlnaHRTZWdtZW50cyAmJiB0aGV0YUVuZCA9PSBNYXRoLlBJKSB7XG4gICAgICAgIHVPZmZzZXQgPSAtMC41IC8gd2lkdGhTZWdtZW50cztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaXggPSAwOyBpeCA8PSB3aWR0aFNlZ21lbnRzOyBpeCsrKSB7XG4gICAgICAgIHZhciB1ID0gaXggLyB3aWR0aFNlZ21lbnRzOyAvLyB2ZXJ0ZXhcblxuICAgICAgICB2ZXJ0ZXgueCA9IC1yYWRpdXMgKiBNYXRoLmNvcyhwaGlTdGFydCArIHUgKiBwaGlMZW5ndGgpICogTWF0aC5zaW4odGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCk7XG4gICAgICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5jb3ModGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCk7XG4gICAgICAgIHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5zaW4ocGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoKSAqIE1hdGguc2luKHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGgpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyBub3JtYWxcblxuICAgICAgICBub3JtYWwuY29weSh2ZXJ0ZXgpLm5vcm1hbGl6ZSgpO1xuICAgICAgICBub3JtYWxzLnB1c2gobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueik7IC8vIHV2XG5cbiAgICAgICAgdXZzLnB1c2godSArIHVPZmZzZXQsIDEgLSB2KTtcbiAgICAgICAgdmVydGljZXNSb3cucHVzaChpbmRleCsrKTtcbiAgICAgIH1cblxuICAgICAgZ3JpZC5wdXNoKHZlcnRpY2VzUm93KTtcbiAgICB9IC8vIGluZGljZXNcblxuXG4gICAgZm9yICh2YXIgX2l5MyA9IDA7IF9peTMgPCBoZWlnaHRTZWdtZW50czsgX2l5MysrKSB7XG4gICAgICBmb3IgKHZhciBfaXgzID0gMDsgX2l4MyA8IHdpZHRoU2VnbWVudHM7IF9peDMrKykge1xuICAgICAgICB2YXIgYSA9IGdyaWRbX2l5M11bX2l4MyArIDFdO1xuICAgICAgICB2YXIgYiA9IGdyaWRbX2l5M11bX2l4M107XG4gICAgICAgIHZhciBjID0gZ3JpZFtfaXkzICsgMV1bX2l4M107XG4gICAgICAgIHZhciBkID0gZ3JpZFtfaXkzICsgMV1bX2l4MyArIDFdO1xuICAgICAgICBpZiAoX2l5MyAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCkgaW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuICAgICAgICBpZiAoX2l5MyAhPT0gaGVpZ2h0U2VnbWVudHMgLSAxIHx8IHRoZXRhRW5kIDwgTWF0aC5QSSkgaW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuICAgICAgfVxuICAgIH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG4gICAgX3RoaXM3NS5zZXRJbmRleChpbmRpY2VzKTtcblxuICAgIF90aGlzNzUuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cbiAgICBfdGhpczc1LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXG4gICAgX3RoaXM3NS5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cbiAgICByZXR1cm4gX3RoaXM3NTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTcGhlcmVHZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBTcGhlcmVHZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS53aWR0aFNlZ21lbnRzLCBkYXRhLmhlaWdodFNlZ21lbnRzLCBkYXRhLnBoaVN0YXJ0LCBkYXRhLnBoaUxlbmd0aCwgZGF0YS50aGV0YVN0YXJ0LCBkYXRhLnRoZXRhTGVuZ3RoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BoZXJlR2VvbWV0cnk7XG59KEJ1ZmZlckdlb21ldHJ5KTtcblxudmFyIFRldHJhaGVkcm9uR2VvbWV0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Qb2x5aGVkcm9uR2VvbWV0cnk0KSB7XG4gIF9pbmhlcml0cyhUZXRyYWhlZHJvbkdlb21ldHJ5LCBfUG9seWhlZHJvbkdlb21ldHJ5NCk7XG5cbiAgdmFyIF9zdXBlcjg1ID0gX2NyZWF0ZVN1cGVyKFRldHJhaGVkcm9uR2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIFRldHJhaGVkcm9uR2VvbWV0cnkoKSB7XG4gICAgdmFyIF90aGlzNzY7XG5cbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIHZhciBkZXRhaWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV0cmFoZWRyb25HZW9tZXRyeSk7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSwgMSwgLTEsIDEsIC0xLCAtMV07XG4gICAgdmFyIGluZGljZXMgPSBbMiwgMSwgMCwgMCwgMywgMiwgMSwgMywgMCwgMiwgMywgMV07XG4gICAgX3RoaXM3NiA9IF9zdXBlcjg1LmNhbGwodGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsKTtcbiAgICBfdGhpczc2LnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG4gICAgX3RoaXM3Ni5wYXJhbWV0ZXJzID0ge1xuICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICBkZXRhaWw6IGRldGFpbFxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzNzY7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV0cmFoZWRyb25HZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXRyYWhlZHJvbkdlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLmRldGFpbCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRldHJhaGVkcm9uR2VvbWV0cnk7XG59KFBvbHloZWRyb25HZW9tZXRyeSk7XG5cbnZhciBUb3J1c0dlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyR2VvbWV0cnkxMikge1xuICBfaW5oZXJpdHMoVG9ydXNHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5MTIpO1xuXG4gIHZhciBfc3VwZXI4NiA9IF9jcmVhdGVTdXBlcihUb3J1c0dlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBUb3J1c0dlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczc3O1xuXG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICB2YXIgdHViZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMC40O1xuICAgIHZhciByYWRpYWxTZWdtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogODtcbiAgICB2YXIgdHVidWxhclNlZ21lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiA2O1xuICAgIHZhciBhcmMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IE1hdGguUEkgKiAyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvcnVzR2VvbWV0cnkpO1xuXG4gICAgX3RoaXM3NyA9IF9zdXBlcjg2LmNhbGwodGhpcyk7XG4gICAgX3RoaXM3Ny50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xuICAgIF90aGlzNzcucGFyYW1ldGVycyA9IHtcbiAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgdHViZTogdHViZSxcbiAgICAgIHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICAgIHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuICAgICAgYXJjOiBhcmNcbiAgICB9O1xuICAgIHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vcihyYWRpYWxTZWdtZW50cyk7XG4gICAgdHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vcih0dWJ1bGFyU2VnbWVudHMpOyAvLyBidWZmZXJzXG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBub3JtYWxzID0gW107XG4gICAgdmFyIHV2cyA9IFtdOyAvLyBoZWxwZXIgdmFyaWFibGVzXG5cbiAgICB2YXIgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTsgLy8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGorKykge1xuICAgICAgZm9yICh2YXIgX2kyNDYgPSAwOyBfaTI0NiA8PSB0dWJ1bGFyU2VnbWVudHM7IF9pMjQ2KyspIHtcbiAgICAgICAgdmFyIHUgPSBfaTI0NiAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcbiAgICAgICAgdmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjsgLy8gdmVydGV4XG5cbiAgICAgICAgdmVydGV4LnggPSAocmFkaXVzICsgdHViZSAqIE1hdGguY29zKHYpKSAqIE1hdGguY29zKHUpO1xuICAgICAgICB2ZXJ0ZXgueSA9IChyYWRpdXMgKyB0dWJlICogTWF0aC5jb3ModikpICogTWF0aC5zaW4odSk7XG4gICAgICAgIHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKHYpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnopOyAvLyBub3JtYWxcblxuICAgICAgICBjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKHUpO1xuICAgICAgICBjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKHUpO1xuICAgICAgICBub3JtYWwuc3ViVmVjdG9ycyh2ZXJ0ZXgsIGNlbnRlcikubm9ybWFsaXplKCk7XG4gICAgICAgIG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTsgLy8gdXZcblxuICAgICAgICB1dnMucHVzaChfaTI0NiAvIHR1YnVsYXJTZWdtZW50cyk7XG4gICAgICAgIHV2cy5wdXNoKGogLyByYWRpYWxTZWdtZW50cyk7XG4gICAgICB9XG4gICAgfSAvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cblxuICAgIGZvciAodmFyIF9qMTEgPSAxOyBfajExIDw9IHJhZGlhbFNlZ21lbnRzOyBfajExKyspIHtcbiAgICAgIGZvciAodmFyIF9pMjQ3ID0gMTsgX2kyNDcgPD0gdHVidWxhclNlZ21lbnRzOyBfaTI0NysrKSB7XG4gICAgICAgIC8vIGluZGljZXNcbiAgICAgICAgdmFyIGEgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBfajExICsgX2kyNDcgLSAxO1xuICAgICAgICB2YXIgYiA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIChfajExIC0gMSkgKyBfaTI0NyAtIDE7XG4gICAgICAgIHZhciBjID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogKF9qMTEgLSAxKSArIF9pMjQ3O1xuICAgICAgICB2YXIgZCA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIF9qMTEgKyBfaTI0NzsgLy8gZmFjZXNcblxuICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG4gICAgICAgIGluZGljZXMucHVzaChiLCBjLCBkKTtcbiAgICAgIH1cbiAgICB9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuICAgIF90aGlzNzcuc2V0SW5kZXgoaW5kaWNlcyk7XG5cbiAgICBfdGhpczc3LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXG4gICAgX3RoaXM3Ny5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblxuICAgIF90aGlzNzcuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpO1xuXG4gICAgcmV0dXJuIF90aGlzNzc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVG9ydXNHZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBUb3J1c0dlb21ldHJ5KGRhdGEucmFkaXVzLCBkYXRhLnR1YmUsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEudHVidWxhclNlZ21lbnRzLCBkYXRhLmFyYyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvcnVzR2VvbWV0cnk7XG59KEJ1ZmZlckdlb21ldHJ5KTtcblxudmFyIFRvcnVzS25vdEdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyR2VvbWV0cnkxMykge1xuICBfaW5oZXJpdHMoVG9ydXNLbm90R2VvbWV0cnksIF9CdWZmZXJHZW9tZXRyeTEzKTtcblxuICB2YXIgX3N1cGVyODcgPSBfY3JlYXRlU3VwZXIoVG9ydXNLbm90R2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIFRvcnVzS25vdEdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczc4O1xuXG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMTtcbiAgICB2YXIgdHViZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMC40O1xuICAgIHZhciB0dWJ1bGFyU2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDY0O1xuICAgIHZhciByYWRpYWxTZWdtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogODtcbiAgICB2YXIgcCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMjtcbiAgICB2YXIgcSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb3J1c0tub3RHZW9tZXRyeSk7XG5cbiAgICBfdGhpczc4ID0gX3N1cGVyODcuY2FsbCh0aGlzKTtcbiAgICBfdGhpczc4LnR5cGUgPSAnVG9ydXNLbm90R2VvbWV0cnknO1xuICAgIF90aGlzNzgucGFyYW1ldGVycyA9IHtcbiAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgdHViZTogdHViZSxcbiAgICAgIHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgICAgcDogcCxcbiAgICAgIHE6IHFcbiAgICB9O1xuICAgIHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IodHVidWxhclNlZ21lbnRzKTtcbiAgICByYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IocmFkaWFsU2VnbWVudHMpOyAvLyBidWZmZXJzXG5cbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBub3JtYWxzID0gW107XG4gICAgdmFyIHV2cyA9IFtdOyAvLyBoZWxwZXIgdmFyaWFibGVzXG5cbiAgICB2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgUDEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHZhciBQMiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIHZhciBUID0gbmV3IFZlY3RvcjMoKTtcbiAgICB2YXIgTiA9IG5ldyBWZWN0b3IzKCk7IC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuICAgIGZvciAodmFyIF9pMjQ4ID0gMDsgX2kyNDggPD0gdHVidWxhclNlZ21lbnRzOyArK19pMjQ4KSB7XG4gICAgICAvLyB0aGUgcmFkaWFuIFwidVwiIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmUgb2YgdGhlIGN1cnJlbnQgdHVidWxhciBzZWdtZW50XG4gICAgICB2YXIgdSA9IF9pMjQ4IC8gdHVidWxhclNlZ21lbnRzICogcCAqIE1hdGguUEkgKiAyOyAvLyBub3cgd2UgY2FsY3VsYXRlIHR3byBwb2ludHMuIFAxIGlzIG91ciBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZSwgUDIgaXMgYSBsaXR0bGUgZmFydGhlciBhaGVhZC5cbiAgICAgIC8vIHRoZXNlIHBvaW50cyBhcmUgdXNlZCB0byBjcmVhdGUgYSBzcGVjaWFsIFwiY29vcmRpbmF0ZSBzcGFjZVwiLCB3aGljaCBpcyBuZWNlc3NhcnkgdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHZlcnRleCBwb3NpdGlvbnNcblxuICAgICAgY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKHUsIHAsIHEsIHJhZGl1cywgUDEpO1xuICAgICAgY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKHUgKyAwLjAxLCBwLCBxLCByYWRpdXMsIFAyKTsgLy8gY2FsY3VsYXRlIG9ydGhvbm9ybWFsIGJhc2lzXG5cbiAgICAgIFQuc3ViVmVjdG9ycyhQMiwgUDEpO1xuICAgICAgTi5hZGRWZWN0b3JzKFAyLCBQMSk7XG4gICAgICBCLmNyb3NzVmVjdG9ycyhULCBOKTtcbiAgICAgIE4uY3Jvc3NWZWN0b3JzKEIsIFQpOyAvLyBub3JtYWxpemUgQiwgTi4gVCBjYW4gYmUgaWdub3JlZCwgd2UgZG9uJ3QgdXNlIGl0XG5cbiAgICAgIEIubm9ybWFsaXplKCk7XG4gICAgICBOLm5vcm1hbGl6ZSgpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgKytqKSB7XG4gICAgICAgIC8vIG5vdyBjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiB0aGV5IGFyZSBub3RoaW5nIG1vcmUgdGhhbiBhbiBleHRydXNpb24gb2YgdGhlIHRvcnVzIGN1cnZlLlxuICAgICAgICAvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cbiAgICAgICAgdmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcbiAgICAgICAgdmFyIGN4ID0gLXR1YmUgKiBNYXRoLmNvcyh2KTtcbiAgICAgICAgdmFyIGN5ID0gdHViZSAqIE1hdGguc2luKHYpOyAvLyBub3cgY2FsY3VsYXRlIHRoZSBmaW5hbCB2ZXJ0ZXggcG9zaXRpb24uXG4gICAgICAgIC8vIGZpcnN0IHdlIG9yaWVudCB0aGUgZXh0cnVzaW9uIHdpdGggb3VyIGJhc2lzIHZlY3RvcnMsIHRoZW4gd2UgYWRkIGl0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBjdXJ2ZVxuXG4gICAgICAgIHZlcnRleC54ID0gUDEueCArIChjeCAqIE4ueCArIGN5ICogQi54KTtcbiAgICAgICAgdmVydGV4LnkgPSBQMS55ICsgKGN4ICogTi55ICsgY3kgKiBCLnkpO1xuICAgICAgICB2ZXJ0ZXgueiA9IFAxLnogKyAoY3ggKiBOLnogKyBjeSAqIEIueik7XG4gICAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueik7IC8vIG5vcm1hbCAoUDEgaXMgYWx3YXlzIHRoZSBjZW50ZXIvb3JpZ2luIG9mIHRoZSBleHRydXNpb24sIHRodXMgd2UgY2FuIHVzZSBpdCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbClcblxuICAgICAgICBub3JtYWwuc3ViVmVjdG9ycyh2ZXJ0ZXgsIFAxKS5ub3JtYWxpemUoKTtcbiAgICAgICAgbm9ybWFscy5wdXNoKG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnopOyAvLyB1dlxuXG4gICAgICAgIHV2cy5wdXNoKF9pMjQ4IC8gdHVidWxhclNlZ21lbnRzKTtcbiAgICAgICAgdXZzLnB1c2goaiAvIHJhZGlhbFNlZ21lbnRzKTtcbiAgICAgIH1cbiAgICB9IC8vIGdlbmVyYXRlIGluZGljZXNcblxuXG4gICAgZm9yICh2YXIgX2oxMiA9IDE7IF9qMTIgPD0gdHVidWxhclNlZ21lbnRzOyBfajEyKyspIHtcbiAgICAgIGZvciAodmFyIF9pMjQ5ID0gMTsgX2kyNDkgPD0gcmFkaWFsU2VnbWVudHM7IF9pMjQ5KyspIHtcbiAgICAgICAgLy8gaW5kaWNlc1xuICAgICAgICB2YXIgYSA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKF9qMTIgLSAxKSArIChfaTI0OSAtIDEpO1xuICAgICAgICB2YXIgYiA9IChyYWRpYWxTZWdtZW50cyArIDEpICogX2oxMiArIChfaTI0OSAtIDEpO1xuICAgICAgICB2YXIgYyA9IChyYWRpYWxTZWdtZW50cyArIDEpICogX2oxMiArIF9pMjQ5O1xuICAgICAgICB2YXIgZCA9IChyYWRpYWxTZWdtZW50cyArIDEpICogKF9qMTIgLSAxKSArIF9pMjQ5OyAvLyBmYWNlc1xuXG4gICAgICAgIGluZGljZXMucHVzaChhLCBiLCBkKTtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuICAgICAgfVxuICAgIH0gLy8gYnVpbGQgZ2VvbWV0cnlcblxuXG4gICAgX3RoaXM3OC5zZXRJbmRleChpbmRpY2VzKTtcblxuICAgIF90aGlzNzguc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG5cbiAgICBfdGhpczc4LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobm9ybWFscywgMykpO1xuXG4gICAgX3RoaXM3OC5zZXRBdHRyaWJ1dGUoJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7IC8vIHRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgdG9ydXMgY3VydmVcblxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKHUsIHAsIHEsIHJhZGl1cywgcG9zaXRpb24pIHtcbiAgICAgIHZhciBjdSA9IE1hdGguY29zKHUpO1xuICAgICAgdmFyIHN1ID0gTWF0aC5zaW4odSk7XG4gICAgICB2YXIgcXVPdmVyUCA9IHEgLyBwICogdTtcbiAgICAgIHZhciBjcyA9IE1hdGguY29zKHF1T3ZlclApO1xuICAgICAgcG9zaXRpb24ueCA9IHJhZGl1cyAqICgyICsgY3MpICogMC41ICogY3U7XG4gICAgICBwb3NpdGlvbi55ID0gcmFkaXVzICogKDIgKyBjcykgKiBzdSAqIDAuNTtcbiAgICAgIHBvc2l0aW9uLnogPSByYWRpdXMgKiBNYXRoLnNpbihxdU92ZXJQKSAqIDAuNTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM3ODtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUb3J1c0tub3RHZW9tZXRyeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBUb3J1c0tub3RHZW9tZXRyeShkYXRhLnJhZGl1cywgZGF0YS50dWJlLCBkYXRhLnR1YnVsYXJTZWdtZW50cywgZGF0YS5yYWRpYWxTZWdtZW50cywgZGF0YS5wLCBkYXRhLnEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUb3J1c0tub3RHZW9tZXRyeTtcbn0oQnVmZmVyR2VvbWV0cnkpO1xuXG52YXIgVHViZUdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyR2VvbWV0cnkxNCkge1xuICBfaW5oZXJpdHMoVHViZUdlb21ldHJ5LCBfQnVmZmVyR2VvbWV0cnkxNCk7XG5cbiAgdmFyIF9zdXBlcjg4ID0gX2NyZWF0ZVN1cGVyKFR1YmVHZW9tZXRyeSk7XG5cbiAgZnVuY3Rpb24gVHViZUdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpczc5O1xuXG4gICAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZTMobmV3IFZlY3RvcjMoLTEsIC0xLCAwKSwgbmV3IFZlY3RvcjMoLTEsIDEsIDApLCBuZXcgVmVjdG9yMygxLCAxLCAwKSk7XG4gICAgdmFyIHR1YnVsYXJTZWdtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogNjQ7XG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICB2YXIgcmFkaWFsU2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDg7XG4gICAgdmFyIGNsb3NlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHViZUdlb21ldHJ5KTtcblxuICAgIF90aGlzNzkgPSBfc3VwZXI4OC5jYWxsKHRoaXMpO1xuICAgIF90aGlzNzkudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuICAgIF90aGlzNzkucGFyYW1ldGVycyA9IHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcbiAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgICAgY2xvc2VkOiBjbG9zZWRcbiAgICB9O1xuICAgIHZhciBmcmFtZXMgPSBwYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXModHVidWxhclNlZ21lbnRzLCBjbG9zZWQpOyAvLyBleHBvc2UgaW50ZXJuYWxzXG5cbiAgICBfdGhpczc5LnRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzO1xuICAgIF90aGlzNzkubm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzO1xuICAgIF90aGlzNzkuYmlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFsczsgLy8gaGVscGVyIHZhcmlhYmxlc1xuXG4gICAgdmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcbiAgICB2YXIgUCA9IG5ldyBWZWN0b3IzKCk7IC8vIGJ1ZmZlclxuXG4gICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgICB2YXIgdXZzID0gW107XG4gICAgdmFyIGluZGljZXMgPSBbXTsgLy8gY3JlYXRlIGJ1ZmZlciBkYXRhXG5cbiAgICBnZW5lcmF0ZUJ1ZmZlckRhdGEoKTsgLy8gYnVpbGQgZ2VvbWV0cnlcblxuICAgIF90aGlzNzkuc2V0SW5kZXgoaW5kaWNlcyk7XG5cbiAgICBfdGhpczc5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuXG4gICAgX3RoaXM3OS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG5vcm1hbHMsIDMpKTtcblxuICAgIF90aGlzNzkuc2V0QXR0cmlidXRlKCd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHV2cywgMikpOyAvLyBmdW5jdGlvbnNcblxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVCdWZmZXJEYXRhKCkge1xuICAgICAgZm9yICh2YXIgX2kyNTAgPSAwOyBfaTI1MCA8IHR1YnVsYXJTZWdtZW50czsgX2kyNTArKykge1xuICAgICAgICBnZW5lcmF0ZVNlZ21lbnQoX2kyNTApO1xuICAgICAgfSAvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgbm90IGNsb3NlZCwgZ2VuZXJhdGUgdGhlIGxhc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzXG4gICAgICAvLyBhdCB0aGUgcmVndWxhciBwb3NpdGlvbiBvbiB0aGUgZ2l2ZW4gcGF0aFxuICAgICAgLy9cbiAgICAgIC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIGR1cGxpY2F0ZSB0aGUgZmlyc3Qgcm93IG9mIHZlcnRpY2VzIGFuZCBub3JtYWxzICh1dnMgd2lsbCBkaWZmZXIpXG5cblxuICAgICAgZ2VuZXJhdGVTZWdtZW50KGNsb3NlZCA9PT0gZmFsc2UgPyB0dWJ1bGFyU2VnbWVudHMgOiAwKTsgLy8gdXZzIGFyZSBnZW5lcmF0ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cbiAgICAgIC8vIHRoaXMgbWFrZXMgaXQgZWFzeSBjb21wdXRlIGNvcnJlY3QgdmFsdWVzIGZvciBjbG9zZWQgZ2VvbWV0cmllc1xuXG4gICAgICBnZW5lcmF0ZVVWcygpOyAvLyBmaW5hbGx5IGNyZWF0ZSBmYWNlc1xuXG4gICAgICBnZW5lcmF0ZUluZGljZXMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnQoaSkge1xuICAgICAgLy8gd2UgdXNlIGdldFBvaW50QXQgdG8gc2FtcGxlIGV2ZW5seSBkaXN0cmlidXRlZCBwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gcGF0aFxuICAgICAgUCA9IHBhdGguZ2V0UG9pbnRBdChpIC8gdHVidWxhclNlZ21lbnRzLCBQKTsgLy8gcmV0cmlldmUgY29ycmVzcG9uZGluZyBub3JtYWwgYW5kIGJpbm9ybWFsXG5cbiAgICAgIHZhciBOID0gZnJhbWVzLm5vcm1hbHNbaV07XG4gICAgICB2YXIgQiA9IGZyYW1lcy5iaW5vcm1hbHNbaV07IC8vIGdlbmVyYXRlIG5vcm1hbHMgYW5kIHZlcnRpY2VzIGZvciB0aGUgY3VycmVudCBzZWdtZW50XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHtcbiAgICAgICAgdmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHYpO1xuICAgICAgICB2YXIgY29zID0gLU1hdGguY29zKHYpOyAvLyBub3JtYWxcblxuICAgICAgICBub3JtYWwueCA9IGNvcyAqIE4ueCArIHNpbiAqIEIueDtcbiAgICAgICAgbm9ybWFsLnkgPSBjb3MgKiBOLnkgKyBzaW4gKiBCLnk7XG4gICAgICAgIG5vcm1hbC56ID0gY29zICogTi56ICsgc2luICogQi56O1xuICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgIG5vcm1hbHMucHVzaChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56KTsgLy8gdmVydGV4XG5cbiAgICAgICAgdmVydGV4LnggPSBQLnggKyByYWRpdXMgKiBub3JtYWwueDtcbiAgICAgICAgdmVydGV4LnkgPSBQLnkgKyByYWRpdXMgKiBub3JtYWwueTtcbiAgICAgICAgdmVydGV4LnogPSBQLnogKyByYWRpdXMgKiBub3JtYWwuejtcbiAgICAgICAgdmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUluZGljZXMoKSB7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8PSB0dWJ1bGFyU2VnbWVudHM7IGorKykge1xuICAgICAgICBmb3IgKHZhciBfaTI1MSA9IDE7IF9pMjUxIDw9IHJhZGlhbFNlZ21lbnRzOyBfaTI1MSsrKSB7XG4gICAgICAgICAgdmFyIGEgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyAoX2kyNTEgLSAxKTtcbiAgICAgICAgICB2YXIgYiA9IChyYWRpYWxTZWdtZW50cyArIDEpICogaiArIChfaTI1MSAtIDEpO1xuICAgICAgICAgIHZhciBjID0gKHJhZGlhbFNlZ21lbnRzICsgMSkgKiBqICsgX2kyNTE7XG4gICAgICAgICAgdmFyIGQgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBfaTI1MTsgLy8gZmFjZXNcblxuICAgICAgICAgIGluZGljZXMucHVzaChhLCBiLCBkKTtcbiAgICAgICAgICBpbmRpY2VzLnB1c2goYiwgYywgZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcbiAgICAgIGZvciAodmFyIF9pMjUyID0gMDsgX2kyNTIgPD0gdHVidWxhclNlZ21lbnRzOyBfaTI1MisrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHtcbiAgICAgICAgICB1di54ID0gX2kyNTIgLyB0dWJ1bGFyU2VnbWVudHM7XG4gICAgICAgICAgdXYueSA9IGogLyByYWRpYWxTZWdtZW50cztcbiAgICAgICAgICB1dnMucHVzaCh1di54LCB1di55KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdGhpczc5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFR1YmVHZW9tZXRyeSwgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBkYXRhID0gX2dldChfZ2V0UHJvdG90eXBlT2YoVHViZUdlb21ldHJ5LnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIGRhdGEucGF0aCA9IHRoaXMucGFyYW1ldGVycy5wYXRoLnRvSlNPTigpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUpTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUpTT04oZGF0YSkge1xuICAgICAgLy8gVGhpcyBvbmx5IHdvcmtzIGZvciBidWlsdC1pbiBjdXJ2ZXMgKGUuZy4gQ2F0bXVsbFJvbUN1cnZlMykuXG4gICAgICAvLyBVc2VyIGRlZmluZWQgY3VydmVzIG9yIGluc3RhbmNlcyBvZiBDdXJ2ZVBhdGggd2lsbCBub3QgYmUgZGVzZXJpYWxpemVkLlxuICAgICAgcmV0dXJuIG5ldyBUdWJlR2VvbWV0cnkobmV3IEN1cnZlc1tkYXRhLnBhdGgudHlwZV0oKS5mcm9tSlNPTihkYXRhLnBhdGgpLCBkYXRhLnR1YnVsYXJTZWdtZW50cywgZGF0YS5yYWRpdXMsIGRhdGEucmFkaWFsU2VnbWVudHMsIGRhdGEuY2xvc2VkKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHViZUdlb21ldHJ5O1xufShCdWZmZXJHZW9tZXRyeSk7XG5cbnZhciBXaXJlZnJhbWVHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckdlb21ldHJ5MTUpIHtcbiAgX2luaGVyaXRzKFdpcmVmcmFtZUdlb21ldHJ5LCBfQnVmZmVyR2VvbWV0cnkxNSk7XG5cbiAgdmFyIF9zdXBlcjg5ID0gX2NyZWF0ZVN1cGVyKFdpcmVmcmFtZUdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBXaXJlZnJhbWVHZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXM4MDtcblxuICAgIHZhciBnZW9tZXRyeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXaXJlZnJhbWVHZW9tZXRyeSk7XG5cbiAgICBfdGhpczgwID0gX3N1cGVyODkuY2FsbCh0aGlzKTtcbiAgICBfdGhpczgwLnR5cGUgPSAnV2lyZWZyYW1lR2VvbWV0cnknO1xuICAgIF90aGlzODAucGFyYW1ldGVycyA9IHtcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeVxuICAgIH07XG5cbiAgICBpZiAoZ2VvbWV0cnkgIT09IG51bGwpIHtcbiAgICAgIC8vIGJ1ZmZlclxuICAgICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgICB2YXIgZWRnZXMgPSBuZXcgU2V0KCk7IC8vIGhlbHBlciB2YXJpYWJsZXNcblxuICAgICAgdmFyIHN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIHZhciBlbmQgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgICBpZiAoZ2VvbWV0cnkuaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgLy8gaW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4O1xuICAgICAgICB2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG4gICAgICAgIGlmIChncm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZ3JvdXBzID0gW3tcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgY291bnQ6IGluZGljZXMuY291bnQsXG4gICAgICAgICAgICBtYXRlcmlhbEluZGV4OiAwXG4gICAgICAgICAgfV07XG4gICAgICAgIH0gLy8gY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjb250YWlucyBhbGwgZWRnZXMgd2l0aG91dCBkdXBsaWNhdGVzXG5cblxuICAgICAgICBmb3IgKHZhciBvID0gMCwgb2wgPSBncm91cHMubGVuZ3RoOyBvIDwgb2w7ICsrbykge1xuICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tvXTtcbiAgICAgICAgICB2YXIgZ3JvdXBTdGFydCA9IGdyb3VwLnN0YXJ0O1xuICAgICAgICAgIHZhciBncm91cENvdW50ID0gZ3JvdXAuY291bnQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTI1MyA9IGdyb3VwU3RhcnQsIGwgPSBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudDsgX2kyNTMgPCBsOyBfaTI1MyArPSAzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICB2YXIgaW5kZXgxID0gaW5kaWNlcy5nZXRYKF9pMjUzICsgaik7XG4gICAgICAgICAgICAgIHZhciBpbmRleDIgPSBpbmRpY2VzLmdldFgoX2kyNTMgKyAoaiArIDEpICUgMyk7XG4gICAgICAgICAgICAgIHN0YXJ0LmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zaXRpb24sIGluZGV4MSk7XG4gICAgICAgICAgICAgIGVuZC5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9uLCBpbmRleDIpO1xuXG4gICAgICAgICAgICAgIGlmIChpc1VuaXF1ZUVkZ2Uoc3RhcnQsIGVuZCwgZWRnZXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaChzdGFydC54LCBzdGFydC55LCBzdGFydC56KTtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKGVuZC54LCBlbmQueSwgZW5kLnopO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuICAgICAgICB2YXIgX3Bvc2l0aW9uMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICAgICAgZm9yICh2YXIgX2kyNTQgPSAwLCBfbDExID0gX3Bvc2l0aW9uMi5jb3VudCAvIDM7IF9pMjU0IDwgX2wxMTsgX2kyNTQrKykge1xuICAgICAgICAgIGZvciAodmFyIF9qMTMgPSAwOyBfajEzIDwgMzsgX2oxMysrKSB7XG4gICAgICAgICAgICAvLyB0aHJlZSBlZGdlcyBwZXIgdHJpYW5nbGUsIGFuIGVkZ2UgaXMgcmVwcmVzZW50ZWQgYXMgKGluZGV4MSwgaW5kZXgyKVxuICAgICAgICAgICAgLy8gZS5nLiB0aGUgZmlyc3QgdHJpYW5nbGUgaGFzIHRoZSBmb2xsb3dpbmcgZWRnZXM6ICgwLDEpLCgxLDIpLCgyLDApXG4gICAgICAgICAgICB2YXIgX2luZGV4ID0gMyAqIF9pMjU0ICsgX2oxMztcblxuICAgICAgICAgICAgdmFyIF9pbmRleDIgPSAzICogX2kyNTQgKyAoX2oxMyArIDEpICUgMztcblxuICAgICAgICAgICAgc3RhcnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShfcG9zaXRpb24yLCBfaW5kZXgpO1xuICAgICAgICAgICAgZW5kLmZyb21CdWZmZXJBdHRyaWJ1dGUoX3Bvc2l0aW9uMiwgX2luZGV4Mik7XG5cbiAgICAgICAgICAgIGlmIChpc1VuaXF1ZUVkZ2Uoc3RhcnQsIGVuZCwgZWRnZXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goc3RhcnQueCwgc3RhcnQueSwgc3RhcnQueik7XG4gICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goZW5kLngsIGVuZC55LCBlbmQueik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGJ1aWxkIGdlb21ldHJ5XG5cblxuICAgICAgX3RoaXM4MC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM4MDtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoV2lyZWZyYW1lR2VvbWV0cnkpO1xufShCdWZmZXJHZW9tZXRyeSk7XG5cbmZ1bmN0aW9uIGlzVW5pcXVlRWRnZShzdGFydCwgZW5kLCBlZGdlcykge1xuICB2YXIgaGFzaDEgPSBcIlwiLmNvbmNhdChzdGFydC54LCBcIixcIikuY29uY2F0KHN0YXJ0LnksIFwiLFwiKS5jb25jYXQoc3RhcnQueiwgXCItXCIpLmNvbmNhdChlbmQueCwgXCIsXCIpLmNvbmNhdChlbmQueSwgXCIsXCIpLmNvbmNhdChlbmQueik7XG4gIHZhciBoYXNoMiA9IFwiXCIuY29uY2F0KGVuZC54LCBcIixcIikuY29uY2F0KGVuZC55LCBcIixcIikuY29uY2F0KGVuZC56LCBcIi1cIikuY29uY2F0KHN0YXJ0LngsIFwiLFwiKS5jb25jYXQoc3RhcnQueSwgXCIsXCIpLmNvbmNhdChzdGFydC56KTsgLy8gY29pbmNpZGVudCBlZGdlXG5cbiAgaWYgKGVkZ2VzLmhhcyhoYXNoMSkgPT09IHRydWUgfHwgZWRnZXMuaGFzKGhhc2gyKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlcy5hZGQoaGFzaDEpO1xuICAgIGVkZ2VzLmFkZChoYXNoMik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIEdlb21ldHJpZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQm94R2VvbWV0cnk6IEJveEdlb21ldHJ5LFxuICBCb3hCdWZmZXJHZW9tZXRyeTogQm94R2VvbWV0cnksXG4gIENhcHN1bGVHZW9tZXRyeTogQ2Fwc3VsZUdlb21ldHJ5LFxuICBDYXBzdWxlQnVmZmVyR2VvbWV0cnk6IENhcHN1bGVHZW9tZXRyeSxcbiAgQ2lyY2xlR2VvbWV0cnk6IENpcmNsZUdlb21ldHJ5LFxuICBDaXJjbGVCdWZmZXJHZW9tZXRyeTogQ2lyY2xlR2VvbWV0cnksXG4gIENvbmVHZW9tZXRyeTogQ29uZUdlb21ldHJ5LFxuICBDb25lQnVmZmVyR2VvbWV0cnk6IENvbmVHZW9tZXRyeSxcbiAgQ3lsaW5kZXJHZW9tZXRyeTogQ3lsaW5kZXJHZW9tZXRyeSxcbiAgQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeTogQ3lsaW5kZXJHZW9tZXRyeSxcbiAgRG9kZWNhaGVkcm9uR2VvbWV0cnk6IERvZGVjYWhlZHJvbkdlb21ldHJ5LFxuICBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeTogRG9kZWNhaGVkcm9uR2VvbWV0cnksXG4gIEVkZ2VzR2VvbWV0cnk6IEVkZ2VzR2VvbWV0cnksXG4gIEV4dHJ1ZGVHZW9tZXRyeTogRXh0cnVkZUdlb21ldHJ5LFxuICBFeHRydWRlQnVmZmVyR2VvbWV0cnk6IEV4dHJ1ZGVHZW9tZXRyeSxcbiAgSWNvc2FoZWRyb25HZW9tZXRyeTogSWNvc2FoZWRyb25HZW9tZXRyeSxcbiAgSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeTogSWNvc2FoZWRyb25HZW9tZXRyeSxcbiAgTGF0aGVHZW9tZXRyeTogTGF0aGVHZW9tZXRyeSxcbiAgTGF0aGVCdWZmZXJHZW9tZXRyeTogTGF0aGVHZW9tZXRyeSxcbiAgT2N0YWhlZHJvbkdlb21ldHJ5OiBPY3RhaGVkcm9uR2VvbWV0cnksXG4gIE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeTogT2N0YWhlZHJvbkdlb21ldHJ5LFxuICBQbGFuZUdlb21ldHJ5OiBQbGFuZUdlb21ldHJ5LFxuICBQbGFuZUJ1ZmZlckdlb21ldHJ5OiBQbGFuZUdlb21ldHJ5LFxuICBQb2x5aGVkcm9uR2VvbWV0cnk6IFBvbHloZWRyb25HZW9tZXRyeSxcbiAgUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBQb2x5aGVkcm9uR2VvbWV0cnksXG4gIFJpbmdHZW9tZXRyeTogUmluZ0dlb21ldHJ5LFxuICBSaW5nQnVmZmVyR2VvbWV0cnk6IFJpbmdHZW9tZXRyeSxcbiAgU2hhcGVHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcbiAgU2hhcGVCdWZmZXJHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcbiAgU3BoZXJlR2VvbWV0cnk6IFNwaGVyZUdlb21ldHJ5LFxuICBTcGhlcmVCdWZmZXJHZW9tZXRyeTogU3BoZXJlR2VvbWV0cnksXG4gIFRldHJhaGVkcm9uR2VvbWV0cnk6IFRldHJhaGVkcm9uR2VvbWV0cnksXG4gIFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IFRldHJhaGVkcm9uR2VvbWV0cnksXG4gIFRvcnVzR2VvbWV0cnk6IFRvcnVzR2VvbWV0cnksXG4gIFRvcnVzQnVmZmVyR2VvbWV0cnk6IFRvcnVzR2VvbWV0cnksXG4gIFRvcnVzS25vdEdlb21ldHJ5OiBUb3J1c0tub3RHZW9tZXRyeSxcbiAgVG9ydXNLbm90QnVmZmVyR2VvbWV0cnk6IFRvcnVzS25vdEdlb21ldHJ5LFxuICBUdWJlR2VvbWV0cnk6IFR1YmVHZW9tZXRyeSxcbiAgVHViZUJ1ZmZlckdlb21ldHJ5OiBUdWJlR2VvbWV0cnksXG4gIFdpcmVmcmFtZUdlb21ldHJ5OiBXaXJlZnJhbWVHZW9tZXRyeVxufSk7XG5cbnZhciBTaGFkb3dNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01hdGVyaWFsOCkge1xuICBfaW5oZXJpdHMoU2hhZG93TWF0ZXJpYWwsIF9NYXRlcmlhbDgpO1xuXG4gIHZhciBfc3VwZXI5MCA9IF9jcmVhdGVTdXBlcihTaGFkb3dNYXRlcmlhbCk7XG5cbiAgZnVuY3Rpb24gU2hhZG93TWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczgxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYWRvd01hdGVyaWFsKTtcblxuICAgIF90aGlzODEgPSBfc3VwZXI5MC5jYWxsKHRoaXMpO1xuICAgIF90aGlzODEuaXNTaGFkb3dNYXRlcmlhbCA9IHRydWU7XG4gICAgX3RoaXM4MS50eXBlID0gJ1NoYWRvd01hdGVyaWFsJztcbiAgICBfdGhpczgxLmNvbG9yID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcbiAgICBfdGhpczgxLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICBfdGhpczgxLmZvZyA9IHRydWU7XG5cbiAgICBfdGhpczgxLnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblxuICAgIHJldHVybiBfdGhpczgxO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNoYWRvd01hdGVyaWFsLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcbiAgICAgIHRoaXMuZm9nID0gc291cmNlLmZvZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGFkb3dNYXRlcmlhbDtcbn0oTWF0ZXJpYWwpO1xuXG52YXIgUmF3U2hhZGVyTWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFkZXJNYXRlcmlhbCkge1xuICBfaW5oZXJpdHMoUmF3U2hhZGVyTWF0ZXJpYWwsIF9TaGFkZXJNYXRlcmlhbCk7XG5cbiAgdmFyIF9zdXBlcjkxID0gX2NyZWF0ZVN1cGVyKFJhd1NoYWRlck1hdGVyaWFsKTtcblxuICBmdW5jdGlvbiBSYXdTaGFkZXJNYXRlcmlhbChwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF90aGlzODI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF3U2hhZGVyTWF0ZXJpYWwpO1xuXG4gICAgX3RoaXM4MiA9IF9zdXBlcjkxLmNhbGwodGhpcywgcGFyYW1ldGVycyk7XG4gICAgX3RoaXM4Mi5pc1Jhd1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcbiAgICBfdGhpczgyLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xuICAgIHJldHVybiBfdGhpczgyO1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSYXdTaGFkZXJNYXRlcmlhbCk7XG59KFNoYWRlck1hdGVyaWFsKTtcblxudmFyIE1lc2hTdGFuZGFyZE1hdGVyaWFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWF0ZXJpYWw5KSB7XG4gIF9pbmhlcml0cyhNZXNoU3RhbmRhcmRNYXRlcmlhbCwgX01hdGVyaWFsOSk7XG5cbiAgdmFyIF9zdXBlcjkyID0gX2NyZWF0ZVN1cGVyKE1lc2hTdGFuZGFyZE1hdGVyaWFsKTtcblxuICBmdW5jdGlvbiBNZXNoU3RhbmRhcmRNYXRlcmlhbChwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF90aGlzODM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzaFN0YW5kYXJkTWF0ZXJpYWwpO1xuXG4gICAgX3RoaXM4MyA9IF9zdXBlcjkyLmNhbGwodGhpcyk7XG4gICAgX3RoaXM4My5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID0gdHJ1ZTtcbiAgICBfdGhpczgzLmRlZmluZXMgPSB7XG4gICAgICAnU1RBTkRBUkQnOiAnJ1xuICAgIH07XG4gICAgX3RoaXM4My50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcbiAgICBfdGhpczgzLmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZGlmZnVzZVxuXG4gICAgX3RoaXM4My5yb3VnaG5lc3MgPSAxLjA7XG4gICAgX3RoaXM4My5tZXRhbG5lc3MgPSAwLjA7XG4gICAgX3RoaXM4My5tYXAgPSBudWxsO1xuICAgIF90aGlzODMubGlnaHRNYXAgPSBudWxsO1xuICAgIF90aGlzODMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG4gICAgX3RoaXM4My5hb01hcCA9IG51bGw7XG4gICAgX3RoaXM4My5hb01hcEludGVuc2l0eSA9IDEuMDtcbiAgICBfdGhpczgzLmVtaXNzaXZlID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcbiAgICBfdGhpczgzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuICAgIF90aGlzODMuZW1pc3NpdmVNYXAgPSBudWxsO1xuICAgIF90aGlzODMuYnVtcE1hcCA9IG51bGw7XG4gICAgX3RoaXM4My5idW1wU2NhbGUgPSAxO1xuICAgIF90aGlzODMubm9ybWFsTWFwID0gbnVsbDtcbiAgICBfdGhpczgzLm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG4gICAgX3RoaXM4My5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuICAgIF90aGlzODMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcbiAgICBfdGhpczgzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcbiAgICBfdGhpczgzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuICAgIF90aGlzODMucm91Z2huZXNzTWFwID0gbnVsbDtcbiAgICBfdGhpczgzLm1ldGFsbmVzc01hcCA9IG51bGw7XG4gICAgX3RoaXM4My5hbHBoYU1hcCA9IG51bGw7XG4gICAgX3RoaXM4My5lbnZNYXAgPSBudWxsO1xuICAgIF90aGlzODMuZW52TWFwSW50ZW5zaXR5ID0gMS4wO1xuICAgIF90aGlzODMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgX3RoaXM4My53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIF90aGlzODMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gICAgX3RoaXM4My53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG4gICAgX3RoaXM4My5mbGF0U2hhZGluZyA9IGZhbHNlO1xuICAgIF90aGlzODMuZm9nID0gdHJ1ZTtcblxuICAgIF90aGlzODMuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXG4gICAgcmV0dXJuIF90aGlzODM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMuZGVmaW5lcyA9IHtcbiAgICAgICAgJ1NUQU5EQVJEJzogJydcbiAgICAgIH07XG4gICAgICB0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcbiAgICAgIHRoaXMucm91Z2huZXNzID0gc291cmNlLnJvdWdobmVzcztcbiAgICAgIHRoaXMubWV0YWxuZXNzID0gc291cmNlLm1ldGFsbmVzcztcbiAgICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcbiAgICAgIHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG4gICAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuICAgICAgdGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG4gICAgICB0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcbiAgICAgIHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG4gICAgICB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuICAgICAgdGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG4gICAgICB0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG4gICAgICB0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG4gICAgICB0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcbiAgICAgIHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuICAgICAgdGhpcy5yb3VnaG5lc3NNYXAgPSBzb3VyY2Uucm91Z2huZXNzTWFwO1xuICAgICAgdGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xuICAgICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcbiAgICAgIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICAgIHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gc291cmNlLmVudk1hcEludGVuc2l0eTtcbiAgICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcbiAgICAgIHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG4gICAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG59KE1hdGVyaWFsKTtcblxudmFyIE1lc2hQaHlzaWNhbE1hdGVyaWFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWVzaFN0YW5kYXJkTWF0ZXJpYWwpIHtcbiAgX2luaGVyaXRzKE1lc2hQaHlzaWNhbE1hdGVyaWFsLCBfTWVzaFN0YW5kYXJkTWF0ZXJpYWwpO1xuXG4gIHZhciBfc3VwZXI5MyA9IF9jcmVhdGVTdXBlcihNZXNoUGh5c2ljYWxNYXRlcmlhbCk7XG5cbiAgZnVuY3Rpb24gTWVzaFBoeXNpY2FsTWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczg0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc2hQaHlzaWNhbE1hdGVyaWFsKTtcblxuICAgIF90aGlzODQgPSBfc3VwZXI5My5jYWxsKHRoaXMpO1xuICAgIF90aGlzODQuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCA9IHRydWU7XG4gICAgX3RoaXM4NC5kZWZpbmVzID0ge1xuICAgICAgJ1NUQU5EQVJEJzogJycsXG4gICAgICAnUEhZU0lDQUwnOiAnJ1xuICAgIH07XG4gICAgX3RoaXM4NC50eXBlID0gJ01lc2hQaHlzaWNhbE1hdGVyaWFsJztcbiAgICBfdGhpczg0LmNsZWFyY29hdE1hcCA9IG51bGw7XG4gICAgX3RoaXM4NC5jbGVhcmNvYXRSb3VnaG5lc3MgPSAwLjA7XG4gICAgX3RoaXM4NC5jbGVhcmNvYXRSb3VnaG5lc3NNYXAgPSBudWxsO1xuICAgIF90aGlzODQuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcbiAgICBfdGhpczg0LmNsZWFyY29hdE5vcm1hbE1hcCA9IG51bGw7XG4gICAgX3RoaXM4NC5pb3IgPSAxLjU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM4NCksICdyZWZsZWN0aXZpdHknLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wKDIuNSAqICh0aGlzLmlvciAtIDEpIC8gKHRoaXMuaW9yICsgMSksIDAsIDEpO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHJlZmxlY3Rpdml0eSkge1xuICAgICAgICB0aGlzLmlvciA9ICgxICsgMC40ICogcmVmbGVjdGl2aXR5KSAvICgxIC0gMC40ICogcmVmbGVjdGl2aXR5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdGhpczg0LmlyaWRlc2NlbmNlTWFwID0gbnVsbDtcbiAgICBfdGhpczg0LmlyaWRlc2NlbmNlSU9SID0gMS4zO1xuICAgIF90aGlzODQuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsxMDAsIDQwMF07XG4gICAgX3RoaXM4NC5pcmlkZXNjZW5jZVRoaWNrbmVzc01hcCA9IG51bGw7XG4gICAgX3RoaXM4NC5zaGVlbkNvbG9yID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcbiAgICBfdGhpczg0LnNoZWVuQ29sb3JNYXAgPSBudWxsO1xuICAgIF90aGlzODQuc2hlZW5Sb3VnaG5lc3MgPSAxLjA7XG4gICAgX3RoaXM4NC5zaGVlblJvdWdobmVzc01hcCA9IG51bGw7XG4gICAgX3RoaXM4NC50cmFuc21pc3Npb25NYXAgPSBudWxsO1xuICAgIF90aGlzODQudGhpY2tuZXNzID0gMDtcbiAgICBfdGhpczg0LnRoaWNrbmVzc01hcCA9IG51bGw7XG4gICAgX3RoaXM4NC5hdHRlbnVhdGlvbkRpc3RhbmNlID0gMC4wO1xuICAgIF90aGlzODQuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICBfdGhpczg0LnNwZWN1bGFySW50ZW5zaXR5ID0gMS4wO1xuICAgIF90aGlzODQuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSBudWxsO1xuICAgIF90aGlzODQuc3BlY3VsYXJDb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICBfdGhpczg0LnNwZWN1bGFyQ29sb3JNYXAgPSBudWxsO1xuICAgIF90aGlzODQuX3NoZWVuID0gMC4wO1xuICAgIF90aGlzODQuX2NsZWFyY29hdCA9IDA7XG4gICAgX3RoaXM4NC5faXJpZGVzY2VuY2UgPSAwO1xuICAgIF90aGlzODQuX3RyYW5zbWlzc2lvbiA9IDA7XG5cbiAgICBfdGhpczg0LnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblxuICAgIHJldHVybiBfdGhpczg0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1lc2hQaHlzaWNhbE1hdGVyaWFsLCBbe1xuICAgIGtleTogXCJzaGVlblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NoZWVuO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zaGVlbiA+IDAgIT09IHZhbHVlID4gMCkge1xuICAgICAgICB0aGlzLnZlcnNpb24rKztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2hlZW4gPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJjb2F0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2xlYXJjb2F0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9jbGVhcmNvYXQgPiAwICE9PSB2YWx1ZSA+IDApIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uKys7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFyY29hdCA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpcmlkZXNjZW5jZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lyaWRlc2NlbmNlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9pcmlkZXNjZW5jZSA+IDAgIT09IHZhbHVlID4gMCkge1xuICAgICAgICB0aGlzLnZlcnNpb24rKztcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXJpZGVzY2VuY2UgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNtaXNzaW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNtaXNzaW9uO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl90cmFuc21pc3Npb24gPiAwICE9PSB2YWx1ZSA+IDApIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uKys7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyYW5zbWlzc2lvbiA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLmRlZmluZXMgPSB7XG4gICAgICAgICdTVEFOREFSRCc6ICcnLFxuICAgICAgICAnUEhZU0lDQUwnOiAnJ1xuICAgICAgfTtcbiAgICAgIHRoaXMuY2xlYXJjb2F0ID0gc291cmNlLmNsZWFyY29hdDtcbiAgICAgIHRoaXMuY2xlYXJjb2F0TWFwID0gc291cmNlLmNsZWFyY29hdE1hcDtcbiAgICAgIHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzID0gc291cmNlLmNsZWFyY29hdFJvdWdobmVzcztcbiAgICAgIHRoaXMuY2xlYXJjb2F0Um91Z2huZXNzTWFwID0gc291cmNlLmNsZWFyY29hdFJvdWdobmVzc01hcDtcbiAgICAgIHRoaXMuY2xlYXJjb2F0Tm9ybWFsTWFwID0gc291cmNlLmNsZWFyY29hdE5vcm1hbE1hcDtcbiAgICAgIHRoaXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUuY29weShzb3VyY2UuY2xlYXJjb2F0Tm9ybWFsU2NhbGUpO1xuICAgICAgdGhpcy5pb3IgPSBzb3VyY2UuaW9yO1xuICAgICAgdGhpcy5pcmlkZXNjZW5jZSA9IHNvdXJjZS5pcmlkZXNjZW5jZTtcbiAgICAgIHRoaXMuaXJpZGVzY2VuY2VNYXAgPSBzb3VyY2UuaXJpZGVzY2VuY2VNYXA7XG4gICAgICB0aGlzLmlyaWRlc2NlbmNlSU9SID0gc291cmNlLmlyaWRlc2NlbmNlSU9SO1xuICAgICAgdGhpcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gX3RvQ29uc3VtYWJsZUFycmF5KHNvdXJjZS5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlKTtcbiAgICAgIHRoaXMuaXJpZGVzY2VuY2VUaGlja25lc3NNYXAgPSBzb3VyY2UuaXJpZGVzY2VuY2VUaGlja25lc3NNYXA7XG4gICAgICB0aGlzLnNoZWVuID0gc291cmNlLnNoZWVuO1xuICAgICAgdGhpcy5zaGVlbkNvbG9yLmNvcHkoc291cmNlLnNoZWVuQ29sb3IpO1xuICAgICAgdGhpcy5zaGVlbkNvbG9yTWFwID0gc291cmNlLnNoZWVuQ29sb3JNYXA7XG4gICAgICB0aGlzLnNoZWVuUm91Z2huZXNzID0gc291cmNlLnNoZWVuUm91Z2huZXNzO1xuICAgICAgdGhpcy5zaGVlblJvdWdobmVzc01hcCA9IHNvdXJjZS5zaGVlblJvdWdobmVzc01hcDtcbiAgICAgIHRoaXMudHJhbnNtaXNzaW9uID0gc291cmNlLnRyYW5zbWlzc2lvbjtcbiAgICAgIHRoaXMudHJhbnNtaXNzaW9uTWFwID0gc291cmNlLnRyYW5zbWlzc2lvbk1hcDtcbiAgICAgIHRoaXMudGhpY2tuZXNzID0gc291cmNlLnRoaWNrbmVzcztcbiAgICAgIHRoaXMudGhpY2tuZXNzTWFwID0gc291cmNlLnRoaWNrbmVzc01hcDtcbiAgICAgIHRoaXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IHNvdXJjZS5hdHRlbnVhdGlvbkRpc3RhbmNlO1xuICAgICAgdGhpcy5hdHRlbnVhdGlvbkNvbG9yLmNvcHkoc291cmNlLmF0dGVudWF0aW9uQ29sb3IpO1xuICAgICAgdGhpcy5zcGVjdWxhckludGVuc2l0eSA9IHNvdXJjZS5zcGVjdWxhckludGVuc2l0eTtcbiAgICAgIHRoaXMuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSBzb3VyY2Uuc3BlY3VsYXJJbnRlbnNpdHlNYXA7XG4gICAgICB0aGlzLnNwZWN1bGFyQ29sb3IuY29weShzb3VyY2Uuc3BlY3VsYXJDb2xvcik7XG4gICAgICB0aGlzLnNwZWN1bGFyQ29sb3JNYXAgPSBzb3VyY2Uuc3BlY3VsYXJDb2xvck1hcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbn0oTWVzaFN0YW5kYXJkTWF0ZXJpYWwpO1xuXG52YXIgTWVzaFBob25nTWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NYXRlcmlhbDEwKSB7XG4gIF9pbmhlcml0cyhNZXNoUGhvbmdNYXRlcmlhbCwgX01hdGVyaWFsMTApO1xuXG4gIHZhciBfc3VwZXI5NCA9IF9jcmVhdGVTdXBlcihNZXNoUGhvbmdNYXRlcmlhbCk7XG5cbiAgZnVuY3Rpb24gTWVzaFBob25nTWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczg1O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc2hQaG9uZ01hdGVyaWFsKTtcblxuICAgIF90aGlzODUgPSBfc3VwZXI5NC5jYWxsKHRoaXMpO1xuICAgIF90aGlzODUuaXNNZXNoUGhvbmdNYXRlcmlhbCA9IHRydWU7XG4gICAgX3RoaXM4NS50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcbiAgICBfdGhpczg1LmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZGlmZnVzZVxuXG4gICAgX3RoaXM4NS5zcGVjdWxhciA9IG5ldyBDb2xvcigweDExMTExMSk7XG4gICAgX3RoaXM4NS5zaGluaW5lc3MgPSAzMDtcbiAgICBfdGhpczg1Lm1hcCA9IG51bGw7XG4gICAgX3RoaXM4NS5saWdodE1hcCA9IG51bGw7XG4gICAgX3RoaXM4NS5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcbiAgICBfdGhpczg1LmFvTWFwID0gbnVsbDtcbiAgICBfdGhpczg1LmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuICAgIF90aGlzODUuZW1pc3NpdmUgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICAgIF90aGlzODUuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG4gICAgX3RoaXM4NS5lbWlzc2l2ZU1hcCA9IG51bGw7XG4gICAgX3RoaXM4NS5idW1wTWFwID0gbnVsbDtcbiAgICBfdGhpczg1LmJ1bXBTY2FsZSA9IDE7XG4gICAgX3RoaXM4NS5ub3JtYWxNYXAgPSBudWxsO1xuICAgIF90aGlzODUubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcbiAgICBfdGhpczg1Lm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgX3RoaXM4NS5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuICAgIF90aGlzODUuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuICAgIF90aGlzODUuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG4gICAgX3RoaXM4NS5zcGVjdWxhck1hcCA9IG51bGw7XG4gICAgX3RoaXM4NS5hbHBoYU1hcCA9IG51bGw7XG4gICAgX3RoaXM4NS5lbnZNYXAgPSBudWxsO1xuICAgIF90aGlzODUuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuICAgIF90aGlzODUucmVmbGVjdGl2aXR5ID0gMTtcbiAgICBfdGhpczg1LnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG4gICAgX3RoaXM4NS53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBfdGhpczg1LndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgX3RoaXM4NS53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICBfdGhpczg1LndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcbiAgICBfdGhpczg1LmZsYXRTaGFkaW5nID0gZmFsc2U7XG4gICAgX3RoaXM4NS5mb2cgPSB0cnVlO1xuXG4gICAgX3RoaXM4NS5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cbiAgICByZXR1cm4gX3RoaXM4NTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZXNoUGhvbmdNYXRlcmlhbCwgW3tcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG4gICAgICB0aGlzLnNwZWN1bGFyLmNvcHkoc291cmNlLnNwZWN1bGFyKTtcbiAgICAgIHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcbiAgICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcbiAgICAgIHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG4gICAgICB0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuICAgICAgdGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgICAgIHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG4gICAgICB0aGlzLmVtaXNzaXZlLmNvcHkoc291cmNlLmVtaXNzaXZlKTtcbiAgICAgIHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG4gICAgICB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuICAgICAgdGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG4gICAgICB0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG4gICAgICB0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG4gICAgICB0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcbiAgICAgIHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuICAgICAgdGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcbiAgICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG4gICAgICB0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG4gICAgICB0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcbiAgICAgIHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcbiAgICAgIHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcbiAgICAgIHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICAgIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgICAgIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcbiAgICAgIHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XG4gICAgICB0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVzaFBob25nTWF0ZXJpYWw7XG59KE1hdGVyaWFsKTtcblxudmFyIE1lc2hUb29uTWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NYXRlcmlhbDExKSB7XG4gIF9pbmhlcml0cyhNZXNoVG9vbk1hdGVyaWFsLCBfTWF0ZXJpYWwxMSk7XG5cbiAgdmFyIF9zdXBlcjk1ID0gX2NyZWF0ZVN1cGVyKE1lc2hUb29uTWF0ZXJpYWwpO1xuXG4gIGZ1bmN0aW9uIE1lc2hUb29uTWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczg2O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc2hUb29uTWF0ZXJpYWwpO1xuXG4gICAgX3RoaXM4NiA9IF9zdXBlcjk1LmNhbGwodGhpcyk7XG4gICAgX3RoaXM4Ni5pc01lc2hUb29uTWF0ZXJpYWwgPSB0cnVlO1xuICAgIF90aGlzODYuZGVmaW5lcyA9IHtcbiAgICAgICdUT09OJzogJydcbiAgICB9O1xuICAgIF90aGlzODYudHlwZSA9ICdNZXNoVG9vbk1hdGVyaWFsJztcbiAgICBfdGhpczg2LmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTtcbiAgICBfdGhpczg2Lm1hcCA9IG51bGw7XG4gICAgX3RoaXM4Ni5ncmFkaWVudE1hcCA9IG51bGw7XG4gICAgX3RoaXM4Ni5saWdodE1hcCA9IG51bGw7XG4gICAgX3RoaXM4Ni5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcbiAgICBfdGhpczg2LmFvTWFwID0gbnVsbDtcbiAgICBfdGhpczg2LmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuICAgIF90aGlzODYuZW1pc3NpdmUgPSBuZXcgQ29sb3IoMHgwMDAwMDApO1xuICAgIF90aGlzODYuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XG4gICAgX3RoaXM4Ni5lbWlzc2l2ZU1hcCA9IG51bGw7XG4gICAgX3RoaXM4Ni5idW1wTWFwID0gbnVsbDtcbiAgICBfdGhpczg2LmJ1bXBTY2FsZSA9IDE7XG4gICAgX3RoaXM4Ni5ub3JtYWxNYXAgPSBudWxsO1xuICAgIF90aGlzODYubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcbiAgICBfdGhpczg2Lm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgX3RoaXM4Ni5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuICAgIF90aGlzODYuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuICAgIF90aGlzODYuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG4gICAgX3RoaXM4Ni5hbHBoYU1hcCA9IG51bGw7XG4gICAgX3RoaXM4Ni53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBfdGhpczg2LndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgX3RoaXM4Ni53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICBfdGhpczg2LndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcbiAgICBfdGhpczg2LmZvZyA9IHRydWU7XG5cbiAgICBfdGhpczg2LnNldFZhbHVlcyhwYXJhbWV0ZXJzKTtcblxuICAgIHJldHVybiBfdGhpczg2O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1lc2hUb29uTWF0ZXJpYWwsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG4gICAgICB0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG4gICAgICB0aGlzLmdyYWRpZW50TWFwID0gc291cmNlLmdyYWRpZW50TWFwO1xuICAgICAgdGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcbiAgICAgIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG4gICAgICB0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuICAgICAgdGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcbiAgICAgIHRoaXMuZW1pc3NpdmUuY29weShzb3VyY2UuZW1pc3NpdmUpO1xuICAgICAgdGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcbiAgICAgIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG4gICAgICB0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcbiAgICAgIHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcbiAgICAgIHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcbiAgICAgIHRoaXMubm9ybWFsTWFwVHlwZSA9IHNvdXJjZS5ub3JtYWxNYXBUeXBlO1xuICAgICAgdGhpcy5ub3JtYWxTY2FsZS5jb3B5KHNvdXJjZS5ub3JtYWxTY2FsZSk7XG4gICAgICB0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG4gICAgICB0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG4gICAgICB0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuICAgICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuICAgICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lc2hUb29uTWF0ZXJpYWw7XG59KE1hdGVyaWFsKTtcblxudmFyIE1lc2hOb3JtYWxNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01hdGVyaWFsMTIpIHtcbiAgX2luaGVyaXRzKE1lc2hOb3JtYWxNYXRlcmlhbCwgX01hdGVyaWFsMTIpO1xuXG4gIHZhciBfc3VwZXI5NiA9IF9jcmVhdGVTdXBlcihNZXNoTm9ybWFsTWF0ZXJpYWwpO1xuXG4gIGZ1bmN0aW9uIE1lc2hOb3JtYWxNYXRlcmlhbChwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF90aGlzODc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzaE5vcm1hbE1hdGVyaWFsKTtcblxuICAgIF90aGlzODcgPSBfc3VwZXI5Ni5jYWxsKHRoaXMpO1xuICAgIF90aGlzODcuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgPSB0cnVlO1xuICAgIF90aGlzODcudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuICAgIF90aGlzODcuYnVtcE1hcCA9IG51bGw7XG4gICAgX3RoaXM4Ny5idW1wU2NhbGUgPSAxO1xuICAgIF90aGlzODcubm9ybWFsTWFwID0gbnVsbDtcbiAgICBfdGhpczg3Lm5vcm1hbE1hcFR5cGUgPSBUYW5nZW50U3BhY2VOb3JtYWxNYXA7XG4gICAgX3RoaXM4Ny5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKDEsIDEpO1xuICAgIF90aGlzODcuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcbiAgICBfdGhpczg3LmRpc3BsYWNlbWVudFNjYWxlID0gMTtcbiAgICBfdGhpczg3LmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuICAgIF90aGlzODcud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgX3RoaXM4Ny53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIF90aGlzODcuZmxhdFNoYWRpbmcgPSBmYWxzZTtcblxuICAgIF90aGlzODcuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXG4gICAgcmV0dXJuIF90aGlzODc7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWVzaE5vcm1hbE1hdGVyaWFsLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XG4gICAgICB0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG4gICAgICB0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG4gICAgICB0aGlzLm5vcm1hbE1hcFR5cGUgPSBzb3VyY2Uubm9ybWFsTWFwVHlwZTtcbiAgICAgIHRoaXMubm9ybWFsU2NhbGUuY29weShzb3VyY2Uubm9ybWFsU2NhbGUpO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICAgIHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuICAgICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgICAgdGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNoTm9ybWFsTWF0ZXJpYWw7XG59KE1hdGVyaWFsKTtcblxudmFyIE1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9NYXRlcmlhbDEzKSB7XG4gIF9pbmhlcml0cyhNZXNoTGFtYmVydE1hdGVyaWFsLCBfTWF0ZXJpYWwxMyk7XG5cbiAgdmFyIF9zdXBlcjk3ID0gX2NyZWF0ZVN1cGVyKE1lc2hMYW1iZXJ0TWF0ZXJpYWwpO1xuXG4gIGZ1bmN0aW9uIE1lc2hMYW1iZXJ0TWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczg4O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc2hMYW1iZXJ0TWF0ZXJpYWwpO1xuXG4gICAgX3RoaXM4OCA9IF9zdXBlcjk3LmNhbGwodGhpcyk7XG4gICAgX3RoaXM4OC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgPSB0cnVlO1xuICAgIF90aGlzODgudHlwZSA9ICdNZXNoTGFtYmVydE1hdGVyaWFsJztcbiAgICBfdGhpczg4LmNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZmZmKTsgLy8gZGlmZnVzZVxuXG4gICAgX3RoaXM4OC5tYXAgPSBudWxsO1xuICAgIF90aGlzODgubGlnaHRNYXAgPSBudWxsO1xuICAgIF90aGlzODgubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XG4gICAgX3RoaXM4OC5hb01hcCA9IG51bGw7XG4gICAgX3RoaXM4OC5hb01hcEludGVuc2l0eSA9IDEuMDtcbiAgICBfdGhpczg4LmVtaXNzaXZlID0gbmV3IENvbG9yKDB4MDAwMDAwKTtcbiAgICBfdGhpczg4LmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuICAgIF90aGlzODguZW1pc3NpdmVNYXAgPSBudWxsO1xuICAgIF90aGlzODguc3BlY3VsYXJNYXAgPSBudWxsO1xuICAgIF90aGlzODguYWxwaGFNYXAgPSBudWxsO1xuICAgIF90aGlzODguZW52TWFwID0gbnVsbDtcbiAgICBfdGhpczg4LmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcbiAgICBfdGhpczg4LnJlZmxlY3Rpdml0eSA9IDE7XG4gICAgX3RoaXM4OC5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuICAgIF90aGlzODgud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgX3RoaXM4OC53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIF90aGlzODgud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gICAgX3RoaXM4OC53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG4gICAgX3RoaXM4OC5mb2cgPSB0cnVlO1xuXG4gICAgX3RoaXM4OC5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cbiAgICByZXR1cm4gX3RoaXM4ODtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZXNoTGFtYmVydE1hdGVyaWFsLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMuY29sb3IuY29weShzb3VyY2UuY29sb3IpO1xuICAgICAgdGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuICAgICAgdGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcbiAgICAgIHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG4gICAgICB0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuICAgICAgdGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcbiAgICAgIHRoaXMuZW1pc3NpdmUuY29weShzb3VyY2UuZW1pc3NpdmUpO1xuICAgICAgdGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcbiAgICAgIHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG4gICAgICB0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuICAgICAgdGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcbiAgICAgIHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICAgIHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuICAgICAgdGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuICAgICAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuICAgICAgdGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgICAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuICAgICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG59KE1hdGVyaWFsKTtcblxudmFyIE1lc2hNYXRjYXBNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX01hdGVyaWFsMTQpIHtcbiAgX2luaGVyaXRzKE1lc2hNYXRjYXBNYXRlcmlhbCwgX01hdGVyaWFsMTQpO1xuXG4gIHZhciBfc3VwZXI5OCA9IF9jcmVhdGVTdXBlcihNZXNoTWF0Y2FwTWF0ZXJpYWwpO1xuXG4gIGZ1bmN0aW9uIE1lc2hNYXRjYXBNYXRlcmlhbChwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF90aGlzODk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzaE1hdGNhcE1hdGVyaWFsKTtcblxuICAgIF90aGlzODkgPSBfc3VwZXI5OC5jYWxsKHRoaXMpO1xuICAgIF90aGlzODkuaXNNZXNoTWF0Y2FwTWF0ZXJpYWwgPSB0cnVlO1xuICAgIF90aGlzODkuZGVmaW5lcyA9IHtcbiAgICAgICdNQVRDQVAnOiAnJ1xuICAgIH07XG4gICAgX3RoaXM4OS50eXBlID0gJ01lc2hNYXRjYXBNYXRlcmlhbCc7XG4gICAgX3RoaXM4OS5jb2xvciA9IG5ldyBDb2xvcigweGZmZmZmZik7IC8vIGRpZmZ1c2VcblxuICAgIF90aGlzODkubWF0Y2FwID0gbnVsbDtcbiAgICBfdGhpczg5Lm1hcCA9IG51bGw7XG4gICAgX3RoaXM4OS5idW1wTWFwID0gbnVsbDtcbiAgICBfdGhpczg5LmJ1bXBTY2FsZSA9IDE7XG4gICAgX3RoaXM4OS5ub3JtYWxNYXAgPSBudWxsO1xuICAgIF90aGlzODkubm9ybWFsTWFwVHlwZSA9IFRhbmdlbnRTcGFjZU5vcm1hbE1hcDtcbiAgICBfdGhpczg5Lm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgX3RoaXM4OS5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuICAgIF90aGlzODkuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuICAgIF90aGlzODkuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG4gICAgX3RoaXM4OS5hbHBoYU1hcCA9IG51bGw7XG4gICAgX3RoaXM4OS5mbGF0U2hhZGluZyA9IGZhbHNlO1xuICAgIF90aGlzODkuZm9nID0gdHJ1ZTtcblxuICAgIF90aGlzODkuc2V0VmFsdWVzKHBhcmFtZXRlcnMpO1xuXG4gICAgcmV0dXJuIF90aGlzODk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWVzaE1hdGNhcE1hdGVyaWFsLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihNZXNoTWF0Y2FwTWF0ZXJpYWwucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy5kZWZpbmVzID0ge1xuICAgICAgICAnTUFUQ0FQJzogJydcbiAgICAgIH07XG4gICAgICB0aGlzLmNvbG9yLmNvcHkoc291cmNlLmNvbG9yKTtcbiAgICAgIHRoaXMubWF0Y2FwID0gc291cmNlLm1hdGNhcDtcbiAgICAgIHRoaXMubWFwID0gc291cmNlLm1hcDtcbiAgICAgIHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuICAgICAgdGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuICAgICAgdGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuICAgICAgdGhpcy5ub3JtYWxNYXBUeXBlID0gc291cmNlLm5vcm1hbE1hcFR5cGU7XG4gICAgICB0aGlzLm5vcm1hbFNjYWxlLmNvcHkoc291cmNlLm5vcm1hbFNjYWxlKTtcbiAgICAgIHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcbiAgICAgIHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgICB0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcbiAgICAgIHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG4gICAgICB0aGlzLmZsYXRTaGFkaW5nID0gc291cmNlLmZsYXRTaGFkaW5nO1xuICAgICAgdGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lc2hNYXRjYXBNYXRlcmlhbDtcbn0oTWF0ZXJpYWwpO1xuXG52YXIgTGluZURhc2hlZE1hdGVyaWFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGluZUJhc2ljTWF0ZXJpYWwpIHtcbiAgX2luaGVyaXRzKExpbmVEYXNoZWRNYXRlcmlhbCwgX0xpbmVCYXNpY01hdGVyaWFsKTtcblxuICB2YXIgX3N1cGVyOTkgPSBfY3JlYXRlU3VwZXIoTGluZURhc2hlZE1hdGVyaWFsKTtcblxuICBmdW5jdGlvbiBMaW5lRGFzaGVkTWF0ZXJpYWwocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczkwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmVEYXNoZWRNYXRlcmlhbCk7XG5cbiAgICBfdGhpczkwID0gX3N1cGVyOTkuY2FsbCh0aGlzKTtcbiAgICBfdGhpczkwLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcbiAgICBfdGhpczkwLnR5cGUgPSAnTGluZURhc2hlZE1hdGVyaWFsJztcbiAgICBfdGhpczkwLnNjYWxlID0gMTtcbiAgICBfdGhpczkwLmRhc2hTaXplID0gMztcbiAgICBfdGhpczkwLmdhcFNpemUgPSAxO1xuXG4gICAgX3RoaXM5MC5zZXRWYWx1ZXMocGFyYW1ldGVycyk7XG5cbiAgICByZXR1cm4gX3RoaXM5MDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5lRGFzaGVkTWF0ZXJpYWwsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xuICAgICAgdGhpcy5kYXNoU2l6ZSA9IHNvdXJjZS5kYXNoU2l6ZTtcbiAgICAgIHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmVEYXNoZWRNYXRlcmlhbDtcbn0oTGluZUJhc2ljTWF0ZXJpYWwpO1xuXG52YXIgbWF0ZXJpYWxMaWIgPSB7XG4gIFNoYWRvd01hdGVyaWFsOiBTaGFkb3dNYXRlcmlhbCxcbiAgU3ByaXRlTWF0ZXJpYWw6IFNwcml0ZU1hdGVyaWFsLFxuICBSYXdTaGFkZXJNYXRlcmlhbDogUmF3U2hhZGVyTWF0ZXJpYWwsXG4gIFNoYWRlck1hdGVyaWFsOiBTaGFkZXJNYXRlcmlhbCxcbiAgUG9pbnRzTWF0ZXJpYWw6IFBvaW50c01hdGVyaWFsLFxuICBNZXNoUGh5c2ljYWxNYXRlcmlhbDogTWVzaFBoeXNpY2FsTWF0ZXJpYWwsXG4gIE1lc2hTdGFuZGFyZE1hdGVyaWFsOiBNZXNoU3RhbmRhcmRNYXRlcmlhbCxcbiAgTWVzaFBob25nTWF0ZXJpYWw6IE1lc2hQaG9uZ01hdGVyaWFsLFxuICBNZXNoVG9vbk1hdGVyaWFsOiBNZXNoVG9vbk1hdGVyaWFsLFxuICBNZXNoTm9ybWFsTWF0ZXJpYWw6IE1lc2hOb3JtYWxNYXRlcmlhbCxcbiAgTWVzaExhbWJlcnRNYXRlcmlhbDogTWVzaExhbWJlcnRNYXRlcmlhbCxcbiAgTWVzaERlcHRoTWF0ZXJpYWw6IE1lc2hEZXB0aE1hdGVyaWFsLFxuICBNZXNoRGlzdGFuY2VNYXRlcmlhbDogTWVzaERpc3RhbmNlTWF0ZXJpYWwsXG4gIE1lc2hCYXNpY01hdGVyaWFsOiBNZXNoQmFzaWNNYXRlcmlhbCxcbiAgTWVzaE1hdGNhcE1hdGVyaWFsOiBNZXNoTWF0Y2FwTWF0ZXJpYWwsXG4gIExpbmVEYXNoZWRNYXRlcmlhbDogTGluZURhc2hlZE1hdGVyaWFsLFxuICBMaW5lQmFzaWNNYXRlcmlhbDogTGluZUJhc2ljTWF0ZXJpYWwsXG4gIE1hdGVyaWFsOiBNYXRlcmlhbFxufTtcblxuTWF0ZXJpYWwuZnJvbVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICByZXR1cm4gbmV3IG1hdGVyaWFsTGliW3R5cGVdKCk7XG59O1xuXG52YXIgQW5pbWF0aW9uVXRpbHMgPSB7XG4gIC8vIHNhbWUgYXMgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgYWxzbyB3b3JrcyBvbiB0eXBlZCBhcnJheXNcbiAgYXJyYXlTbGljZTogZnVuY3Rpb24gYXJyYXlTbGljZShhcnJheSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KGFycmF5KSkge1xuICAgICAgLy8gaW4gaW9zOSBhcnJheS5zdWJhcnJheShmcm9tLCB1bmRlZmluZWQpIHdpbGwgcmV0dXJuIGVtcHR5IGFycmF5XG4gICAgICAvLyBidXQgYXJyYXkuc3ViYXJyYXkoZnJvbSkgb3IgYXJyYXkuc3ViYXJyYXkoZnJvbSwgbGVuKSBpcyBjb3JyZWN0XG4gICAgICByZXR1cm4gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGFycmF5LnN1YmFycmF5KGZyb20sIHRvICE9PSB1bmRlZmluZWQgPyB0byA6IGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheS5zbGljZShmcm9tLCB0byk7XG4gIH0sXG4gIC8vIGNvbnZlcnRzIGFuIGFycmF5IHRvIGEgc3BlY2lmaWMgdHlwZVxuICBjb252ZXJ0QXJyYXk6IGZ1bmN0aW9uIGNvbnZlcnRBcnJheShhcnJheSwgdHlwZSwgZm9yY2VDbG9uZSkge1xuICAgIGlmICghYXJyYXkgfHwgLy8gbGV0ICd1bmRlZmluZWQnIGFuZCAnbnVsbCcgcGFzc1xuICAgICFmb3JjZUNsb25lICYmIGFycmF5LmNvbnN0cnVjdG9yID09PSB0eXBlKSByZXR1cm4gYXJyYXk7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUoYXJyYXkpOyAvLyBjcmVhdGUgdHlwZWQgYXJyYXlcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXkpOyAvLyBjcmVhdGUgQXJyYXlcbiAgfSxcbiAgaXNUeXBlZEFycmF5OiBmdW5jdGlvbiBpc1R5cGVkQXJyYXkob2JqZWN0KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpICYmICEob2JqZWN0IGluc3RhbmNlb2YgRGF0YVZpZXcpO1xuICB9LFxuICAvLyByZXR1cm5zIGFuIGFycmF5IGJ5IHdoaWNoIHRpbWVzIGFuZCB2YWx1ZXMgY2FuIGJlIHNvcnRlZFxuICBnZXRLZXlmcmFtZU9yZGVyOiBmdW5jdGlvbiBnZXRLZXlmcmFtZU9yZGVyKHRpbWVzKSB7XG4gICAgZnVuY3Rpb24gY29tcGFyZVRpbWUoaSwgaikge1xuICAgICAgcmV0dXJuIHRpbWVzW2ldIC0gdGltZXNbal07XG4gICAgfVxuXG4gICAgdmFyIG4gPSB0aW1lcy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAodmFyIF9pMjU1ID0gMDsgX2kyNTUgIT09IG47ICsrX2kyNTUpIHtcbiAgICAgIHJlc3VsdFtfaTI1NV0gPSBfaTI1NTtcbiAgICB9XG5cbiAgICByZXN1bHQuc29ydChjb21wYXJlVGltZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgLy8gdXNlcyB0aGUgYXJyYXkgcHJldmlvdXNseSByZXR1cm5lZCBieSAnZ2V0S2V5ZnJhbWVPcmRlcicgdG8gc29ydCBkYXRhXG4gIHNvcnRlZEFycmF5OiBmdW5jdGlvbiBzb3J0ZWRBcnJheSh2YWx1ZXMsIHN0cmlkZSwgb3JkZXIpIHtcbiAgICB2YXIgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyB2YWx1ZXMuY29uc3RydWN0b3IoblZhbHVlcyk7XG5cbiAgICBmb3IgKHZhciBfaTI1NiA9IDAsIGRzdE9mZnNldCA9IDA7IGRzdE9mZnNldCAhPT0gblZhbHVlczsgKytfaTI1Nikge1xuICAgICAgdmFyIHNyY09mZnNldCA9IG9yZGVyW19pMjU2XSAqIHN0cmlkZTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKytqKSB7XG4gICAgICAgIHJlc3VsdFtkc3RPZmZzZXQrK10gPSB2YWx1ZXNbc3JjT2Zmc2V0ICsgal07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgLy8gZnVuY3Rpb24gZm9yIHBhcnNpbmcgQU9TIGtleWZyYW1lIGZvcm1hdHNcbiAgZmxhdHRlbkpTT046IGZ1bmN0aW9uIGZsYXR0ZW5KU09OKGpzb25LZXlzLCB0aW1lcywgdmFsdWVzLCB2YWx1ZVByb3BlcnR5TmFtZSkge1xuICAgIHZhciBpID0gMSxcbiAgICAgICAga2V5ID0ganNvbktleXNbMF07XG5cbiAgICB3aGlsZSAoa2V5ICE9PSB1bmRlZmluZWQgJiYga2V5W3ZhbHVlUHJvcGVydHlOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSBqc29uS2V5c1tpKytdO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBubyBkYXRhXG5cbiAgICB2YXIgdmFsdWUgPSBrZXlbdmFsdWVQcm9wZXJ0eU5hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG5vIGRhdGFcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZG8ge1xuICAgICAgICB2YWx1ZSA9IGtleVt2YWx1ZVByb3BlcnR5TmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcy5wdXNoKGtleS50aW1lKTtcbiAgICAgICAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIHZhbHVlKTsgLy8gcHVzaCBhbGwgZWxlbWVudHNcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IGpzb25LZXlzW2krK107XG4gICAgICB9IHdoaWxlIChrZXkgIT09IHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZS50b0FycmF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIC4uLmFzc3VtZSBUSFJFRS5NYXRoLWlzaFxuICAgICAgZG8ge1xuICAgICAgICB2YWx1ZSA9IGtleVt2YWx1ZVByb3BlcnR5TmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcy5wdXNoKGtleS50aW1lKTtcbiAgICAgICAgICB2YWx1ZS50b0FycmF5KHZhbHVlcywgdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBqc29uS2V5c1tpKytdO1xuICAgICAgfSB3aGlsZSAoa2V5ICE9PSB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UgcHVzaCBhcy1pc1xuICAgICAgZG8ge1xuICAgICAgICB2YWx1ZSA9IGtleVt2YWx1ZVByb3BlcnR5TmFtZV07XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcy5wdXNoKGtleS50aW1lKTtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBqc29uS2V5c1tpKytdO1xuICAgICAgfSB3aGlsZSAoa2V5ICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSxcbiAgc3ViY2xpcDogZnVuY3Rpb24gc3ViY2xpcChzb3VyY2VDbGlwLCBuYW1lLCBzdGFydEZyYW1lLCBlbmRGcmFtZSkge1xuICAgIHZhciBmcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDMwO1xuICAgIHZhciBjbGlwID0gc291cmNlQ2xpcC5jbG9uZSgpO1xuICAgIGNsaXAubmFtZSA9IG5hbWU7XG4gICAgdmFyIHRyYWNrcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kyNTcgPSAwOyBfaTI1NyA8IGNsaXAudHJhY2tzLmxlbmd0aDsgKytfaTI1Nykge1xuICAgICAgdmFyIHRyYWNrID0gY2xpcC50cmFja3NbX2kyNTddO1xuICAgICAgdmFyIHZhbHVlU2l6ZSA9IHRyYWNrLmdldFZhbHVlU2l6ZSgpO1xuICAgICAgdmFyIHRpbWVzID0gW107XG4gICAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdHJhY2sudGltZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgdmFyIGZyYW1lID0gdHJhY2sudGltZXNbal0gKiBmcHM7XG4gICAgICAgIGlmIChmcmFtZSA8IHN0YXJ0RnJhbWUgfHwgZnJhbWUgPj0gZW5kRnJhbWUpIGNvbnRpbnVlO1xuICAgICAgICB0aW1lcy5wdXNoKHRyYWNrLnRpbWVzW2pdKTtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHZhbHVlU2l6ZTsgKytrKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2godHJhY2sudmFsdWVzW2ogKiB2YWx1ZVNpemUgKyBrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWVzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICB0cmFjay50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSh0aW1lcywgdHJhY2sudGltZXMuY29uc3RydWN0b3IpO1xuICAgICAgdHJhY2sudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KHZhbHVlcywgdHJhY2sudmFsdWVzLmNvbnN0cnVjdG9yKTtcbiAgICAgIHRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICB9XG5cbiAgICBjbGlwLnRyYWNrcyA9IHRyYWNrczsgLy8gZmluZCBtaW5pbXVtIC50aW1lcyB2YWx1ZSBhY3Jvc3MgYWxsIHRyYWNrcyBpbiB0aGUgdHJpbW1lZCBjbGlwXG5cbiAgICB2YXIgbWluU3RhcnRUaW1lID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBfaTI1OCA9IDA7IF9pMjU4IDwgY2xpcC50cmFja3MubGVuZ3RoOyArK19pMjU4KSB7XG4gICAgICBpZiAobWluU3RhcnRUaW1lID4gY2xpcC50cmFja3NbX2kyNThdLnRpbWVzWzBdKSB7XG4gICAgICAgIG1pblN0YXJ0VGltZSA9IGNsaXAudHJhY2tzW19pMjU4XS50aW1lc1swXTtcbiAgICAgIH1cbiAgICB9IC8vIHNoaWZ0IGFsbCB0cmFja3Mgc3VjaCB0aGF0IGNsaXAgYmVnaW5zIGF0IHQ9MFxuXG5cbiAgICBmb3IgKHZhciBfaTI1OSA9IDA7IF9pMjU5IDwgY2xpcC50cmFja3MubGVuZ3RoOyArK19pMjU5KSB7XG4gICAgICBjbGlwLnRyYWNrc1tfaTI1OV0uc2hpZnQoLTEgKiBtaW5TdGFydFRpbWUpO1xuICAgIH1cblxuICAgIGNsaXAucmVzZXREdXJhdGlvbigpO1xuICAgIHJldHVybiBjbGlwO1xuICB9LFxuICBtYWtlQ2xpcEFkZGl0aXZlOiBmdW5jdGlvbiBtYWtlQ2xpcEFkZGl0aXZlKHRhcmdldENsaXApIHtcbiAgICB2YXIgcmVmZXJlbmNlRnJhbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIHJlZmVyZW5jZUNsaXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRhcmdldENsaXA7XG4gICAgdmFyIGZwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMzA7XG4gICAgaWYgKGZwcyA8PSAwKSBmcHMgPSAzMDtcbiAgICB2YXIgbnVtVHJhY2tzID0gcmVmZXJlbmNlQ2xpcC50cmFja3MubGVuZ3RoO1xuICAgIHZhciByZWZlcmVuY2VUaW1lID0gcmVmZXJlbmNlRnJhbWUgLyBmcHM7IC8vIE1ha2UgZWFjaCB0cmFjaydzIHZhbHVlcyByZWxhdGl2ZSB0byB0aGUgdmFsdWVzIGF0IHRoZSByZWZlcmVuY2UgZnJhbWVcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pMjYwKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlVHJhY2sgPSByZWZlcmVuY2VDbGlwLnRyYWNrc1tfaTI2MF07XG4gICAgICB2YXIgcmVmZXJlbmNlVHJhY2tUeXBlID0gcmVmZXJlbmNlVHJhY2suVmFsdWVUeXBlTmFtZTsgLy8gU2tpcCB0aGlzIHRyYWNrIGlmIGl0J3Mgbm9uLW51bWVyaWNcblxuICAgICAgaWYgKHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ2Jvb2wnIHx8IHJlZmVyZW5jZVRyYWNrVHlwZSA9PT0gJ3N0cmluZycpIHJldHVybiBcImNvbnRpbnVlXCI7IC8vIEZpbmQgdGhlIHRyYWNrIGluIHRoZSB0YXJnZXQgY2xpcCB3aG9zZSBuYW1lIGFuZCB0eXBlIG1hdGNoZXMgdGhlIHJlZmVyZW5jZSB0cmFja1xuXG4gICAgICB2YXIgdGFyZ2V0VHJhY2sgPSB0YXJnZXRDbGlwLnRyYWNrcy5maW5kKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2submFtZSA9PT0gcmVmZXJlbmNlVHJhY2submFtZSAmJiB0cmFjay5WYWx1ZVR5cGVOYW1lID09PSByZWZlcmVuY2VUcmFja1R5cGU7XG4gICAgICB9KTtcbiAgICAgIGlmICh0YXJnZXRUcmFjayA9PT0gdW5kZWZpbmVkKSByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgdmFyIHJlZmVyZW5jZU9mZnNldCA9IDA7XG4gICAgICB2YXIgcmVmZXJlbmNlVmFsdWVTaXplID0gcmVmZXJlbmNlVHJhY2suZ2V0VmFsdWVTaXplKCk7XG5cbiAgICAgIGlmIChyZWZlcmVuY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSkge1xuICAgICAgICByZWZlcmVuY2VPZmZzZXQgPSByZWZlcmVuY2VWYWx1ZVNpemUgLyAzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciB0YXJnZXRWYWx1ZVNpemUgPSB0YXJnZXRUcmFjay5nZXRWYWx1ZVNpemUoKTtcblxuICAgICAgaWYgKHRhcmdldFRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lKSB7XG4gICAgICAgIHRhcmdldE9mZnNldCA9IHRhcmdldFZhbHVlU2l6ZSAvIDM7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0SW5kZXggPSByZWZlcmVuY2VUcmFjay50aW1lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHJlZmVyZW5jZVZhbHVlID0gdm9pZCAwOyAvLyBGaW5kIHRoZSB2YWx1ZSB0byBzdWJ0cmFjdCBvdXQgb2YgdGhlIHRyYWNrXG5cbiAgICAgIGlmIChyZWZlcmVuY2VUaW1lIDw9IHJlZmVyZW5jZVRyYWNrLnRpbWVzWzBdKSB7XG4gICAgICAgIC8vIFJlZmVyZW5jZSBmcmFtZSBpcyBlYXJsaWVyIHRoYW4gdGhlIGZpcnN0IGtleWZyYW1lLCBzbyBqdXN0IHVzZSB0aGUgZmlyc3Qga2V5ZnJhbWVcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSByZWZlcmVuY2VPZmZzZXQ7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHJlZmVyZW5jZVZhbHVlU2l6ZSAtIHJlZmVyZW5jZU9mZnNldDtcbiAgICAgICAgcmVmZXJlbmNlVmFsdWUgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHJlZmVyZW5jZVRyYWNrLnZhbHVlcywgc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChyZWZlcmVuY2VUaW1lID49IHJlZmVyZW5jZVRyYWNrLnRpbWVzW2xhc3RJbmRleF0pIHtcbiAgICAgICAgLy8gUmVmZXJlbmNlIGZyYW1lIGlzIGFmdGVyIHRoZSBsYXN0IGtleWZyYW1lLCBzbyBqdXN0IHVzZSB0aGUgbGFzdCBrZXlmcmFtZVxuICAgICAgICB2YXIgX3N0YXJ0SW5kZXggPSBsYXN0SW5kZXggKiByZWZlcmVuY2VWYWx1ZVNpemUgKyByZWZlcmVuY2VPZmZzZXQ7XG5cbiAgICAgICAgdmFyIF9lbmRJbmRleCA9IF9zdGFydEluZGV4ICsgcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xuXG4gICAgICAgIHJlZmVyZW5jZVZhbHVlID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZShyZWZlcmVuY2VUcmFjay52YWx1ZXMsIF9zdGFydEluZGV4LCBfZW5kSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgdG8gdGhlIHJlZmVyZW5jZSB2YWx1ZVxuICAgICAgICB2YXIgaW50ZXJwb2xhbnQgPSByZWZlcmVuY2VUcmFjay5jcmVhdGVJbnRlcnBvbGFudCgpO1xuICAgICAgICB2YXIgX3N0YXJ0SW5kZXgyID0gcmVmZXJlbmNlT2Zmc2V0O1xuXG4gICAgICAgIHZhciBfZW5kSW5kZXgyID0gcmVmZXJlbmNlVmFsdWVTaXplIC0gcmVmZXJlbmNlT2Zmc2V0O1xuXG4gICAgICAgIGludGVycG9sYW50LmV2YWx1YXRlKHJlZmVyZW5jZVRpbWUpO1xuICAgICAgICByZWZlcmVuY2VWYWx1ZSA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoaW50ZXJwb2xhbnQucmVzdWx0QnVmZmVyLCBfc3RhcnRJbmRleDIsIF9lbmRJbmRleDIpO1xuICAgICAgfSAvLyBDb25qdWdhdGUgdGhlIHF1YXRlcm5pb25cblxuXG4gICAgICBpZiAocmVmZXJlbmNlVHJhY2tUeXBlID09PSAncXVhdGVybmlvbicpIHtcbiAgICAgICAgdmFyIHJlZmVyZW5jZVF1YXQgPSBuZXcgUXVhdGVybmlvbigpLmZyb21BcnJheShyZWZlcmVuY2VWYWx1ZSkubm9ybWFsaXplKCkuY29uanVnYXRlKCk7XG4gICAgICAgIHJlZmVyZW5jZVF1YXQudG9BcnJheShyZWZlcmVuY2VWYWx1ZSk7XG4gICAgICB9IC8vIFN1YnRyYWN0IHRoZSByZWZlcmVuY2UgdmFsdWUgZnJvbSBhbGwgb2YgdGhlIHRyYWNrIHZhbHVlc1xuXG5cbiAgICAgIHZhciBudW1UaW1lcyA9IHRhcmdldFRyYWNrLnRpbWVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1UaW1lczsgKytqKSB7XG4gICAgICAgIHZhciB2YWx1ZVN0YXJ0ID0gaiAqIHRhcmdldFZhbHVlU2l6ZSArIHRhcmdldE9mZnNldDtcblxuICAgICAgICBpZiAocmVmZXJlbmNlVHJhY2tUeXBlID09PSAncXVhdGVybmlvbicpIHtcbiAgICAgICAgICAvLyBNdWx0aXBseSB0aGUgY29uanVnYXRlIGZvciBxdWF0ZXJuaW9uIHRyYWNrIHR5cGVzXG4gICAgICAgICAgUXVhdGVybmlvbi5tdWx0aXBseVF1YXRlcm5pb25zRmxhdCh0YXJnZXRUcmFjay52YWx1ZXMsIHZhbHVlU3RhcnQsIHJlZmVyZW5jZVZhbHVlLCAwLCB0YXJnZXRUcmFjay52YWx1ZXMsIHZhbHVlU3RhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWx1ZUVuZCA9IHRhcmdldFZhbHVlU2l6ZSAtIHRhcmdldE9mZnNldCAqIDI7IC8vIFN1YnRyYWN0IGVhY2ggdmFsdWUgZm9yIGFsbCBvdGhlciBudW1lcmljIHRyYWNrIHR5cGVzXG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHZhbHVlRW5kOyArK2spIHtcbiAgICAgICAgICAgIHRhcmdldFRyYWNrLnZhbHVlc1t2YWx1ZVN0YXJ0ICsga10gLT0gcmVmZXJlbmNlVmFsdWVba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pMjYwID0gMDsgX2kyNjAgPCBudW1UcmFja3M7ICsrX2kyNjApIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kyNjApO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0YXJnZXRDbGlwLmJsZW5kTW9kZSA9IEFkZGl0aXZlQW5pbWF0aW9uQmxlbmRNb2RlO1xuICAgIHJldHVybiB0YXJnZXRDbGlwO1xuICB9XG59O1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIG9mIGludGVycG9sYW50cyBvdmVyIHBhcmFtZXRyaWMgc2FtcGxlcy5cbiAqXG4gKiBUaGUgcGFyYW1ldGVyIGRvbWFpbiBpcyBvbmUgZGltZW5zaW9uYWwsIHR5cGljYWxseSB0aGUgdGltZSBvciBhIHBhdGhcbiAqIGFsb25nIGEgY3VydmUgZGVmaW5lZCBieSB0aGUgZGF0YS5cbiAqXG4gKiBUaGUgc2FtcGxlIHZhbHVlcyBjYW4gaGF2ZSBhbnkgZGltZW5zaW9uYWxpdHkgYW5kIGRlcml2ZWQgY2xhc3NlcyBtYXlcbiAqIGFwcGx5IHNwZWNpYWwgaW50ZXJwcmV0YXRpb25zIHRvIHRoZSBkYXRhLlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgdGhlIGludGVydmFsIHNlZWsgaW4gYSBUZW1wbGF0ZSBNZXRob2QsIGRlZmVycmluZ1xuICogdGhlIGFjdHVhbCBpbnRlcnBvbGF0aW9uIHRvIGRlcml2ZWQgY2xhc3Nlcy5cbiAqXG4gKiBUaW1lIGNvbXBsZXhpdHkgaXMgTygxKSBmb3IgbGluZWFyIGFjY2VzcyBjcm9zc2luZyBhdCBtb3N0IHR3byBwb2ludHNcbiAqIGFuZCBPKGxvZyBOKSBmb3IgcmFuZG9tIGFjY2Vzcywgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mIHBvc2l0aW9ucy5cbiAqXG4gKiBSZWZlcmVuY2VzOlxuICpcbiAqIFx0XHRodHRwOi8vd3d3Lm9vZGVzaWduLmNvbS90ZW1wbGF0ZS1tZXRob2QtcGF0dGVybi5odG1sXG4gKlxuICovXG5cbnZhciBJbnRlcnBvbGFudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludGVycG9sYW50KHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJwb2xhbnQpO1xuXG4gICAgdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBwYXJhbWV0ZXJQb3NpdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuICAgIHRoaXMucmVzdWx0QnVmZmVyID0gcmVzdWx0QnVmZmVyICE9PSB1bmRlZmluZWQgPyByZXN1bHRCdWZmZXIgOiBuZXcgc2FtcGxlVmFsdWVzLmNvbnN0cnVjdG9yKHNhbXBsZVNpemUpO1xuICAgIHRoaXMuc2FtcGxlVmFsdWVzID0gc2FtcGxlVmFsdWVzO1xuICAgIHRoaXMudmFsdWVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICB0aGlzLnNldHRpbmdzID0gbnVsbDtcbiAgICB0aGlzLkRlZmF1bHRTZXR0aW5nc18gPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbnRlcnBvbGFudCwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUodCkge1xuICAgICAgdmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnM7XG4gICAgICB2YXIgaTEgPSB0aGlzLl9jYWNoZWRJbmRleCxcbiAgICAgICAgICB0MSA9IHBwW2kxXSxcbiAgICAgICAgICB0MCA9IHBwW2kxIC0gMV07XG5cbiAgICAgIHZhbGlkYXRlX2ludGVydmFsOiB7XG4gICAgICAgIHNlZWs6IHtcbiAgICAgICAgICB2YXIgcmlnaHQ7XG5cbiAgICAgICAgICBsaW5lYXJfc2Nhbjoge1xuICAgICAgICAgICAgLy8tIFNlZSBodHRwOi8vanNwZXJmLmNvbS9jb21wYXJpc29uLXRvLXVuZGVmaW5lZC8zXG4gICAgICAgICAgICAvLy0gc2xvd2VyIGNvZGU6XG4gICAgICAgICAgICAvLy1cbiAgICAgICAgICAgIC8vLSBcdFx0XHRcdGlmICggdCA+PSB0MSB8fCB0MSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgZm9yd2FyZF9zY2FuOiBpZiAoISh0IDwgdDEpKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGdpdmVVcEF0ID0gaTEgKyAyOzspIHtcbiAgICAgICAgICAgICAgICBpZiAodDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHQgPCB0MCkgYnJlYWsgZm9yd2FyZF9zY2FuOyAvLyBhZnRlciBlbmRcblxuICAgICAgICAgICAgICAgICAgaTEgPSBwcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyhpMSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpMSA9PT0gZ2l2ZVVwQXQpIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuICAgICAgICAgICAgICAgIHQwID0gdDE7XG4gICAgICAgICAgICAgICAgdDEgPSBwcFsrK2kxXTtcblxuICAgICAgICAgICAgICAgIGlmICh0IDwgdDEpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXG4gICAgICAgICAgICAgICAgICBicmVhayBzZWVrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGluZGV4XG5cblxuICAgICAgICAgICAgICByaWdodCA9IHBwLmxlbmd0aDtcbiAgICAgICAgICAgICAgYnJlYWsgbGluZWFyX3NjYW47XG4gICAgICAgICAgICB9IC8vLSBzbG93ZXIgY29kZTpcbiAgICAgICAgICAgIC8vLVx0XHRcdFx0XHRpZiAoIHQgPCB0MCB8fCB0MCA9PT0gdW5kZWZpbmVkICkge1xuXG5cbiAgICAgICAgICAgIGlmICghKHQgPj0gdDApKSB7XG4gICAgICAgICAgICAgIC8vIGxvb3Bpbmc/XG4gICAgICAgICAgICAgIHZhciB0MWdsb2JhbCA9IHBwWzFdO1xuXG4gICAgICAgICAgICAgIGlmICh0IDwgdDFnbG9iYWwpIHtcbiAgICAgICAgICAgICAgICBpMSA9IDI7IC8vICsgMSwgdXNpbmcgdGhlIHNjYW4gZm9yIHRoZSBkZXRhaWxzXG5cbiAgICAgICAgICAgICAgICB0MCA9IHQxZ2xvYmFsO1xuICAgICAgICAgICAgICB9IC8vIGxpbmVhciByZXZlcnNlIHNjYW5cblxuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9naXZlVXBBdCA9IGkxIC0gMjs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHQwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGJlZm9yZSBzdGFydFxuICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXygwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaTEgPT09IF9naXZlVXBBdCkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG4gICAgICAgICAgICAgICAgdDEgPSB0MDtcbiAgICAgICAgICAgICAgICB0MCA9IHBwWy0taTEgLSAxXTtcblxuICAgICAgICAgICAgICAgIGlmICh0ID49IHQwKSB7XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgYnJlYWsgc2VlaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XG5cblxuICAgICAgICAgICAgICByaWdodCA9IGkxO1xuICAgICAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrIGxpbmVhcl9zY2FuO1xuICAgICAgICAgICAgfSAvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcblxuXG4gICAgICAgICAgICBicmVhayB2YWxpZGF0ZV9pbnRlcnZhbDtcbiAgICAgICAgICB9IC8vIGxpbmVhciBzY2FuXG4gICAgICAgICAgLy8gYmluYXJ5IHNlYXJjaFxuXG5cbiAgICAgICAgICB3aGlsZSAoaTEgPCByaWdodCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IGkxICsgcmlnaHQgPj4+IDE7XG5cbiAgICAgICAgICAgIGlmICh0IDwgcHBbbWlkXSkge1xuICAgICAgICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGkxID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0MSA9IHBwW2kxXTtcbiAgICAgICAgICB0MCA9IHBwW2kxIC0gMV07IC8vIGNoZWNrIGJvdW5kYXJ5IGNhc2VzLCBhZ2FpblxuXG4gICAgICAgICAgaWYgKHQwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGkxID0gcHAubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oaTEgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gc2Vla1xuXG5cbiAgICAgICAgdGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbENoYW5nZWRfKGkxLCB0MCwgdDEpO1xuICAgICAgfSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxuXG5cbiAgICAgIHJldHVybiB0aGlzLmludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2V0dGluZ3NfXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNldHRpbmdzXygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzIHx8IHRoaXMuRGVmYXVsdFNldHRpbmdzXztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVNhbXBsZVZhbHVlX1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5U2FtcGxlVmFsdWVfKGluZGV4KSB7XG4gICAgICAvLyBjb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXJcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcbiAgICAgICAgICB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcbiAgICAgICAgICBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcbiAgICAgICAgICBvZmZzZXQgPSBpbmRleCAqIHN0cmlkZTtcblxuICAgICAgZm9yICh2YXIgX2kyNjEgPSAwOyBfaTI2MSAhPT0gc3RyaWRlOyArK19pMjYxKSB7XG4gICAgICAgIHJlc3VsdFtfaTI2MV0gPSB2YWx1ZXNbb2Zmc2V0ICsgX2kyNjFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gLy8gVGVtcGxhdGUgbWV0aG9kcyBmb3IgZGVyaXZlZCBjbGFzc2VzOlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVfXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uXG4gICAgICAvKiBpMSwgdDAsIHQsIHQxICovXG4gICAgaW50ZXJwb2xhdGVfKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsIHRvIGFic3RyYWN0IG1ldGhvZCcpOyAvLyBpbXBsZW1lbnRhdGlvbnMgc2hhbGwgcmV0dXJuIHRoaXMucmVzdWx0QnVmZmVyXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVydmFsQ2hhbmdlZF9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb25cbiAgICAgIC8qIGkxLCB0MCwgdDEgKi9cbiAgICBpbnRlcnZhbENoYW5nZWRfKCkgey8vIGVtcHR5XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEludGVycG9sYW50O1xufSgpO1xuLyoqXG4gKiBGYXN0IGFuZCBzaW1wbGUgY3ViaWMgc3BsaW5lIGludGVycG9sYW50LlxuICpcbiAqIEl0IHdhcyBkZXJpdmVkIGZyb20gYSBIZXJtaXRpYW4gY29uc3RydWN0aW9uIHNldHRpbmcgdGhlIGZpcnN0IGRlcml2YXRpdmVcbiAqIGF0IGVhY2ggc2FtcGxlIHBvc2l0aW9uIHRvIHRoZSBsaW5lYXIgc2xvcGUgYmV0d2VlbiBuZWlnaGJvcmluZyBwb3NpdGlvbnNcbiAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxuICovXG5cblxudmFyIEN1YmljSW50ZXJwb2xhbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9JbnRlcnBvbGFudCkge1xuICBfaW5oZXJpdHMoQ3ViaWNJbnRlcnBvbGFudCwgX0ludGVycG9sYW50KTtcblxuICB2YXIgX3N1cGVyMTAwID0gX2NyZWF0ZVN1cGVyKEN1YmljSW50ZXJwb2xhbnQpO1xuXG4gIGZ1bmN0aW9uIEN1YmljSW50ZXJwb2xhbnQocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuICAgIHZhciBfdGhpczkxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmljSW50ZXJwb2xhbnQpO1xuXG4gICAgX3RoaXM5MSA9IF9zdXBlcjEwMC5jYWxsKHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuICAgIF90aGlzOTEuX3dlaWdodFByZXYgPSAtMDtcbiAgICBfdGhpczkxLl9vZmZzZXRQcmV2ID0gLTA7XG4gICAgX3RoaXM5MS5fd2VpZ2h0TmV4dCA9IC0wO1xuICAgIF90aGlzOTEuX29mZnNldE5leHQgPSAtMDtcbiAgICBfdGhpczkxLkRlZmF1bHRTZXR0aW5nc18gPSB7XG4gICAgICBlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcbiAgICAgIGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xuICAgIH07XG4gICAgcmV0dXJuIF90aGlzOTE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ3ViaWNJbnRlcnBvbGFudCwgW3tcbiAgICBrZXk6IFwiaW50ZXJ2YWxDaGFuZ2VkX1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnZhbENoYW5nZWRfKGkxLCB0MCwgdDEpIHtcbiAgICAgIHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zO1xuICAgICAgdmFyIGlQcmV2ID0gaTEgLSAyLFxuICAgICAgICAgIGlOZXh0ID0gaTEgKyAxLFxuICAgICAgICAgIHRQcmV2ID0gcHBbaVByZXZdLFxuICAgICAgICAgIHROZXh0ID0gcHBbaU5leHRdO1xuXG4gICAgICBpZiAodFByZXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nU3RhcnQpIHtcbiAgICAgICAgICBjYXNlIFplcm9TbG9wZUVuZGluZzpcbiAgICAgICAgICAgIC8vIGYnKHQwKSA9IDBcbiAgICAgICAgICAgIGlQcmV2ID0gaTE7XG4gICAgICAgICAgICB0UHJldiA9IDIgKiB0MCAtIHQxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFdyYXBBcm91bmRFbmRpbmc6XG4gICAgICAgICAgICAvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcbiAgICAgICAgICAgIGlQcmV2ID0gcHAubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIHRQcmV2ID0gdDAgKyBwcFtpUHJldl0gLSBwcFtpUHJldiArIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xuICAgICAgICAgICAgLy8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG4gICAgICAgICAgICBpUHJldiA9IGkxO1xuICAgICAgICAgICAgdFByZXYgPSB0MTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodE5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nRW5kKSB7XG4gICAgICAgICAgY2FzZSBaZXJvU2xvcGVFbmRpbmc6XG4gICAgICAgICAgICAvLyBmJyh0TikgPSAwXG4gICAgICAgICAgICBpTmV4dCA9IGkxO1xuICAgICAgICAgICAgdE5leHQgPSAyICogdDEgLSB0MDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxuICAgICAgICAgICAgLy8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG4gICAgICAgICAgICBpTmV4dCA9IDE7XG4gICAgICAgICAgICB0TmV4dCA9IHQxICsgcHBbMV0gLSBwcFswXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcbiAgICAgICAgICAgIC8vIGYnJyh0TikgPSAwLCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcbiAgICAgICAgICAgIGlOZXh0ID0gaTEgLSAxO1xuICAgICAgICAgICAgdE5leHQgPSB0MDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaGFsZkR0ID0gKHQxIC0gdDApICogMC41LFxuICAgICAgICAgIHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xuICAgICAgdGhpcy5fd2VpZ2h0UHJldiA9IGhhbGZEdCAvICh0MCAtIHRQcmV2KTtcbiAgICAgIHRoaXMuX3dlaWdodE5leHQgPSBoYWxmRHQgLyAodE5leHQgLSB0MSk7XG4gICAgICB0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XG4gICAgICB0aGlzLl9vZmZzZXROZXh0ID0gaU5leHQgKiBzdHJpZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVycG9sYXRlX1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuICAgICAgICAgIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuICAgICAgICAgIHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuICAgICAgICAgIG8xID0gaTEgKiBzdHJpZGUsXG4gICAgICAgICAgbzAgPSBvMSAtIHN0cmlkZSxcbiAgICAgICAgICBvUCA9IHRoaXMuX29mZnNldFByZXYsXG4gICAgICAgICAgb04gPSB0aGlzLl9vZmZzZXROZXh0LFxuICAgICAgICAgIHdQID0gdGhpcy5fd2VpZ2h0UHJldixcbiAgICAgICAgICB3TiA9IHRoaXMuX3dlaWdodE5leHQsXG4gICAgICAgICAgcCA9ICh0IC0gdDApIC8gKHQxIC0gdDApLFxuICAgICAgICAgIHBwID0gcCAqIHAsXG4gICAgICAgICAgcHBwID0gcHAgKiBwOyAvLyBldmFsdWF0ZSBwb2x5bm9taWFsc1xuXG4gICAgICB2YXIgc1AgPSAtd1AgKiBwcHAgKyAyICogd1AgKiBwcCAtIHdQICogcDtcbiAgICAgIHZhciBzMCA9ICgxICsgd1ApICogcHBwICsgKC0xLjUgLSAyICogd1ApICogcHAgKyAoLTAuNSArIHdQKSAqIHAgKyAxO1xuICAgICAgdmFyIHMxID0gKC0xIC0gd04pICogcHBwICsgKDEuNSArIHdOKSAqIHBwICsgMC41ICogcDtcbiAgICAgIHZhciBzTiA9IHdOICogcHBwIC0gd04gKiBwcDsgLy8gY29tYmluZSBkYXRhIGxpbmVhcmx5XG5cbiAgICAgIGZvciAodmFyIF9pMjYyID0gMDsgX2kyNjIgIT09IHN0cmlkZTsgKytfaTI2Mikge1xuICAgICAgICByZXN1bHRbX2kyNjJdID0gc1AgKiB2YWx1ZXNbb1AgKyBfaTI2Ml0gKyBzMCAqIHZhbHVlc1tvMCArIF9pMjYyXSArIHMxICogdmFsdWVzW28xICsgX2kyNjJdICsgc04gKiB2YWx1ZXNbb04gKyBfaTI2Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEN1YmljSW50ZXJwb2xhbnQ7XG59KEludGVycG9sYW50KTtcblxudmFyIExpbmVhckludGVycG9sYW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW50ZXJwb2xhbnQyKSB7XG4gIF9pbmhlcml0cyhMaW5lYXJJbnRlcnBvbGFudCwgX0ludGVycG9sYW50Mik7XG5cbiAgdmFyIF9zdXBlcjEwMSA9IF9jcmVhdGVTdXBlcihMaW5lYXJJbnRlcnBvbGFudCk7XG5cbiAgZnVuY3Rpb24gTGluZWFySW50ZXJwb2xhbnQocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lYXJJbnRlcnBvbGFudCk7XG5cbiAgICByZXR1cm4gX3N1cGVyMTAxLmNhbGwodGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGluZWFySW50ZXJwb2xhbnQsIFt7XG4gICAga2V5OiBcImludGVycG9sYXRlX1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuICAgICAgICAgIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuICAgICAgICAgIHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuICAgICAgICAgIG9mZnNldDEgPSBpMSAqIHN0cmlkZSxcbiAgICAgICAgICBvZmZzZXQwID0gb2Zmc2V0MSAtIHN0cmlkZSxcbiAgICAgICAgICB3ZWlnaHQxID0gKHQgLSB0MCkgLyAodDEgLSB0MCksXG4gICAgICAgICAgd2VpZ2h0MCA9IDEgLSB3ZWlnaHQxO1xuXG4gICAgICBmb3IgKHZhciBfaTI2MyA9IDA7IF9pMjYzICE9PSBzdHJpZGU7ICsrX2kyNjMpIHtcbiAgICAgICAgcmVzdWx0W19pMjYzXSA9IHZhbHVlc1tvZmZzZXQwICsgX2kyNjNdICogd2VpZ2h0MCArIHZhbHVlc1tvZmZzZXQxICsgX2kyNjNdICogd2VpZ2h0MTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZWFySW50ZXJwb2xhbnQ7XG59KEludGVycG9sYW50KTtcbi8qKlxuICpcbiAqIEludGVycG9sYW50IHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBzYW1wbGUgdmFsdWUgYXQgdGhlIHBvc2l0aW9uIHByZWNlZGluZ1xuICogdGhlIHBhcmFtZXRlci5cbiAqL1xuXG5cbnZhciBEaXNjcmV0ZUludGVycG9sYW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW50ZXJwb2xhbnQzKSB7XG4gIF9pbmhlcml0cyhEaXNjcmV0ZUludGVycG9sYW50LCBfSW50ZXJwb2xhbnQzKTtcblxuICB2YXIgX3N1cGVyMTAyID0gX2NyZWF0ZVN1cGVyKERpc2NyZXRlSW50ZXJwb2xhbnQpO1xuXG4gIGZ1bmN0aW9uIERpc2NyZXRlSW50ZXJwb2xhbnQocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNjcmV0ZUludGVycG9sYW50KTtcblxuICAgIHJldHVybiBfc3VwZXIxMDIuY2FsbCh0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEaXNjcmV0ZUludGVycG9sYW50LCBbe1xuICAgIGtleTogXCJpbnRlcnBvbGF0ZV9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGVfKGkxXG4gICAgLyosIHQwLCB0LCB0MSAqL1xuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyhpMSAtIDEpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEaXNjcmV0ZUludGVycG9sYW50O1xufShJbnRlcnBvbGFudCk7XG5cbnZhciBLZXlmcmFtZVRyYWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gS2V5ZnJhbWVUcmFjayhuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEtleWZyYW1lVHJhY2spO1xuXG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayBuYW1lIGlzIHVuZGVmaW5lZCcpO1xuICAgIGlmICh0aW1lcyA9PT0gdW5kZWZpbmVkIHx8IHRpbWVzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiBubyBrZXlmcmFtZXMgaW4gdHJhY2sgbmFtZWQgJyArIG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSh0aW1lcywgdGhpcy5UaW1lQnVmZmVyVHlwZSk7XG4gICAgdGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkodmFsdWVzLCB0aGlzLlZhbHVlQnVmZmVyVHlwZSk7XG4gICAgdGhpcy5zZXRJbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb24gfHwgdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbik7XG4gIH0gLy8gU2VyaWFsaXphdGlvbiAoaW4gc3RhdGljIGNvbnRleHQsIGJlY2F1c2Ugb2YgY29uc3RydWN0b3IgaW52b2NhdGlvblxuICAvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XG5cblxuICBfY3JlYXRlQ2xhc3MoS2V5ZnJhbWVUcmFjaywgW3tcbiAgICBrZXk6IFwiSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGUocmVzdWx0KSB7XG4gICAgICByZXR1cm4gbmV3IERpc2NyZXRlSW50ZXJwb2xhbnQodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIocmVzdWx0KSB7XG4gICAgICByZXR1cm4gbmV3IExpbmVhckludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIG5ldyBDdWJpY0ludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRJbnRlcnBvbGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbikge1xuICAgICAgdmFyIGZhY3RvcnlNZXRob2Q7XG5cbiAgICAgIHN3aXRjaCAoaW50ZXJwb2xhdGlvbikge1xuICAgICAgICBjYXNlIEludGVycG9sYXRlRGlzY3JldGU6XG4gICAgICAgICAgZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBJbnRlcnBvbGF0ZUxpbmVhcjpcbiAgICAgICAgICBmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBJbnRlcnBvbGF0ZVNtb290aDpcbiAgICAgICAgICBmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChmYWN0b3J5TWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAndW5zdXBwb3J0ZWQgaW50ZXJwb2xhdGlvbiBmb3IgJyArIHRoaXMuVmFsdWVUeXBlTmFtZSArICcga2V5ZnJhbWUgdHJhY2sgbmFtZWQgJyArIHRoaXMubmFtZTtcblxuICAgICAgICBpZiAodGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGRlZmF1bHQsIHVubGVzcyB0aGUgZGVmYXVsdCBpdHNlbGYgaXMgbWVzc2VkIHVwXG4gICAgICAgICAgaWYgKGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW50ZXJwb2xhdGlvbih0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOyAvLyBmYXRhbCwgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5LZXlmcmFtZVRyYWNrOicsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9IGZhY3RvcnlNZXRob2Q7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW50ZXJwb2xhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0aW9uKCkge1xuICAgICAgc3dpdGNoICh0aGlzLmNyZWF0ZUludGVycG9sYW50KSB7XG4gICAgICAgIGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTpcbiAgICAgICAgICByZXR1cm4gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcblxuICAgICAgICBjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOlxuICAgICAgICAgIHJldHVybiBJbnRlcnBvbGF0ZUxpbmVhcjtcblxuICAgICAgICBjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOlxuICAgICAgICAgIHJldHVybiBJbnRlcnBvbGF0ZVNtb290aDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlU2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggLyB0aGlzLnRpbWVzLmxlbmd0aDtcbiAgICB9IC8vIG1vdmUgYWxsIGtleWZyYW1lcyBlaXRoZXIgZm9yd2FyZHMgb3IgYmFja3dhcmRzIGluIHRpbWVcblxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KHRpbWVPZmZzZXQpIHtcbiAgICAgIGlmICh0aW1lT2Zmc2V0ICE9PSAwLjApIHtcbiAgICAgICAgdmFyIHRpbWVzID0gdGhpcy50aW1lcztcblxuICAgICAgICBmb3IgKHZhciBfaTI2NCA9IDAsIG4gPSB0aW1lcy5sZW5ndGg7IF9pMjY0ICE9PSBuOyArK19pMjY0KSB7XG4gICAgICAgICAgdGltZXNbX2kyNjRdICs9IHRpbWVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXG5cbiAgfSwge1xuICAgIGtleTogXCJzY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2FsZSh0aW1lU2NhbGUpIHtcbiAgICAgIGlmICh0aW1lU2NhbGUgIT09IDEuMCkge1xuICAgICAgICB2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xuXG4gICAgICAgIGZvciAodmFyIF9pMjY1ID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgX2kyNjUgIT09IG47ICsrX2kyNjUpIHtcbiAgICAgICAgICB0aW1lc1tfaTI2NV0gKj0gdGltZVNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXG4gICAgLy8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidHJpbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmltKHN0YXJ0VGltZSwgZW5kVGltZSkge1xuICAgICAgdmFyIHRpbWVzID0gdGhpcy50aW1lcyxcbiAgICAgICAgICBuS2V5cyA9IHRpbWVzLmxlbmd0aDtcbiAgICAgIHZhciBmcm9tID0gMCxcbiAgICAgICAgICB0byA9IG5LZXlzIC0gMTtcblxuICAgICAgd2hpbGUgKGZyb20gIT09IG5LZXlzICYmIHRpbWVzW2Zyb21dIDwgc3RhcnRUaW1lKSB7XG4gICAgICAgICsrZnJvbTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRvICE9PSAtMSAmJiB0aW1lc1t0b10gPiBlbmRUaW1lKSB7XG4gICAgICAgIC0tdG87XG4gICAgICB9XG5cbiAgICAgICsrdG87IC8vIGluY2x1c2l2ZSAtPiBleGNsdXNpdmUgYm91bmRcblxuICAgICAgaWYgKGZyb20gIT09IDAgfHwgdG8gIT09IG5LZXlzKSB7XG4gICAgICAgIC8vIGVtcHR5IHRyYWNrcyBhcmUgZm9yYmlkZGVuLCBzbyBrZWVwIGF0IGxlYXN0IG9uZSBrZXlmcmFtZVxuICAgICAgICBpZiAoZnJvbSA+PSB0bykge1xuICAgICAgICAgIHRvID0gTWF0aC5tYXgodG8sIDEpO1xuICAgICAgICAgIGZyb20gPSB0byAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcbiAgICAgICAgdGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodGltZXMsIGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHRoaXMudmFsdWVzLCBmcm9tICogc3RyaWRlLCB0byAqIHN0cmlkZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gZW5zdXJlIHdlIGRvIG5vdCBnZXQgYSBHYXJiYWdlSW5HYXJiYWdlT3V0IHNpdHVhdGlvbiwgbWFrZSBzdXJlIHRyYWNrcyBhcmUgYXQgbGVhc3QgbWluaW1hbGx5IHZpYWJsZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gICAgICB2YXIgdmFsaWQgPSB0cnVlO1xuICAgICAgdmFyIHZhbHVlU2l6ZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG5cbiAgICAgIGlmICh2YWx1ZVNpemUgLSBNYXRoLmZsb29yKHZhbHVlU2l6ZSkgIT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogSW52YWxpZCB2YWx1ZSBzaXplIGluIHRyYWNrLicsIHRoaXMpO1xuICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxuICAgICAgICAgIHZhbHVlcyA9IHRoaXMudmFsdWVzLFxuICAgICAgICAgIG5LZXlzID0gdGltZXMubGVuZ3RoO1xuXG4gICAgICBpZiAobktleXMgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuS2V5ZnJhbWVUcmFjazogVHJhY2sgaXMgZW1wdHkuJywgdGhpcyk7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2VGltZSA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIF9pMjY2ID0gMDsgX2kyNjYgIT09IG5LZXlzOyBfaTI2NisrKSB7XG4gICAgICAgIHZhciBjdXJyVGltZSA9IHRpbWVzW19pMjY2XTtcblxuICAgICAgICBpZiAodHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTihjdXJyVGltZSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5LZXlmcmFtZVRyYWNrOiBUaW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBfaTI2NiwgY3VyclRpbWUpO1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlRpbWUgIT09IG51bGwgJiYgcHJldlRpbWUgPiBjdXJyVGltZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IE91dCBvZiBvcmRlciBrZXlzLicsIHRoaXMsIF9pMjY2LCBjdXJyVGltZSwgcHJldlRpbWUpO1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2VGltZSA9IGN1cnJUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKEFuaW1hdGlvblV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kyNjcgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgX2kyNjcgIT09IG47ICsrX2kyNjcpIHtcbiAgICAgICAgICAgIHZhciBfdmFsdWU1ID0gdmFsdWVzW19pMjY3XTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKF92YWx1ZTUpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IFZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBfaTI2NywgX3ZhbHVlNSk7XG4gICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSAvLyByZW1vdmVzIGVxdWl2YWxlbnQgc2VxdWVudGlhbCBrZXlzIGFzIGNvbW1vbiBpbiBtb3JwaCB0YXJnZXQgc2VxdWVuY2VzXG4gICAgLy8gKDAsMCwwLDAsMSwxLDEsMCwwLDAsMCwwLDAsMCkgLS0+ICgwLDAsMSwxLDAsMClcblxuICB9LCB7XG4gICAga2V5OiBcIm9wdGltaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGltaXplKCkge1xuICAgICAgLy8gdGltZXMgb3IgdmFsdWVzIG1heSBiZSBzaGFyZWQgd2l0aCBvdGhlciB0cmFja3MsIHNvIG92ZXJ3cml0aW5nIGlzIHVuc2FmZVxuICAgICAgdmFyIHRpbWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSh0aGlzLnRpbWVzKSxcbiAgICAgICAgICB2YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHRoaXMudmFsdWVzKSxcbiAgICAgICAgICBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxuICAgICAgICAgIHNtb290aEludGVycG9sYXRpb24gPSB0aGlzLmdldEludGVycG9sYXRpb24oKSA9PT0gSW50ZXJwb2xhdGVTbW9vdGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gdGltZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciB3cml0ZUluZGV4ID0gMTtcblxuICAgICAgZm9yICh2YXIgX2kyNjggPSAxOyBfaTI2OCA8IGxhc3RJbmRleDsgKytfaTI2OCkge1xuICAgICAgICB2YXIga2VlcCA9IGZhbHNlO1xuICAgICAgICB2YXIgdGltZSA9IHRpbWVzW19pMjY4XTtcbiAgICAgICAgdmFyIHRpbWVOZXh0ID0gdGltZXNbX2kyNjggKyAxXTsgLy8gcmVtb3ZlIGFkamFjZW50IGtleWZyYW1lcyBzY2hlZHVsZWQgYXQgdGhlIHNhbWUgdGltZVxuXG4gICAgICAgIGlmICh0aW1lICE9PSB0aW1lTmV4dCAmJiAoX2kyNjggIT09IDEgfHwgdGltZSAhPT0gdGltZXNbMF0pKSB7XG4gICAgICAgICAgaWYgKCFzbW9vdGhJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHNhbWUgYXMgdGhlaXIgbmVpZ2hib3JzXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX2kyNjggKiBzdHJpZGUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0UCA9IG9mZnNldCAtIHN0cmlkZSxcbiAgICAgICAgICAgICAgICBvZmZzZXROID0gb2Zmc2V0ICsgc3RyaWRlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArK2opIHtcbiAgICAgICAgICAgICAgdmFyIF92YWx1ZTYgPSB2YWx1ZXNbb2Zmc2V0ICsgal07XG5cbiAgICAgICAgICAgICAgaWYgKF92YWx1ZTYgIT09IHZhbHVlc1tvZmZzZXRQICsgal0gfHwgX3ZhbHVlNiAhPT0gdmFsdWVzW29mZnNldE4gKyBqXSkge1xuICAgICAgICAgICAgICAgIGtlZXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGtlZXAgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpbi1wbGFjZSBjb21wYWN0aW9uXG5cblxuICAgICAgICBpZiAoa2VlcCkge1xuICAgICAgICAgIGlmIChfaTI2OCAhPT0gd3JpdGVJbmRleCkge1xuICAgICAgICAgICAgdGltZXNbd3JpdGVJbmRleF0gPSB0aW1lc1tfaTI2OF07XG4gICAgICAgICAgICB2YXIgcmVhZE9mZnNldCA9IF9pMjY4ICogc3RyaWRlLFxuICAgICAgICAgICAgICAgIHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2oxNCA9IDA7IF9qMTQgIT09IHN0cmlkZTsgKytfajE0KSB7XG4gICAgICAgICAgICAgIHZhbHVlc1t3cml0ZU9mZnNldCArIF9qMTRdID0gdmFsdWVzW3JlYWRPZmZzZXQgKyBfajE0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK3dyaXRlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZmx1c2ggbGFzdCBrZXlmcmFtZSAoY29tcGFjdGlvbiBsb29rcyBhaGVhZClcblxuXG4gICAgICBpZiAobGFzdEluZGV4ID4gMCkge1xuICAgICAgICB0aW1lc1t3cml0ZUluZGV4XSA9IHRpbWVzW2xhc3RJbmRleF07XG5cbiAgICAgICAgZm9yICh2YXIgX3JlYWRPZmZzZXQgPSBsYXN0SW5kZXggKiBzdHJpZGUsIF93cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGUsIF9qMTUgPSAwOyBfajE1ICE9PSBzdHJpZGU7ICsrX2oxNSkge1xuICAgICAgICAgIHZhbHVlc1tfd3JpdGVPZmZzZXQgKyBfajE1XSA9IHZhbHVlc1tfcmVhZE9mZnNldCArIF9qMTVdO1xuICAgICAgICB9XG5cbiAgICAgICAgKyt3cml0ZUluZGV4O1xuICAgICAgfVxuXG4gICAgICBpZiAod3JpdGVJbmRleCAhPT0gdGltZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGltZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHRpbWVzLCAwLCB3cml0ZUluZGV4KTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHZhbHVlcywgMCwgd3JpdGVJbmRleCAqIHN0cmlkZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpbWVzID0gdGltZXM7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB2YXIgdGltZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKHRoaXMudGltZXMsIDApO1xuICAgICAgdmFyIHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UodGhpcy52YWx1ZXMsIDApO1xuICAgICAgdmFyIFR5cGVkS2V5ZnJhbWVUcmFjayA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICB2YXIgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKHRoaXMubmFtZSwgdGltZXMsIHZhbHVlcyk7IC8vIEludGVycG9sYW50IGFyZ3VtZW50IHRvIGNvbnN0cnVjdG9yIGlzIG5vdCBzYXZlZCwgc28gY29weSB0aGUgZmFjdG9yeSBtZXRob2QgZGlyZWN0bHkuXG5cbiAgICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50ID0gdGhpcy5jcmVhdGVJbnRlcnBvbGFudDtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKHRyYWNrKSB7XG4gICAgICB2YXIgdHJhY2tUeXBlID0gdHJhY2suY29uc3RydWN0b3I7XG4gICAgICB2YXIganNvbjsgLy8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgdG9KU09OIG1ldGhvZFxuXG4gICAgICBpZiAodHJhY2tUeXBlLnRvSlNPTiAhPT0gdGhpcy50b0pTT04pIHtcbiAgICAgICAganNvbiA9IHRyYWNrVHlwZS50b0pTT04odHJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIHRoZSBkYXRhIGNhbiBiZSBzZXJpYWxpemVkIGFzLWlzXG4gICAgICAgIGpzb24gPSB7XG4gICAgICAgICAgJ25hbWUnOiB0cmFjay5uYW1lLFxuICAgICAgICAgICd0aW1lcyc6IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSh0cmFjay50aW1lcywgQXJyYXkpLFxuICAgICAgICAgICd2YWx1ZXMnOiBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkodHJhY2sudmFsdWVzLCBBcnJheSlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGludGVycG9sYXRpb24gPSB0cmFjay5nZXRJbnRlcnBvbGF0aW9uKCk7XG5cbiAgICAgICAgaWYgKGludGVycG9sYXRpb24gIT09IHRyYWNrLkRlZmF1bHRJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAganNvbi5pbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBqc29uLnR5cGUgPSB0cmFjay5WYWx1ZVR5cGVOYW1lOyAvLyBtYW5kYXRvcnlcblxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEtleWZyYW1lVHJhY2s7XG59KCk7XG5cbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlRpbWVCdWZmZXJUeXBlID0gRmxvYXQzMkFycmF5O1xuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVCdWZmZXJUeXBlID0gRmxvYXQzMkFycmF5O1xuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZUxpbmVhcjtcbi8qKlxuICogQSBUcmFjayBvZiBCb29sZWFuIGtleWZyYW1lIHZhbHVlcy5cbiAqL1xuXG52YXIgQm9vbGVhbktleWZyYW1lVHJhY2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LZXlmcmFtZVRyYWNrKSB7XG4gIF9pbmhlcml0cyhCb29sZWFuS2V5ZnJhbWVUcmFjaywgX0tleWZyYW1lVHJhY2spO1xuXG4gIHZhciBfc3VwZXIxMDMgPSBfY3JlYXRlU3VwZXIoQm9vbGVhbktleWZyYW1lVHJhY2spO1xuXG4gIGZ1bmN0aW9uIEJvb2xlYW5LZXlmcmFtZVRyYWNrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb29sZWFuS2V5ZnJhbWVUcmFjayk7XG5cbiAgICByZXR1cm4gX3N1cGVyMTAzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEJvb2xlYW5LZXlmcmFtZVRyYWNrKTtcbn0oS2V5ZnJhbWVUcmFjayk7XG5cbkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ2Jvb2wnO1xuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZSA9IEFycmF5O1xuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkRlZmF1bHRJbnRlcnBvbGF0aW9uID0gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcbkJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXIgPSB1bmRlZmluZWQ7XG5Cb29sZWFuS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBBIFRyYWNrIG9mIGtleWZyYW1lIHZhbHVlcyB0aGF0IHJlcHJlc2VudCBjb2xvci5cbiAqL1xuXG52YXIgQ29sb3JLZXlmcmFtZVRyYWNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfS2V5ZnJhbWVUcmFjazIpIHtcbiAgX2luaGVyaXRzKENvbG9yS2V5ZnJhbWVUcmFjaywgX0tleWZyYW1lVHJhY2syKTtcblxuICB2YXIgX3N1cGVyMTA0ID0gX2NyZWF0ZVN1cGVyKENvbG9yS2V5ZnJhbWVUcmFjayk7XG5cbiAgZnVuY3Rpb24gQ29sb3JLZXlmcmFtZVRyYWNrKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvcktleWZyYW1lVHJhY2spO1xuXG4gICAgcmV0dXJuIF9zdXBlcjEwNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb2xvcktleWZyYW1lVHJhY2spO1xufShLZXlmcmFtZVRyYWNrKTtcblxuQ29sb3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ2NvbG9yJztcbi8qKlxuICogQSBUcmFjayBvZiBudW1lcmljIGtleWZyYW1lIHZhbHVlcy5cbiAqL1xuXG52YXIgTnVtYmVyS2V5ZnJhbWVUcmFjayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0tleWZyYW1lVHJhY2szKSB7XG4gIF9pbmhlcml0cyhOdW1iZXJLZXlmcmFtZVRyYWNrLCBfS2V5ZnJhbWVUcmFjazMpO1xuXG4gIHZhciBfc3VwZXIxMDUgPSBfY3JlYXRlU3VwZXIoTnVtYmVyS2V5ZnJhbWVUcmFjayk7XG5cbiAgZnVuY3Rpb24gTnVtYmVyS2V5ZnJhbWVUcmFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyS2V5ZnJhbWVUcmFjayk7XG5cbiAgICByZXR1cm4gX3N1cGVyMTA1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE51bWJlcktleWZyYW1lVHJhY2spO1xufShLZXlmcmFtZVRyYWNrKTtcblxuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICdudW1iZXInO1xuLyoqXG4gKiBTcGhlcmljYWwgbGluZWFyIHVuaXQgcXVhdGVybmlvbiBpbnRlcnBvbGFudC5cbiAqL1xuXG52YXIgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfSW50ZXJwb2xhbnQ0KSB7XG4gIF9pbmhlcml0cyhRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQsIF9JbnRlcnBvbGFudDQpO1xuXG4gIHZhciBfc3VwZXIxMDYgPSBfY3JlYXRlU3VwZXIoUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50KTtcblxuICBmdW5jdGlvbiBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjEwNi5jYWxsKHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCwgW3tcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGVfXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG4gICAgICAgICAgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG4gICAgICAgICAgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG4gICAgICAgICAgYWxwaGEgPSAodCAtIHQwKSAvICh0MSAtIHQwKTtcbiAgICAgIHZhciBvZmZzZXQgPSBpMSAqIHN0cmlkZTtcblxuICAgICAgZm9yICh2YXIgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgUXVhdGVybmlvbi5zbGVycEZsYXQocmVzdWx0LCAwLCB2YWx1ZXMsIG9mZnNldCAtIHN0cmlkZSwgdmFsdWVzLCBvZmZzZXQsIGFscGhhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50O1xufShJbnRlcnBvbGFudCk7XG4vKipcbiAqIEEgVHJhY2sgb2YgcXVhdGVybmlvbiBrZXlmcmFtZSB2YWx1ZXMuXG4gKi9cblxuXG52YXIgUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LZXlmcmFtZVRyYWNrNCkge1xuICBfaW5oZXJpdHMoUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIF9LZXlmcmFtZVRyYWNrNCk7XG5cbiAgdmFyIF9zdXBlcjEwNyA9IF9jcmVhdGVTdXBlcihRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayk7XG5cbiAgZnVuY3Rpb24gUXVhdGVybmlvbktleWZyYW1lVHJhY2soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKTtcblxuICAgIHJldHVybiBfc3VwZXIxMDcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgW3tcbiAgICBrZXk6IFwiSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcihyZXN1bHQpIHtcbiAgICAgIHJldHVybiBuZXcgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50KHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcbn0oS2V5ZnJhbWVUcmFjayk7XG5cblF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5WYWx1ZVR5cGVOYW1lID0gJ3F1YXRlcm5pb24nOyAvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZS5EZWZhdWx0SW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRlTGluZWFyO1xuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aCA9IHVuZGVmaW5lZDtcbi8qKlxuICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXG4gKi9cblxudmFyIFN0cmluZ0tleWZyYW1lVHJhY2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9LZXlmcmFtZVRyYWNrNSkge1xuICBfaW5oZXJpdHMoU3RyaW5nS2V5ZnJhbWVUcmFjaywgX0tleWZyYW1lVHJhY2s1KTtcblxuICB2YXIgX3N1cGVyMTA4ID0gX2NyZWF0ZVN1cGVyKFN0cmluZ0tleWZyYW1lVHJhY2spO1xuXG4gIGZ1bmN0aW9uIFN0cmluZ0tleWZyYW1lVHJhY2soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmluZ0tleWZyYW1lVHJhY2spO1xuXG4gICAgcmV0dXJuIF9zdXBlcjEwOC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTdHJpbmdLZXlmcmFtZVRyYWNrKTtcbn0oS2V5ZnJhbWVUcmFjayk7XG5cblN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlVHlwZU5hbWUgPSAnc3RyaW5nJztcblN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlLlZhbHVlQnVmZmVyVHlwZSA9IEFycmF5O1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuRGVmYXVsdEludGVycG9sYXRpb24gPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyID0gdW5kZWZpbmVkO1xuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBBIFRyYWNrIG9mIHZlY3RvcmVkIGtleWZyYW1lIHZhbHVlcy5cbiAqL1xuXG52YXIgVmVjdG9yS2V5ZnJhbWVUcmFjayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0tleWZyYW1lVHJhY2s2KSB7XG4gIF9pbmhlcml0cyhWZWN0b3JLZXlmcmFtZVRyYWNrLCBfS2V5ZnJhbWVUcmFjazYpO1xuXG4gIHZhciBfc3VwZXIxMDkgPSBfY3JlYXRlU3VwZXIoVmVjdG9yS2V5ZnJhbWVUcmFjayk7XG5cbiAgZnVuY3Rpb24gVmVjdG9yS2V5ZnJhbWVUcmFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVjdG9yS2V5ZnJhbWVUcmFjayk7XG5cbiAgICByZXR1cm4gX3N1cGVyMTA5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFZlY3RvcktleWZyYW1lVHJhY2spO1xufShLZXlmcmFtZVRyYWNrKTtcblxuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUuVmFsdWVUeXBlTmFtZSA9ICd2ZWN0b3InO1xuXG52YXIgQW5pbWF0aW9uQ2xpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbkNsaXAobmFtZSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogLTE7XG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHZhciBibGVuZE1vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbmltYXRpb25DbGlwKTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHRoaXMuYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuICAgIHRoaXMudXVpZCA9IGdlbmVyYXRlVVVJRCgpOyAvLyB0aGlzIG1lYW5zIGl0IHNob3VsZCBmaWd1cmUgb3V0IGl0cyBkdXJhdGlvbiBieSBzY2FubmluZyB0aGUgdHJhY2tzXG5cbiAgICBpZiAodGhpcy5kdXJhdGlvbiA8IDApIHtcbiAgICAgIHRoaXMucmVzZXREdXJhdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbmltYXRpb25DbGlwLCBbe1xuICAgIGtleTogXCJyZXNldER1cmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0RHVyYXRpb24oKSB7XG4gICAgICB2YXIgdHJhY2tzID0gdGhpcy50cmFja3M7XG4gICAgICB2YXIgZHVyYXRpb24gPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTI2OSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBfaTI2OSAhPT0gbjsgKytfaTI2OSkge1xuICAgICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1tfaTI2OV07XG4gICAgICAgIGR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIHRyYWNrLnRpbWVzW3RyYWNrLnRpbWVzLmxlbmd0aCAtIDFdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyaW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICAgIGZvciAodmFyIF9pMjcwID0gMDsgX2kyNzAgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IF9pMjcwKyspIHtcbiAgICAgICAgdGhpcy50cmFja3NbX2kyNzBdLnRyaW0oMCwgdGhpcy5kdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgICAgIHZhciB2YWxpZCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIF9pMjcxID0gMDsgX2kyNzEgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IF9pMjcxKyspIHtcbiAgICAgICAgdmFsaWQgPSB2YWxpZCAmJiB0aGlzLnRyYWNrc1tfaTI3MV0udmFsaWRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcHRpbWl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpbWl6ZSgpIHtcbiAgICAgIGZvciAodmFyIF9pMjcyID0gMDsgX2kyNzIgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IF9pMjcyKyspIHtcbiAgICAgICAgdGhpcy50cmFja3NbX2kyNzJdLm9wdGltaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciB0cmFja3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kyNzMgPSAwOyBfaTI3MyA8IHRoaXMudHJhY2tzLmxlbmd0aDsgX2kyNzMrKykge1xuICAgICAgICB0cmFja3MucHVzaCh0aGlzLnRyYWNrc1tfaTI3M10uY2xvbmUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLm5hbWUsIHRoaXMuZHVyYXRpb24sIHRyYWNrcywgdGhpcy5ibGVuZE1vZGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9KU09OKHRoaXMpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGpzb24pIHtcbiAgICAgIHZhciB0cmFja3MgPSBbXSxcbiAgICAgICAgICBqc29uVHJhY2tzID0ganNvbi50cmFja3MsXG4gICAgICAgICAgZnJhbWVUaW1lID0gMS4wIC8gKGpzb24uZnBzIHx8IDEuMCk7XG5cbiAgICAgIGZvciAodmFyIF9pMjc0ID0gMCwgbiA9IGpzb25UcmFja3MubGVuZ3RoOyBfaTI3NCAhPT0gbjsgKytfaTI3NCkge1xuICAgICAgICB0cmFja3MucHVzaChwYXJzZUtleWZyYW1lVHJhY2soanNvblRyYWNrc1tfaTI3NF0pLnNjYWxlKGZyYW1lVGltZSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xpcCA9IG5ldyB0aGlzKGpzb24ubmFtZSwganNvbi5kdXJhdGlvbiwgdHJhY2tzLCBqc29uLmJsZW5kTW9kZSk7XG4gICAgICBjbGlwLnV1aWQgPSBqc29uLnV1aWQ7XG4gICAgICByZXR1cm4gY2xpcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihjbGlwKSB7XG4gICAgICB2YXIgdHJhY2tzID0gW10sXG4gICAgICAgICAgY2xpcFRyYWNrcyA9IGNsaXAudHJhY2tzO1xuICAgICAgdmFyIGpzb24gPSB7XG4gICAgICAgICduYW1lJzogY2xpcC5uYW1lLFxuICAgICAgICAnZHVyYXRpb24nOiBjbGlwLmR1cmF0aW9uLFxuICAgICAgICAndHJhY2tzJzogdHJhY2tzLFxuICAgICAgICAndXVpZCc6IGNsaXAudXVpZCxcbiAgICAgICAgJ2JsZW5kTW9kZSc6IGNsaXAuYmxlbmRNb2RlXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaTI3NSA9IDAsIG4gPSBjbGlwVHJhY2tzLmxlbmd0aDsgX2kyNzUgIT09IG47ICsrX2kyNzUpIHtcbiAgICAgICAgdHJhY2tzLnB1c2goS2V5ZnJhbWVUcmFjay50b0pTT04oY2xpcFRyYWNrc1tfaTI3NV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKG5hbWUsIG1vcnBoVGFyZ2V0U2VxdWVuY2UsIGZwcywgbm9Mb29wKSB7XG4gICAgICB2YXIgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhUYXJnZXRTZXF1ZW5jZS5sZW5ndGg7XG4gICAgICB2YXIgdHJhY2tzID0gW107XG5cbiAgICAgIGZvciAodmFyIF9pMjc2ID0gMDsgX2kyNzYgPCBudW1Nb3JwaFRhcmdldHM7IF9pMjc2KyspIHtcbiAgICAgICAgdmFyIHRpbWVzID0gW107XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGltZXMucHVzaCgoX2kyNzYgKyBudW1Nb3JwaFRhcmdldHMgLSAxKSAlIG51bU1vcnBoVGFyZ2V0cywgX2kyNzYsIChfaTI3NiArIDEpICUgbnVtTW9ycGhUYXJnZXRzKTtcbiAgICAgICAgdmFsdWVzLnB1c2goMCwgMSwgMCk7XG4gICAgICAgIHZhciBvcmRlciA9IEFuaW1hdGlvblV0aWxzLmdldEtleWZyYW1lT3JkZXIodGltZXMpO1xuICAgICAgICB0aW1lcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KHRpbWVzLCAxLCBvcmRlcik7XG4gICAgICAgIHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KHZhbHVlcywgMSwgb3JkZXIpOyAvLyBpZiB0aGVyZSBpcyBhIGtleSBhdCB0aGUgZmlyc3QgZnJhbWUsIGR1cGxpY2F0ZSBpdCBhcyB0aGVcbiAgICAgICAgLy8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXG5cbiAgICAgICAgaWYgKCFub0xvb3AgJiYgdGltZXNbMF0gPT09IDApIHtcbiAgICAgICAgICB0aW1lcy5wdXNoKG51bU1vcnBoVGFyZ2V0cyk7XG4gICAgICAgICAgdmFsdWVzLnB1c2godmFsdWVzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYWNrcy5wdXNoKG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlW19pMjc2XS5uYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzKS5zY2FsZSgxLjAgLyBmcHMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyB0aGlzKG5hbWUsIC0xLCB0cmFja3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQnlOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCeU5hbWUob2JqZWN0T3JDbGlwQXJyYXksIG5hbWUpIHtcbiAgICAgIHZhciBjbGlwQXJyYXkgPSBvYmplY3RPckNsaXBBcnJheTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdE9yQ2xpcEFycmF5KSkge1xuICAgICAgICB2YXIgbyA9IG9iamVjdE9yQ2xpcEFycmF5O1xuICAgICAgICBjbGlwQXJyYXkgPSBvLmdlb21ldHJ5ICYmIG8uZ2VvbWV0cnkuYW5pbWF0aW9ucyB8fCBvLmFuaW1hdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMjc3ID0gMDsgX2kyNzcgPCBjbGlwQXJyYXkubGVuZ3RoOyBfaTI3NysrKSB7XG4gICAgICAgIGlmIChjbGlwQXJyYXlbX2kyNzddLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gY2xpcEFycmF5W19pMjc3XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMobW9ycGhUYXJnZXRzLCBmcHMsIG5vTG9vcCkge1xuICAgICAgdmFyIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307IC8vIHRlc3RlZCB3aXRoIGh0dHBzOi8vcmVnZXgxMDEuY29tLyBvbiB0cmljayBzZXF1ZW5jZXNcbiAgICAgIC8vIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxuXG4gICAgICB2YXIgcGF0dGVybiA9IC9eKFtcXHctXSo/KShbXFxkXSspJC87IC8vIHNvcnQgbW9ycGggdGFyZ2V0IG5hbWVzIGludG8gYW5pbWF0aW9uIGdyb3VwcyBiYXNlZFxuICAgICAgLy8gcGF0dGVybnMgbGlrZSBXYWxrXzAwMSwgV2Fsa18wMDIsIFJ1bl8wMDEsIFJ1bl8wMDJcblxuICAgICAgZm9yICh2YXIgX2kyNzggPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IF9pMjc4IDwgaWw7IF9pMjc4KyspIHtcbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzW19pMjc4XTtcbiAgICAgICAgdmFyIHBhcnRzID0gbW9ycGhUYXJnZXQubmFtZS5tYXRjaChwYXR0ZXJuKTtcblxuICAgICAgICBpZiAocGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBuYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzW25hbWVdO1xuXG4gICAgICAgICAgaWYgKCFhbmltYXRpb25Nb3JwaFRhcmdldHMpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzW25hbWVdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5pbWF0aW9uTW9ycGhUYXJnZXRzLnB1c2gobW9ycGhUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGlwcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfbmFtZTQgaW4gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHMpIHtcbiAgICAgICAgY2xpcHMucHVzaCh0aGlzLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKF9uYW1lNCwgYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbX25hbWU0XSwgZnBzLCBub0xvb3ApKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsaXBzO1xuICAgIH0gLy8gcGFyc2UgdGhlIGFuaW1hdGlvbi5oaWVyYXJjaHkgZm9ybWF0XG5cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUFuaW1hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUFuaW1hdGlvbihhbmltYXRpb24sIGJvbmVzKSB7XG4gICAgICBpZiAoIWFuaW1hdGlvbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5BbmltYXRpb25DbGlwOiBObyBhbmltYXRpb24gaW4gSlNPTkxvYWRlciBkYXRhLicpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFkZE5vbmVtcHR5VHJhY2sgPSBmdW5jdGlvbiBhZGROb25lbXB0eVRyYWNrKHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MpIHtcbiAgICAgICAgLy8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXG4gICAgICAgIGlmIChhbmltYXRpb25LZXlzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHZhciB0aW1lcyA9IFtdO1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICBBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTihhbmltYXRpb25LZXlzLCB0aW1lcywgdmFsdWVzLCBwcm9wZXJ0eU5hbWUpOyAvLyBlbXB0eSBrZXlzIGFyZSBmaWx0ZXJlZCBvdXQsIHNvIGNoZWNrIGFnYWluXG5cbiAgICAgICAgICBpZiAodGltZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICBkZXN0VHJhY2tzLnB1c2gobmV3IHRyYWNrVHlwZSh0cmFja05hbWUsIHRpbWVzLCB2YWx1ZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFja3MgPSBbXTtcbiAgICAgIHZhciBjbGlwTmFtZSA9IGFuaW1hdGlvbi5uYW1lIHx8ICdkZWZhdWx0JztcbiAgICAgIHZhciBmcHMgPSBhbmltYXRpb24uZnBzIHx8IDMwO1xuICAgICAgdmFyIGJsZW5kTW9kZSA9IGFuaW1hdGlvbi5ibGVuZE1vZGU7IC8vIGF1dG9tYXRpYyBsZW5ndGggZGV0ZXJtaW5hdGlvbiBpbiBBbmltYXRpb25DbGlwLlxuXG4gICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRpb24ubGVuZ3RoIHx8IC0xO1xuICAgICAgdmFyIGhpZXJhcmNoeVRyYWNrcyA9IGFuaW1hdGlvbi5oaWVyYXJjaHkgfHwgW107XG5cbiAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgaGllcmFyY2h5VHJhY2tzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25LZXlzID0gaGllcmFyY2h5VHJhY2tzW2hdLmtleXM7IC8vIHNraXAgZW1wdHkgdHJhY2tzXG5cbiAgICAgICAgaWYgKCFhbmltYXRpb25LZXlzIHx8IGFuaW1hdGlvbktleXMubGVuZ3RoID09PSAwKSBjb250aW51ZTsgLy8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzXG5cbiAgICAgICAgaWYgKGFuaW1hdGlvbktleXNbMF0ubW9ycGhUYXJnZXRzKSB7XG4gICAgICAgICAgLy8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcbiAgICAgICAgICB2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xuICAgICAgICAgIHZhciBrID0gdm9pZCAwO1xuXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGFuaW1hdGlvbktleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSsrKSB7XG4gICAgICAgICAgICAgICAgbW9ycGhUYXJnZXROYW1lc1thbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0c1ttXV0gPSAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cbiAgICAgICAgICAvLyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaFxuICAgICAgICAgIC8vIHRoZSBtb3JwaFRhcmdldCBpcyBuYW1lZC5cblxuXG4gICAgICAgICAgZm9yICh2YXIgbW9ycGhUYXJnZXROYW1lIGluIG1vcnBoVGFyZ2V0TmFtZXMpIHtcbiAgICAgICAgICAgIHZhciB0aW1lcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfbSA9IDA7IF9tICE9PSBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7ICsrX20pIHtcbiAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbktleSA9IGFuaW1hdGlvbktleXNba107XG4gICAgICAgICAgICAgIHRpbWVzLnB1c2goYW5pbWF0aW9uS2V5LnRpbWUpO1xuICAgICAgICAgICAgICB2YWx1ZXMucHVzaChhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSA/IDEgOiAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhY2tzLnB1c2gobmV3IE51bWJlcktleWZyYW1lVHJhY2soJy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqIGZwcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAuLi5hc3N1bWUgc2tlbGV0YWwgYW5pbWF0aW9uXG4gICAgICAgICAgdmFyIGJvbmVOYW1lID0gJy5ib25lc1snICsgYm9uZXNbaF0ubmFtZSArICddJztcbiAgICAgICAgICBhZGROb25lbXB0eVRyYWNrKFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5wb3NpdGlvbicsIGFuaW1hdGlvbktleXMsICdwb3MnLCB0cmFja3MpO1xuICAgICAgICAgIGFkZE5vbmVtcHR5VHJhY2soUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5xdWF0ZXJuaW9uJywgYW5pbWF0aW9uS2V5cywgJ3JvdCcsIHRyYWNrcyk7XG4gICAgICAgICAgYWRkTm9uZW1wdHlUcmFjayhWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcuc2NhbGUnLCBhbmltYXRpb25LZXlzLCAnc2NsJywgdHJhY2tzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsaXAgPSBuZXcgdGhpcyhjbGlwTmFtZSwgZHVyYXRpb24sIHRyYWNrcywgYmxlbmRNb2RlKTtcbiAgICAgIHJldHVybiBjbGlwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbmltYXRpb25DbGlwO1xufSgpO1xuXG5mdW5jdGlvbiBnZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lKHR5cGVOYW1lKSB7XG4gIHN3aXRjaCAodHlwZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgY2FzZSAnZG91YmxlJzpcbiAgICBjYXNlICdmbG9hdCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgIHJldHVybiBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXG4gICAgY2FzZSAndmVjdG9yJzpcbiAgICBjYXNlICd2ZWN0b3IyJzpcbiAgICBjYXNlICd2ZWN0b3IzJzpcbiAgICBjYXNlICd2ZWN0b3I0JzpcbiAgICAgIHJldHVybiBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuXG4gICAgY2FzZSAnY29sb3InOlxuICAgICAgcmV0dXJuIENvbG9yS2V5ZnJhbWVUcmFjaztcblxuICAgIGNhc2UgJ3F1YXRlcm5pb24nOlxuICAgICAgcmV0dXJuIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuXG4gICAgY2FzZSAnYm9vbCc6XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gQm9vbGVhbktleWZyYW1lVHJhY2s7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIFN0cmluZ0tleWZyYW1lVHJhY2s7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IFVuc3VwcG9ydGVkIHR5cGVOYW1lOiAnICsgdHlwZU5hbWUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUtleWZyYW1lVHJhY2soanNvbikge1xuICBpZiAoanNvbi50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIHR5cGUgdW5kZWZpbmVkLCBjYW4gbm90IHBhcnNlJyk7XG4gIH1cblxuICB2YXIgdHJhY2tUeXBlID0gZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZShqc29uLnR5cGUpO1xuXG4gIGlmIChqc29uLnRpbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgdGltZXMgPSBbXSxcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgQW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oanNvbi5rZXlzLCB0aW1lcywgdmFsdWVzLCAndmFsdWUnKTtcbiAgICBqc29uLnRpbWVzID0gdGltZXM7XG4gICAganNvbi52YWx1ZXMgPSB2YWx1ZXM7XG4gIH0gLy8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgcGFyc2UgbWV0aG9kXG5cblxuICBpZiAodHJhY2tUeXBlLnBhcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdHJhY2tUeXBlLnBhcnNlKGpzb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSBhIGNvbnN0cnVjdG9yIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFzZVxuICAgIHJldHVybiBuZXcgdHJhY2tUeXBlKGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbik7XG4gIH1cbn1cblxudmFyIENhY2hlID0ge1xuICBlbmFibGVkOiBmYWxzZSxcbiAgZmlsZXM6IHt9LFxuICBhZGQ6IGZ1bmN0aW9uIGFkZChrZXksIGZpbGUpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuOyAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XG5cbiAgICB0aGlzLmZpbGVzW2tleV0gPSBmaWxlO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkID09PSBmYWxzZSkgcmV0dXJuOyAvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0NoZWNraW5nIGtleTonLCBrZXkgKTtcblxuICAgIHJldHVybiB0aGlzLmZpbGVzW2tleV07XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLmZpbGVzW2tleV07XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmZpbGVzID0ge307XG4gIH1cbn07XG5cbnZhciBMb2FkaW5nTWFuYWdlciA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gTG9hZGluZ01hbmFnZXIob25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkaW5nTWFuYWdlcik7XG5cbiAgdmFyIHNjb3BlID0gdGhpcztcbiAgdmFyIGlzTG9hZGluZyA9IGZhbHNlO1xuICB2YXIgaXRlbXNMb2FkZWQgPSAwO1xuICB2YXIgaXRlbXNUb3RhbCA9IDA7XG4gIHZhciB1cmxNb2RpZmllciA9IHVuZGVmaW5lZDtcbiAgdmFyIGhhbmRsZXJzID0gW107IC8vIFJlZmVyIHRvICM1Njg5IGZvciB0aGUgcmVhc29uIHdoeSB3ZSBkb24ndCBzZXQgLm9uU3RhcnRcbiAgLy8gaW4gdGhlIGNvbnN0cnVjdG9yXG5cbiAgdGhpcy5vblN0YXJ0ID0gdW5kZWZpbmVkO1xuICB0aGlzLm9uTG9hZCA9IG9uTG9hZDtcbiAgdGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcblxuICB0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBpdGVtc1RvdGFsKys7XG5cbiAgICBpZiAoaXNMb2FkaW5nID09PSBmYWxzZSkge1xuICAgICAgaWYgKHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzY29wZS5vblN0YXJ0KHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlzTG9hZGluZyA9IHRydWU7XG4gIH07XG5cbiAgdGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGl0ZW1zTG9hZGVkKys7XG5cbiAgICBpZiAoc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY29wZS5vblByb2dyZXNzKHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwpO1xuICAgIH1cblxuICAgIGlmIChpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCkge1xuICAgICAgaXNMb2FkaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmIChzY29wZS5vbkxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzY29wZS5vbkxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2NvcGUub25FcnJvcih1cmwpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnJlc29sdmVVUkwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKHVybE1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gdXJsTW9kaWZpZXIodXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xuICB9O1xuXG4gIHRoaXMuc2V0VVJMTW9kaWZpZXIgPSBmdW5jdGlvbiAodHJhbnNmb3JtKSB7XG4gICAgdXJsTW9kaWZpZXIgPSB0cmFuc2Zvcm07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5hZGRIYW5kbGVyID0gZnVuY3Rpb24gKHJlZ2V4LCBsb2FkZXIpIHtcbiAgICBoYW5kbGVycy5wdXNoKHJlZ2V4LCBsb2FkZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMucmVtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChyZWdleCkge1xuICAgIHZhciBpbmRleCA9IGhhbmRsZXJzLmluZGV4T2YocmVnZXgpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmdldEhhbmRsZXIgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgIGZvciAodmFyIF9pMjc5ID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgX2kyNzkgPCBsOyBfaTI3OSArPSAyKSB7XG4gICAgICB2YXIgcmVnZXggPSBoYW5kbGVyc1tfaTI3OV07XG4gICAgICB2YXIgbG9hZGVyID0gaGFuZGxlcnNbX2kyNzkgKyAxXTtcbiAgICAgIGlmIChyZWdleC5nbG9iYWwpIHJlZ2V4Lmxhc3RJbmRleCA9IDA7IC8vIHNlZSAjMTc5MjBcblxuICAgICAgaWYgKHJlZ2V4LnRlc3QoZmlsZSkpIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn0pO1xuXG52YXIgRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCk7XG5cbnZhciBMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb2FkZXIobWFuYWdlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkZXIpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlciAhPT0gdW5kZWZpbmVkID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICB0aGlzLnBhdGggPSAnJztcbiAgICB0aGlzLnJlc291cmNlUGF0aCA9ICcnO1xuICAgIHRoaXMucmVxdWVzdEhlYWRlciA9IHt9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExvYWRlciwgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvblxuICAgICAgLyogdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKi9cbiAgICBsb2FkKCkge31cbiAgfSwge1xuICAgIGtleTogXCJsb2FkQXN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEFzeW5jKHVybCwgb25Qcm9ncmVzcykge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNjb3BlLmxvYWQodXJsLCByZXNvbHZlLCBvblByb2dyZXNzLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uXG4gICAgICAvKiBkYXRhICovXG4gICAgcGFyc2UoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInNldENyb3NzT3JpZ2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENyb3NzT3JpZ2luKGNyb3NzT3JpZ2luKSB7XG4gICAgICB0aGlzLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0V2l0aENyZWRlbnRpYWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFdpdGhDcmVkZW50aWFscyh2YWx1ZSkge1xuICAgICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBhdGgocGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRSZXNvdXJjZVBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmVzb3VyY2VQYXRoKHJlc291cmNlUGF0aCkge1xuICAgICAgdGhpcy5yZXNvdXJjZVBhdGggPSByZXNvdXJjZVBhdGg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UmVxdWVzdEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHJlcXVlc3RIZWFkZXIpIHtcbiAgICAgIHRoaXMucmVxdWVzdEhlYWRlciA9IHJlcXVlc3RIZWFkZXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTG9hZGVyO1xufSgpO1xuXG52YXIgbG9hZGluZyA9IHt9O1xuXG52YXIgRmlsZUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcikge1xuICBfaW5oZXJpdHMoRmlsZUxvYWRlciwgX0xvYWRlcik7XG5cbiAgdmFyIF9zdXBlcjExMCA9IF9jcmVhdGVTdXBlcihGaWxlTG9hZGVyKTtcblxuICBmdW5jdGlvbiBGaWxlTG9hZGVyKG1hbmFnZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsZUxvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyMTEwLmNhbGwodGhpcywgbWFuYWdlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmlsZUxvYWRlciwgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgICB2YXIgX3RoaXM5MiA9IHRoaXM7XG5cbiAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCkgdXJsID0gJyc7XG4gICAgICBpZiAodGhpcy5wYXRoICE9PSB1bmRlZmluZWQpIHVybCA9IHRoaXMucGF0aCArIHVybDtcbiAgICAgIHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKHVybCk7XG4gICAgICB2YXIgY2FjaGVkID0gQ2FjaGUuZ2V0KHVybCk7XG5cbiAgICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvbkxvYWQpIG9uTG9hZChjYWNoZWQpO1xuXG4gICAgICAgICAgX3RoaXM5Mi5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICB9IC8vIENoZWNrIGlmIHJlcXVlc3QgaXMgZHVwbGljYXRlXG5cblxuICAgICAgaWYgKGxvYWRpbmdbdXJsXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvYWRpbmdbdXJsXS5wdXNoKHtcbiAgICAgICAgICBvbkxvYWQ6IG9uTG9hZCxcbiAgICAgICAgICBvblByb2dyZXNzOiBvblByb2dyZXNzLFxuICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSW5pdGlhbGlzZSBhcnJheSBmb3IgZHVwbGljYXRlIHJlcXVlc3RzXG5cblxuICAgICAgbG9hZGluZ1t1cmxdID0gW107XG4gICAgICBsb2FkaW5nW3VybF0ucHVzaCh7XG4gICAgICAgIG9uTG9hZDogb25Mb2FkLFxuICAgICAgICBvblByb2dyZXNzOiBvblByb2dyZXNzLFxuICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICB9KTsgLy8gY3JlYXRlIHJlcXVlc3RcblxuICAgICAgdmFyIHJlcSA9IG5ldyBSZXF1ZXN0KHVybCwge1xuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLnJlcXVlc3RIZWFkZXIpLFxuICAgICAgICBjcmVkZW50aWFsczogdGhpcy53aXRoQ3JlZGVudGlhbHMgPyAnaW5jbHVkZScgOiAnc2FtZS1vcmlnaW4nIC8vIEFuIGFib3J0IGNvbnRyb2xsZXIgY291bGQgYmUgYWRkZWQgd2l0aGluIGEgZnV0dXJlIFBSXG5cbiAgICAgIH0pOyAvLyByZWNvcmQgc3RhdGVzICggYXZvaWQgZGF0YSByYWNlIClcblxuICAgICAgdmFyIG1pbWVUeXBlID0gdGhpcy5taW1lVHlwZTtcbiAgICAgIHZhciByZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTsgLy8gc3RhcnQgdGhlIGZldGNoXG5cbiAgICAgIGZldGNoKHJlcSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIEhUVFAgU3RhdHVzIDAgd2hlbiB1c2luZyBub24taHR0cCBwcm90b2NvbFxuICAgICAgICAgIC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5GaWxlTG9hZGVyOiBIVFRQIFN0YXR1cyAwIHJlY2VpdmVkLicpO1xuICAgICAgICAgIH0gLy8gV29ya2Fyb3VuZDogQ2hlY2tpbmcgaWYgcmVzcG9uc2UuYm9keSA9PT0gdW5kZWZpbmVkIGZvciBBbGlwYXkgYnJvd3NlciAjMjM1NDhcblxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzcG9uc2UuYm9keSA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gbG9hZGluZ1t1cmxdO1xuICAgICAgICAgIHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICAgIHZhciBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgICAgICAgdmFyIHRvdGFsID0gY29udGVudExlbmd0aCA/IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpIDogMDtcbiAgICAgICAgICB2YXIgbGVuZ3RoQ29tcHV0YWJsZSA9IHRvdGFsICE9PSAwO1xuICAgICAgICAgIHZhciBsb2FkZWQgPSAwOyAvLyBwZXJpb2RpY2FsbHkgcmVhZCBkYXRhIGludG8gdGhlIG5ldyBzdHJlYW0gdHJhY2tpbmcgd2hpbGUgZG93bmxvYWQgcHJvZ3Jlc3NcblxuICAgICAgICAgIHZhciBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgcmVhZERhdGEoKTtcblxuICAgICAgICAgICAgICBmdW5jdGlvbiByZWFkRGF0YSgpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IF9yZWYyLmRvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfcmVmMi52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBQcm9ncmVzc0V2ZW50KCdwcm9ncmVzcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhDb21wdXRhYmxlOiBsZW5ndGhDb21wdXRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogbG9hZGVkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTI4MCA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgX2kyODAgPCBpbDsgX2kyODArKykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1tfaTI4MF07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLm9uUHJvZ3Jlc3MpIGNhbGxiYWNrLm9uUHJvZ3Jlc3MoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZERhdGEoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcImZldGNoIGZvciBcXFwiXCIuY29uY2F0KHJlc3BvbnNlLnVybCwgXCJcXFwiIHJlc3BvbmRlZCB3aXRoIFwiKS5jb25jYXQocmVzcG9uc2Uuc3RhdHVzLCBcIjogXCIpLmNvbmNhdChyZXNwb25zZS5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHN3aXRjaCAocmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG5cbiAgICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG5cbiAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgbWltZVR5cGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHNuaWZmIGVuY29kaW5nXG4gICAgICAgICAgICAgIHZhciByZSA9IC9jaGFyc2V0PVwiPyhbXjtcIlxcc10qKVwiPy9pO1xuICAgICAgICAgICAgICB2YXIgZXhlYyA9IHJlLmV4ZWMobWltZVR5cGUpO1xuICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBleGVjICYmIGV4ZWNbMV0gPyBleGVjWzFdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHZhciBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGxhYmVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkudGhlbihmdW5jdGlvbiAoYWIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYWIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIEFkZCB0byBjYWNoZSBvbmx5IG9uIEhUVFAgc3VjY2Vzcywgc28gdGhhdCB3ZSBkbyBub3QgY2FjaGVcbiAgICAgICAgLy8gZXJyb3IgcmVzcG9uc2UgYm9kaWVzIGFzIHByb3BlciByZXNwb25zZXMgdG8gcmVxdWVzdHMuXG4gICAgICAgIENhY2hlLmFkZCh1cmwsIGRhdGEpO1xuICAgICAgICB2YXIgY2FsbGJhY2tzID0gbG9hZGluZ1t1cmxdO1xuICAgICAgICBkZWxldGUgbG9hZGluZ1t1cmxdO1xuXG4gICAgICAgIGZvciAodmFyIF9pMjgxID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBfaTI4MSA8IGlsOyBfaTI4MSsrKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzW19pMjgxXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sub25Mb2FkKSBjYWxsYmFjay5vbkxvYWQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gQWJvcnQgZXJyb3JzIGFuZCBvdGhlciBlcnJvcnMgYXJlIGhhbmRsZWQgdGhlIHNhbWVcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGxvYWRpbmdbdXJsXTtcblxuICAgICAgICBpZiAoY2FsbGJhY2tzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIG9uTG9hZCB3YXMgY2FsbGVkIGFuZCB1cmwgd2FzIGRlbGV0ZWQgaW4gYGxvYWRpbmdgXG4gICAgICAgICAgX3RoaXM5Mi5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuXG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGxvYWRpbmdbdXJsXTtcblxuICAgICAgICBmb3IgKHZhciBfaTI4MiA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgX2kyODIgPCBpbDsgX2kyODIrKykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1tfaTI4Ml07XG4gICAgICAgICAgaWYgKGNhbGxiYWNrLm9uRXJyb3IpIGNhbGxiYWNrLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzOTIubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczkyLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFJlc3BvbnNlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRSZXNwb25zZVR5cGUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TWltZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWltZVR5cGUodmFsdWUpIHtcbiAgICAgIHRoaXMubWltZVR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWxlTG9hZGVyO1xufShMb2FkZXIpO1xuXG52YXIgQW5pbWF0aW9uTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9hZGVyMikge1xuICBfaW5oZXJpdHMoQW5pbWF0aW9uTG9hZGVyLCBfTG9hZGVyMik7XG5cbiAgdmFyIF9zdXBlcjExMSA9IF9jcmVhdGVTdXBlcihBbmltYXRpb25Mb2FkZXIpO1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGlvbkxvYWRlcihtYW5hZ2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuaW1hdGlvbkxvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyMTExLmNhbGwodGhpcywgbWFuYWdlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQW5pbWF0aW9uTG9hZGVyLCBbe1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICB2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICBsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb25Mb2FkKHNjb3BlLnBhcnNlKEpTT04ucGFyc2UodGV4dCkpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgIH1cbiAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShqc29uKSB7XG4gICAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaTI4MyA9IDA7IF9pMjgzIDwganNvbi5sZW5ndGg7IF9pMjgzKyspIHtcbiAgICAgICAgdmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlKGpzb25bX2kyODNdKTtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGNsaXApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5pbWF0aW9uTG9hZGVyO1xufShMb2FkZXIpO1xuLyoqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcbiAqXG4gKiBTdWIgY2xhc3NlcyBoYXZlIHRvIGltcGxlbWVudCB0aGUgcGFyc2UoKSBtZXRob2Qgd2hpY2ggd2lsbCBiZSB1c2VkIGluIGxvYWQoKS5cbiAqL1xuXG5cbnZhciBDb21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcjMpIHtcbiAgX2luaGVyaXRzKENvbXByZXNzZWRUZXh0dXJlTG9hZGVyLCBfTG9hZGVyMyk7XG5cbiAgdmFyIF9zdXBlcjExMiA9IF9jcmVhdGVTdXBlcihDb21wcmVzc2VkVGV4dHVyZUxvYWRlcik7XG5cbiAgZnVuY3Rpb24gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIobWFuYWdlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wcmVzc2VkVGV4dHVyZUxvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyMTEyLmNhbGwodGhpcywgbWFuYWdlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsIFt7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgIHZhciBpbWFnZXMgPSBbXTtcbiAgICAgIHZhciB0ZXh0dXJlID0gbmV3IENvbXByZXNzZWRUZXh0dXJlKCk7XG4gICAgICB2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgIHZhciBsb2FkZWQgPSAwO1xuXG4gICAgICBmdW5jdGlvbiBsb2FkVGV4dHVyZShpKSB7XG4gICAgICAgIGxvYWRlci5sb2FkKHVybFtpXSwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIHZhciB0ZXhEYXRhcyA9IHNjb3BlLnBhcnNlKGJ1ZmZlciwgdHJ1ZSk7XG4gICAgICAgICAgaW1hZ2VzW2ldID0ge1xuICAgICAgICAgICAgd2lkdGg6IHRleERhdGFzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRleERhdGFzLmZvcm1hdCxcbiAgICAgICAgICAgIG1pcG1hcHM6IHRleERhdGFzLm1pcG1hcHNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxvYWRlZCArPSAxO1xuXG4gICAgICAgICAgaWYgKGxvYWRlZCA9PT0gNikge1xuICAgICAgICAgICAgaWYgKHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxKSB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9uTG9hZCkgb25Mb2FkKHRleHR1cmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHVybCkpIHtcbiAgICAgICAgZm9yICh2YXIgX2kyODQgPSAwLCBpbCA9IHVybC5sZW5ndGg7IF9pMjg0IDwgaWw7ICsrX2kyODQpIHtcbiAgICAgICAgICBsb2FkVGV4dHVyZShfaTI4NCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbXByZXNzZWQgY3ViZW1hcCB0ZXh0dXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBERFMgZmlsZVxuICAgICAgICBsb2FkZXIubG9hZCh1cmwsIGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICB2YXIgdGV4RGF0YXMgPSBzY29wZS5wYXJzZShidWZmZXIsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHRleERhdGFzLmlzQ3ViZW1hcCkge1xuICAgICAgICAgICAgdmFyIGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcblxuICAgICAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCBmYWNlczsgZisrKSB7XG4gICAgICAgICAgICAgIGltYWdlc1tmXSA9IHtcbiAgICAgICAgICAgICAgICBtaXBtYXBzOiBbXVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjg1ID0gMDsgX2kyODUgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgX2kyODUrKykge1xuICAgICAgICAgICAgICAgIGltYWdlc1tmXS5taXBtYXBzLnB1c2godGV4RGF0YXMubWlwbWFwc1tmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBfaTI4NV0pO1xuICAgICAgICAgICAgICAgIGltYWdlc1tmXS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgaW1hZ2VzW2ZdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgaW1hZ2VzW2ZdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcbiAgICAgICAgICAgIHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob25Mb2FkKSBvbkxvYWQodGV4dHVyZSk7XG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXI7XG59KExvYWRlcik7XG5cbnZhciBJbWFnZUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcjQpIHtcbiAgX2luaGVyaXRzKEltYWdlTG9hZGVyLCBfTG9hZGVyNCk7XG5cbiAgdmFyIF9zdXBlcjExMyA9IF9jcmVhdGVTdXBlcihJbWFnZUxvYWRlcik7XG5cbiAgZnVuY3Rpb24gSW1hZ2VMb2FkZXIobWFuYWdlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZUxvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyMTEzLmNhbGwodGhpcywgbWFuYWdlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW1hZ2VMb2FkZXIsIFt7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgaWYgKHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG4gICAgICB1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCh1cmwpO1xuICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgIHZhciBjYWNoZWQgPSBDYWNoZS5nZXQodXJsKTtcblxuICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvbkxvYWQpIG9uTG9hZChjYWNoZWQpO1xuICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGltYWdlID0gY3JlYXRlRWxlbWVudE5TKCdpbWcnKTtcblxuICAgICAgZnVuY3Rpb24gb25JbWFnZUxvYWQoKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIENhY2hlLmFkZCh1cmwsIHRoaXMpO1xuICAgICAgICBpZiAob25Mb2FkKSBvbkxvYWQodGhpcyk7XG4gICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvbkltYWdlRXJyb3IoZXZlbnQpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKG9uRXJyb3IpIG9uRXJyb3IoZXZlbnQpO1xuICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkltYWdlTG9hZCwgZmFsc2UpO1xuICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uSW1hZ2VFcnJvciwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25JbWFnZUxvYWQsIGZhbHNlKTtcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25JbWFnZUVycm9yLCBmYWxzZSk7XG5cbiAgICAgIGlmICh1cmwuc2xpY2UoMCwgNSkgIT09ICdkYXRhOicpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xuICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZUxvYWRlcjtcbn0oTG9hZGVyKTtcblxudmFyIEN1YmVUZXh0dXJlTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9hZGVyNSkge1xuICBfaW5oZXJpdHMoQ3ViZVRleHR1cmVMb2FkZXIsIF9Mb2FkZXI1KTtcblxuICB2YXIgX3N1cGVyMTE0ID0gX2NyZWF0ZVN1cGVyKEN1YmVUZXh0dXJlTG9hZGVyKTtcblxuICBmdW5jdGlvbiBDdWJlVGV4dHVyZUxvYWRlcihtYW5hZ2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmVUZXh0dXJlTG9hZGVyKTtcblxuICAgIHJldHVybiBfc3VwZXIxMTQuY2FsbCh0aGlzLCBtYW5hZ2VyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDdWJlVGV4dHVyZUxvYWRlciwgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgdmFyIHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcbiAgICAgIHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcbiAgICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICB2YXIgbG9hZGVkID0gMDtcblxuICAgICAgZnVuY3Rpb24gbG9hZFRleHR1cmUoaSkge1xuICAgICAgICBsb2FkZXIubG9hZCh1cmxzW2ldLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlc1tpXSA9IGltYWdlO1xuICAgICAgICAgIGxvYWRlZCsrO1xuXG4gICAgICAgICAgaWYgKGxvYWRlZCA9PT0gNikge1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAob25Mb2FkKSBvbkxvYWQodGV4dHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB1bmRlZmluZWQsIG9uRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTI4NiA9IDA7IF9pMjg2IDwgdXJscy5sZW5ndGg7ICsrX2kyODYpIHtcbiAgICAgICAgbG9hZFRleHR1cmUoX2kyODYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3ViZVRleHR1cmVMb2FkZXI7XG59KExvYWRlcik7XG4vKipcbiAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcbiAqXG4gKiBTdWIgY2xhc3NlcyBoYXZlIHRvIGltcGxlbWVudCB0aGUgcGFyc2UoKSBtZXRob2Qgd2hpY2ggd2lsbCBiZSB1c2VkIGluIGxvYWQoKS5cbiAqL1xuXG5cbnZhciBEYXRhVGV4dHVyZUxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcjYpIHtcbiAgX2luaGVyaXRzKERhdGFUZXh0dXJlTG9hZGVyLCBfTG9hZGVyNik7XG5cbiAgdmFyIF9zdXBlcjExNSA9IF9jcmVhdGVTdXBlcihEYXRhVGV4dHVyZUxvYWRlcik7XG5cbiAgZnVuY3Rpb24gRGF0YVRleHR1cmVMb2FkZXIobWFuYWdlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhVGV4dHVyZUxvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyMTE1LmNhbGwodGhpcywgbWFuYWdlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGF0YVRleHR1cmVMb2FkZXIsIFt7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgIHZhciB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XG4gICAgICB2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICB2YXIgdGV4RGF0YSA9IHNjb3BlLnBhcnNlKGJ1ZmZlcik7XG4gICAgICAgIGlmICghdGV4RGF0YSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh0ZXhEYXRhLmltYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXhEYXRhLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5kYXRhID0gdGV4RGF0YS5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS53cmFwUyA9IHRleERhdGEud3JhcFMgIT09IHVuZGVmaW5lZCA/IHRleERhdGEud3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuICAgICAgICB0ZXh0dXJlLndyYXBUID0gdGV4RGF0YS53cmFwVCAhPT0gdW5kZWZpbmVkID8gdGV4RGF0YS53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gdGV4RGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IHRleERhdGEubWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IHRleERhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IExpbmVhckZpbHRlcjtcbiAgICAgICAgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gdGV4RGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xuXG4gICAgICAgIGlmICh0ZXhEYXRhLmVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gdGV4RGF0YS5lbmNvZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXhEYXRhLmZsaXBZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0ZXh0dXJlLmZsaXBZID0gdGV4RGF0YS5mbGlwWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXhEYXRhLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXhEYXRhLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRleHR1cmUudHlwZSA9IHRleERhdGEudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXhEYXRhLm1pcG1hcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRleHR1cmUubWlwbWFwcyA9IHRleERhdGEubWlwbWFwcztcbiAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjsgLy8gcHJlc3VtYWJseS4uLlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleERhdGEubWlwbWFwQ291bnQgPT09IDEpIHtcbiAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXhEYXRhLmdlbmVyYXRlTWlwbWFwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0ZXhEYXRhLmdlbmVyYXRlTWlwbWFwcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBpZiAob25Mb2FkKSBvbkxvYWQodGV4dHVyZSwgdGV4RGF0YSk7XG4gICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEYXRhVGV4dHVyZUxvYWRlcjtcbn0oTG9hZGVyKTtcblxudmFyIFRleHR1cmVMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Mb2FkZXI3KSB7XG4gIF9pbmhlcml0cyhUZXh0dXJlTG9hZGVyLCBfTG9hZGVyNyk7XG5cbiAgdmFyIF9zdXBlcjExNiA9IF9jcmVhdGVTdXBlcihUZXh0dXJlTG9hZGVyKTtcblxuICBmdW5jdGlvbiBUZXh0dXJlTG9hZGVyKG1hbmFnZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dHVyZUxvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyMTE2LmNhbGwodGhpcywgbWFuYWdlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dHVyZUxvYWRlciwgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XG4gICAgICB2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7XG4gICAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICBpZiAob25Mb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvbkxvYWQodGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHR1cmVMb2FkZXI7XG59KExvYWRlcik7XG5cbnZhciBMaWdodCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iamVjdDNEMTEpIHtcbiAgX2luaGVyaXRzKExpZ2h0LCBfT2JqZWN0M0QxMSk7XG5cbiAgdmFyIF9zdXBlcjExNyA9IF9jcmVhdGVTdXBlcihMaWdodCk7XG5cbiAgZnVuY3Rpb24gTGlnaHQoY29sb3IpIHtcbiAgICB2YXIgX3RoaXM5MztcblxuICAgIHZhciBpbnRlbnNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlnaHQpO1xuXG4gICAgX3RoaXM5MyA9IF9zdXBlcjExNy5jYWxsKHRoaXMpO1xuICAgIF90aGlzOTMuaXNMaWdodCA9IHRydWU7XG4gICAgX3RoaXM5My50eXBlID0gJ0xpZ2h0JztcbiAgICBfdGhpczkzLmNvbG9yID0gbmV3IENvbG9yKGNvbG9yKTtcbiAgICBfdGhpczkzLmludGVuc2l0eSA9IGludGVuc2l0eTtcbiAgICByZXR1cm4gX3RoaXM5MztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaWdodCwgW3tcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkgey8vIEVtcHR5IGhlcmUgaW4gYmFzZSBjbGFzczsgc29tZSBzdWJjbGFzc2VzIG92ZXJyaWRlLlxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKExpZ2h0LnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlKTtcblxuICAgICAgdGhpcy5jb2xvci5jb3B5KHNvdXJjZS5jb2xvcik7XG4gICAgICB0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihtZXRhKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKExpZ2h0LnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcywgbWV0YSk7XG5cbiAgICAgIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgICAgIGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuICAgICAgaWYgKHRoaXMuZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCkgZGF0YS5vYmplY3QuZ3JvdW5kQ29sb3IgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpO1xuICAgICAgaWYgKHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCkgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuICAgICAgaWYgKHRoaXMuYW5nbGUgIT09IHVuZGVmaW5lZCkgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgICAgaWYgKHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCkgZGF0YS5vYmplY3QuZGVjYXkgPSB0aGlzLmRlY2F5O1xuICAgICAgaWYgKHRoaXMucGVudW1icmEgIT09IHVuZGVmaW5lZCkgZGF0YS5vYmplY3QucGVudW1icmEgPSB0aGlzLnBlbnVtYnJhO1xuICAgICAgaWYgKHRoaXMuc2hhZG93ICE9PSB1bmRlZmluZWQpIGRhdGEub2JqZWN0LnNoYWRvdyA9IHRoaXMuc2hhZG93LnRvSlNPTigpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpZ2h0O1xufShPYmplY3QzRCk7XG5cbnZhciBIZW1pc3BoZXJlTGlnaHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaWdodCkge1xuICBfaW5oZXJpdHMoSGVtaXNwaGVyZUxpZ2h0LCBfTGlnaHQpO1xuXG4gIHZhciBfc3VwZXIxMTggPSBfY3JlYXRlU3VwZXIoSGVtaXNwaGVyZUxpZ2h0KTtcblxuICBmdW5jdGlvbiBIZW1pc3BoZXJlTGlnaHQoc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkpIHtcbiAgICB2YXIgX3RoaXM5NDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZW1pc3BoZXJlTGlnaHQpO1xuXG4gICAgX3RoaXM5NCA9IF9zdXBlcjExOC5jYWxsKHRoaXMsIHNreUNvbG9yLCBpbnRlbnNpdHkpO1xuICAgIF90aGlzOTQuaXNIZW1pc3BoZXJlTGlnaHQgPSB0cnVlO1xuICAgIF90aGlzOTQudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xuXG4gICAgX3RoaXM5NC5wb3NpdGlvbi5jb3B5KE9iamVjdDNELkRlZmF1bHRVcCk7XG5cbiAgICBfdGhpczk0LnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgX3RoaXM5NC5ncm91bmRDb2xvciA9IG5ldyBDb2xvcihncm91bmRDb2xvcik7XG4gICAgcmV0dXJuIF90aGlzOTQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGVtaXNwaGVyZUxpZ2h0LCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlLCByZWN1cnNpdmUpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cbiAgICAgIHRoaXMuZ3JvdW5kQ29sb3IuY29weShzb3VyY2UuZ3JvdW5kQ29sb3IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEhlbWlzcGhlcmVMaWdodDtcbn0oTGlnaHQpO1xuXG52YXIgX3Byb2pTY3JlZW5NYXRyaXgkMSA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG52YXIgX2xpZ2h0UG9zaXRpb25Xb3JsZCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfbG9va1RhcmdldCQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBMaWdodFNoYWRvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpZ2h0U2hhZG93KGNhbWVyYSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaWdodFNoYWRvdyk7XG5cbiAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLmJpYXMgPSAwO1xuICAgIHRoaXMubm9ybWFsQmlhcyA9IDA7XG4gICAgdGhpcy5yYWRpdXMgPSAxO1xuICAgIHRoaXMuYmx1clNhbXBsZXMgPSA4O1xuICAgIHRoaXMubWFwU2l6ZSA9IG5ldyBWZWN0b3IyKDUxMiwgNTEyKTtcbiAgICB0aGlzLm1hcCA9IG51bGw7XG4gICAgdGhpcy5tYXBQYXNzID0gbnVsbDtcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCk7XG4gICAgdGhpcy5fZnJhbWVFeHRlbnRzID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgdGhpcy5fdmlld3BvcnRDb3VudCA9IDE7XG4gICAgdGhpcy5fdmlld3BvcnRzID0gW25ldyBWZWN0b3I0KDAsIDAsIDEsIDEpXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaWdodFNoYWRvdywgW3tcbiAgICBrZXk6IFwiZ2V0Vmlld3BvcnRDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3cG9ydENvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0Q291bnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZydXN0dW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnJ1c3R1bSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mcnVzdHVtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVNYXRyaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNYXRyaWNlcyhsaWdodCkge1xuICAgICAgdmFyIHNoYWRvd0NhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgICAgdmFyIHNoYWRvd01hdHJpeCA9IHRoaXMubWF0cml4O1xuXG4gICAgICBfbGlnaHRQb3NpdGlvbldvcmxkJDEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblxuICAgICAgc2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoX2xpZ2h0UG9zaXRpb25Xb3JsZCQxKTtcblxuICAgICAgX2xvb2tUYXJnZXQkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24obGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkKTtcblxuICAgICAgc2hhZG93Q2FtZXJhLmxvb2tBdChfbG9va1RhcmdldCQxKTtcbiAgICAgIHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICBfcHJvalNjcmVlbk1hdHJpeCQxLm11bHRpcGx5TWF0cmljZXMoc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuXG4gICAgICB0aGlzLl9mcnVzdHVtLnNldEZyb21Qcm9qZWN0aW9uTWF0cml4KF9wcm9qU2NyZWVuTWF0cml4JDEpO1xuXG4gICAgICBzaGFkb3dNYXRyaXguc2V0KDAuNSwgMC4wLCAwLjAsIDAuNSwgMC4wLCAwLjUsIDAuMCwgMC41LCAwLjAsIDAuMCwgMC41LCAwLjUsIDAuMCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgICBzaGFkb3dNYXRyaXgubXVsdGlwbHkoc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgc2hhZG93TWF0cml4Lm11bHRpcGx5KHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3cG9ydCh2aWV3cG9ydEluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRzW3ZpZXdwb3J0SW5kZXhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGcmFtZUV4dGVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnJhbWVFeHRlbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lRXh0ZW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgIHRoaXMubWFwLmRpc3Bvc2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWFwUGFzcykge1xuICAgICAgICB0aGlzLm1hcFBhc3MuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICB0aGlzLmNhbWVyYSA9IHNvdXJjZS5jYW1lcmEuY2xvbmUoKTtcbiAgICAgIHRoaXMuYmlhcyA9IHNvdXJjZS5iaWFzO1xuICAgICAgdGhpcy5yYWRpdXMgPSBzb3VyY2UucmFkaXVzO1xuICAgICAgdGhpcy5tYXBTaXplLmNvcHkoc291cmNlLm1hcFNpemUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgIGlmICh0aGlzLmJpYXMgIT09IDApIG9iamVjdC5iaWFzID0gdGhpcy5iaWFzO1xuICAgICAgaWYgKHRoaXMubm9ybWFsQmlhcyAhPT0gMCkgb2JqZWN0Lm5vcm1hbEJpYXMgPSB0aGlzLm5vcm1hbEJpYXM7XG4gICAgICBpZiAodGhpcy5yYWRpdXMgIT09IDEpIG9iamVjdC5yYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICAgIGlmICh0aGlzLm1hcFNpemUueCAhPT0gNTEyIHx8IHRoaXMubWFwU2l6ZS55ICE9PSA1MTIpIG9iamVjdC5tYXBTaXplID0gdGhpcy5tYXBTaXplLnRvQXJyYXkoKTtcbiAgICAgIG9iamVjdC5jYW1lcmEgPSB0aGlzLmNhbWVyYS50b0pTT04oZmFsc2UpLm9iamVjdDtcbiAgICAgIGRlbGV0ZSBvYmplY3QuY2FtZXJhLm1hdHJpeDtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpZ2h0U2hhZG93O1xufSgpO1xuXG52YXIgU3BvdExpZ2h0U2hhZG93ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGlnaHRTaGFkb3cpIHtcbiAgX2luaGVyaXRzKFNwb3RMaWdodFNoYWRvdywgX0xpZ2h0U2hhZG93KTtcblxuICB2YXIgX3N1cGVyMTE5ID0gX2NyZWF0ZVN1cGVyKFNwb3RMaWdodFNoYWRvdyk7XG5cbiAgZnVuY3Rpb24gU3BvdExpZ2h0U2hhZG93KCkge1xuICAgIHZhciBfdGhpczk1O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwb3RMaWdodFNoYWRvdyk7XG5cbiAgICBfdGhpczk1ID0gX3N1cGVyMTE5LmNhbGwodGhpcywgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKDUwLCAxLCAwLjUsIDUwMCkpO1xuICAgIF90aGlzOTUuaXNTcG90TGlnaHRTaGFkb3cgPSB0cnVlO1xuICAgIF90aGlzOTUuZm9jdXMgPSAxO1xuICAgIHJldHVybiBfdGhpczk1O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNwb3RMaWdodFNoYWRvdywgW3tcbiAgICBrZXk6IFwidXBkYXRlTWF0cmljZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTWF0cmljZXMobGlnaHQpIHtcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICAgIHZhciBmb3YgPSBSQUQyREVHICogMiAqIGxpZ2h0LmFuZ2xlICogdGhpcy5mb2N1cztcbiAgICAgIHZhciBhc3BlY3QgPSB0aGlzLm1hcFNpemUud2lkdGggLyB0aGlzLm1hcFNpemUuaGVpZ2h0O1xuICAgICAgdmFyIGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XG5cbiAgICAgIGlmIChmb3YgIT09IGNhbWVyYS5mb3YgfHwgYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0IHx8IGZhciAhPT0gY2FtZXJhLmZhcikge1xuICAgICAgICBjYW1lcmEuZm92ID0gZm92O1xuICAgICAgICBjYW1lcmEuYXNwZWN0ID0gYXNwZWN0O1xuICAgICAgICBjYW1lcmEuZmFyID0gZmFyO1xuICAgICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgfVxuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTcG90TGlnaHRTaGFkb3cucHJvdG90eXBlKSwgXCJ1cGRhdGVNYXRyaWNlc1wiLCB0aGlzKS5jYWxsKHRoaXMsIGxpZ2h0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU3BvdExpZ2h0U2hhZG93LnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BvdExpZ2h0U2hhZG93O1xufShMaWdodFNoYWRvdyk7XG5cbnZhciBTcG90TGlnaHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaWdodDIpIHtcbiAgX2luaGVyaXRzKFNwb3RMaWdodCwgX0xpZ2h0Mik7XG5cbiAgdmFyIF9zdXBlcjEyMCA9IF9jcmVhdGVTdXBlcihTcG90TGlnaHQpO1xuXG4gIGZ1bmN0aW9uIFNwb3RMaWdodChjb2xvciwgaW50ZW5zaXR5KSB7XG4gICAgdmFyIF90aGlzOTY7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIGFuZ2xlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBNYXRoLlBJIC8gMztcbiAgICB2YXIgcGVudW1icmEgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IDA7XG4gICAgdmFyIGRlY2F5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwb3RMaWdodCk7XG5cbiAgICBfdGhpczk2ID0gX3N1cGVyMTIwLmNhbGwodGhpcywgY29sb3IsIGludGVuc2l0eSk7XG4gICAgX3RoaXM5Ni5pc1Nwb3RMaWdodCA9IHRydWU7XG4gICAgX3RoaXM5Ni50eXBlID0gJ1Nwb3RMaWdodCc7XG5cbiAgICBfdGhpczk2LnBvc2l0aW9uLmNvcHkoT2JqZWN0M0QuRGVmYXVsdFVwKTtcblxuICAgIF90aGlzOTYudXBkYXRlTWF0cml4KCk7XG5cbiAgICBfdGhpczk2LnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xuICAgIF90aGlzOTYuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBfdGhpczk2LmFuZ2xlID0gYW5nbGU7XG4gICAgX3RoaXM5Ni5wZW51bWJyYSA9IHBlbnVtYnJhO1xuICAgIF90aGlzOTYuZGVjYXkgPSBkZWNheTsgLy8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG4gICAgX3RoaXM5Ni5zaGFkb3cgPSBuZXcgU3BvdExpZ2h0U2hhZG93KCk7XG4gICAgcmV0dXJuIF90aGlzOTY7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3BvdExpZ2h0LCBbe1xuICAgIGtleTogXCJwb3dlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gY29tcHV0ZSB0aGUgbGlnaHQncyBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKSBmcm9tIGl0cyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpXG4gICAgICAvLyBieSBjb252ZW50aW9uIGZvciBhIHNwb3RsaWdodCwgbHVtaW5vdXMgcG93ZXIgKGxtKSA9IM+AICogbHVtaW5vdXMgaW50ZW5zaXR5IChjZClcbiAgICAgIHJldHVybiB0aGlzLmludGVuc2l0eSAqIE1hdGguUEk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChwb3dlcikge1xuICAgICAgLy8gc2V0IHRoZSBsaWdodCdzIGludGVuc2l0eSAoaW4gY2FuZGVsYSkgZnJvbSB0aGUgZGVzaXJlZCBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKVxuICAgICAgdGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvIE1hdGguUEk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTcG90TGlnaHQucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlLCByZWN1cnNpdmUpO1xuXG4gICAgICB0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuICAgICAgdGhpcy5hbmdsZSA9IHNvdXJjZS5hbmdsZTtcbiAgICAgIHRoaXMucGVudW1icmEgPSBzb3VyY2UucGVudW1icmE7XG4gICAgICB0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuICAgICAgdGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG4gICAgICB0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcG90TGlnaHQ7XG59KExpZ2h0KTtcblxudmFyIF9wcm9qU2NyZWVuTWF0cml4ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfbGlnaHRQb3NpdGlvbldvcmxkID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfbG9va1RhcmdldCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgUG9pbnRMaWdodFNoYWRvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpZ2h0U2hhZG93Mikge1xuICBfaW5oZXJpdHMoUG9pbnRMaWdodFNoYWRvdywgX0xpZ2h0U2hhZG93Mik7XG5cbiAgdmFyIF9zdXBlcjEyMSA9IF9jcmVhdGVTdXBlcihQb2ludExpZ2h0U2hhZG93KTtcblxuICBmdW5jdGlvbiBQb2ludExpZ2h0U2hhZG93KCkge1xuICAgIHZhciBfdGhpczk3O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvaW50TGlnaHRTaGFkb3cpO1xuXG4gICAgX3RoaXM5NyA9IF9zdXBlcjEyMS5jYWxsKHRoaXMsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSg5MCwgMSwgMC41LCA1MDApKTtcbiAgICBfdGhpczk3LmlzUG9pbnRMaWdodFNoYWRvdyA9IHRydWU7XG4gICAgX3RoaXM5Ny5fZnJhbWVFeHRlbnRzID0gbmV3IFZlY3RvcjIoNCwgMik7XG4gICAgX3RoaXM5Ny5fdmlld3BvcnRDb3VudCA9IDY7XG4gICAgX3RoaXM5Ny5fdmlld3BvcnRzID0gWy8vIFRoZXNlIHZpZXdwb3J0cyBtYXAgYSBjdWJlLW1hcCBvbnRvIGEgMkQgdGV4dHVyZSB3aXRoIHRoZVxuICAgIC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcbiAgICAvL1xuICAgIC8vICB4elhaXG4gICAgLy8gICB5IFlcbiAgICAvL1xuICAgIC8vIFggLSBQb3NpdGl2ZSB4IGRpcmVjdGlvblxuICAgIC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuICAgIC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxuICAgIC8vIHkgLSBOZWdhdGl2ZSB5IGRpcmVjdGlvblxuICAgIC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuICAgIC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxuICAgIC8vIHBvc2l0aXZlIFhcbiAgICBuZXcgVmVjdG9yNCgyLCAxLCAxLCAxKSwgLy8gbmVnYXRpdmUgWFxuICAgIG5ldyBWZWN0b3I0KDAsIDEsIDEsIDEpLCAvLyBwb3NpdGl2ZSBaXG4gICAgbmV3IFZlY3RvcjQoMywgMSwgMSwgMSksIC8vIG5lZ2F0aXZlIFpcbiAgICBuZXcgVmVjdG9yNCgxLCAxLCAxLCAxKSwgLy8gcG9zaXRpdmUgWVxuICAgIG5ldyBWZWN0b3I0KDMsIDAsIDEsIDEpLCAvLyBuZWdhdGl2ZSBZXG4gICAgbmV3IFZlY3RvcjQoMSwgMCwgMSwgMSldO1xuICAgIF90aGlzOTcuX2N1YmVEaXJlY3Rpb25zID0gW25ldyBWZWN0b3IzKDEsIDAsIDApLCBuZXcgVmVjdG9yMygtMSwgMCwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBuZXcgVmVjdG9yMygwLCAwLCAtMSksIG5ldyBWZWN0b3IzKDAsIDEsIDApLCBuZXcgVmVjdG9yMygwLCAtMSwgMCldO1xuICAgIF90aGlzOTcuX2N1YmVVcHMgPSBbbmV3IFZlY3RvcjMoMCwgMSwgMCksIG5ldyBWZWN0b3IzKDAsIDEsIDApLCBuZXcgVmVjdG9yMygwLCAxLCAwKSwgbmV3IFZlY3RvcjMoMCwgMSwgMCksIG5ldyBWZWN0b3IzKDAsIDAsIDEpLCBuZXcgVmVjdG9yMygwLCAwLCAtMSldO1xuICAgIHJldHVybiBfdGhpczk3O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvaW50TGlnaHRTaGFkb3csIFt7XG4gICAga2V5OiBcInVwZGF0ZU1hdHJpY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU1hdHJpY2VzKGxpZ2h0KSB7XG4gICAgICB2YXIgdmlld3BvcnRJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICAgIHZhciBzaGFkb3dNYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgIHZhciBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xuXG4gICAgICBpZiAoZmFyICE9PSBjYW1lcmEuZmFyKSB7XG4gICAgICAgIGNhbWVyYS5mYXIgPSBmYXI7XG4gICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICB9XG5cbiAgICAgIF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGxpZ2h0Lm1hdHJpeFdvcmxkKTtcblxuICAgICAgY2FtZXJhLnBvc2l0aW9uLmNvcHkoX2xpZ2h0UG9zaXRpb25Xb3JsZCk7XG5cbiAgICAgIF9sb29rVGFyZ2V0LmNvcHkoY2FtZXJhLnBvc2l0aW9uKTtcblxuICAgICAgX2xvb2tUYXJnZXQuYWRkKHRoaXMuX2N1YmVEaXJlY3Rpb25zW3ZpZXdwb3J0SW5kZXhdKTtcblxuICAgICAgY2FtZXJhLnVwLmNvcHkodGhpcy5fY3ViZVVwc1t2aWV3cG9ydEluZGV4XSk7XG4gICAgICBjYW1lcmEubG9va0F0KF9sb29rVGFyZ2V0KTtcbiAgICAgIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgc2hhZG93TWF0cml4Lm1ha2VUcmFuc2xhdGlvbigtX2xpZ2h0UG9zaXRpb25Xb3JsZC54LCAtX2xpZ2h0UG9zaXRpb25Xb3JsZC55LCAtX2xpZ2h0UG9zaXRpb25Xb3JsZC56KTtcblxuICAgICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG5cbiAgICAgIHRoaXMuX2ZydXN0dW0uc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoX3Byb2pTY3JlZW5NYXRyaXgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb2ludExpZ2h0U2hhZG93O1xufShMaWdodFNoYWRvdyk7XG5cbnZhciBQb2ludExpZ2h0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGlnaHQzKSB7XG4gIF9pbmhlcml0cyhQb2ludExpZ2h0LCBfTGlnaHQzKTtcblxuICB2YXIgX3N1cGVyMTIyID0gX2NyZWF0ZVN1cGVyKFBvaW50TGlnaHQpO1xuXG4gIGZ1bmN0aW9uIFBvaW50TGlnaHQoY29sb3IsIGludGVuc2l0eSkge1xuICAgIHZhciBfdGhpczk4O1xuXG4gICAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciBkZWNheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2ludExpZ2h0KTtcblxuICAgIF90aGlzOTggPSBfc3VwZXIxMjIuY2FsbCh0aGlzLCBjb2xvciwgaW50ZW5zaXR5KTtcbiAgICBfdGhpczk4LmlzUG9pbnRMaWdodCA9IHRydWU7XG4gICAgX3RoaXM5OC50eXBlID0gJ1BvaW50TGlnaHQnO1xuICAgIF90aGlzOTguZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBfdGhpczk4LmRlY2F5ID0gZGVjYXk7IC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuICAgIF90aGlzOTguc2hhZG93ID0gbmV3IFBvaW50TGlnaHRTaGFkb3coKTtcbiAgICByZXR1cm4gX3RoaXM5ODtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb2ludExpZ2h0LCBbe1xuICAgIGtleTogXCJwb3dlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gY29tcHV0ZSB0aGUgbGlnaHQncyBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKSBmcm9tIGl0cyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpXG4gICAgICAvLyBmb3IgYW4gaXNvdHJvcGljIGxpZ2h0IHNvdXJjZSwgbHVtaW5vdXMgcG93ZXIgKGxtKSA9IDQgz4AgbHVtaW5vdXMgaW50ZW5zaXR5IChjZClcbiAgICAgIHJldHVybiB0aGlzLmludGVuc2l0eSAqIDQgKiBNYXRoLlBJO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQocG93ZXIpIHtcbiAgICAgIC8vIHNldCB0aGUgbGlnaHQncyBpbnRlbnNpdHkgKGluIGNhbmRlbGEpIGZyb20gdGhlIGRlc2lyZWQgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucylcbiAgICAgIHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoNCAqIE1hdGguUEkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLnNoYWRvdy5kaXNwb3NlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UsIHJlY3Vyc2l2ZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoUG9pbnRMaWdodC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSk7XG5cbiAgICAgIHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG4gICAgICB0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuICAgICAgdGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9pbnRMaWdodDtcbn0oTGlnaHQpO1xuXG52YXIgRGlyZWN0aW9uYWxMaWdodFNoYWRvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpZ2h0U2hhZG93Mykge1xuICBfaW5oZXJpdHMoRGlyZWN0aW9uYWxMaWdodFNoYWRvdywgX0xpZ2h0U2hhZG93Myk7XG5cbiAgdmFyIF9zdXBlcjEyMyA9IF9jcmVhdGVTdXBlcihEaXJlY3Rpb25hbExpZ2h0U2hhZG93KTtcblxuICBmdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0U2hhZG93KCkge1xuICAgIHZhciBfdGhpczk5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpcmVjdGlvbmFsTGlnaHRTaGFkb3cpO1xuXG4gICAgX3RoaXM5OSA9IF9zdXBlcjEyMy5jYWxsKHRoaXMsIG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLTUsIDUsIDUsIC01LCAwLjUsIDUwMCkpO1xuICAgIF90aGlzOTkuaXNEaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM5OTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGlyZWN0aW9uYWxMaWdodFNoYWRvdyk7XG59KExpZ2h0U2hhZG93KTtcblxudmFyIERpcmVjdGlvbmFsTGlnaHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaWdodDQpIHtcbiAgX2luaGVyaXRzKERpcmVjdGlvbmFsTGlnaHQsIF9MaWdodDQpO1xuXG4gIHZhciBfc3VwZXIxMjQgPSBfY3JlYXRlU3VwZXIoRGlyZWN0aW9uYWxMaWdodCk7XG5cbiAgZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodChjb2xvciwgaW50ZW5zaXR5KSB7XG4gICAgdmFyIF90aGlzMTAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpcmVjdGlvbmFsTGlnaHQpO1xuXG4gICAgX3RoaXMxMDAgPSBfc3VwZXIxMjQuY2FsbCh0aGlzLCBjb2xvciwgaW50ZW5zaXR5KTtcbiAgICBfdGhpczEwMC5pc0RpcmVjdGlvbmFsTGlnaHQgPSB0cnVlO1xuICAgIF90aGlzMTAwLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cbiAgICBfdGhpczEwMC5wb3NpdGlvbi5jb3B5KE9iamVjdDNELkRlZmF1bHRVcCk7XG5cbiAgICBfdGhpczEwMC51cGRhdGVNYXRyaXgoKTtcblxuICAgIF90aGlzMTAwLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xuICAgIF90aGlzMTAwLnNoYWRvdyA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0U2hhZG93KCk7XG4gICAgcmV0dXJuIF90aGlzMTAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERpcmVjdGlvbmFsTGlnaHQsIFt7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuc2hhZG93LmRpc3Bvc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcbiAgICAgIHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERpcmVjdGlvbmFsTGlnaHQ7XG59KExpZ2h0KTtcblxudmFyIEFtYmllbnRMaWdodCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpZ2h0NSkge1xuICBfaW5oZXJpdHMoQW1iaWVudExpZ2h0LCBfTGlnaHQ1KTtcblxuICB2YXIgX3N1cGVyMTI1ID0gX2NyZWF0ZVN1cGVyKEFtYmllbnRMaWdodCk7XG5cbiAgZnVuY3Rpb24gQW1iaWVudExpZ2h0KGNvbG9yLCBpbnRlbnNpdHkpIHtcbiAgICB2YXIgX3RoaXMxMDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW1iaWVudExpZ2h0KTtcblxuICAgIF90aGlzMTAxID0gX3N1cGVyMTI1LmNhbGwodGhpcywgY29sb3IsIGludGVuc2l0eSk7XG4gICAgX3RoaXMxMDEuaXNBbWJpZW50TGlnaHQgPSB0cnVlO1xuICAgIF90aGlzMTAxLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcbiAgICByZXR1cm4gX3RoaXMxMDE7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFtYmllbnRMaWdodCk7XG59KExpZ2h0KTtcblxudmFyIFJlY3RBcmVhTGlnaHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaWdodDYpIHtcbiAgX2luaGVyaXRzKFJlY3RBcmVhTGlnaHQsIF9MaWdodDYpO1xuXG4gIHZhciBfc3VwZXIxMjYgPSBfY3JlYXRlU3VwZXIoUmVjdEFyZWFMaWdodCk7XG5cbiAgZnVuY3Rpb24gUmVjdEFyZWFMaWdodChjb2xvciwgaW50ZW5zaXR5KSB7XG4gICAgdmFyIF90aGlzMTAyO1xuXG4gICAgdmFyIHdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMDtcbiAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAxMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWN0QXJlYUxpZ2h0KTtcblxuICAgIF90aGlzMTAyID0gX3N1cGVyMTI2LmNhbGwodGhpcywgY29sb3IsIGludGVuc2l0eSk7XG4gICAgX3RoaXMxMDIuaXNSZWN0QXJlYUxpZ2h0ID0gdHJ1ZTtcbiAgICBfdGhpczEwMi50eXBlID0gJ1JlY3RBcmVhTGlnaHQnO1xuICAgIF90aGlzMTAyLndpZHRoID0gd2lkdGg7XG4gICAgX3RoaXMxMDIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBfdGhpczEwMjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZWN0QXJlYUxpZ2h0LCBbe1xuICAgIGtleTogXCJwb3dlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgLy8gY29tcHV0ZSB0aGUgbGlnaHQncyBsdW1pbm91cyBwb3dlciAoaW4gbHVtZW5zKSBmcm9tIGl0cyBpbnRlbnNpdHkgKGluIG5pdHMpXG4gICAgICByZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiBNYXRoLlBJO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQocG93ZXIpIHtcbiAgICAgIC8vIHNldCB0aGUgbGlnaHQncyBpbnRlbnNpdHkgKGluIG5pdHMpIGZyb20gdGhlIGRlc2lyZWQgbHVtaW5vdXMgcG93ZXIgKGluIGx1bWVucylcbiAgICAgIHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0ICogTWF0aC5QSSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFJlY3RBcmVhTGlnaHQucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlKTtcblxuICAgICAgdGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKG1ldGEpIHtcbiAgICAgIHZhciBkYXRhID0gX2dldChfZ2V0UHJvdG90eXBlT2YoUmVjdEFyZWFMaWdodC5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMsIG1ldGEpO1xuXG4gICAgICBkYXRhLm9iamVjdC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICBkYXRhLm9iamVjdC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWN0QXJlYUxpZ2h0O1xufShMaWdodCk7XG4vKipcbiAqIFByaW1hcnkgcmVmZXJlbmNlOlxuICogICBodHRwczovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9wYXBlcnMvZW52bWFwL2Vudm1hcC5wZGZcbiAqXG4gKiBTZWNvbmRhcnkgcmVmZXJlbmNlOlxuICogICBodHRwczovL3d3dy5wcHNsb2FuLm9yZy9wdWJsaWNhdGlvbnMvU3R1cGlkU0gzNi5wZGZcbiAqL1xuLy8gMy1iYW5kIFNIIGRlZmluZWQgYnkgOSBjb2VmZmljaWVudHNcblxuXG52YXIgU3BoZXJpY2FsSGFybW9uaWNzMyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNwaGVyaWNhbEhhcm1vbmljczMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwaGVyaWNhbEhhcm1vbmljczMpO1xuXG4gICAgdGhpcy5pc1NwaGVyaWNhbEhhcm1vbmljczMgPSB0cnVlO1xuICAgIHRoaXMuY29lZmZpY2llbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBfaTI4NyA9IDA7IF9pMjg3IDwgOTsgX2kyODcrKykge1xuICAgICAgdGhpcy5jb2VmZmljaWVudHMucHVzaChuZXcgVmVjdG9yMygpKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3BoZXJpY2FsSGFybW9uaWNzMywgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChjb2VmZmljaWVudHMpIHtcbiAgICAgIGZvciAodmFyIF9pMjg4ID0gMDsgX2kyODggPCA5OyBfaTI4OCsrKSB7XG4gICAgICAgIHRoaXMuY29lZmZpY2llbnRzW19pMjg4XS5jb3B5KGNvZWZmaWNpZW50c1tfaTI4OF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiemVyb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6ZXJvKCkge1xuICAgICAgZm9yICh2YXIgX2kyODkgPSAwOyBfaTI4OSA8IDk7IF9pMjg5KyspIHtcbiAgICAgICAgdGhpcy5jb2VmZmljaWVudHNbX2kyODldLnNldCgwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBnZXQgdGhlIHJhZGlhbmNlIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG5vcm1hbFxuICAgIC8vIHRhcmdldCBpcyBhIFZlY3RvcjNcblxuICB9LCB7XG4gICAga2V5OiBcImdldEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF0KG5vcm1hbCwgdGFyZ2V0KSB7XG4gICAgICAvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuICAgICAgdmFyIHggPSBub3JtYWwueCxcbiAgICAgICAgICB5ID0gbm9ybWFsLnksXG4gICAgICAgICAgeiA9IG5vcm1hbC56O1xuICAgICAgdmFyIGNvZWZmID0gdGhpcy5jb2VmZmljaWVudHM7IC8vIGJhbmQgMFxuXG4gICAgICB0YXJnZXQuY29weShjb2VmZlswXSkubXVsdGlwbHlTY2FsYXIoMC4yODIwOTUpOyAvLyBiYW5kIDFcblxuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlsxXSwgMC40ODg2MDMgKiB5KTtcbiAgICAgIHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbMl0sIDAuNDg4NjAzICogeik7XG4gICAgICB0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzNdLCAwLjQ4ODYwMyAqIHgpOyAvLyBiYW5kIDJcblxuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls0XSwgMS4wOTI1NDggKiAoeCAqIHkpKTtcbiAgICAgIHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbNV0sIDEuMDkyNTQ4ICogKHkgKiB6KSk7XG4gICAgICB0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzZdLCAwLjMxNTM5MiAqICgzLjAgKiB6ICogeiAtIDEuMCkpO1xuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls3XSwgMS4wOTI1NDggKiAoeCAqIHopKTtcbiAgICAgIHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbOF0sIDAuNTQ2Mjc0ICogKHggKiB4IC0geSAqIHkpKTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSAvLyBnZXQgdGhlIGlycmFkaWFuY2UgKHJhZGlhbmNlIGNvbnZvbHZlZCB3aXRoIGNvc2luZSBsb2JlKSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcbiAgICAvLyB0YXJnZXQgaXMgYSBWZWN0b3IzXG4gICAgLy8gaHR0cHM6Ly9ncmFwaGljcy5zdGFuZm9yZC5lZHUvcGFwZXJzL2Vudm1hcC9lbnZtYXAucGRmXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJcnJhZGlhbmNlQXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXJyYWRpYW5jZUF0KG5vcm1hbCwgdGFyZ2V0KSB7XG4gICAgICAvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuICAgICAgdmFyIHggPSBub3JtYWwueCxcbiAgICAgICAgICB5ID0gbm9ybWFsLnksXG4gICAgICAgICAgeiA9IG5vcm1hbC56O1xuICAgICAgdmFyIGNvZWZmID0gdGhpcy5jb2VmZmljaWVudHM7IC8vIGJhbmQgMFxuXG4gICAgICB0YXJnZXQuY29weShjb2VmZlswXSkubXVsdGlwbHlTY2FsYXIoMC44ODYyMjcpOyAvLyDPgCAqIDAuMjgyMDk1XG4gICAgICAvLyBiYW5kIDFcblxuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlsxXSwgMi4wICogMC41MTE2NjQgKiB5KTsgLy8gKCAyICogz4AgLyAzICkgKiAwLjQ4ODYwM1xuXG4gICAgICB0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzJdLCAyLjAgKiAwLjUxMTY2NCAqIHopO1xuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZlszXSwgMi4wICogMC41MTE2NjQgKiB4KTsgLy8gYmFuZCAyXG5cbiAgICAgIHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbNF0sIDIuMCAqIDAuNDI5MDQzICogeCAqIHkpOyAvLyAoIM+AIC8gNCApICogMS4wOTI1NDhcblxuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls1XSwgMi4wICogMC40MjkwNDMgKiB5ICogeik7XG4gICAgICB0YXJnZXQuYWRkU2NhbGVkVmVjdG9yKGNvZWZmWzZdLCAwLjc0MzEyNSAqIHogKiB6IC0gMC4yNDc3MDgpOyAvLyAoIM+AIC8gNCApICogMC4zMTUzOTIgKiAzXG5cbiAgICAgIHRhcmdldC5hZGRTY2FsZWRWZWN0b3IoY29lZmZbN10sIDIuMCAqIDAuNDI5MDQzICogeCAqIHopO1xuICAgICAgdGFyZ2V0LmFkZFNjYWxlZFZlY3Rvcihjb2VmZls4XSwgMC40MjkwNDMgKiAoeCAqIHggLSB5ICogeSkpOyAvLyAoIM+AIC8gNCApICogMC41NDYyNzRcblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChzaCkge1xuICAgICAgZm9yICh2YXIgX2kyOTAgPSAwOyBfaTI5MCA8IDk7IF9pMjkwKyspIHtcbiAgICAgICAgdGhpcy5jb2VmZmljaWVudHNbX2kyOTBdLmFkZChzaC5jb2VmZmljaWVudHNbX2kyOTBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFNjYWxlZFNIXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNjYWxlZFNIKHNoLCBzKSB7XG4gICAgICBmb3IgKHZhciBfaTI5MSA9IDA7IF9pMjkxIDwgOTsgX2kyOTErKykge1xuICAgICAgICB0aGlzLmNvZWZmaWNpZW50c1tfaTI5MV0uYWRkU2NhbGVkVmVjdG9yKHNoLmNvZWZmaWNpZW50c1tfaTI5MV0sIHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGUocykge1xuICAgICAgZm9yICh2YXIgX2kyOTIgPSAwOyBfaTI5MiA8IDk7IF9pMjkyKyspIHtcbiAgICAgICAgdGhpcy5jb2VmZmljaWVudHNbX2kyOTJdLm11bHRpcGx5U2NhbGFyKHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGVycFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXJwKHNoLCBhbHBoYSkge1xuICAgICAgZm9yICh2YXIgX2kyOTMgPSAwOyBfaTI5MyA8IDk7IF9pMjkzKyspIHtcbiAgICAgICAgdGhpcy5jb2VmZmljaWVudHNbX2kyOTNdLmxlcnAoc2guY29lZmZpY2llbnRzW19pMjkzXSwgYWxwaGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhzaCkge1xuICAgICAgZm9yICh2YXIgX2kyOTQgPSAwOyBfaTI5NCA8IDk7IF9pMjk0KyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvZWZmaWNpZW50c1tfaTI5NF0uZXF1YWxzKHNoLmNvZWZmaWNpZW50c1tfaTI5NF0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc2gpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChzaC5jb2VmZmljaWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG5cbiAgICAgIGZvciAodmFyIF9pMjk1ID0gMDsgX2kyOTUgPCA5OyBfaTI5NSsrKSB7XG4gICAgICAgIGNvZWZmaWNpZW50c1tfaTI5NV0uZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgKyBfaTI5NSAqIDMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgdmFyIGFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICAgIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgY29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG5cbiAgICAgIGZvciAodmFyIF9pMjk2ID0gMDsgX2kyOTYgPCA5OyBfaTI5NisrKSB7XG4gICAgICAgIGNvZWZmaWNpZW50c1tfaTI5Nl0udG9BcnJheShhcnJheSwgb2Zmc2V0ICsgX2kyOTYgKiAzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0gLy8gZXZhbHVhdGUgdGhlIGJhc2lzIGZ1bmN0aW9uc1xuICAgIC8vIHNoQmFzaXMgaXMgYW4gQXJyYXlbIDkgXVxuXG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXRCYXNpc0F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2lzQXQobm9ybWFsLCBzaEJhc2lzKSB7XG4gICAgICAvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSB1bml0IGxlbmd0aFxuICAgICAgdmFyIHggPSBub3JtYWwueCxcbiAgICAgICAgICB5ID0gbm9ybWFsLnksXG4gICAgICAgICAgeiA9IG5vcm1hbC56OyAvLyBiYW5kIDBcblxuICAgICAgc2hCYXNpc1swXSA9IDAuMjgyMDk1OyAvLyBiYW5kIDFcblxuICAgICAgc2hCYXNpc1sxXSA9IDAuNDg4NjAzICogeTtcbiAgICAgIHNoQmFzaXNbMl0gPSAwLjQ4ODYwMyAqIHo7XG4gICAgICBzaEJhc2lzWzNdID0gMC40ODg2MDMgKiB4OyAvLyBiYW5kIDJcblxuICAgICAgc2hCYXNpc1s0XSA9IDEuMDkyNTQ4ICogeCAqIHk7XG4gICAgICBzaEJhc2lzWzVdID0gMS4wOTI1NDggKiB5ICogejtcbiAgICAgIHNoQmFzaXNbNl0gPSAwLjMxNTM5MiAqICgzICogeiAqIHogLSAxKTtcbiAgICAgIHNoQmFzaXNbN10gPSAxLjA5MjU0OCAqIHggKiB6O1xuICAgICAgc2hCYXNpc1s4XSA9IDAuNTQ2Mjc0ICogKHggKiB4IC0geSAqIHkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcGhlcmljYWxIYXJtb25pY3MzO1xufSgpO1xuXG52YXIgTGlnaHRQcm9iZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpZ2h0Nykge1xuICBfaW5oZXJpdHMoTGlnaHRQcm9iZSwgX0xpZ2h0Nyk7XG5cbiAgdmFyIF9zdXBlcjEyNyA9IF9jcmVhdGVTdXBlcihMaWdodFByb2JlKTtcblxuICBmdW5jdGlvbiBMaWdodFByb2JlKCkge1xuICAgIHZhciBfdGhpczEwMztcblxuICAgIHZhciBzaCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFNwaGVyaWNhbEhhcm1vbmljczMoKTtcbiAgICB2YXIgaW50ZW5zaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpZ2h0UHJvYmUpO1xuXG4gICAgX3RoaXMxMDMgPSBfc3VwZXIxMjcuY2FsbCh0aGlzLCB1bmRlZmluZWQsIGludGVuc2l0eSk7XG4gICAgX3RoaXMxMDMuaXNMaWdodFByb2JlID0gdHJ1ZTtcbiAgICBfdGhpczEwMy5zaCA9IHNoO1xuICAgIHJldHVybiBfdGhpczEwMztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaWdodFByb2JlLCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihMaWdodFByb2JlLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMuc2guY29weShzb3VyY2Uuc2gpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcbiAgICAgIHRoaXMuaW50ZW5zaXR5ID0ganNvbi5pbnRlbnNpdHk7IC8vIFRPRE86IE1vdmUgdGhpcyBiaXQgdG8gTGlnaHQuZnJvbUpTT04oKTtcblxuICAgICAgdGhpcy5zaC5mcm9tQXJyYXkoanNvbi5zaCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihtZXRhKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKExpZ2h0UHJvYmUucHJvdG90eXBlKSwgXCJ0b0pTT05cIiwgdGhpcykuY2FsbCh0aGlzLCBtZXRhKTtcblxuICAgICAgZGF0YS5vYmplY3Quc2ggPSB0aGlzLnNoLnRvQXJyYXkoKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaWdodFByb2JlO1xufShMaWdodCk7XG5cbnZhciBNYXRlcmlhbExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcjgpIHtcbiAgX2luaGVyaXRzKE1hdGVyaWFsTG9hZGVyLCBfTG9hZGVyOCk7XG5cbiAgdmFyIF9zdXBlcjEyOCA9IF9jcmVhdGVTdXBlcihNYXRlcmlhbExvYWRlcik7XG5cbiAgZnVuY3Rpb24gTWF0ZXJpYWxMb2FkZXIobWFuYWdlcikge1xuICAgIHZhciBfdGhpczEwNDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXRlcmlhbExvYWRlcik7XG5cbiAgICBfdGhpczEwNCA9IF9zdXBlcjEyOC5jYWxsKHRoaXMsIG1hbmFnZXIpO1xuICAgIF90aGlzMTA0LnRleHR1cmVzID0ge307XG4gICAgcmV0dXJuIF90aGlzMTA0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hdGVyaWFsTG9hZGVyLCBbe1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICB2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoc2NvcGUubWFuYWdlcik7XG4gICAgICBsb2FkZXIuc2V0UGF0aChzY29wZS5wYXRoKTtcbiAgICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHNjb3BlLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyhzY29wZS53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9uTG9hZChzY29wZS5wYXJzZShKU09OLnBhcnNlKHRleHQpKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICB9XG4gICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoanNvbikge1xuICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcblxuICAgICAgZnVuY3Rpb24gZ2V0VGV4dHVyZShuYW1lKSB7XG4gICAgICAgIGlmICh0ZXh0dXJlc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGVyaWFsID0gTWF0ZXJpYWwuZnJvbVR5cGUoanNvbi50eXBlKTtcbiAgICAgIGlmIChqc29uLnV1aWQgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudXVpZCA9IGpzb24udXVpZDtcbiAgICAgIGlmIChqc29uLm5hbWUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubmFtZSA9IGpzb24ubmFtZTtcbiAgICAgIGlmIChqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuY29sb3IgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KGpzb24uY29sb3IpO1xuICAgICAgaWYgKGpzb24ucm91Z2huZXNzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJvdWdobmVzcyA9IGpzb24ucm91Z2huZXNzO1xuICAgICAgaWYgKGpzb24ubWV0YWxuZXNzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm1ldGFsbmVzcyA9IGpzb24ubWV0YWxuZXNzO1xuICAgICAgaWYgKGpzb24uc2hlZW4gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hlZW4gPSBqc29uLnNoZWVuO1xuICAgICAgaWYgKGpzb24uc2hlZW5Db2xvciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaGVlbkNvbG9yID0gbmV3IENvbG9yKCkuc2V0SGV4KGpzb24uc2hlZW5Db2xvcik7XG4gICAgICBpZiAoanNvbi5zaGVlblJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaGVlblJvdWdobmVzcyA9IGpzb24uc2hlZW5Sb3VnaG5lc3M7XG4gICAgICBpZiAoanNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLmVtaXNzaXZlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleChqc29uLmVtaXNzaXZlKTtcbiAgICAgIGlmIChqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuc3BlY3VsYXIgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXIuc2V0SGV4KGpzb24uc3BlY3VsYXIpO1xuICAgICAgaWYgKGpzb24uc3BlY3VsYXJJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHkgPSBqc29uLnNwZWN1bGFySW50ZW5zaXR5O1xuICAgICAgaWYgKGpzb24uc3BlY3VsYXJDb2xvciAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvci5zZXRIZXgoanNvbi5zcGVjdWxhckNvbG9yKTtcbiAgICAgIGlmIChqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcbiAgICAgIGlmIChqc29uLmNsZWFyY29hdCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jbGVhcmNvYXQgPSBqc29uLmNsZWFyY29hdDtcbiAgICAgIGlmIChqc29uLmNsZWFyY29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5jbGVhcmNvYXRSb3VnaG5lc3MgPSBqc29uLmNsZWFyY29hdFJvdWdobmVzcztcbiAgICAgIGlmIChqc29uLmlyaWRlc2NlbmNlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmlyaWRlc2NlbmNlID0ganNvbi5pcmlkZXNjZW5jZTtcbiAgICAgIGlmIChqc29uLmlyaWRlc2NlbmNlSU9SICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmlyaWRlc2NlbmNlSU9SID0ganNvbi5pcmlkZXNjZW5jZUlPUjtcbiAgICAgIGlmIChqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IGpzb24uaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZTtcbiAgICAgIGlmIChqc29uLnRyYW5zbWlzc2lvbiAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50cmFuc21pc3Npb24gPSBqc29uLnRyYW5zbWlzc2lvbjtcbiAgICAgIGlmIChqc29uLnRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50aGlja25lc3MgPSBqc29uLnRoaWNrbmVzcztcbiAgICAgIGlmIChqc29uLmF0dGVudWF0aW9uRGlzdGFuY2UgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGpzb24uYXR0ZW51YXRpb25EaXN0YW5jZTtcbiAgICAgIGlmIChqc29uLmF0dGVudWF0aW9uQ29sb3IgIT09IHVuZGVmaW5lZCAmJiBtYXRlcmlhbC5hdHRlbnVhdGlvbkNvbG9yICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmF0dGVudWF0aW9uQ29sb3Iuc2V0SGV4KGpzb24uYXR0ZW51YXRpb25Db2xvcik7XG4gICAgICBpZiAoanNvbi5mb2cgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZm9nID0ganNvbi5mb2c7XG4gICAgICBpZiAoanNvbi5mbGF0U2hhZGluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uZmxhdFNoYWRpbmc7XG4gICAgICBpZiAoanNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG4gICAgICBpZiAoanNvbi5jb21iaW5lICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNvbWJpbmUgPSBqc29uLmNvbWJpbmU7XG4gICAgICBpZiAoanNvbi5zaWRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG4gICAgICBpZiAoanNvbi5zaGFkb3dTaWRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNoYWRvd1NpZGUgPSBqc29uLnNoYWRvd1NpZGU7XG4gICAgICBpZiAoanNvbi5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG4gICAgICBpZiAoanNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG4gICAgICBpZiAoanNvbi5hbHBoYVRlc3QgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYWxwaGFUZXN0ID0ganNvbi5hbHBoYVRlc3Q7XG4gICAgICBpZiAoanNvbi5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XG4gICAgICBpZiAoanNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XG4gICAgICBpZiAoanNvbi5jb2xvcldyaXRlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNvbG9yV3JpdGUgPSBqc29uLmNvbG9yV3JpdGU7XG4gICAgICBpZiAoanNvbi5zdGVuY2lsV3JpdGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbFdyaXRlID0ganNvbi5zdGVuY2lsV3JpdGU7XG4gICAgICBpZiAoanNvbi5zdGVuY2lsV3JpdGVNYXNrICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxXcml0ZU1hc2sgPSBqc29uLnN0ZW5jaWxXcml0ZU1hc2s7XG4gICAgICBpZiAoanNvbi5zdGVuY2lsRnVuYyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zdGVuY2lsRnVuYyA9IGpzb24uc3RlbmNpbEZ1bmM7XG4gICAgICBpZiAoanNvbi5zdGVuY2lsUmVmICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnN0ZW5jaWxSZWYgPSBqc29uLnN0ZW5jaWxSZWY7XG4gICAgICBpZiAoanNvbi5zdGVuY2lsRnVuY01hc2sgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbEZ1bmNNYXNrID0ganNvbi5zdGVuY2lsRnVuY01hc2s7XG4gICAgICBpZiAoanNvbi5zdGVuY2lsRmFpbCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zdGVuY2lsRmFpbCA9IGpzb24uc3RlbmNpbEZhaWw7XG4gICAgICBpZiAoanNvbi5zdGVuY2lsWkZhaWwgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbFpGYWlsID0ganNvbi5zdGVuY2lsWkZhaWw7XG4gICAgICBpZiAoanNvbi5zdGVuY2lsWlBhc3MgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3RlbmNpbFpQYXNzID0ganNvbi5zdGVuY2lsWlBhc3M7XG4gICAgICBpZiAoanNvbi53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG4gICAgICBpZiAoanNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgICBpZiAoanNvbi53aXJlZnJhbWVMaW5lY2FwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSBqc29uLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgICBpZiAoanNvbi53aXJlZnJhbWVMaW5lam9pbiAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IGpzb24ud2lyZWZyYW1lTGluZWpvaW47XG4gICAgICBpZiAoanNvbi5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5yb3RhdGlvbiA9IGpzb24ucm90YXRpb247XG4gICAgICBpZiAoanNvbi5saW5ld2lkdGggIT09IDEpIG1hdGVyaWFsLmxpbmV3aWR0aCA9IGpzb24ubGluZXdpZHRoO1xuICAgICAgaWYgKGpzb24uZGFzaFNpemUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZGFzaFNpemUgPSBqc29uLmRhc2hTaXplO1xuICAgICAgaWYgKGpzb24uZ2FwU2l6ZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5nYXBTaXplID0ganNvbi5nYXBTaXplO1xuICAgICAgaWYgKGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2NhbGUgPSBqc29uLnNjYWxlO1xuICAgICAgaWYgKGpzb24ucG9seWdvbk9mZnNldCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0ganNvbi5wb2x5Z29uT2Zmc2V0O1xuICAgICAgaWYgKGpzb24ucG9seWdvbk9mZnNldEZhY3RvciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0ganNvbi5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xuICAgICAgaWYgKGpzb24ucG9seWdvbk9mZnNldFVuaXRzICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IGpzb24ucG9seWdvbk9mZnNldFVuaXRzO1xuICAgICAgaWYgKGpzb24uZGl0aGVyaW5nICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRpdGhlcmluZyA9IGpzb24uZGl0aGVyaW5nO1xuICAgICAgaWYgKGpzb24uYWxwaGFUb0NvdmVyYWdlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmFscGhhVG9Db3ZlcmFnZSA9IGpzb24uYWxwaGFUb0NvdmVyYWdlO1xuICAgICAgaWYgKGpzb24ucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSA9IGpzb24ucHJlbXVsdGlwbGllZEFscGhhO1xuICAgICAgaWYgKGpzb24udmlzaWJsZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC52aXNpYmxlID0ganNvbi52aXNpYmxlO1xuICAgICAgaWYgKGpzb24udG9uZU1hcHBlZCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50b25lTWFwcGVkID0ganNvbi50b25lTWFwcGVkO1xuICAgICAgaWYgKGpzb24udXNlckRhdGEgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuXG4gICAgICBpZiAoanNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24udmVydGV4Q29sb3JzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzID4gMCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcbiAgICAgICAgfVxuICAgICAgfSAvLyBTaGFkZXIgTWF0ZXJpYWxcblxuXG4gICAgICBpZiAoanNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4ganNvbi51bmlmb3Jtcykge1xuICAgICAgICAgIHZhciB1bmlmb3JtID0ganNvbi51bmlmb3Jtc1tuYW1lXTtcbiAgICAgICAgICBtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXSA9IHt9O1xuXG4gICAgICAgICAgc3dpdGNoICh1bmlmb3JtLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICBtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IGdldFRleHR1cmUodW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgbWF0ZXJpYWwudW5pZm9ybXNbbmFtZV0udmFsdWUgPSBuZXcgQ29sb3IoKS5zZXRIZXgodW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd2Mic6XG4gICAgICAgICAgICAgIG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gbmV3IFZlY3RvcjIoKS5mcm9tQXJyYXkodW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd2Myc6XG4gICAgICAgICAgICAgIG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkodW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd2NCc6XG4gICAgICAgICAgICAgIG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gbmV3IFZlY3RvcjQoKS5mcm9tQXJyYXkodW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtMyc6XG4gICAgICAgICAgICAgIG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gbmV3IE1hdHJpeDMoKS5mcm9tQXJyYXkodW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtNCc6XG4gICAgICAgICAgICAgIG1hdGVyaWFsLnVuaWZvcm1zW25hbWVdLnZhbHVlID0gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkodW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBtYXRlcmlhbC51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHVuaWZvcm0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChqc29uLmRlZmluZXMgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZGVmaW5lcyA9IGpzb24uZGVmaW5lcztcbiAgICAgIGlmIChqc29uLnZlcnRleFNoYWRlciAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcbiAgICAgIGlmIChqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcblxuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBqc29uLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICBtYXRlcmlhbC5leHRlbnNpb25zW2tleV0gPSBqc29uLmV4dGVuc2lvbnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEZXByZWNhdGVkXG5cblxuICAgICAgaWYgKGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uc2hhZGluZyA9PT0gMTsgLy8gVEhSRUUuRmxhdFNoYWRpbmdcbiAgICAgIC8vIGZvciBQb2ludHNNYXRlcmlhbFxuXG4gICAgICBpZiAoanNvbi5zaXplICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XG4gICAgICBpZiAoanNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247IC8vIG1hcHNcblxuICAgICAgaWYgKGpzb24ubWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoanNvbi5tYXApO1xuICAgICAgaWYgKGpzb24ubWF0Y2FwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm1hdGNhcCA9IGdldFRleHR1cmUoanNvbi5tYXRjYXApO1xuICAgICAgaWYgKGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYWxwaGFNYXAgPSBnZXRUZXh0dXJlKGpzb24uYWxwaGFNYXApO1xuICAgICAgaWYgKGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZShqc29uLmJ1bXBNYXApO1xuICAgICAgaWYgKGpzb24uYnVtcFNjYWxlICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xuICAgICAgaWYgKGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm5vcm1hbE1hcCA9IGdldFRleHR1cmUoanNvbi5ub3JtYWxNYXApO1xuICAgICAgaWYgKGpzb24ubm9ybWFsTWFwVHlwZSAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5ub3JtYWxNYXBUeXBlID0ganNvbi5ub3JtYWxNYXBUeXBlO1xuXG4gICAgICBpZiAoanNvbi5ub3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub3JtYWxTY2FsZSA9IGpzb24ubm9ybWFsU2NhbGU7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9ybWFsU2NhbGUpID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxuICAgICAgICAgIG5vcm1hbFNjYWxlID0gW25vcm1hbFNjYWxlLCBub3JtYWxTY2FsZV07XG4gICAgICAgIH1cblxuICAgICAgICBtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KG5vcm1hbFNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCA9IGdldFRleHR1cmUoanNvbi5kaXNwbGFjZW1lbnRNYXApO1xuICAgICAgaWYgKGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgICAgaWYgKGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0ganNvbi5kaXNwbGFjZW1lbnRCaWFzO1xuICAgICAgaWYgKGpzb24ucm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5yb3VnaG5lc3NNYXApO1xuICAgICAgaWYgKGpzb24ubWV0YWxuZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLm1ldGFsbmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5tZXRhbG5lc3NNYXApO1xuICAgICAgaWYgKGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZW1pc3NpdmVNYXAgPSBnZXRUZXh0dXJlKGpzb24uZW1pc3NpdmVNYXApO1xuICAgICAgaWYgKGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgPSBqc29uLmVtaXNzaXZlSW50ZW5zaXR5O1xuICAgICAgaWYgKGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKGpzb24uc3BlY3VsYXJNYXApO1xuICAgICAgaWYgKGpzb24uc3BlY3VsYXJJbnRlbnNpdHlNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc3BlY3VsYXJJbnRlbnNpdHlNYXAgPSBnZXRUZXh0dXJlKGpzb24uc3BlY3VsYXJJbnRlbnNpdHlNYXApO1xuICAgICAgaWYgKGpzb24uc3BlY3VsYXJDb2xvck1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC5zcGVjdWxhckNvbG9yTWFwID0gZ2V0VGV4dHVyZShqc29uLnNwZWN1bGFyQ29sb3JNYXApO1xuICAgICAgaWYgKGpzb24uZW52TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmVudk1hcCA9IGdldFRleHR1cmUoanNvbi5lbnZNYXApO1xuICAgICAgaWYgKGpzb24uZW52TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmVudk1hcEludGVuc2l0eSA9IGpzb24uZW52TWFwSW50ZW5zaXR5O1xuICAgICAgaWYgKGpzb24ucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xuICAgICAgaWYgKGpzb24ucmVmcmFjdGlvblJhdGlvICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbyA9IGpzb24ucmVmcmFjdGlvblJhdGlvO1xuICAgICAgaWYgKGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubGlnaHRNYXAgPSBnZXRUZXh0dXJlKGpzb24ubGlnaHRNYXApO1xuICAgICAgaWYgKGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5O1xuICAgICAgaWYgKGpzb24uYW9NYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKGpzb24uYW9NYXApO1xuICAgICAgaWYgKGpzb24uYW9NYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xuICAgICAgaWYgKGpzb24uZ3JhZGllbnRNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuZ3JhZGllbnRNYXAgPSBnZXRUZXh0dXJlKGpzb24uZ3JhZGllbnRNYXApO1xuICAgICAgaWYgKGpzb24uY2xlYXJjb2F0TWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdE1hcCA9IGdldFRleHR1cmUoanNvbi5jbGVhcmNvYXRNYXApO1xuICAgICAgaWYgKGpzb24uY2xlYXJjb2F0Um91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdFJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoanNvbi5jbGVhcmNvYXRSb3VnaG5lc3NNYXApO1xuICAgICAgaWYgKGpzb24uY2xlYXJjb2F0Tm9ybWFsTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbE1hcCA9IGdldFRleHR1cmUoanNvbi5jbGVhcmNvYXROb3JtYWxNYXApO1xuICAgICAgaWYgKGpzb24uY2xlYXJjb2F0Tm9ybWFsU2NhbGUgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheShqc29uLmNsZWFyY29hdE5vcm1hbFNjYWxlKTtcbiAgICAgIGlmIChqc29uLmlyaWRlc2NlbmNlTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmlyaWRlc2NlbmNlTWFwID0gZ2V0VGV4dHVyZShqc29uLmlyaWRlc2NlbmNlTWFwKTtcbiAgICAgIGlmIChqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwID0gZ2V0VGV4dHVyZShqc29uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwKTtcbiAgICAgIGlmIChqc29uLnRyYW5zbWlzc2lvbk1hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50cmFuc21pc3Npb25NYXAgPSBnZXRUZXh0dXJlKGpzb24udHJhbnNtaXNzaW9uTWFwKTtcbiAgICAgIGlmIChqc29uLnRoaWNrbmVzc01hcCAhPT0gdW5kZWZpbmVkKSBtYXRlcmlhbC50aGlja25lc3NNYXAgPSBnZXRUZXh0dXJlKGpzb24udGhpY2tuZXNzTWFwKTtcbiAgICAgIGlmIChqc29uLnNoZWVuQ29sb3JNYXAgIT09IHVuZGVmaW5lZCkgbWF0ZXJpYWwuc2hlZW5Db2xvck1hcCA9IGdldFRleHR1cmUoanNvbi5zaGVlbkNvbG9yTWFwKTtcbiAgICAgIGlmIChqc29uLnNoZWVuUm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQpIG1hdGVyaWFsLnNoZWVuUm91Z2huZXNzTWFwID0gZ2V0VGV4dHVyZShqc29uLnNoZWVuUm91Z2huZXNzTWFwKTtcbiAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGV4dHVyZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dHVyZXModmFsdWUpIHtcbiAgICAgIHRoaXMudGV4dHVyZXMgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXRlcmlhbExvYWRlcjtcbn0oTG9hZGVyKTtcblxudmFyIExvYWRlclV0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9hZGVyVXRpbHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvYWRlclV0aWxzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMb2FkZXJVdGlscywgbnVsbCwgW3tcbiAgICBrZXk6IFwiZGVjb2RlVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVUZXh0KGFycmF5KSB7XG4gICAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGFycmF5KTtcbiAgICAgIH0gLy8gQXZvaWQgdGhlIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIHNob3J0Y3V0LCB3aGljaFxuICAgICAgLy8gdGhyb3dzIGEgXCJtYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiIGVycm9yIGZvciBsYXJnZSBhcnJheXMuXG5cblxuICAgICAgdmFyIHMgPSAnJztcblxuICAgICAgZm9yICh2YXIgX2kyOTcgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgX2kyOTcgPCBpbDsgX2kyOTcrKykge1xuICAgICAgICAvLyBJbXBsaWNpdGx5IGFzc3VtZXMgbGl0dGxlLWVuZGlhbi5cbiAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W19pMjk3XSk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIG1lcmdlcyBtdWx0aS1ieXRlIHV0Zi04IGNoYXJhY3RlcnMuXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHMpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gc2VlICMxNjM1OFxuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdFVybEJhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdFVybEJhc2UodXJsKSB7XG4gICAgICB2YXIgaW5kZXggPSB1cmwubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiAnLi8nO1xuICAgICAgcmV0dXJuIHVybC5zbGljZSgwLCBpbmRleCArIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlVVJMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsLCBwYXRoKSB7XG4gICAgICAvLyBJbnZhbGlkIFVSTFxuICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnIHx8IHVybCA9PT0gJycpIHJldHVybiAnJzsgLy8gSG9zdCBSZWxhdGl2ZSBVUkxcblxuICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QocGF0aCkgJiYgL15cXC8vLnRlc3QodXJsKSkge1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC8oXmh0dHBzPzpcXC9cXC9bXlxcL10rKS4qL2ksICckMScpO1xuICAgICAgfSAvLyBBYnNvbHV0ZSBVUkwgaHR0cDovLyxodHRwczovLywvL1xuXG5cbiAgICAgIGlmICgvXihodHRwcz86KT9cXC9cXC8vaS50ZXN0KHVybCkpIHJldHVybiB1cmw7IC8vIERhdGEgVVJJXG5cbiAgICAgIGlmICgvXmRhdGE6LiosLiokL2kudGVzdCh1cmwpKSByZXR1cm4gdXJsOyAvLyBCbG9iIFVSTFxuXG4gICAgICBpZiAoL15ibG9iOi4qJC9pLnRlc3QodXJsKSkgcmV0dXJuIHVybDsgLy8gUmVsYXRpdmUgVVJMXG5cbiAgICAgIHJldHVybiBwYXRoICsgdXJsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMb2FkZXJVdGlscztcbn0oKTtcblxudmFyIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQnVmZmVyR2VvbWV0cnkxNikge1xuICBfaW5oZXJpdHMoSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksIF9CdWZmZXJHZW9tZXRyeTE2KTtcblxuICB2YXIgX3N1cGVyMTI5ID0gX2NyZWF0ZVN1cGVyKEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXMxMDU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkpO1xuXG4gICAgX3RoaXMxMDUgPSBfc3VwZXIxMjkuY2FsbCh0aGlzKTtcbiAgICBfdGhpczEwNS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gdHJ1ZTtcbiAgICBfdGhpczEwNS50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5JztcbiAgICBfdGhpczEwNS5pbnN0YW5jZUNvdW50ID0gSW5maW5pdHk7XG4gICAgcmV0dXJuIF90aGlzMTA1O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LCBbe1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoc291cmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUpLCBcImNvcHlcIiwgdGhpcykuY2FsbCh0aGlzLCBzb3VyY2UpO1xuXG4gICAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBzb3VyY2UuaW5zdGFuY2VDb3VudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgZGF0YSA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcywgdGhpcyk7XG5cbiAgICAgIGRhdGEuaW5zdGFuY2VDb3VudCA9IHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgICAgIGRhdGEuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IHRydWU7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk7XG59KEJ1ZmZlckdlb21ldHJ5KTtcblxudmFyIEJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9hZGVyOSkge1xuICBfaW5oZXJpdHMoQnVmZmVyR2VvbWV0cnlMb2FkZXIsIF9Mb2FkZXI5KTtcblxuICB2YXIgX3N1cGVyMTMwID0gX2NyZWF0ZVN1cGVyKEJ1ZmZlckdlb21ldHJ5TG9hZGVyKTtcblxuICBmdW5jdGlvbiBCdWZmZXJHZW9tZXRyeUxvYWRlcihtYW5hZ2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckdlb21ldHJ5TG9hZGVyKTtcblxuICAgIHJldHVybiBfc3VwZXIxMzAuY2FsbCh0aGlzLCBtYW5hZ2VyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJHZW9tZXRyeUxvYWRlciwgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgdmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHNjb3BlLm1hbmFnZXIpO1xuICAgICAgbG9hZGVyLnNldFBhdGgoc2NvcGUucGF0aCk7XG4gICAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcihzY29wZS5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoc2NvcGUud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvbkxvYWQoc2NvcGUucGFyc2UoSlNPTi5wYXJzZSh0ZXh0KSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgfVxuICAgICAgfSwgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGpzb24pIHtcbiAgICAgIHZhciBpbnRlcmxlYXZlZEJ1ZmZlck1hcCA9IHt9O1xuICAgICAgdmFyIGFycmF5QnVmZmVyTWFwID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIGdldEludGVybGVhdmVkQnVmZmVyKGpzb24sIHV1aWQpIHtcbiAgICAgICAgaWYgKGludGVybGVhdmVkQnVmZmVyTWFwW3V1aWRdICE9PSB1bmRlZmluZWQpIHJldHVybiBpbnRlcmxlYXZlZEJ1ZmZlck1hcFt1dWlkXTtcbiAgICAgICAgdmFyIGludGVybGVhdmVkQnVmZmVycyA9IGpzb24uaW50ZXJsZWF2ZWRCdWZmZXJzO1xuICAgICAgICB2YXIgaW50ZXJsZWF2ZWRCdWZmZXIgPSBpbnRlcmxlYXZlZEJ1ZmZlcnNbdXVpZF07XG4gICAgICAgIHZhciBidWZmZXIgPSBnZXRBcnJheUJ1ZmZlcihqc29uLCBpbnRlcmxlYXZlZEJ1ZmZlci5idWZmZXIpO1xuICAgICAgICB2YXIgYXJyYXkgPSBnZXRUeXBlZEFycmF5KGludGVybGVhdmVkQnVmZmVyLnR5cGUsIGJ1ZmZlcik7XG4gICAgICAgIHZhciBpYiA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgaW50ZXJsZWF2ZWRCdWZmZXIuc3RyaWRlKTtcbiAgICAgICAgaWIudXVpZCA9IGludGVybGVhdmVkQnVmZmVyLnV1aWQ7XG4gICAgICAgIGludGVybGVhdmVkQnVmZmVyTWFwW3V1aWRdID0gaWI7XG4gICAgICAgIHJldHVybiBpYjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIoanNvbiwgdXVpZCkge1xuICAgICAgICBpZiAoYXJyYXlCdWZmZXJNYXBbdXVpZF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIGFycmF5QnVmZmVyTWFwW3V1aWRdO1xuICAgICAgICB2YXIgYXJyYXlCdWZmZXJzID0ganNvbi5hcnJheUJ1ZmZlcnM7XG4gICAgICAgIHZhciBhcnJheUJ1ZmZlciA9IGFycmF5QnVmZmVyc1t1dWlkXTtcbiAgICAgICAgdmFyIGFiID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKS5idWZmZXI7XG4gICAgICAgIGFycmF5QnVmZmVyTWFwW3V1aWRdID0gYWI7XG4gICAgICAgIHJldHVybiBhYjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdlb21ldHJ5ID0ganNvbi5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID8gbmV3IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KCkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcblxuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHR5cGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5KGluZGV4LnR5cGUsIGluZGV4LmFycmF5KTtcbiAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZSh0eXBlZEFycmF5LCAxKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIHZhciBidWZmZXJBdHRyaWJ1dGUgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSB7XG4gICAgICAgICAgdmFyIGludGVybGVhdmVkQnVmZmVyID0gZ2V0SW50ZXJsZWF2ZWRCdWZmZXIoanNvbi5kYXRhLCBhdHRyaWJ1dGUuZGF0YSk7XG4gICAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGludGVybGVhdmVkQnVmZmVyLCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5vZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3R5cGVkQXJyYXkgPSBnZXRUeXBlZEFycmF5KGF0dHJpYnV0ZS50eXBlLCBhdHRyaWJ1dGUuYXJyYXkpO1xuXG4gICAgICAgICAgdmFyIGJ1ZmZlckF0dHJpYnV0ZUNvbnN0ciA9IGF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA/IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA6IEJ1ZmZlckF0dHJpYnV0ZTtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgYnVmZmVyQXR0cmlidXRlQ29uc3RyKF90eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyaWJ1dGUubmFtZSAhPT0gdW5kZWZpbmVkKSBidWZmZXJBdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICBpZiAoYXR0cmlidXRlLnVzYWdlICE9PSB1bmRlZmluZWQpIGJ1ZmZlckF0dHJpYnV0ZS5zZXRVc2FnZShhdHRyaWJ1dGUudXNhZ2UpO1xuXG4gICAgICAgIGlmIChhdHRyaWJ1dGUudXBkYXRlUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZS5vZmZzZXQgPSBhdHRyaWJ1dGUudXBkYXRlUmFuZ2Uub2Zmc2V0O1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS51cGRhdGVSYW5nZS5jb3VudCA9IGF0dHJpYnV0ZS51cGRhdGVSYW5nZS5jb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShrZXksIGJ1ZmZlckF0dHJpYnV0ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBqc29uLmRhdGEubW9ycGhBdHRyaWJ1dGVzO1xuXG4gICAgICBpZiAobW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAodmFyIF9rZXkzIGluIG1vcnBoQXR0cmlidXRlcykge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVBcnJheSA9IG1vcnBoQXR0cmlidXRlc1tfa2V5M107XG4gICAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTI5OCA9IDAsIGlsID0gYXR0cmlidXRlQXJyYXkubGVuZ3RoOyBfaTI5OCA8IGlsOyBfaTI5OCsrKSB7XG4gICAgICAgICAgICB2YXIgX2F0dHJpYnV0ZTMgPSBhdHRyaWJ1dGVBcnJheVtfaTI5OF07XG5cbiAgICAgICAgICAgIHZhciBfYnVmZmVyQXR0cmlidXRlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoX2F0dHJpYnV0ZTMuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICB2YXIgX2ludGVybGVhdmVkQnVmZmVyID0gZ2V0SW50ZXJsZWF2ZWRCdWZmZXIoanNvbi5kYXRhLCBfYXR0cmlidXRlMy5kYXRhKTtcblxuICAgICAgICAgICAgICBfYnVmZmVyQXR0cmlidXRlID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKF9pbnRlcmxlYXZlZEJ1ZmZlciwgX2F0dHJpYnV0ZTMuaXRlbVNpemUsIF9hdHRyaWJ1dGUzLm9mZnNldCwgX2F0dHJpYnV0ZTMubm9ybWFsaXplZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX3R5cGVkQXJyYXkyID0gZ2V0VHlwZWRBcnJheShfYXR0cmlidXRlMy50eXBlLCBfYXR0cmlidXRlMy5hcnJheSk7XG5cbiAgICAgICAgICAgICAgX2J1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoX3R5cGVkQXJyYXkyLCBfYXR0cmlidXRlMy5pdGVtU2l6ZSwgX2F0dHJpYnV0ZTMubm9ybWFsaXplZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfYXR0cmlidXRlMy5uYW1lICE9PSB1bmRlZmluZWQpIF9idWZmZXJBdHRyaWJ1dGUubmFtZSA9IF9hdHRyaWJ1dGUzLm5hbWU7XG4gICAgICAgICAgICBhcnJheS5wdXNoKF9idWZmZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tfa2V5M10gPSBhcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBqc29uLmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG5cbiAgICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuICAgICAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XG5cbiAgICAgIGlmIChncm91cHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBfaTI5OSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBfaTI5OSAhPT0gbjsgKytfaTI5OSkge1xuICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tfaTI5OV07XG4gICAgICAgICAgZ2VvbWV0cnkuYWRkR3JvdXAoZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XG5cbiAgICAgIGlmIChib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgICAgIGlmIChib3VuZGluZ1NwaGVyZS5jZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNlbnRlci5mcm9tQXJyYXkoYm91bmRpbmdTcGhlcmUuY2VudGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZShjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChqc29uLm5hbWUpIGdlb21ldHJ5Lm5hbWUgPSBqc29uLm5hbWU7XG4gICAgICBpZiAoanNvbi51c2VyRGF0YSkgZ2VvbWV0cnkudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xuICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJHZW9tZXRyeUxvYWRlcjtcbn0oTG9hZGVyKTtcblxudmFyIE9iamVjdExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcjEwKSB7XG4gIF9pbmhlcml0cyhPYmplY3RMb2FkZXIsIF9Mb2FkZXIxMCk7XG5cbiAgdmFyIF9zdXBlcjEzMSA9IF9jcmVhdGVTdXBlcihPYmplY3RMb2FkZXIpO1xuXG4gIGZ1bmN0aW9uIE9iamVjdExvYWRlcihtYW5hZ2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdExvYWRlcik7XG5cbiAgICByZXR1cm4gX3N1cGVyMTMxLmNhbGwodGhpcywgbWFuYWdlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0TG9hZGVyLCBbe1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCA9PT0gJycgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpIDogdGhpcy5wYXRoO1xuICAgICAgdGhpcy5yZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aCB8fCBwYXRoO1xuICAgICAgdmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIganNvbiA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAob25FcnJvciAhPT0gdW5kZWZpbmVkKSBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRTpPYmplY3RMb2FkZXI6IENhblxcJ3QgcGFyc2UgJyArIHVybCArICcuJywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuICAgICAgICBpZiAobWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZS50b0xvd2VyQ2FzZSgpID09PSAnZ2VvbWV0cnknKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXCd0IGxvYWQgJyArIHVybCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2NvcGUucGFyc2UoanNvbiwgb25Mb2FkKTtcbiAgICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkQXN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sb2FkQXN5bmMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMih1cmwsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIHNjb3BlLCBwYXRoLCBsb2FkZXIsIHRleHQsIGpzb24sIG1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBzY29wZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9PT0gJycgPyBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpIDogdGhpcy5wYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGggfHwgcGF0aDtcbiAgICAgICAgICAgICAgICBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgICAgICAgICAgICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgICAgICAgICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgICAgICAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlci5sb2FkQXN5bmModXJsLCBvblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgdGV4dCA9IF9jb250ZXh0OS5zZW50O1xuICAgICAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuICAgICAgICAgICAgICAgIGlmICghKG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5JykpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFwndCBsb2FkICcgKyB1cmwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUucGFyc2VBc3luYyhqc29uKTtcblxuICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0OS5zZW50KTtcblxuICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWRBc3luYyhfeDcsIF94OCkge1xuICAgICAgICByZXR1cm4gX2xvYWRBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9hZEFzeW5jO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGpzb24sIG9uTG9hZCkge1xuICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucyhqc29uLmFuaW1hdGlvbnMpO1xuICAgICAgdmFyIHNoYXBlcyA9IHRoaXMucGFyc2VTaGFwZXMoanNvbi5zaGFwZXMpO1xuICAgICAgdmFyIGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcyhqc29uLmdlb21ldHJpZXMsIHNoYXBlcyk7XG4gICAgICB2YXIgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcyhqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob25Mb2FkICE9PSB1bmRlZmluZWQpIG9uTG9hZChvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnBhcnNlVGV4dHVyZXMoanNvbi50ZXh0dXJlcywgaW1hZ2VzKTtcbiAgICAgIHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyk7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdChqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyk7XG4gICAgICB2YXIgc2tlbGV0b25zID0gdGhpcy5wYXJzZVNrZWxldG9ucyhqc29uLnNrZWxldG9ucywgb2JqZWN0KTtcbiAgICAgIHRoaXMuYmluZFNrZWxldG9ucyhvYmplY3QsIHNrZWxldG9ucyk7IC8vXG5cbiAgICAgIGlmIChvbkxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaGFzSW1hZ2VzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgdXVpZCBpbiBpbWFnZXMpIHtcbiAgICAgICAgICBpZiAoaW1hZ2VzW3V1aWRdLmRhdGEgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICBoYXNJbWFnZXMgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0ltYWdlcyA9PT0gZmFsc2UpIG9uTG9hZChvYmplY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUFzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcGFyc2VBc3luYyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGpzb24pIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMsIHNoYXBlcywgZ2VvbWV0cmllcywgaW1hZ2VzLCB0ZXh0dXJlcywgbWF0ZXJpYWxzLCBvYmplY3QsIHNrZWxldG9ucztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQxMCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucyA9IHRoaXMucGFyc2VBbmltYXRpb25zKGpzb24uYW5pbWF0aW9ucyk7XG4gICAgICAgICAgICAgICAgc2hhcGVzID0gdGhpcy5wYXJzZVNoYXBlcyhqc29uLnNoYXBlcyk7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKGpzb24uZ2VvbWV0cmllcywgc2hhcGVzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1hZ2VzQXN5bmMoanNvbi5pbWFnZXMpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpbWFnZXMgPSBfY29udGV4dDEwLnNlbnQ7XG4gICAgICAgICAgICAgICAgdGV4dHVyZXMgPSB0aGlzLnBhcnNlVGV4dHVyZXMoanNvbi50ZXh0dXJlcywgaW1hZ2VzKTtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyk7XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gdGhpcy5wYXJzZU9iamVjdChqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLCB0ZXh0dXJlcywgYW5pbWF0aW9ucyk7XG4gICAgICAgICAgICAgICAgc2tlbGV0b25zID0gdGhpcy5wYXJzZVNrZWxldG9ucyhqc29uLnNrZWxldG9ucywgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRTa2VsZXRvbnMob2JqZWN0LCBza2VsZXRvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcInJldHVyblwiLCBvYmplY3QpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlQXN5bmMoX3g5KSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VBc3luYztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVNoYXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVNoYXBlcyhqc29uKSB7XG4gICAgICB2YXIgc2hhcGVzID0ge307XG5cbiAgICAgIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgX2kzMDAgPSAwLCBsID0ganNvbi5sZW5ndGg7IF9pMzAwIDwgbDsgX2kzMDArKykge1xuICAgICAgICAgIHZhciBzaGFwZSA9IG5ldyBTaGFwZSgpLmZyb21KU09OKGpzb25bX2kzMDBdKTtcbiAgICAgICAgICBzaGFwZXNbc2hhcGUudXVpZF0gPSBzaGFwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hhcGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVNrZWxldG9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVNrZWxldG9ucyhqc29uLCBvYmplY3QpIHtcbiAgICAgIHZhciBza2VsZXRvbnMgPSB7fTtcbiAgICAgIHZhciBib25lcyA9IHt9OyAvLyBnZW5lcmF0ZSBib25lIGxvb2t1cCB0YWJsZVxuXG4gICAgICBvYmplY3QudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5pc0JvbmUpIGJvbmVzW2NoaWxkLnV1aWRdID0gY2hpbGQ7XG4gICAgICB9KTsgLy8gY3JlYXRlIHNrZWxldG9uc1xuXG4gICAgICBpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIF9pMzAxID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBfaTMwMSA8IGw7IF9pMzAxKyspIHtcbiAgICAgICAgICB2YXIgc2tlbGV0b24gPSBuZXcgU2tlbGV0b24oKS5mcm9tSlNPTihqc29uW19pMzAxXSwgYm9uZXMpO1xuICAgICAgICAgIHNrZWxldG9uc1tza2VsZXRvbi51dWlkXSA9IHNrZWxldG9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBza2VsZXRvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlR2VvbWV0cmllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUdlb21ldHJpZXMoanNvbiwgc2hhcGVzKSB7XG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG4gICAgICBpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBCdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMzAyID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBfaTMwMiA8IGw7IF9pMzAyKyspIHtcbiAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIGRhdGEgPSBqc29uW19pMzAyXTtcblxuICAgICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdCdWZmZXJHZW9tZXRyeSc6XG4gICAgICAgICAgICBjYXNlICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc6XG4gICAgICAgICAgICAgIGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHZW9tZXRyeSc6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLk9iamVjdExvYWRlcjogVGhlIGxlZ2FjeSBHZW9tZXRyeSB0eXBlIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoZGF0YS50eXBlIGluIEdlb21ldHJpZXMpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeSA9IEdlb21ldHJpZXNbZGF0YS50eXBlXS5mcm9tSlNPTihkYXRhLCBzaGFwZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBcXFwiXCIuY29uY2F0KGRhdGEudHlwZSwgXCJcXFwiXCIpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2VvbWV0cnkudXVpZCA9IGRhdGEudXVpZDtcbiAgICAgICAgICBpZiAoZGF0YS5uYW1lICE9PSB1bmRlZmluZWQpIGdlb21ldHJ5Lm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgaWYgKGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgPT09IHRydWUgJiYgZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkKSBnZW9tZXRyeS51c2VyRGF0YSA9IGRhdGEudXNlckRhdGE7XG4gICAgICAgICAgZ2VvbWV0cmllc1tkYXRhLnV1aWRdID0gZ2VvbWV0cnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdlb21ldHJpZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlTWF0ZXJpYWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlTWF0ZXJpYWxzKGpzb24sIHRleHR1cmVzKSB7XG4gICAgICB2YXIgY2FjaGUgPSB7fTsgLy8gTXVsdGlNYXRlcmlhbFxuXG4gICAgICB2YXIgbWF0ZXJpYWxzID0ge307XG5cbiAgICAgIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGxvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xuICAgICAgICBsb2FkZXIuc2V0VGV4dHVyZXModGV4dHVyZXMpO1xuXG4gICAgICAgIGZvciAodmFyIF9pMzAzID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBfaTMwMyA8IGw7IF9pMzAzKyspIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGpzb25bX2kzMDNdO1xuXG4gICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ011bHRpTWF0ZXJpYWwnKSB7XG4gICAgICAgICAgICAvLyBEZXByZWNhdGVkXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhLm1hdGVyaWFscy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgbWF0ZXJpYWwgPSBkYXRhLm1hdGVyaWFsc1tqXTtcblxuICAgICAgICAgICAgICBpZiAoY2FjaGVbbWF0ZXJpYWwudXVpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhY2hlW21hdGVyaWFsLnV1aWRdID0gbG9hZGVyLnBhcnNlKG1hdGVyaWFsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFycmF5LnB1c2goY2FjaGVbbWF0ZXJpYWwudXVpZF0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRlcmlhbHNbZGF0YS51dWlkXSA9IGFycmF5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2FjaGVbZGF0YS51dWlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNhY2hlW2RhdGEudXVpZF0gPSBsb2FkZXIucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGVyaWFsc1tkYXRhLnV1aWRdID0gY2FjaGVbZGF0YS51dWlkXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGVyaWFscztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VBbmltYXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9ucyhqc29uKSB7XG4gICAgICB2YXIgYW5pbWF0aW9ucyA9IHt9O1xuXG4gICAgICBpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIF9pMzA0ID0gMDsgX2kzMDQgPCBqc29uLmxlbmd0aDsgX2kzMDQrKykge1xuICAgICAgICAgIHZhciBkYXRhID0ganNvbltfaTMwNF07XG4gICAgICAgICAgdmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlKGRhdGEpO1xuICAgICAgICAgIGFuaW1hdGlvbnNbY2xpcC51dWlkXSA9IGNsaXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlSW1hZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlSW1hZ2VzKGpzb24sIG9uTG9hZCkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgIHZhciBpbWFnZXMgPSB7fTtcbiAgICAgIHZhciBsb2FkZXI7XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZSh1cmwpIHtcbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICAgICAgcmV0dXJuIGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICB9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemVJbWFnZShpbWFnZSkge1xuICAgICAgICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciB1cmwgPSBpbWFnZTtcbiAgICAgICAgICB2YXIgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCh1cmwpID8gdXJsIDogc2NvcGUucmVzb3VyY2VQYXRoICsgdXJsO1xuICAgICAgICAgIHJldHVybiBsb2FkSW1hZ2UocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGltYWdlLmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IGdldFR5cGVkQXJyYXkoaW1hZ2UudHlwZSwgaW1hZ2UuZGF0YSksXG4gICAgICAgICAgICAgIHdpZHRoOiBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZS5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoanNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcihvbkxvYWQpO1xuICAgICAgICBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIobWFuYWdlcik7XG4gICAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtcblxuICAgICAgICBmb3IgKHZhciBfaTMwNSA9IDAsIGlsID0ganNvbi5sZW5ndGg7IF9pMzA1IDwgaWw7IF9pMzA1KyspIHtcbiAgICAgICAgICB2YXIgaW1hZ2UgPSBqc29uW19pMzA1XTtcbiAgICAgICAgICB2YXIgdXJsID0gaW1hZ2UudXJsO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXJsKSkge1xuICAgICAgICAgICAgLy8gbG9hZCBhcnJheSBvZiBpbWFnZXMgZS5nIEN1YmVUZXh0dXJlXG4gICAgICAgICAgICB2YXIgaW1hZ2VBcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamwgPSB1cmwubGVuZ3RoOyBqIDwgamw7IGorKykge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudFVybCA9IHVybFtqXTtcbiAgICAgICAgICAgICAgdmFyIGRlc2VyaWFsaXplZEltYWdlID0gZGVzZXJpYWxpemVJbWFnZShjdXJyZW50VXJsKTtcblxuICAgICAgICAgICAgICBpZiAoZGVzZXJpYWxpemVkSW1hZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVzZXJpYWxpemVkSW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICBpbWFnZUFycmF5LnB1c2goZGVzZXJpYWxpemVkSW1hZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBhcnJheSBvZiBkYXRhIHRleHR1cmVzIGZvciBjdWJlIHRleHR1cmVzXG4gICAgICAgICAgICAgICAgICBpbWFnZUFycmF5LnB1c2gobmV3IERhdGFUZXh0dXJlKGRlc2VyaWFsaXplZEltYWdlLmRhdGEsIGRlc2VyaWFsaXplZEltYWdlLndpZHRoLCBkZXNlcmlhbGl6ZWRJbWFnZS5oZWlnaHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW1hZ2VzW2ltYWdlLnV1aWRdID0gbmV3IFNvdXJjZShpbWFnZUFycmF5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbG9hZCBzaW5nbGUgaW1hZ2VcbiAgICAgICAgICAgIHZhciBfZGVzZXJpYWxpemVkSW1hZ2UgPSBkZXNlcmlhbGl6ZUltYWdlKGltYWdlLnVybCk7XG5cbiAgICAgICAgICAgIGltYWdlc1tpbWFnZS51dWlkXSA9IG5ldyBTb3VyY2UoX2Rlc2VyaWFsaXplZEltYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGltYWdlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VJbWFnZXNBc3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3BhcnNlSW1hZ2VzQXN5bmMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNShqc29uKSB7XG4gICAgICAgIHZhciBzY29wZSwgaW1hZ2VzLCBsb2FkZXIsIGRlc2VyaWFsaXplSW1hZ2UsIF9kZXNlcmlhbGl6ZUltYWdlLCBfaTMwNiwgaWwsIGltYWdlLCB1cmwsIGltYWdlQXJyYXksIGosIGpsLCBjdXJyZW50VXJsLCBkZXNlcmlhbGl6ZWRJbWFnZSwgX2Rlc2VyaWFsaXplZEltYWdlMjtcblxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDEyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfZGVzZXJpYWxpemVJbWFnZSA9IGZ1bmN0aW9uIF9kZXNlcmlhbGl6ZUltYWdlMygpIHtcbiAgICAgICAgICAgICAgICAgIF9kZXNlcmlhbGl6ZUltYWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF91cmwsIHBhdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQxMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdXJsID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdChfdXJsKSA/IF91cmwgOiBzY29wZS5yZXNvdXJjZVBhdGggKyBfdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlci5sb2FkQXN5bmMocGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDExLnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGdldFR5cGVkQXJyYXkoaW1hZ2UudHlwZSwgaW1hZ2UuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGltYWdlLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFwicmV0dXJuXCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNCk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2Rlc2VyaWFsaXplSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGVzZXJpYWxpemVJbWFnZSA9IGZ1bmN0aW9uIF9kZXNlcmlhbGl6ZUltYWdlMihfeDExKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2Rlc2VyaWFsaXplSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGltYWdlcyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoanNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDMzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgICAgICAgICAgICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pO1xuICAgICAgICAgICAgICAgIF9pMzA2ID0gMCwgaWwgPSBqc29uLmxlbmd0aDtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaWYgKCEoX2kzMDYgPCBpbCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDMzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW1hZ2UgPSBqc29uW19pMzA2XTtcbiAgICAgICAgICAgICAgICB1cmwgPSBpbWFnZS51cmw7XG5cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodXJsKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMjY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsb2FkIGFycmF5IG9mIGltYWdlcyBlLmcgQ3ViZVRleHR1cmVcbiAgICAgICAgICAgICAgICBpbWFnZUFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgaiA9IDAsIGpsID0gdXJsLmxlbmd0aDtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGlmICghKGogPCBqbCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDIzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudFVybCA9IHVybFtqXTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVJbWFnZShjdXJyZW50VXJsKTtcblxuICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgIGRlc2VyaWFsaXplZEltYWdlID0gX2NvbnRleHQxMi5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlc2VyaWFsaXplZEltYWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZGVzZXJpYWxpemVkSW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlQXJyYXkucHVzaChkZXNlcmlhbGl6ZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBhcnJheSBvZiBkYXRhIHRleHR1cmVzIGZvciBjdWJlIHRleHR1cmVzXG4gICAgICAgICAgICAgICAgICAgIGltYWdlQXJyYXkucHVzaChuZXcgRGF0YVRleHR1cmUoZGVzZXJpYWxpemVkSW1hZ2UuZGF0YSwgZGVzZXJpYWxpemVkSW1hZ2Uud2lkdGgsIGRlc2VyaWFsaXplZEltYWdlLmhlaWdodCkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgIGltYWdlc1tpbWFnZS51dWlkXSA9IG5ldyBTb3VyY2UoaW1hZ2VBcnJheSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAyODtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVJbWFnZShpbWFnZS51cmwpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgICAgX2Rlc2VyaWFsaXplZEltYWdlMiA9IF9jb250ZXh0MTIuc2VudDtcbiAgICAgICAgICAgICAgICBpbWFnZXNbaW1hZ2UudXVpZF0gPSBuZXcgU291cmNlKF9kZXNlcmlhbGl6ZWRJbWFnZTIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgICAgX2kzMDYrKztcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIGltYWdlcyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcGFyc2VJbWFnZXNBc3luYyhfeDEwKSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VJbWFnZXNBc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VJbWFnZXNBc3luYztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVRleHR1cmVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlVGV4dHVyZXMoanNvbiwgaW1hZ2VzKSB7XG4gICAgICBmdW5jdGlvbiBwYXJzZUNvbnN0YW50KHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0eXBlW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRleHR1cmVzID0ge307XG5cbiAgICAgIGlmIChqc29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgX2kzMDcgPSAwLCBsID0ganNvbi5sZW5ndGg7IF9pMzA3IDwgbDsgX2kzMDcrKykge1xuICAgICAgICAgIHZhciBkYXRhID0ganNvbltfaTMwN107XG5cbiAgICAgICAgICBpZiAoZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbWFnZXNbZGF0YS5pbWFnZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBpbWFnZScsIGRhdGEuaW1hZ2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzb3VyY2UgPSBpbWFnZXNbZGF0YS5pbWFnZV07XG4gICAgICAgICAgdmFyIGltYWdlID0gc291cmNlLmRhdGE7XG4gICAgICAgICAgdmFyIHRleHR1cmUgPSB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbWFnZSkpIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGlmIChpbWFnZS5sZW5ndGggPT09IDYpIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW1hZ2UgJiYgaW1hZ2UuZGF0YSkge1xuICAgICAgICAgICAgICB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGltYWdlKSB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gdGV4dHVyZXMgY2FuIGhhdmUgdW5kZWZpbmVkIGltYWdlIGRhdGFcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ZXh0dXJlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICB0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XG4gICAgICAgICAgaWYgKGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgaWYgKGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KGRhdGEubWFwcGluZywgVEVYVFVSRV9NQVBQSU5HKTtcbiAgICAgICAgICBpZiAoZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KGRhdGEub2Zmc2V0KTtcbiAgICAgICAgICBpZiAoZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KGRhdGEucmVwZWF0KTtcbiAgICAgICAgICBpZiAoZGF0YS5jZW50ZXIgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5jZW50ZXIuZnJvbUFycmF5KGRhdGEuY2VudGVyKTtcbiAgICAgICAgICBpZiAoZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcblxuICAgICAgICAgIGlmIChkYXRhLndyYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGV4dHVyZS53cmFwUyA9IHBhcnNlQ29uc3RhbnQoZGF0YS53cmFwWzBdLCBURVhUVVJFX1dSQVBQSU5HKTtcbiAgICAgICAgICAgIHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KGRhdGEud3JhcFsxXSwgVEVYVFVSRV9XUkFQUElORyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRhdGEuZm9ybWF0ICE9PSB1bmRlZmluZWQpIHRleHR1cmUuZm9ybWF0ID0gZGF0YS5mb3JtYXQ7XG4gICAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnR5cGUgPSBkYXRhLnR5cGU7XG4gICAgICAgICAgaWYgKGRhdGEuZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS5lbmNvZGluZyA9IGRhdGEuZW5jb2Rpbmc7XG4gICAgICAgICAgaWYgKGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQpIHRleHR1cmUubWluRmlsdGVyID0gcGFyc2VDb25zdGFudChkYXRhLm1pbkZpbHRlciwgVEVYVFVSRV9GSUxURVIpO1xuICAgICAgICAgIGlmIChkYXRhLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoZGF0YS5tYWdGaWx0ZXIsIFRFWFRVUkVfRklMVEVSKTtcbiAgICAgICAgICBpZiAoZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQpIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcbiAgICAgICAgICBpZiAoZGF0YS5mbGlwWSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLmZsaXBZID0gZGF0YS5mbGlwWTtcbiAgICAgICAgICBpZiAoZGF0YS5wcmVtdWx0aXBseUFscGhhICE9PSB1bmRlZmluZWQpIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IGRhdGEucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgICBpZiAoZGF0YS51bnBhY2tBbGlnbm1lbnQgIT09IHVuZGVmaW5lZCkgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgPSBkYXRhLnVucGFja0FsaWdubWVudDtcbiAgICAgICAgICBpZiAoZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkKSB0ZXh0dXJlLnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcbiAgICAgICAgICB0ZXh0dXJlc1tkYXRhLnV1aWRdID0gdGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGV4dHVyZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlT2JqZWN0KGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMpIHtcbiAgICAgIHZhciBvYmplY3Q7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEdlb21ldHJ5KG5hbWUpIHtcbiAgICAgICAgaWYgKGdlb21ldHJpZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZW9tZXRyaWVzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRNYXRlcmlhbChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMzA4ID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBfaTMwOCA8IGw7IF9pMzA4KyspIHtcbiAgICAgICAgICAgIHZhciB1dWlkID0gbmFtZVtfaTMwOF07XG5cbiAgICAgICAgICAgIGlmIChtYXRlcmlhbHNbdXVpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgdXVpZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFycmF5LnB1c2gobWF0ZXJpYWxzW3V1aWRdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0ZXJpYWxzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0ZXJpYWxzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRUZXh0dXJlKHV1aWQpIHtcbiAgICAgICAgaWYgKHRleHR1cmVzW3V1aWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCB1dWlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlc1t1dWlkXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdlb21ldHJ5LCBtYXRlcmlhbDtcblxuICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnU2NlbmUnOlxuICAgICAgICAgIG9iamVjdCA9IG5ldyBTY2VuZSgpO1xuXG4gICAgICAgICAgaWYgKGRhdGEuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihkYXRhLmJhY2tncm91bmQpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5iYWNrZ3JvdW5kID0gbmV3IENvbG9yKGRhdGEuYmFja2dyb3VuZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmplY3QuYmFja2dyb3VuZCA9IGdldFRleHR1cmUoZGF0YS5iYWNrZ3JvdW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGF0YS5lbnZpcm9ubWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmplY3QuZW52aXJvbm1lbnQgPSBnZXRUZXh0dXJlKGRhdGEuZW52aXJvbm1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkYXRhLmZvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZycpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LmZvZyA9IG5ldyBGb2coZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLm5lYXIsIGRhdGEuZm9nLmZhcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuZm9nLnR5cGUgPT09ICdGb2dFeHAyJykge1xuICAgICAgICAgICAgICBvYmplY3QuZm9nID0gbmV3IEZvZ0V4cDIoZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLmRlbnNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcbiAgICAgICAgICBvYmplY3QgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoZGF0YS5mb3YsIGRhdGEuYXNwZWN0LCBkYXRhLm5lYXIsIGRhdGEuZmFyKTtcbiAgICAgICAgICBpZiAoZGF0YS5mb2N1cyAhPT0gdW5kZWZpbmVkKSBvYmplY3QuZm9jdXMgPSBkYXRhLmZvY3VzO1xuICAgICAgICAgIGlmIChkYXRhLnpvb20gIT09IHVuZGVmaW5lZCkgb2JqZWN0Lnpvb20gPSBkYXRhLnpvb207XG4gICAgICAgICAgaWYgKGRhdGEuZmlsbUdhdWdlICE9PSB1bmRlZmluZWQpIG9iamVjdC5maWxtR2F1Z2UgPSBkYXRhLmZpbG1HYXVnZTtcbiAgICAgICAgICBpZiAoZGF0YS5maWxtT2Zmc2V0ICE9PSB1bmRlZmluZWQpIG9iamVjdC5maWxtT2Zmc2V0ID0gZGF0YS5maWxtT2Zmc2V0O1xuICAgICAgICAgIGlmIChkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhLnZpZXcpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XG4gICAgICAgICAgb2JqZWN0ID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYShkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhcik7XG4gICAgICAgICAgaWYgKGRhdGEuem9vbSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcbiAgICAgICAgICBpZiAoZGF0YS52aWV3ICE9PSB1bmRlZmluZWQpIG9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YS52aWV3KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBbWJpZW50TGlnaHQnOlxuICAgICAgICAgIG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuICAgICAgICAgIG9iamVjdCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQb2ludExpZ2h0JzpcbiAgICAgICAgICBvYmplY3QgPSBuZXcgUG9pbnRMaWdodChkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUmVjdEFyZWFMaWdodCc6XG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTcG90TGlnaHQnOlxuICAgICAgICAgIG9iamVjdCA9IG5ldyBTcG90TGlnaHQoZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEucGVudW1icmEsIGRhdGEuZGVjYXkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG4gICAgICAgICAgb2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodChkYXRhLmNvbG9yLCBkYXRhLmdyb3VuZENvbG9yLCBkYXRhLmludGVuc2l0eSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTGlnaHRQcm9iZSc6XG4gICAgICAgICAgb2JqZWN0ID0gbmV3IExpZ2h0UHJvYmUoKS5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdTa2lubmVkTWVzaCc6XG4gICAgICAgICAgZ2VvbWV0cnkgPSBnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KTtcbiAgICAgICAgICBtYXRlcmlhbCA9IGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpO1xuICAgICAgICAgIG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgIGlmIChkYXRhLmJpbmRNb2RlICE9PSB1bmRlZmluZWQpIG9iamVjdC5iaW5kTW9kZSA9IGRhdGEuYmluZE1vZGU7XG4gICAgICAgICAgaWYgKGRhdGEuYmluZE1hdHJpeCAhPT0gdW5kZWZpbmVkKSBvYmplY3QuYmluZE1hdHJpeC5mcm9tQXJyYXkoZGF0YS5iaW5kTWF0cml4KTtcbiAgICAgICAgICBpZiAoZGF0YS5za2VsZXRvbiAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2tlbGV0b24gPSBkYXRhLnNrZWxldG9uO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ01lc2gnOlxuICAgICAgICAgIGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSk7XG4gICAgICAgICAgbWF0ZXJpYWwgPSBnZXRNYXRlcmlhbChkYXRhLm1hdGVyaWFsKTtcbiAgICAgICAgICBvYmplY3QgPSBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0luc3RhbmNlZE1lc2gnOlxuICAgICAgICAgIGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSk7XG4gICAgICAgICAgbWF0ZXJpYWwgPSBnZXRNYXRlcmlhbChkYXRhLm1hdGVyaWFsKTtcbiAgICAgICAgICB2YXIgY291bnQgPSBkYXRhLmNvdW50O1xuICAgICAgICAgIHZhciBpbnN0YW5jZU1hdHJpeCA9IGRhdGEuaW5zdGFuY2VNYXRyaXg7XG4gICAgICAgICAgdmFyIGluc3RhbmNlQ29sb3IgPSBkYXRhLmluc3RhbmNlQ29sb3I7XG4gICAgICAgICAgb2JqZWN0ID0gbmV3IEluc3RhbmNlZE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsLCBjb3VudCk7XG4gICAgICAgICAgb2JqZWN0Lmluc3RhbmNlTWF0cml4ID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGluc3RhbmNlTWF0cml4LmFycmF5KSwgMTYpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZUNvbG9yICE9PSB1bmRlZmluZWQpIG9iamVjdC5pbnN0YW5jZUNvbG9yID0gbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGluc3RhbmNlQ29sb3IuYXJyYXkpLCBpbnN0YW5jZUNvbG9yLml0ZW1TaXplKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdMT0QnOlxuICAgICAgICAgIG9iamVjdCA9IG5ldyBMT0QoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdMaW5lJzpcbiAgICAgICAgICBvYmplY3QgPSBuZXcgTGluZShnZXRHZW9tZXRyeShkYXRhLmdlb21ldHJ5KSwgZ2V0TWF0ZXJpYWwoZGF0YS5tYXRlcmlhbCkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0xpbmVMb29wJzpcbiAgICAgICAgICBvYmplY3QgPSBuZXcgTGluZUxvb3AoZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSksIGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdMaW5lU2VnbWVudHMnOlxuICAgICAgICAgIG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoZ2V0R2VvbWV0cnkoZGF0YS5nZW9tZXRyeSksIGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQb2ludENsb3VkJzpcbiAgICAgICAgY2FzZSAnUG9pbnRzJzpcbiAgICAgICAgICBvYmplY3QgPSBuZXcgUG9pbnRzKGdldEdlb21ldHJ5KGRhdGEuZ2VvbWV0cnkpLCBnZXRNYXRlcmlhbChkYXRhLm1hdGVyaWFsKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnU3ByaXRlJzpcbiAgICAgICAgICBvYmplY3QgPSBuZXcgU3ByaXRlKGdldE1hdGVyaWFsKGRhdGEubWF0ZXJpYWwpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdHcm91cCc6XG4gICAgICAgICAgb2JqZWN0ID0gbmV3IEdyb3VwKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQm9uZSc6XG4gICAgICAgICAgb2JqZWN0ID0gbmV3IEJvbmUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xuICAgICAgfVxuXG4gICAgICBvYmplY3QudXVpZCA9IGRhdGEudXVpZDtcbiAgICAgIGlmIChkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XG5cbiAgICAgIGlmIChkYXRhLm1hdHJpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iamVjdC5tYXRyaXguZnJvbUFycmF5KGRhdGEubWF0cml4KTtcbiAgICAgICAgaWYgKGRhdGEubWF0cml4QXV0b1VwZGF0ZSAhPT0gdW5kZWZpbmVkKSBvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IGRhdGEubWF0cml4QXV0b1VwZGF0ZTtcbiAgICAgICAgaWYgKG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlKSBvYmplY3QubWF0cml4LmRlY29tcG9zZShvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheShkYXRhLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKGRhdGEucm90YXRpb24gIT09IHVuZGVmaW5lZCkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheShkYXRhLnJvdGF0aW9uKTtcbiAgICAgICAgaWYgKGRhdGEucXVhdGVybmlvbiAhPT0gdW5kZWZpbmVkKSBvYmplY3QucXVhdGVybmlvbi5mcm9tQXJyYXkoZGF0YS5xdWF0ZXJuaW9uKTtcbiAgICAgICAgaWYgKGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnNjYWxlLmZyb21BcnJheShkYXRhLnNjYWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcbiAgICAgIGlmIChkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cbiAgICAgIGlmIChkYXRhLnNoYWRvdykge1xuICAgICAgICBpZiAoZGF0YS5zaGFkb3cuYmlhcyAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xuICAgICAgICBpZiAoZGF0YS5zaGFkb3cubm9ybWFsQmlhcyAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93Lm5vcm1hbEJpYXMgPSBkYXRhLnNoYWRvdy5ub3JtYWxCaWFzO1xuICAgICAgICBpZiAoZGF0YS5zaGFkb3cucmFkaXVzICE9PSB1bmRlZmluZWQpIG9iamVjdC5zaGFkb3cucmFkaXVzID0gZGF0YS5zaGFkb3cucmFkaXVzO1xuICAgICAgICBpZiAoZGF0YS5zaGFkb3cubWFwU2l6ZSAhPT0gdW5kZWZpbmVkKSBvYmplY3Quc2hhZG93Lm1hcFNpemUuZnJvbUFycmF5KGRhdGEuc2hhZG93Lm1hcFNpemUpO1xuICAgICAgICBpZiAoZGF0YS5zaGFkb3cuY2FtZXJhICE9PSB1bmRlZmluZWQpIG9iamVjdC5zaGFkb3cuY2FtZXJhID0gdGhpcy5wYXJzZU9iamVjdChkYXRhLnNoYWRvdy5jYW1lcmEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQpIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuICAgICAgaWYgKGRhdGEuZnJ1c3R1bUN1bGxlZCAhPT0gdW5kZWZpbmVkKSBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IGRhdGEuZnJ1c3R1bUN1bGxlZDtcbiAgICAgIGlmIChkYXRhLnJlbmRlck9yZGVyICE9PSB1bmRlZmluZWQpIG9iamVjdC5yZW5kZXJPcmRlciA9IGRhdGEucmVuZGVyT3JkZXI7XG4gICAgICBpZiAoZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuICAgICAgaWYgKGRhdGEubGF5ZXJzICE9PSB1bmRlZmluZWQpIG9iamVjdC5sYXllcnMubWFzayA9IGRhdGEubGF5ZXJzO1xuXG4gICAgICBpZiAoZGF0YS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGRhdGEuY2hpbGRyZW47XG5cbiAgICAgICAgZm9yICh2YXIgX2kzMDkgPSAwOyBfaTMwOSA8IGNoaWxkcmVuLmxlbmd0aDsgX2kzMDkrKykge1xuICAgICAgICAgIG9iamVjdC5hZGQodGhpcy5wYXJzZU9iamVjdChjaGlsZHJlbltfaTMwOV0sIGdlb21ldHJpZXMsIG1hdGVyaWFscywgdGV4dHVyZXMsIGFuaW1hdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5hbmltYXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9iamVjdEFuaW1hdGlvbnMgPSBkYXRhLmFuaW1hdGlvbnM7XG5cbiAgICAgICAgZm9yICh2YXIgX2kzMTAgPSAwOyBfaTMxMCA8IG9iamVjdEFuaW1hdGlvbnMubGVuZ3RoOyBfaTMxMCsrKSB7XG4gICAgICAgICAgdmFyIHV1aWQgPSBvYmplY3RBbmltYXRpb25zW19pMzEwXTtcbiAgICAgICAgICBvYmplY3QuYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbnNbdXVpZF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdMT0QnKSB7XG4gICAgICAgIGlmIChkYXRhLmF1dG9VcGRhdGUgIT09IHVuZGVmaW5lZCkgb2JqZWN0LmF1dG9VcGRhdGUgPSBkYXRhLmF1dG9VcGRhdGU7XG4gICAgICAgIHZhciBsZXZlbHMgPSBkYXRhLmxldmVscztcblxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tsXTtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgndXVpZCcsIGxldmVsLm9iamVjdCk7XG5cbiAgICAgICAgICBpZiAoY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqZWN0LmFkZExldmVsKGNoaWxkLCBsZXZlbC5kaXN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRTa2VsZXRvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZFNrZWxldG9ucyhvYmplY3QsIHNrZWxldG9ucykge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHNrZWxldG9ucykubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICBvYmplY3QudHJhdmVyc2UoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5pc1NraW5uZWRNZXNoID09PSB0cnVlICYmIGNoaWxkLnNrZWxldG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc2tlbGV0b24gPSBza2VsZXRvbnNbY2hpbGQuc2tlbGV0b25dO1xuXG4gICAgICAgICAgaWYgKHNrZWxldG9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBza2VsZXRvbiBmb3VuZCB3aXRoIFVVSUQ6JywgY2hpbGQuc2tlbGV0b24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZC5iaW5kKHNrZWxldG9uLCBjaGlsZC5iaW5kTWF0cml4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBERVBSRUNBVEVEICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUZXh0dXJlUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0dXJlUGF0aCh2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5PYmplY3RMb2FkZXI6IC5zZXRUZXh0dXJlUGF0aCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldFJlc291cmNlUGF0aCgpLicpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0UmVzb3VyY2VQYXRoKHZhbHVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2JqZWN0TG9hZGVyO1xufShMb2FkZXIpO1xuXG52YXIgVEVYVFVSRV9NQVBQSU5HID0ge1xuICBVVk1hcHBpbmc6IFVWTWFwcGluZyxcbiAgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsXG4gIEN1YmVSZWZyYWN0aW9uTWFwcGluZzogQ3ViZVJlZnJhY3Rpb25NYXBwaW5nLFxuICBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsXG4gIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyxcbiAgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nXG59O1xudmFyIFRFWFRVUkVfV1JBUFBJTkcgPSB7XG4gIFJlcGVhdFdyYXBwaW5nOiBSZXBlYXRXcmFwcGluZyxcbiAgQ2xhbXBUb0VkZ2VXcmFwcGluZzogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcbiAgTWlycm9yZWRSZXBlYXRXcmFwcGluZzogTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xufTtcbnZhciBURVhUVVJFX0ZJTFRFUiA9IHtcbiAgTmVhcmVzdEZpbHRlcjogTmVhcmVzdEZpbHRlcixcbiAgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXI6IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyOiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuICBMaW5lYXJGaWx0ZXI6IExpbmVhckZpbHRlcixcbiAgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcjogTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcixcbiAgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyOiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcbn07XG5cbnZhciBJbWFnZUJpdG1hcExvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xvYWRlcjExKSB7XG4gIF9pbmhlcml0cyhJbWFnZUJpdG1hcExvYWRlciwgX0xvYWRlcjExKTtcblxuICB2YXIgX3N1cGVyMTMyID0gX2NyZWF0ZVN1cGVyKEltYWdlQml0bWFwTG9hZGVyKTtcblxuICBmdW5jdGlvbiBJbWFnZUJpdG1hcExvYWRlcihtYW5hZ2VyKSB7XG4gICAgdmFyIF90aGlzMTA2O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlQml0bWFwTG9hZGVyKTtcblxuICAgIF90aGlzMTA2ID0gX3N1cGVyMTMyLmNhbGwodGhpcywgbWFuYWdlcik7XG4gICAgX3RoaXMxMDYuaXNJbWFnZUJpdG1hcExvYWRlciA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogY3JlYXRlSW1hZ2VCaXRtYXAoKSBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBmZXRjaCgpIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgX3RoaXMxMDYub3B0aW9ucyA9IHtcbiAgICAgIHByZW11bHRpcGx5QWxwaGE6ICdub25lJ1xuICAgIH07XG4gICAgcmV0dXJuIF90aGlzMTA2O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEltYWdlQml0bWFwTG9hZGVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCkgdXJsID0gJyc7XG4gICAgICBpZiAodGhpcy5wYXRoICE9PSB1bmRlZmluZWQpIHVybCA9IHRoaXMucGF0aCArIHVybDtcbiAgICAgIHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKHVybCk7XG4gICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlZCA9IENhY2hlLmdldCh1cmwpO1xuXG4gICAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9uTG9hZCkgb25Mb2FkKGNhY2hlZCk7XG4gICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmV0Y2hPcHRpb25zID0ge307XG4gICAgICBmZXRjaE9wdGlvbnMuY3JlZGVudGlhbHMgPSB0aGlzLmNyb3NzT3JpZ2luID09PSAnYW5vbnltb3VzJyA/ICdzYW1lLW9yaWdpbicgOiAnaW5jbHVkZSc7XG4gICAgICBmZXRjaE9wdGlvbnMuaGVhZGVycyA9IHRoaXMucmVxdWVzdEhlYWRlcjtcbiAgICAgIGZldGNoKHVybCwgZmV0Y2hPcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5ibG9iKCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChibG9iLCBPYmplY3QuYXNzaWduKHNjb3BlLm9wdGlvbnMsIHtcbiAgICAgICAgICBjb2xvclNwYWNlQ29udmVyc2lvbjogJ25vbmUnXG4gICAgICAgIH0pKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGltYWdlQml0bWFwKSB7XG4gICAgICAgIENhY2hlLmFkZCh1cmwsIGltYWdlQml0bWFwKTtcbiAgICAgICAgaWYgKG9uTG9hZCkgb25Mb2FkKGltYWdlQml0bWFwKTtcbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAob25FcnJvcikgb25FcnJvcihlKTtcbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICB9KTtcbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlQml0bWFwTG9hZGVyO1xufShMb2FkZXIpO1xuXG52YXIgX2NvbnRleHQ7XG5cbnZhciBBdWRpb0NvbnRleHQgPSB7XG4gIGdldENvbnRleHQ6IGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgaWYgKF9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIF9jb250ZXh0ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jb250ZXh0O1xuICB9LFxuICBzZXRDb250ZXh0OiBmdW5jdGlvbiBzZXRDb250ZXh0KHZhbHVlKSB7XG4gICAgX2NvbnRleHQgPSB2YWx1ZTtcbiAgfVxufTtcblxudmFyIEF1ZGlvTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTG9hZGVyMTIpIHtcbiAgX2luaGVyaXRzKEF1ZGlvTG9hZGVyLCBfTG9hZGVyMTIpO1xuXG4gIHZhciBfc3VwZXIxMzMgPSBfY3JlYXRlU3VwZXIoQXVkaW9Mb2FkZXIpO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvTG9hZGVyKG1hbmFnZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9Mb2FkZXIpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjEzMy5jYWxsKHRoaXMsIG1hbmFnZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF1ZGlvTG9hZGVyLCBbe1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICB2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgbG9hZGVyLmxvYWQodXJsLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgYnVmZmVyLiBUaGUgYGRlY29kZUF1ZGlvRGF0YWAgbWV0aG9kXG4gICAgICAgICAgLy8gZGV0YWNoZXMgdGhlIGJ1ZmZlciB3aGVuIGNvbXBsZXRlLCBwcmV2ZW50aW5nIHJldXNlLlxuICAgICAgICAgIHZhciBidWZmZXJDb3B5ID0gYnVmZmVyLnNsaWNlKDApO1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcbiAgICAgICAgICBjb250ZXh0LmRlY29kZUF1ZGlvRGF0YShidWZmZXJDb3B5LCBmdW5jdGlvbiAoYXVkaW9CdWZmZXIpIHtcbiAgICAgICAgICAgIG9uTG9hZChhdWRpb0J1ZmZlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICB9XG4gICAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXVkaW9Mb2FkZXI7XG59KExvYWRlcik7XG5cbnZhciBIZW1pc3BoZXJlTGlnaHRQcm9iZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpZ2h0UHJvYmUpIHtcbiAgX2luaGVyaXRzKEhlbWlzcGhlcmVMaWdodFByb2JlLCBfTGlnaHRQcm9iZSk7XG5cbiAgdmFyIF9zdXBlcjEzNCA9IF9jcmVhdGVTdXBlcihIZW1pc3BoZXJlTGlnaHRQcm9iZSk7XG5cbiAgZnVuY3Rpb24gSGVtaXNwaGVyZUxpZ2h0UHJvYmUoc2t5Q29sb3IsIGdyb3VuZENvbG9yKSB7XG4gICAgdmFyIF90aGlzMTA3O1xuXG4gICAgdmFyIGludGVuc2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZW1pc3BoZXJlTGlnaHRQcm9iZSk7XG5cbiAgICBfdGhpczEwNyA9IF9zdXBlcjEzNC5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgaW50ZW5zaXR5KTtcbiAgICBfdGhpczEwNy5pc0hlbWlzcGhlcmVMaWdodFByb2JlID0gdHJ1ZTtcbiAgICB2YXIgY29sb3IxID0gbmV3IENvbG9yKCkuc2V0KHNreUNvbG9yKTtcbiAgICB2YXIgY29sb3IyID0gbmV3IENvbG9yKCkuc2V0KGdyb3VuZENvbG9yKTtcbiAgICB2YXIgc2t5ID0gbmV3IFZlY3RvcjMoY29sb3IxLnIsIGNvbG9yMS5nLCBjb2xvcjEuYik7XG4gICAgdmFyIGdyb3VuZCA9IG5ldyBWZWN0b3IzKGNvbG9yMi5yLCBjb2xvcjIuZywgY29sb3IyLmIpOyAvLyB3aXRob3V0IGV4dHJhIGZhY3RvciBvZiBQSSBpbiB0aGUgc2hhZGVyLCBzaG91bGQgPSAxIC8gTWF0aC5zcXJ0KCBNYXRoLlBJICk7XG5cbiAgICB2YXIgYzAgPSBNYXRoLnNxcnQoTWF0aC5QSSk7XG4gICAgdmFyIGMxID0gYzAgKiBNYXRoLnNxcnQoMC43NSk7XG5cbiAgICBfdGhpczEwNy5zaC5jb2VmZmljaWVudHNbMF0uY29weShza3kpLmFkZChncm91bmQpLm11bHRpcGx5U2NhbGFyKGMwKTtcblxuICAgIF90aGlzMTA3LnNoLmNvZWZmaWNpZW50c1sxXS5jb3B5KHNreSkuc3ViKGdyb3VuZCkubXVsdGlwbHlTY2FsYXIoYzEpO1xuXG4gICAgcmV0dXJuIF90aGlzMTA3O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhIZW1pc3BoZXJlTGlnaHRQcm9iZSk7XG59KExpZ2h0UHJvYmUpO1xuXG52YXIgQW1iaWVudExpZ2h0UHJvYmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaWdodFByb2JlMikge1xuICBfaW5oZXJpdHMoQW1iaWVudExpZ2h0UHJvYmUsIF9MaWdodFByb2JlMik7XG5cbiAgdmFyIF9zdXBlcjEzNSA9IF9jcmVhdGVTdXBlcihBbWJpZW50TGlnaHRQcm9iZSk7XG5cbiAgZnVuY3Rpb24gQW1iaWVudExpZ2h0UHJvYmUoY29sb3IpIHtcbiAgICB2YXIgX3RoaXMxMDg7XG5cbiAgICB2YXIgaW50ZW5zaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFtYmllbnRMaWdodFByb2JlKTtcblxuICAgIF90aGlzMTA4ID0gX3N1cGVyMTM1LmNhbGwodGhpcywgdW5kZWZpbmVkLCBpbnRlbnNpdHkpO1xuICAgIF90aGlzMTA4LmlzQW1iaWVudExpZ2h0UHJvYmUgPSB0cnVlO1xuICAgIHZhciBjb2xvcjEgPSBuZXcgQ29sb3IoKS5zZXQoY29sb3IpOyAvLyB3aXRob3V0IGV4dHJhIGZhY3RvciBvZiBQSSBpbiB0aGUgc2hhZGVyLCB3b3VsZCBiZSAyIC8gTWF0aC5zcXJ0KCBNYXRoLlBJICk7XG5cbiAgICBfdGhpczEwOC5zaC5jb2VmZmljaWVudHNbMF0uc2V0KGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIpLm11bHRpcGx5U2NhbGFyKDIgKiBNYXRoLnNxcnQoTWF0aC5QSSkpO1xuXG4gICAgcmV0dXJuIF90aGlzMTA4O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBbWJpZW50TGlnaHRQcm9iZSk7XG59KExpZ2h0UHJvYmUpO1xuXG52YXIgX2V5ZVJpZ2h0ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBfZXllTGVmdCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG52YXIgX3Byb2plY3Rpb25NYXRyaXggPSAvKkBfX1BVUkVfXyovbmV3IE1hdHJpeDQoKTtcblxudmFyIFN0ZXJlb0NhbWVyYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0ZXJlb0NhbWVyYSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlcmVvQ2FtZXJhKTtcblxuICAgIHRoaXMudHlwZSA9ICdTdGVyZW9DYW1lcmEnO1xuICAgIHRoaXMuYXNwZWN0ID0gMTtcbiAgICB0aGlzLmV5ZVNlcCA9IDAuMDY0O1xuICAgIHRoaXMuY2FtZXJhTCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xuICAgIHRoaXMuY2FtZXJhTC5sYXllcnMuZW5hYmxlKDEpO1xuICAgIHRoaXMuY2FtZXJhTC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5jYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XG4gICAgdGhpcy5jYW1lcmFSLmxheWVycy5lbmFibGUoMik7XG4gICAgdGhpcy5jYW1lcmFSLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGZvY3VzOiBudWxsLFxuICAgICAgZm92OiBudWxsLFxuICAgICAgYXNwZWN0OiBudWxsLFxuICAgICAgbmVhcjogbnVsbCxcbiAgICAgIGZhcjogbnVsbCxcbiAgICAgIHpvb206IG51bGwsXG4gICAgICBleWVTZXA6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0ZXJlb0NhbWVyYSwgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShjYW1lcmEpIHtcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdmFyIG5lZWRzVXBkYXRlID0gY2FjaGUuZm9jdXMgIT09IGNhbWVyYS5mb2N1cyB8fCBjYWNoZS5mb3YgIT09IGNhbWVyYS5mb3YgfHwgY2FjaGUuYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3QgfHwgY2FjaGUubmVhciAhPT0gY2FtZXJhLm5lYXIgfHwgY2FjaGUuZmFyICE9PSBjYW1lcmEuZmFyIHx8IGNhY2hlLnpvb20gIT09IGNhbWVyYS56b29tIHx8IGNhY2hlLmV5ZVNlcCAhPT0gdGhpcy5leWVTZXA7XG5cbiAgICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgICBjYWNoZS5mb2N1cyA9IGNhbWVyYS5mb2N1cztcbiAgICAgICAgY2FjaGUuZm92ID0gY2FtZXJhLmZvdjtcbiAgICAgICAgY2FjaGUuYXNwZWN0ID0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0O1xuICAgICAgICBjYWNoZS5uZWFyID0gY2FtZXJhLm5lYXI7XG4gICAgICAgIGNhY2hlLmZhciA9IGNhbWVyYS5mYXI7XG4gICAgICAgIGNhY2hlLnpvb20gPSBjYW1lcmEuem9vbTtcbiAgICAgICAgY2FjaGUuZXllU2VwID0gdGhpcy5leWVTZXA7IC8vIE9mZi1heGlzIHN0ZXJlb3Njb3BpYyBlZmZlY3QgYmFzZWQgb25cbiAgICAgICAgLy8gaHR0cDovL3BhdWxib3Vya2UubmV0L3N0ZXJlb2dyYXBoaWNzL3N0ZXJlb3JlbmRlci9cblxuICAgICAgICBfcHJvamVjdGlvbk1hdHJpeC5jb3B5KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcblxuICAgICAgICB2YXIgZXllU2VwSGFsZiA9IGNhY2hlLmV5ZVNlcCAvIDI7XG4gICAgICAgIHZhciBleWVTZXBPblByb2plY3Rpb24gPSBleWVTZXBIYWxmICogY2FjaGUubmVhciAvIGNhY2hlLmZvY3VzO1xuICAgICAgICB2YXIgeW1heCA9IGNhY2hlLm5lYXIgKiBNYXRoLnRhbihERUcyUkFEICogY2FjaGUuZm92ICogMC41KSAvIGNhY2hlLnpvb207XG4gICAgICAgIHZhciB4bWluLCB4bWF4OyAvLyB0cmFuc2xhdGUgeE9mZnNldFxuXG4gICAgICAgIF9leWVMZWZ0LmVsZW1lbnRzWzEyXSA9IC1leWVTZXBIYWxmO1xuICAgICAgICBfZXllUmlnaHQuZWxlbWVudHNbMTJdID0gZXllU2VwSGFsZjsgLy8gZm9yIGxlZnQgZXllXG5cbiAgICAgICAgeG1pbiA9IC15bWF4ICogY2FjaGUuYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xuICAgICAgICB4bWF4ID0geW1heCAqIGNhY2hlLmFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcbiAgICAgICAgX3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMF0gPSAyICogY2FjaGUubmVhciAvICh4bWF4IC0geG1pbik7XG4gICAgICAgIF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzhdID0gKHhtYXggKyB4bWluKSAvICh4bWF4IC0geG1pbik7XG4gICAgICAgIHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoX3Byb2plY3Rpb25NYXRyaXgpOyAvLyBmb3IgcmlnaHQgZXllXG5cbiAgICAgICAgeG1pbiA9IC15bWF4ICogY2FjaGUuYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xuICAgICAgICB4bWF4ID0geW1heCAqIGNhY2hlLmFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcbiAgICAgICAgX3Byb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMF0gPSAyICogY2FjaGUubmVhciAvICh4bWF4IC0geG1pbik7XG4gICAgICAgIF9wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzhdID0gKHhtYXggKyB4bWluKSAvICh4bWF4IC0geG1pbik7XG4gICAgICAgIHRoaXMuY2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmNvcHkoX3Byb2plY3Rpb25NYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbWVyYUwubWF0cml4V29ybGQuY29weShjYW1lcmEubWF0cml4V29ybGQpLm11bHRpcGx5KF9leWVMZWZ0KTtcbiAgICAgIHRoaXMuY2FtZXJhUi5tYXRyaXhXb3JsZC5jb3B5KGNhbWVyYS5tYXRyaXhXb3JsZCkubXVsdGlwbHkoX2V5ZVJpZ2h0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RlcmVvQ2FtZXJhO1xufSgpO1xuXG52YXIgQ2xvY2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDbG9jaygpIHtcbiAgICB2YXIgYXV0b1N0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsb2NrKTtcblxuICAgIHRoaXMuYXV0b1N0YXJ0ID0gYXV0b1N0YXJ0O1xuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLm9sZFRpbWUgPSAwO1xuICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENsb2NrLCBbe1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gbm93KCk7XG4gICAgICB0aGlzLm9sZFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5nZXRFbGFwc2VkVGltZSgpO1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbGFwc2VkVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGFwc2VkVGltZSgpIHtcbiAgICAgIHRoaXMuZ2V0RGVsdGEoKTtcbiAgICAgIHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZWx0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWx0YSgpIHtcbiAgICAgIHZhciBkaWZmID0gMDtcblxuICAgICAgaWYgKHRoaXMuYXV0b1N0YXJ0ICYmICF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICB2YXIgbmV3VGltZSA9IG5vdygpO1xuICAgICAgICBkaWZmID0gKG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUpIC8gMTAwMDtcbiAgICAgICAgdGhpcy5vbGRUaW1lID0gbmV3VGltZTtcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xvY2s7XG59KCk7XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZSA6IHBlcmZvcm1hbmNlKS5ub3coKTsgLy8gc2VlICMxMDczMlxufVxuXG52YXIgX3Bvc2l0aW9uJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9xdWF0ZXJuaW9uJDEgPSAvKkBfX1BVUkVfXyovbmV3IFF1YXRlcm5pb24oKTtcblxudmFyIF9zY2FsZSQxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfb3JpZW50YXRpb24kMSA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgQXVkaW9MaXN0ZW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iamVjdDNEMTIpIHtcbiAgX2luaGVyaXRzKEF1ZGlvTGlzdGVuZXIsIF9PYmplY3QzRDEyKTtcblxuICB2YXIgX3N1cGVyMTM2ID0gX2NyZWF0ZVN1cGVyKEF1ZGlvTGlzdGVuZXIpO1xuXG4gIGZ1bmN0aW9uIEF1ZGlvTGlzdGVuZXIoKSB7XG4gICAgdmFyIF90aGlzMTA5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvTGlzdGVuZXIpO1xuXG4gICAgX3RoaXMxMDkgPSBfc3VwZXIxMzYuY2FsbCh0aGlzKTtcbiAgICBfdGhpczEwOS50eXBlID0gJ0F1ZGlvTGlzdGVuZXInO1xuICAgIF90aGlzMTA5LmNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xuICAgIF90aGlzMTA5LmdhaW4gPSBfdGhpczEwOS5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAgIF90aGlzMTA5LmdhaW4uY29ubmVjdChfdGhpczEwOS5jb250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgIF90aGlzMTA5LmZpbHRlciA9IG51bGw7XG4gICAgX3RoaXMxMDkudGltZURlbHRhID0gMDsgLy8gcHJpdmF0ZVxuXG4gICAgX3RoaXMxMDkuX2Nsb2NrID0gbmV3IENsb2NrKCk7XG4gICAgcmV0dXJuIF90aGlzMTA5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF1ZGlvTGlzdGVuZXIsIFt7XG4gICAga2V5OiBcImdldElucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElucHV0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2FpbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZpbHRlcigpIHtcbiAgICAgIGlmICh0aGlzLmZpbHRlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmdhaW4uZGlzY29ubmVjdCh0aGlzLmZpbHRlcik7XG4gICAgICAgIHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5nYWluLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbHRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmlsdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbHRlcih2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZ2Fpbi5kaXNjb25uZWN0KHRoaXMuZmlsdGVyKTtcbiAgICAgICAgdGhpcy5maWx0ZXIuZGlzY29ubmVjdCh0aGlzLmNvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nYWluLmRpc2Nvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maWx0ZXIgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZ2Fpbi5jb25uZWN0KHRoaXMuZmlsdGVyKTtcbiAgICAgIHRoaXMuZmlsdGVyLmNvbm5lY3QodGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXN0ZXJWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWFzdGVyVm9sdW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNYXN0ZXJWb2x1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWFzdGVyVm9sdW1lKHZhbHVlKSB7XG4gICAgICB0aGlzLmdhaW4uZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodmFsdWUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTWF0cml4V29ybGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEF1ZGlvTGlzdGVuZXIucHJvdG90eXBlKSwgXCJ1cGRhdGVNYXRyaXhXb3JsZFwiLCB0aGlzKS5jYWxsKHRoaXMsIGZvcmNlKTtcblxuICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xuICAgICAgdmFyIHVwID0gdGhpcy51cDtcbiAgICAgIHRoaXMudGltZURlbHRhID0gdGhpcy5fY2xvY2suZ2V0RGVsdGEoKTtcbiAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKF9wb3NpdGlvbiQxLCBfcXVhdGVybmlvbiQxLCBfc2NhbGUkMSk7XG5cbiAgICAgIF9vcmllbnRhdGlvbiQxLnNldCgwLCAwLCAtMSkuYXBwbHlRdWF0ZXJuaW9uKF9xdWF0ZXJuaW9uJDEpO1xuXG4gICAgICBpZiAobGlzdGVuZXIucG9zaXRpb25YKSB7XG4gICAgICAgIC8vIGNvZGUgcGF0aCBmb3IgQ2hyb21lIChzZWUgIzE0MzkzKVxuICAgICAgICB2YXIgZW5kVGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMudGltZURlbHRhO1xuICAgICAgICBsaXN0ZW5lci5wb3NpdGlvblgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX3Bvc2l0aW9uJDEueCwgZW5kVGltZSk7XG4gICAgICAgIGxpc3RlbmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfcG9zaXRpb24kMS55LCBlbmRUaW1lKTtcbiAgICAgICAgbGlzdGVuZXIucG9zaXRpb25aLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbiQxLnosIGVuZFRpbWUpO1xuICAgICAgICBsaXN0ZW5lci5mb3J3YXJkWC5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfb3JpZW50YXRpb24kMS54LCBlbmRUaW1lKTtcbiAgICAgICAgbGlzdGVuZXIuZm9yd2FyZFkubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX29yaWVudGF0aW9uJDEueSwgZW5kVGltZSk7XG4gICAgICAgIGxpc3RlbmVyLmZvcndhcmRaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9vcmllbnRhdGlvbiQxLnosIGVuZFRpbWUpO1xuICAgICAgICBsaXN0ZW5lci51cFgubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodXAueCwgZW5kVGltZSk7XG4gICAgICAgIGxpc3RlbmVyLnVwWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh1cC55LCBlbmRUaW1lKTtcbiAgICAgICAgbGlzdGVuZXIudXBaLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHVwLnosIGVuZFRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXIuc2V0UG9zaXRpb24oX3Bvc2l0aW9uJDEueCwgX3Bvc2l0aW9uJDEueSwgX3Bvc2l0aW9uJDEueik7XG4gICAgICAgIGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKF9vcmllbnRhdGlvbiQxLngsIF9vcmllbnRhdGlvbiQxLnksIF9vcmllbnRhdGlvbiQxLnosIHVwLngsIHVwLnksIHVwLnopO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBdWRpb0xpc3RlbmVyO1xufShPYmplY3QzRCk7XG5cbnZhciBBdWRpbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iamVjdDNEMTMpIHtcbiAgX2luaGVyaXRzKEF1ZGlvLCBfT2JqZWN0M0QxMyk7XG5cbiAgdmFyIF9zdXBlcjEzNyA9IF9jcmVhdGVTdXBlcihBdWRpbyk7XG5cbiAgZnVuY3Rpb24gQXVkaW8obGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMxMTA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW8pO1xuXG4gICAgX3RoaXMxMTAgPSBfc3VwZXIxMzcuY2FsbCh0aGlzKTtcbiAgICBfdGhpczExMC50eXBlID0gJ0F1ZGlvJztcbiAgICBfdGhpczExMC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIF90aGlzMTEwLmNvbnRleHQgPSBsaXN0ZW5lci5jb250ZXh0O1xuICAgIF90aGlzMTEwLmdhaW4gPSBfdGhpczExMC5jb250ZXh0LmNyZWF0ZUdhaW4oKTtcblxuICAgIF90aGlzMTEwLmdhaW4uY29ubmVjdChsaXN0ZW5lci5nZXRJbnB1dCgpKTtcblxuICAgIF90aGlzMTEwLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgX3RoaXMxMTAuYnVmZmVyID0gbnVsbDtcbiAgICBfdGhpczExMC5kZXR1bmUgPSAwO1xuICAgIF90aGlzMTEwLmxvb3AgPSBmYWxzZTtcbiAgICBfdGhpczExMC5sb29wU3RhcnQgPSAwO1xuICAgIF90aGlzMTEwLmxvb3BFbmQgPSAwO1xuICAgIF90aGlzMTEwLm9mZnNldCA9IDA7XG4gICAgX3RoaXMxMTAuZHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgX3RoaXMxMTAucGxheWJhY2tSYXRlID0gMTtcbiAgICBfdGhpczExMC5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICBfdGhpczExMC5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xuICAgIF90aGlzMTEwLnNvdXJjZSA9IG51bGw7XG4gICAgX3RoaXMxMTAuc291cmNlVHlwZSA9ICdlbXB0eSc7XG4gICAgX3RoaXMxMTAuX3N0YXJ0ZWRBdCA9IDA7XG4gICAgX3RoaXMxMTAuX3Byb2dyZXNzID0gMDtcbiAgICBfdGhpczExMC5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgX3RoaXMxMTAuZmlsdGVycyA9IFtdO1xuICAgIHJldHVybiBfdGhpczExMDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBdWRpbywgW3tcbiAgICBrZXk6IFwiZ2V0T3V0cHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE91dHB1dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdhaW47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE5vZGVTb3VyY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Tm9kZVNvdXJjZShhdWRpb05vZGUpIHtcbiAgICAgIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG4gICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcbiAgICAgIHRoaXMuc291cmNlID0gYXVkaW9Ob2RlO1xuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TWVkaWFFbGVtZW50U291cmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1lZGlhRWxlbWVudFNvdXJjZShtZWRpYUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG4gICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnbWVkaWFOb2RlJztcbiAgICAgIHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhRWxlbWVudFNvdXJjZShtZWRpYUVsZW1lbnQpO1xuICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TWVkaWFTdHJlYW1Tb3VyY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TWVkaWFTdHJlYW1Tb3VyY2UobWVkaWFTdHJlYW0pIHtcbiAgICAgIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG4gICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnbWVkaWFTdHJlYW1Ob2RlJztcbiAgICAgIHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKG1lZGlhU3RyZWFtKTtcbiAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRCdWZmZXIoYXVkaW9CdWZmZXIpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgICB0aGlzLnNvdXJjZVR5cGUgPSAnYnVmZmVyJztcbiAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB0aGlzLnBsYXkoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICB2YXIgZGVsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgIGlmICh0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkF1ZGlvOiBBdWRpbyBpcyBhbHJlYWR5IHBsYXlpbmcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIGRlbGF5O1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgIHNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xuICAgICAgc291cmNlLmxvb3BTdGFydCA9IHRoaXMubG9vcFN0YXJ0O1xuICAgICAgc291cmNlLmxvb3BFbmQgPSB0aGlzLmxvb3BFbmQ7XG4gICAgICBzb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgc291cmNlLnN0YXJ0KHRoaXMuX3N0YXJ0ZWRBdCwgdGhpcy5fcHJvZ3Jlc3MgKyB0aGlzLm9mZnNldCwgdGhpcy5kdXJhdGlvbik7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRoaXMuc2V0RGV0dW5lKHRoaXMuZGV0dW5lKTtcbiAgICAgIHRoaXMuc2V0UGxheWJhY2tSYXRlKHRoaXMucGxheWJhY2tSYXRlKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICBpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IHByb2dyZXNzXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzICs9IE1hdGgubWF4KHRoaXMuY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0ZWRBdCwgMCkgKiB0aGlzLnBsYXliYWNrUmF0ZTtcblxuICAgICAgICBpZiAodGhpcy5sb29wID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIF9wcm9ncmVzcyBkb2VzIG5vdCBleGNlZWQgZHVyYXRpb24gd2l0aCBsb29wZWQgYXVkaW9zXG4gICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSB0aGlzLl9wcm9ncmVzcyAlICh0aGlzLmR1cmF0aW9uIHx8IHRoaXMuYnVmZmVyLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc291cmNlLnN0b3AoKTtcbiAgICAgICAgdGhpcy5zb3VyY2Uub25lbmRlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgICAgdGhpcy5zb3VyY2Uuc3RvcCgpO1xuICAgICAgdGhpcy5zb3VyY2Uub25lbmRlZCA9IG51bGw7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNvdXJjZS5jb25uZWN0KHRoaXMuZmlsdGVyc1swXSk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kzMTEgPSAxLCBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDsgX2kzMTEgPCBsOyBfaTMxMSsrKSB7XG4gICAgICAgICAgdGhpcy5maWx0ZXJzW19pMzExIC0gMV0uY29ubmVjdCh0aGlzLmZpbHRlcnNbX2kzMTFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsdGVyc1t0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMV0uY29ubmVjdCh0aGlzLmdldE91dHB1dCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5nZXRPdXRwdXQoKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc291cmNlLmRpc2Nvbm5lY3QodGhpcy5maWx0ZXJzWzBdKTtcblxuICAgICAgICBmb3IgKHZhciBfaTMxMiA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBfaTMxMiA8IGw7IF9pMzEyKyspIHtcbiAgICAgICAgICB0aGlzLmZpbHRlcnNbX2kzMTIgLSAxXS5kaXNjb25uZWN0KHRoaXMuZmlsdGVyc1tfaTMxMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWx0ZXJzW3RoaXMuZmlsdGVycy5sZW5ndGggLSAxXS5kaXNjb25uZWN0KHRoaXMuZ2V0T3V0cHV0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zb3VyY2UuZGlzY29ubmVjdCh0aGlzLmdldE91dHB1dCgpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RmlsdGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWx0ZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RmlsdGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWx0ZXJzKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHZhbHVlLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREZXR1bmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGV0dW5lKHZhbHVlKSB7XG4gICAgICB0aGlzLmRldHVuZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMuc291cmNlLmRldHVuZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG9ubHkgc2V0IGRldHVuZSB3aGVuIGF2YWlsYWJsZVxuXG4gICAgICBpZiAodGhpcy5pc1BsYXlpbmcgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UuZGV0dW5lLnNldFRhcmdldEF0VGltZSh0aGlzLmRldHVuZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERldHVuZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXR1bmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXR1bmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaWx0ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGaWx0ZXJzKClbMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKGZpbHRlciA/IFtmaWx0ZXJdIDogW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQbGF5YmFja1JhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGxheWJhY2tSYXRlKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS5zZXRUYXJnZXRBdFRpbWUodGhpcy5wbGF5YmFja1JhdGUsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSwgMC4wMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQbGF5YmFja1JhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxheWJhY2tSYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkVuZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRW5kZWQoKSB7XG4gICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRMb29wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExvb3AoKSB7XG4gICAgICBpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubG9vcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9vcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMb29wKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb29wID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TG9vcFN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvb3BTdGFydCh2YWx1ZSkge1xuICAgICAgdGhpcy5sb29wU3RhcnQgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRMb29wRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvb3BFbmQodmFsdWUpIHtcbiAgICAgIHRoaXMubG9vcEVuZCA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZvbHVtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWb2x1bWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFZvbHVtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWb2x1bWUodmFsdWUpIHtcbiAgICAgIHRoaXMuZ2Fpbi5nYWluLnNldFRhcmdldEF0VGltZSh2YWx1ZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lLCAwLjAxKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBdWRpbztcbn0oT2JqZWN0M0QpO1xuXG52YXIgX3Bvc2l0aW9uID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfcXVhdGVybmlvbiA9IC8qQF9fUFVSRV9fKi9uZXcgUXVhdGVybmlvbigpO1xuXG52YXIgX3NjYWxlID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfb3JpZW50YXRpb24gPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIFBvc2l0aW9uYWxBdWRpbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0F1ZGlvKSB7XG4gIF9pbmhlcml0cyhQb3NpdGlvbmFsQXVkaW8sIF9BdWRpbyk7XG5cbiAgdmFyIF9zdXBlcjEzOCA9IF9jcmVhdGVTdXBlcihQb3NpdGlvbmFsQXVkaW8pO1xuXG4gIGZ1bmN0aW9uIFBvc2l0aW9uYWxBdWRpbyhsaXN0ZW5lcikge1xuICAgIHZhciBfdGhpczExMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3NpdGlvbmFsQXVkaW8pO1xuXG4gICAgX3RoaXMxMTEgPSBfc3VwZXIxMzguY2FsbCh0aGlzLCBsaXN0ZW5lcik7XG4gICAgX3RoaXMxMTEucGFubmVyID0gX3RoaXMxMTEuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcbiAgICBfdGhpczExMS5wYW5uZXIucGFubmluZ01vZGVsID0gJ0hSVEYnO1xuXG4gICAgX3RoaXMxMTEucGFubmVyLmNvbm5lY3QoX3RoaXMxMTEuZ2Fpbik7XG5cbiAgICByZXR1cm4gX3RoaXMxMTE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9zaXRpb25hbEF1ZGlvLCBbe1xuICAgIGtleTogXCJkaXNjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihQb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlKSwgXCJkaXNjb25uZWN0XCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMucGFubmVyLmRpc2Nvbm5lY3QodGhpcy5nYWluKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3V0cHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE91dHB1dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhbm5lcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVmRGlzdGFuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVmRGlzdGFuY2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFJlZkRpc3RhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJlZkRpc3RhbmNlKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJvbGxvZmZGYWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9sbG9mZkZhY3RvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRSb2xsb2ZmRmFjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJvbGxvZmZGYWN0b3IodmFsdWUpIHtcbiAgICAgIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREaXN0YW5jZU1vZGVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpc3RhbmNlTW9kZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGlzdGFuY2VNb2RlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXN0YW5jZU1vZGVsKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhbm5lci5kaXN0YW5jZU1vZGVsID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWF4RGlzdGFuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWF4RGlzdGFuY2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYW5uZXIubWF4RGlzdGFuY2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1heERpc3RhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1heERpc3RhbmNlKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERpcmVjdGlvbmFsQ29uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXJlY3Rpb25hbENvbmUoY29uZUlubmVyQW5nbGUsIGNvbmVPdXRlckFuZ2xlLCBjb25lT3V0ZXJHYWluKSB7XG4gICAgICB0aGlzLnBhbm5lci5jb25lSW5uZXJBbmdsZSA9IGNvbmVJbm5lckFuZ2xlO1xuICAgICAgdGhpcy5wYW5uZXIuY29uZU91dGVyQW5nbGUgPSBjb25lT3V0ZXJBbmdsZTtcbiAgICAgIHRoaXMucGFubmVyLmNvbmVPdXRlckdhaW4gPSBjb25lT3V0ZXJHYWluO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZU1hdHJpeFdvcmxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihQb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlKSwgXCJ1cGRhdGVNYXRyaXhXb3JsZFwiLCB0aGlzKS5jYWxsKHRoaXMsIGZvcmNlKTtcblxuICAgICAgaWYgKHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSB0cnVlICYmIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcXVhdGVybmlvbiwgX3NjYWxlKTtcblxuICAgICAgX29yaWVudGF0aW9uLnNldCgwLCAwLCAxKS5hcHBseVF1YXRlcm5pb24oX3F1YXRlcm5pb24pO1xuXG4gICAgICB2YXIgcGFubmVyID0gdGhpcy5wYW5uZXI7XG5cbiAgICAgIGlmIChwYW5uZXIucG9zaXRpb25YKSB7XG4gICAgICAgIC8vIGNvZGUgcGF0aCBmb3IgQ2hyb21lIGFuZCBGaXJlZm94IChzZWUgIzE0MzkzKVxuICAgICAgICB2YXIgZW5kVGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZSArIHRoaXMubGlzdGVuZXIudGltZURlbHRhO1xuICAgICAgICBwYW5uZXIucG9zaXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9wb3NpdGlvbi54LCBlbmRUaW1lKTtcbiAgICAgICAgcGFubmVyLnBvc2l0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfcG9zaXRpb24ueSwgZW5kVGltZSk7XG4gICAgICAgIHBhbm5lci5wb3NpdGlvbloubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX3Bvc2l0aW9uLnosIGVuZFRpbWUpO1xuICAgICAgICBwYW5uZXIub3JpZW50YXRpb25YLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKF9vcmllbnRhdGlvbi54LCBlbmRUaW1lKTtcbiAgICAgICAgcGFubmVyLm9yaWVudGF0aW9uWS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZShfb3JpZW50YXRpb24ueSwgZW5kVGltZSk7XG4gICAgICAgIHBhbm5lci5vcmllbnRhdGlvbloubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoX29yaWVudGF0aW9uLnosIGVuZFRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFubmVyLnNldFBvc2l0aW9uKF9wb3NpdGlvbi54LCBfcG9zaXRpb24ueSwgX3Bvc2l0aW9uLnopO1xuICAgICAgICBwYW5uZXIuc2V0T3JpZW50YXRpb24oX29yaWVudGF0aW9uLngsIF9vcmllbnRhdGlvbi55LCBfb3JpZW50YXRpb24ueik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvc2l0aW9uYWxBdWRpbztcbn0oQXVkaW8pO1xuXG52YXIgQXVkaW9BbmFseXNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF1ZGlvQW5hbHlzZXIoYXVkaW8pIHtcbiAgICB2YXIgZmZ0U2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjA0ODtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb0FuYWx5c2VyKTtcblxuICAgIHRoaXMuYW5hbHlzZXIgPSBhdWRpby5jb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgdGhpcy5hbmFseXNlci5mZnRTaXplID0gZmZ0U2l6ZTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50KTtcbiAgICBhdWRpby5nZXRPdXRwdXQoKS5jb25uZWN0KHRoaXMuYW5hbHlzZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF1ZGlvQW5hbHlzZXIsIFt7XG4gICAga2V5OiBcImdldEZyZXF1ZW5jeURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnJlcXVlbmN5RGF0YSgpIHtcbiAgICAgIHRoaXMuYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEodGhpcy5kYXRhKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF2ZXJhZ2VGcmVxdWVuY3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXZlcmFnZUZyZXF1ZW5jeSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IDA7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xuXG4gICAgICBmb3IgKHZhciBfaTMxMyA9IDA7IF9pMzEzIDwgZGF0YS5sZW5ndGg7IF9pMzEzKyspIHtcbiAgICAgICAgdmFsdWUgKz0gZGF0YVtfaTMxM107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZSAvIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBdWRpb0FuYWx5c2VyO1xufSgpO1xuXG52YXIgUHJvcGVydHlNaXhlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3BlcnR5TWl4ZXIoYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9wZXJ0eU1peGVyKTtcblxuICAgIHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG4gICAgdGhpcy52YWx1ZVNpemUgPSB2YWx1ZVNpemU7XG4gICAgdmFyIG1peEZ1bmN0aW9uLCBtaXhGdW5jdGlvbkFkZGl0aXZlLCBzZXRJZGVudGl0eTsgLy8gYnVmZmVyIGxheW91dDogWyBpbmNvbWluZyB8IGFjY3UwIHwgYWNjdTEgfCBvcmlnIHwgYWRkQWNjdSB8IChvcHRpb25hbCB3b3JrKSBdXG4gICAgLy9cbiAgICAvLyBpbnRlcnBvbGF0b3JzIGNhbiB1c2UgLmJ1ZmZlciBhcyB0aGVpciAucmVzdWx0XG4gICAgLy8gdGhlIGRhdGEgdGhlbiBnb2VzIHRvICdpbmNvbWluZydcbiAgICAvL1xuICAgIC8vICdhY2N1MCcgYW5kICdhY2N1MScgYXJlIHVzZWQgZnJhbWUtaW50ZXJsZWF2ZWQgZm9yXG4gICAgLy8gdGhlIGN1bXVsYXRpdmUgcmVzdWx0IGFuZCBhcmUgY29tcGFyZWQgdG8gZGV0ZWN0XG4gICAgLy8gY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gJ29yaWcnIHN0b3JlcyB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHByb3BlcnR5XG4gICAgLy9cbiAgICAvLyAnYWRkJyBpcyB1c2VkIGZvciBhZGRpdGl2ZSBjdW11bGF0aXZlIHJlc3VsdHNcbiAgICAvL1xuICAgIC8vICd3b3JrJyBpcyBvcHRpb25hbCBhbmQgaXMgb25seSBwcmVzZW50IGZvciBxdWF0ZXJuaW9uIHR5cGVzLiBJdCBpcyB1c2VkXG4gICAgLy8gdG8gc3RvcmUgaW50ZXJtZWRpYXRlIHF1YXRlcm5pb24gbXVsdGlwbGljYXRpb24gcmVzdWx0c1xuXG4gICAgc3dpdGNoICh0eXBlTmFtZSkge1xuICAgICAgY2FzZSAncXVhdGVybmlvbic6XG4gICAgICAgIG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XG4gICAgICAgIG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9zbGVycEFkZGl0aXZlO1xuICAgICAgICBzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlRdWF0ZXJuaW9uO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBGbG9hdDY0QXJyYXkodmFsdWVTaXplICogNik7XG4gICAgICAgIHRoaXMuX3dvcmtJbmRleCA9IDU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIG1peEZ1bmN0aW9uID0gdGhpcy5fc2VsZWN0OyAvLyBVc2UgdGhlIHJlZ3VsYXIgbWl4IGZ1bmN0aW9uIGFuZCBmb3IgYWRkaXRpdmUgb24gdGhlc2UgdHlwZXMsXG4gICAgICAgIC8vIGFkZGl0aXZlIGlzIG5vdCByZWxldmFudCBmb3Igbm9uLW51bWVyaWMgdHlwZXNcblxuICAgICAgICBtaXhGdW5jdGlvbkFkZGl0aXZlID0gdGhpcy5fc2VsZWN0O1xuICAgICAgICBzZXRJZGVudGl0eSA9IHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcjtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXkodmFsdWVTaXplICogNSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtaXhGdW5jdGlvbiA9IHRoaXMuX2xlcnA7XG4gICAgICAgIG1peEZ1bmN0aW9uQWRkaXRpdmUgPSB0aGlzLl9sZXJwQWRkaXRpdmU7XG4gICAgICAgIHNldElkZW50aXR5ID0gdGhpcy5fc2V0QWRkaXRpdmVJZGVudGl0eU51bWVyaWM7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEZsb2F0NjRBcnJheSh2YWx1ZVNpemUgKiA1KTtcbiAgICB9XG5cbiAgICB0aGlzLl9taXhCdWZmZXJSZWdpb24gPSBtaXhGdW5jdGlvbjtcbiAgICB0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZSA9IG1peEZ1bmN0aW9uQWRkaXRpdmU7XG4gICAgdGhpcy5fc2V0SWRlbnRpdHkgPSBzZXRJZGVudGl0eTtcbiAgICB0aGlzLl9vcmlnSW5kZXggPSAzO1xuICAgIHRoaXMuX2FkZEluZGV4ID0gNDtcbiAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuICAgIHRoaXMuY3VtdWxhdGl2ZVdlaWdodEFkZGl0aXZlID0gMDtcbiAgICB0aGlzLnVzZUNvdW50ID0gMDtcbiAgICB0aGlzLnJlZmVyZW5jZUNvdW50ID0gMDtcbiAgfSAvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXG5cblxuICBfY3JlYXRlQ2xhc3MoUHJvcGVydHlNaXhlciwgW3tcbiAgICBrZXk6IFwiYWNjdW11bGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2N1bXVsYXRlKGFjY3VJbmRleCwgd2VpZ2h0KSB7XG4gICAgICAvLyBub3RlOiBoYXBwaWx5IGFjY3VtdWxhdGluZyBub3RoaW5nIHdoZW4gd2VpZ2h0ID0gMCwgdGhlIGNhbGxlciBrbm93c1xuICAgICAgLy8gdGhlIHdlaWdodCBhbmQgc2hvdWxkbid0IGhhdmUgbWFkZSB0aGUgY2FsbCBpbiB0aGUgZmlyc3QgcGxhY2VcbiAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcbiAgICAgICAgICBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcbiAgICAgICAgICBvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGU7XG4gICAgICB2YXIgY3VycmVudFdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcblxuICAgICAgaWYgKGN1cnJlbnRXZWlnaHQgPT09IDApIHtcbiAgICAgICAgLy8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcbiAgICAgICAgZm9yICh2YXIgX2kzMTQgPSAwOyBfaTMxNCAhPT0gc3RyaWRlOyArK19pMzE0KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCArIF9pMzE0XSA9IGJ1ZmZlcltfaTMxNF07XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWNjdU4gOj0gYWNjdU4gKyBpbmNvbWluZyAqIHdlaWdodFxuICAgICAgICBjdXJyZW50V2VpZ2h0ICs9IHdlaWdodDtcbiAgICAgICAgdmFyIG1peCA9IHdlaWdodCAvIGN1cnJlbnRXZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5fbWl4QnVmZmVyUmVnaW9uKGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IGN1cnJlbnRXZWlnaHQ7XG4gICAgfSAvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FkZCdcblxuICB9LCB7XG4gICAga2V5OiBcImFjY3VtdWxhdGVBZGRpdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhY2N1bXVsYXRlQWRkaXRpdmUod2VpZ2h0KSB7XG4gICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsXG4gICAgICAgICAgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG4gICAgICAgICAgb2Zmc2V0ID0gc3RyaWRlICogdGhpcy5fYWRkSW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9PT0gMCkge1xuICAgICAgICAvLyBhZGQgPSBpZGVudGl0eVxuICAgICAgICB0aGlzLl9zZXRJZGVudGl0eSgpO1xuICAgICAgfSAvLyBhZGQgOj0gYWRkICsgaW5jb21pbmcgKiB3ZWlnaHRcblxuXG4gICAgICB0aGlzLl9taXhCdWZmZXJSZWdpb25BZGRpdGl2ZShidWZmZXIsIG9mZnNldCwgMCwgd2VpZ2h0LCBzdHJpZGUpO1xuXG4gICAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSArPSB3ZWlnaHQ7XG4gICAgfSAvLyBhcHBseSB0aGUgc3RhdGUgb2YgJ2FjY3U8aT4nIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyXG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShhY2N1SW5kZXgpIHtcbiAgICAgIHZhciBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcbiAgICAgICAgICBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcbiAgICAgICAgICBvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGUsXG4gICAgICAgICAgd2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxuICAgICAgICAgIHdlaWdodEFkZGl0aXZlID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUsXG4gICAgICAgICAgYmluZGluZyA9IHRoaXMuYmluZGluZztcbiAgICAgIHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG4gICAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHRBZGRpdGl2ZSA9IDA7XG5cbiAgICAgIGlmICh3ZWlnaHQgPCAxKSB7XG4gICAgICAgIC8vIGFjY3VOIDo9IGFjY3VOICsgb3JpZ2luYWwgKiAoIDEgLSBjdW11bGF0aXZlV2VpZ2h0IClcbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9vcmlnSW5kZXg7XG5cbiAgICAgICAgdGhpcy5fbWl4QnVmZmVyUmVnaW9uKGJ1ZmZlciwgb2Zmc2V0LCBvcmlnaW5hbFZhbHVlT2Zmc2V0LCAxIC0gd2VpZ2h0LCBzdHJpZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAod2VpZ2h0QWRkaXRpdmUgPiAwKSB7XG4gICAgICAgIC8vIGFjY3VOIDo9IGFjY3VOICsgYWRkaXRpdmUgYWNjdU5cbiAgICAgICAgdGhpcy5fbWl4QnVmZmVyUmVnaW9uQWRkaXRpdmUoYnVmZmVyLCBvZmZzZXQsIHRoaXMuX2FkZEluZGV4ICogc3RyaWRlLCAxLCBzdHJpZGUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTMxNSA9IHN0cmlkZSwgZSA9IHN0cmlkZSArIHN0cmlkZTsgX2kzMTUgIT09IGU7ICsrX2kzMTUpIHtcbiAgICAgICAgaWYgKGJ1ZmZlcltfaTMxNV0gIT09IGJ1ZmZlcltfaTMxNSArIHN0cmlkZV0pIHtcbiAgICAgICAgICAvLyB2YWx1ZSBoYXMgY2hhbmdlZCAtPiB1cGRhdGUgc2NlbmUgZ3JhcGhcbiAgICAgICAgICBiaW5kaW5nLnNldFZhbHVlKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gcmVtZW1iZXIgdGhlIHN0YXRlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eSBhbmQgY29weSBpdCB0byBib3RoIGFjY3VzXG5cbiAgfSwge1xuICAgIGtleTogXCJzYXZlT3JpZ2luYWxTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlT3JpZ2luYWxTdGF0ZSgpIHtcbiAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuICAgICAgICAgIHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuICAgICAgICAgIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSBzdHJpZGUgKiB0aGlzLl9vcmlnSW5kZXg7XG4gICAgICBiaW5kaW5nLmdldFZhbHVlKGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCk7IC8vIGFjY3VbMC4uMV0gOj0gb3JpZyAtLSBpbml0aWFsbHkgZGV0ZWN0IGNoYW5nZXMgYWdhaW5zdCB0aGUgb3JpZ2luYWxcblxuICAgICAgZm9yICh2YXIgX2kzMTYgPSBzdHJpZGUsIGUgPSBvcmlnaW5hbFZhbHVlT2Zmc2V0OyBfaTMxNiAhPT0gZTsgKytfaTMxNikge1xuICAgICAgICBidWZmZXJbX2kzMTZdID0gYnVmZmVyW29yaWdpbmFsVmFsdWVPZmZzZXQgKyBfaTMxNiAlIHN0cmlkZV07XG4gICAgICB9IC8vIEFkZCB0byBpZGVudGl0eSBmb3IgYWRkaXRpdmVcblxuXG4gICAgICB0aGlzLl9zZXRJZGVudGl0eSgpO1xuXG4gICAgICB0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuICAgICAgdGhpcy5jdW11bGF0aXZlV2VpZ2h0QWRkaXRpdmUgPSAwO1xuICAgIH0gLy8gYXBwbHkgdGhlIHN0YXRlIHByZXZpb3VzbHkgdGFrZW4gdmlhICdzYXZlT3JpZ2luYWxTdGF0ZScgdG8gdGhlIGJpbmRpbmdcblxuICB9LCB7XG4gICAga2V5OiBcInJlc3RvcmVPcmlnaW5hbFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RvcmVPcmlnaW5hbFN0YXRlKCkge1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSB0aGlzLnZhbHVlU2l6ZSAqIDM7XG4gICAgICB0aGlzLmJpbmRpbmcuc2V0VmFsdWUodGhpcy5idWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QWRkaXRpdmVJZGVudGl0eU51bWVyaWNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCkge1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplO1xuICAgICAgdmFyIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIHRoaXMudmFsdWVTaXplO1xuXG4gICAgICBmb3IgKHZhciBfaTMxNyA9IHN0YXJ0SW5kZXg7IF9pMzE3IDwgZW5kSW5kZXg7IF9pMzE3KyspIHtcbiAgICAgICAgdGhpcy5idWZmZXJbX2kzMTddID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEFkZGl0aXZlSWRlbnRpdHlRdWF0ZXJuaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRBZGRpdGl2ZUlkZW50aXR5UXVhdGVybmlvbigpIHtcbiAgICAgIHRoaXMuX3NldEFkZGl0aXZlSWRlbnRpdHlOdW1lcmljKCk7XG5cbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMuX2FkZEluZGV4ICogdGhpcy52YWx1ZVNpemUgKyAzXSA9IDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRBZGRpdGl2ZUlkZW50aXR5T3RoZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEFkZGl0aXZlSWRlbnRpdHlPdGhlcigpIHtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gdGhpcy5fb3JpZ0luZGV4ICogdGhpcy52YWx1ZVNpemU7XG4gICAgICB2YXIgdGFyZ2V0SW5kZXggPSB0aGlzLl9hZGRJbmRleCAqIHRoaXMudmFsdWVTaXplO1xuXG4gICAgICBmb3IgKHZhciBfaTMxOCA9IDA7IF9pMzE4IDwgdGhpcy52YWx1ZVNpemU7IF9pMzE4KyspIHtcbiAgICAgICAgdGhpcy5idWZmZXJbdGFyZ2V0SW5kZXggKyBfaTMxOF0gPSB0aGlzLmJ1ZmZlcltzdGFydEluZGV4ICsgX2kzMThdO1xuICAgICAgfVxuICAgIH0gLy8gbWl4IGZ1bmN0aW9uc1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0KGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSkge1xuICAgICAgaWYgKHQgPj0gMC41KSB7XG4gICAgICAgIGZvciAodmFyIF9pMzE5ID0gMDsgX2kzMTkgIT09IHN0cmlkZTsgKytfaTMxOSkge1xuICAgICAgICAgIGJ1ZmZlcltkc3RPZmZzZXQgKyBfaTMxOV0gPSBidWZmZXJbc3JjT2Zmc2V0ICsgX2kzMTldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zbGVycFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2xlcnAoYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCkge1xuICAgICAgUXVhdGVybmlvbi5zbGVycEZsYXQoYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHNyY09mZnNldCwgdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zbGVycEFkZGl0aXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zbGVycEFkZGl0aXZlKGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSkge1xuICAgICAgdmFyIHdvcmtPZmZzZXQgPSB0aGlzLl93b3JrSW5kZXggKiBzdHJpZGU7IC8vIFN0b3JlIHJlc3VsdCBpbiBpbnRlcm1lZGlhdGUgYnVmZmVyIG9mZnNldFxuXG4gICAgICBRdWF0ZXJuaW9uLm11bHRpcGx5UXVhdGVybmlvbnNGbGF0KGJ1ZmZlciwgd29ya09mZnNldCwgYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgc3JjT2Zmc2V0KTsgLy8gU2xlcnAgdG8gdGhlIGludGVybWVkaWF0ZSByZXN1bHRcblxuICAgICAgUXVhdGVybmlvbi5zbGVycEZsYXQoYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHdvcmtPZmZzZXQsIHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbGVycFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGVycChidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUpIHtcbiAgICAgIHZhciBzID0gMSAtIHQ7XG5cbiAgICAgIGZvciAodmFyIF9pMzIwID0gMDsgX2kzMjAgIT09IHN0cmlkZTsgKytfaTMyMCkge1xuICAgICAgICB2YXIgaiA9IGRzdE9mZnNldCArIF9pMzIwO1xuICAgICAgICBidWZmZXJbal0gPSBidWZmZXJbal0gKiBzICsgYnVmZmVyW3NyY09mZnNldCArIF9pMzIwXSAqIHQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9sZXJwQWRkaXRpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xlcnBBZGRpdGl2ZShidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUpIHtcbiAgICAgIGZvciAodmFyIF9pMzIxID0gMDsgX2kzMjEgIT09IHN0cmlkZTsgKytfaTMyMSkge1xuICAgICAgICB2YXIgaiA9IGRzdE9mZnNldCArIF9pMzIxO1xuICAgICAgICBidWZmZXJbal0gPSBidWZmZXJbal0gKyBidWZmZXJbc3JjT2Zmc2V0ICsgX2kzMjFdICogdDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJvcGVydHlNaXhlcjtcbn0oKTsgLy8gQ2hhcmFjdGVycyBbXS46LyBhcmUgcmVzZXJ2ZWQgZm9yIHRyYWNrIGJpbmRpbmcgc3ludGF4LlxuXG5cbnZhciBfUkVTRVJWRURfQ0hBUlNfUkUgPSAnXFxcXFtcXFxcXVxcXFwuOlxcXFwvJztcblxudmFyIF9yZXNlcnZlZFJlID0gbmV3IFJlZ0V4cCgnWycgKyBfUkVTRVJWRURfQ0hBUlNfUkUgKyAnXScsICdnJyk7IC8vIEF0dGVtcHRzIHRvIGFsbG93IG5vZGUgbmFtZXMgZnJvbSBhbnkgbGFuZ3VhZ2UuIEVTNSdzIGBcXHdgIHJlZ2V4cCBtYXRjaGVzXG4vLyBvbmx5IGxhdGluIGNoYXJhY3RlcnMsIGFuZCB0aGUgdW5pY29kZSBcXHB7TH0gaXMgbm90IHlldCBzdXBwb3J0ZWQuIFNvXG4vLyBpbnN0ZWFkLCB3ZSBleGNsdWRlIHJlc2VydmVkIGNoYXJhY3RlcnMgYW5kIG1hdGNoIGV2ZXJ5dGhpbmcgZWxzZS5cblxuXG52YXIgX3dvcmRDaGFyID0gJ1teJyArIF9SRVNFUlZFRF9DSEFSU19SRSArICddJztcblxudmFyIF93b3JkQ2hhck9yRG90ID0gJ1teJyArIF9SRVNFUlZFRF9DSEFSU19SRS5yZXBsYWNlKCdcXFxcLicsICcnKSArICddJzsgLy8gUGFyZW50IGRpcmVjdG9yaWVzLCBkZWxpbWl0ZWQgYnkgJy8nIG9yICc6Jy4gQ3VycmVudGx5IHVudXNlZCwgYnV0IG11c3Rcbi8vIGJlIG1hdGNoZWQgdG8gcGFyc2UgdGhlIHJlc3Qgb2YgdGhlIHRyYWNrIG5hbWUuXG5cblxudmFyIF9kaXJlY3RvcnlSZSA9IC8oKD86V0MrW1xcLzpdKSopLy5zb3VyY2UucmVwbGFjZSgnV0MnLCBfd29yZENoYXIpOyAvLyBUYXJnZXQgbm9kZS4gTWF5IGNvbnRhaW4gd29yZCBjaGFyYWN0ZXJzIChhLXpBLVowLTlfKSBhbmQgJy4nIG9yICctJy5cblxuXG52YXIgX25vZGVSZSA9IC8oV0NPRCspPy8uc291cmNlLnJlcGxhY2UoJ1dDT0QnLCBfd29yZENoYXJPckRvdCk7IC8vIE9iamVjdCBvbiB0YXJnZXQgbm9kZSwgYW5kIGFjY2Vzc29yLiBNYXkgbm90IGNvbnRhaW4gcmVzZXJ2ZWRcbi8vIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heSBjb250YWluIGFueSBjaGFyYWN0ZXIgZXhjZXB0IGNsb3NpbmcgYnJhY2tldC5cblxuXG52YXIgX29iamVjdFJlID0gLyg/OlxcLihXQyspKD86XFxbKC4rKVxcXSk/KT8vLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7IC8vIFByb3BlcnR5IGFuZCBhY2Nlc3Nvci4gTWF5IG5vdCBjb250YWluIHJlc2VydmVkIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heVxuLy8gY29udGFpbiBhbnkgbm9uLWJyYWNrZXQgY2hhcmFjdGVycy5cblxuXG52YXIgX3Byb3BlcnR5UmUgPSAvXFwuKFdDKykoPzpcXFsoLispXFxdKT8vLnNvdXJjZS5yZXBsYWNlKCdXQycsIF93b3JkQ2hhcik7XG5cbnZhciBfdHJhY2tSZSA9IG5ldyBSZWdFeHAoJycgKyAnXicgKyBfZGlyZWN0b3J5UmUgKyBfbm9kZVJlICsgX29iamVjdFJlICsgX3Byb3BlcnR5UmUgKyAnJCcpO1xuXG52YXIgX3N1cHBvcnRlZE9iamVjdE5hbWVzID0gWydtYXRlcmlhbCcsICdtYXRlcmlhbHMnLCAnYm9uZXMnXTtcblxudmFyIENvbXBvc2l0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbXBvc2l0ZSh0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBvc2l0ZSk7XG5cbiAgICB2YXIgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUocGF0aCk7XG4gICAgdGhpcy5fdGFyZ2V0R3JvdXAgPSB0YXJnZXRHcm91cDtcbiAgICB0aGlzLl9iaW5kaW5ncyA9IHRhcmdldEdyb3VwLnN1YnNjcmliZV8ocGF0aCwgcGFyc2VkUGF0aCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29tcG9zaXRlLCBbe1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShhcnJheSwgb2Zmc2V0KSB7XG4gICAgICB0aGlzLmJpbmQoKTsgLy8gYmluZCBhbGwgYmluZGluZ1xuXG4gICAgICB2YXIgZmlyc3RWYWxpZEluZGV4ID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxuICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1tmaXJzdFZhbGlkSW5kZXhdOyAvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3RcblxuICAgICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkgYmluZGluZy5nZXRWYWx1ZShhcnJheSwgb2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUoYXJyYXksIG9mZnNldCkge1xuICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cbiAgICAgIGZvciAodmFyIF9pMzIyID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLCBuID0gYmluZGluZ3MubGVuZ3RoOyBfaTMyMiAhPT0gbjsgKytfaTMyMikge1xuICAgICAgICBiaW5kaW5nc1tfaTMyMl0uc2V0VmFsdWUoYXJyYXksIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG4gICAgICBmb3IgKHZhciBfaTMyMyA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgX2kzMjMgIT09IG47ICsrX2kzMjMpIHtcbiAgICAgICAgYmluZGluZ3NbX2kzMjNdLmJpbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG4gICAgICBmb3IgKHZhciBfaTMyNCA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXywgbiA9IGJpbmRpbmdzLmxlbmd0aDsgX2kzMjQgIT09IG47ICsrX2kzMjQpIHtcbiAgICAgICAgYmluZGluZ3NbX2kzMjRdLnVuYmluZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb21wb3NpdGU7XG59KCk7IC8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxuLy8gJ2JpbmQnIHNldHMgJ3RoaXMuZ2V0VmFsdWUnIC8gJ3NldFZhbHVlJyBhbmQgc2hhZG93cyB0aGVcbi8vIHByb3RvdHlwZSB2ZXJzaW9uIG9mIHRoZXNlIG1ldGhvZHMgd2l0aCBvbmUgdGhhdCByZXByZXNlbnRzXG4vLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcbi8vIGJlY29tZSBuby1vcHMuXG5cblxudmFyIFByb3BlcnR5QmluZGluZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3BlcnR5QmluZGluZyhyb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9wZXJ0eUJpbmRpbmcpO1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZShwYXRoKTtcbiAgICB0aGlzLm5vZGUgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUocm9vdE5vZGUsIHRoaXMucGFyc2VkUGF0aC5ub2RlTmFtZSkgfHwgcm9vdE5vZGU7XG4gICAgdGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlOyAvLyBpbml0aWFsIHN0YXRlIG9mIHRoZXNlIG1ldGhvZHMgdGhhdCBjYWxscyAnYmluZCdcblxuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmJvdW5kO1xuICAgIHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmJvdW5kO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFByb3BlcnR5QmluZGluZywgW3tcbiAgICBrZXk6IFwiX2dldFZhbHVlX3VuYXZhaWxhYmxlXCIsXG4gICAgdmFsdWU6IC8vIHRoZXNlIGFyZSB1c2VkIHRvIFwiYmluZFwiIGEgbm9uZXhpc3RlbnQgcHJvcGVydHlcbiAgICBmdW5jdGlvbiBfZ2V0VmFsdWVfdW5hdmFpbGFibGUoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRWYWx1ZV91bmF2YWlsYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVfdW5hdmFpbGFibGUoKSB7fSAvLyBHZXR0ZXJzXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmFsdWVfZGlyZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWYWx1ZV9kaXJlY3QoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIGJ1ZmZlcltvZmZzZXRdID0gdGhpcy50YXJnZXRPYmplY3RbdGhpcy5wcm9wZXJ0eU5hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmFsdWVfYXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZhbHVlX2FycmF5KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG4gICAgICBmb3IgKHZhciBfaTMyNSA9IDAsIG4gPSBzb3VyY2UubGVuZ3RoOyBfaTMyNSAhPT0gbjsgKytfaTMyNSkge1xuICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gc291cmNlW19pMzI1XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZhbHVlX2FycmF5RWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmFsdWVfYXJyYXlFbGVtZW50KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICBidWZmZXJbb2Zmc2V0XSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmFsdWVfdG9BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmFsdWVfdG9BcnJheShidWZmZXIsIG9mZnNldCkge1xuICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuICAgIH0gLy8gRGlyZWN0XG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VmFsdWVfZGlyZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRWYWx1ZV9kaXJlY3QoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHRoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXSA9IGJ1ZmZlcltvZmZzZXRdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRWYWx1ZV9kaXJlY3Rfc2V0TmVlZHNVcGRhdGUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHRoaXMudGFyZ2V0T2JqZWN0W3RoaXMucHJvcGVydHlOYW1lXSA9IGJ1ZmZlcltvZmZzZXRdO1xuICAgICAgdGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICB0aGlzLnRhcmdldE9iamVjdFt0aGlzLnByb3BlcnR5TmFtZV0gPSBidWZmZXJbb2Zmc2V0XTtcbiAgICAgIHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gLy8gRW50aXJlQXJyYXlcblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRWYWx1ZV9hcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVfYXJyYXkoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG4gICAgICBmb3IgKHZhciBfaTMyNiA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgX2kzMjYgIT09IG47ICsrX2kzMjYpIHtcbiAgICAgICAgZGVzdFtfaTMyNl0gPSBidWZmZXJbb2Zmc2V0KytdO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFZhbHVlX2FycmF5X3NldE5lZWRzVXBkYXRlKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICB2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuICAgICAgZm9yICh2YXIgX2kzMjcgPSAwLCBuID0gZGVzdC5sZW5ndGg7IF9pMzI3ICE9PSBuOyArK19pMzI3KSB7XG4gICAgICAgIGRlc3RbX2kzMjddID0gYnVmZmVyW29mZnNldCsrXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuICAgICAgdmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cbiAgICAgIGZvciAodmFyIF9pMzI4ID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBfaTMyOCAhPT0gbjsgKytfaTMyOCkge1xuICAgICAgICBkZXN0W19pMzI4XSA9IGJ1ZmZlcltvZmZzZXQrK107XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gLy8gQXJyYXlFbGVtZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VmFsdWVfYXJyYXlFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRWYWx1ZV9hcnJheUVsZW1lbnQoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVt0aGlzLnByb3BlcnR5SW5kZXhdID0gYnVmZmVyW29mZnNldF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF0gPSBidWZmZXJbb2Zmc2V0XTtcbiAgICAgIHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5W3RoaXMucHJvcGVydHlJbmRleF0gPSBidWZmZXJbb2Zmc2V0XTtcbiAgICAgIHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gLy8gSGFzVG9Gcm9tQXJyYXlcblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRWYWx1ZV9mcm9tQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFZhbHVlX2Zyb21BcnJheShidWZmZXIsIG9mZnNldCkge1xuICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFZhbHVlX2Zyb21BcnJheV9zZXROZWVkc1VwZGF0ZShidWZmZXIsIG9mZnNldCkge1xuICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheShidWZmZXIsIG9mZnNldCk7XG4gICAgICB0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgdGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWYWx1ZV91bmJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWYWx1ZV91bmJvdW5kKHRhcmdldEFycmF5LCBvZmZzZXQpIHtcbiAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0YXJnZXRBcnJheSwgb2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFZhbHVlX3VuYm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFZhbHVlX3VuYm91bmQoc291cmNlQXJyYXksIG9mZnNldCkge1xuICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICB0aGlzLnNldFZhbHVlKHNvdXJjZUFycmF5LCBvZmZzZXQpO1xuICAgIH0gLy8gY3JlYXRlIGdldHRlciAvIHNldHRlciBwYWlyIGZvciBhIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kKCkge1xuICAgICAgdmFyIHRhcmdldE9iamVjdCA9IHRoaXMubm9kZTtcbiAgICAgIHZhciBwYXJzZWRQYXRoID0gdGhpcy5wYXJzZWRQYXRoO1xuICAgICAgdmFyIG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWU7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcGFyc2VkUGF0aC5wcm9wZXJ0eU5hbWU7XG4gICAgICB2YXIgcHJvcGVydHlJbmRleCA9IHBhcnNlZFBhdGgucHJvcGVydHlJbmRleDtcblxuICAgICAgaWYgKCF0YXJnZXRPYmplY3QpIHtcbiAgICAgICAgdGFyZ2V0T2JqZWN0ID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKHRoaXMucm9vdE5vZGUsIHBhcnNlZFBhdGgubm9kZU5hbWUpIHx8IHRoaXMucm9vdE5vZGU7XG4gICAgICAgIHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcbiAgICAgIH0gLy8gc2V0IGZhaWwgc3RhdGUgc28gd2UgY2FuIGp1c3QgJ3JldHVybicgb24gZXJyb3JcblxuXG4gICAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5hdmFpbGFibGU7XG4gICAgICB0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5hdmFpbGFibGU7IC8vIGVuc3VyZSB0aGVyZSBpcyBhIHZhbHVlIG5vZGVcblxuICAgICAgaWYgKCF0YXJnZXRPYmplY3QpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gdXBkYXRlIG5vZGUgZm9yIHRyYWNrOiAnICsgdGhpcy5wYXRoICsgJyBidXQgaXQgd2FzblxcJ3QgZm91bmQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdE5hbWUpIHtcbiAgICAgICAgdmFyIG9iamVjdEluZGV4ID0gcGFyc2VkUGF0aC5vYmplY3RJbmRleDsgLy8gc3BlY2lhbCBjYXNlcyB3ZXJlIHdlIG5lZWQgdG8gcmVhY2ggZGVlcGVyIGludG8gdGhlIGhpZXJhcmNoeSB0byBnZXQgdGhlIGZhY2UgbWF0ZXJpYWxzLi4uLlxuXG4gICAgICAgIHN3aXRjaCAob2JqZWN0TmFtZSkge1xuICAgICAgICAgIGNhc2UgJ21hdGVyaWFscyc6XG4gICAgICAgICAgICBpZiAoIXRhcmdldE9iamVjdC5tYXRlcmlhbCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbCBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbC4nLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheS4nLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdib25lcyc6XG4gICAgICAgICAgICBpZiAoIXRhcmdldE9iamVjdC5za2VsZXRvbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbi4nLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSAvLyBwb3RlbnRpYWwgZnV0dXJlIG9wdGltaXphdGlvbjogc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyXG4gICAgICAgICAgICAvLyBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXG5cblxuICAgICAgICAgICAgdGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0LnNrZWxldG9uLmJvbmVzOyAvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMzI5ID0gMDsgX2kzMjkgPCB0YXJnZXRPYmplY3QubGVuZ3RoOyBfaTMyOSsrKSB7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRPYmplY3RbX2kzMjldLm5hbWUgPT09IG9iamVjdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0SW5kZXggPSBfaTMyOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAodGFyZ2V0T2JqZWN0W29iamVjdE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlIHVuZGVmaW5lZC4nLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Rbb2JqZWN0TmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqZWN0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0YXJnZXRPYmplY3Rbb2JqZWN0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZC4nLCB0aGlzLCB0YXJnZXRPYmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFtvYmplY3RJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcmVzb2x2ZSBwcm9wZXJ0eVxuXG5cbiAgICAgIHZhciBub2RlUHJvcGVydHkgPSB0YXJnZXRPYmplY3RbcHJvcGVydHlOYW1lXTtcblxuICAgICAgaWYgKG5vZGVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBub2RlTmFtZSA9IHBhcnNlZFBhdGgubm9kZU5hbWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6ICcgKyBub2RlTmFtZSArICcuJyArIHByb3BlcnR5TmFtZSArICcgYnV0IGl0IHdhc25cXCd0IGZvdW5kLicsIHRhcmdldE9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXG5cblxuICAgICAgdmFyIHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTm9uZTtcbiAgICAgIHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xuXG4gICAgICBpZiAodGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbWF0ZXJpYWxcbiAgICAgICAgdmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5OZWVkc1VwZGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBub2RlIHRyYW5zZm9ybVxuICAgICAgICB2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG4gICAgICB9IC8vIGRldGVybWluZSBob3cgdGhlIHByb3BlcnR5IGdldHMgYm91bmRcblxuXG4gICAgICB2YXIgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhY2Nlc3MgYSBzdWIgZWxlbWVudCBvZiB0aGUgcHJvcGVydHkgYXJyYXkgKG9ubHkgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkIHJpZ2h0IG5vdylcbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZSA9PT0gJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycpIHtcbiAgICAgICAgICAvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cbiAgICAgICAgICAvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG4gICAgICAgICAgaWYgKCF0YXJnZXRPYmplY3QuZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5LicsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLicsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0YXJnZXRPYmplY3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3Byb3BlcnR5SW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb3BlcnR5SW5kZXggPSB0YXJnZXRPYmplY3QubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3Byb3BlcnR5SW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUluZGV4ID0gcHJvcGVydHlJbmRleDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZVByb3BlcnR5LmZyb21BcnJheSAhPT0gdW5kZWZpbmVkICYmIG5vZGVQcm9wZXJ0eS50b0FycmF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbXVzdCB1c2UgY29weSBmb3IgT2JqZWN0M0QuRXVsZXIvUXVhdGVybmlvblxuICAgICAgICBiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlUHJvcGVydHkpKSB7XG4gICAgICAgIGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICB9IC8vIHNlbGVjdCBnZXR0ZXIgLyBzZXR0ZXJcblxuXG4gICAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5HZXR0ZXJCeUJpbmRpbmdUeXBlW2JpbmRpbmdUeXBlXTtcbiAgICAgIHRoaXMuc2V0VmFsdWUgPSB0aGlzLlNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nW2JpbmRpbmdUeXBlXVt2ZXJzaW9uaW5nXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZCgpIHtcbiAgICAgIHRoaXMubm9kZSA9IG51bGw7IC8vIGJhY2sgdG8gdGhlIHByb3RvdHlwZSB2ZXJzaW9uIG9mIGdldFZhbHVlIC8gc2V0VmFsdWVcbiAgICAgIC8vIG5vdGU6IGF2b2lkaW5nIHRvIG11dGF0ZSB0aGUgc2hhcGUgb2YgJ3RoaXMnIHZpYSAnZGVsZXRlJ1xuXG4gICAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5ib3VuZDtcbiAgICAgIHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmJvdW5kO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocm9vdCwgcGF0aCwgcGFyc2VkUGF0aCkge1xuICAgICAgaWYgKCEocm9vdCAmJiByb290LmlzQW5pbWF0aW9uT2JqZWN0R3JvdXApKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nKHJvb3QsIHBhdGgsIHBhcnNlZFBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlKHJvb3QsIHBhdGgsIHBhcnNlZFBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBzcGFjZXMgd2l0aCB1bmRlcnNjb3JlcyBhbmQgcmVtb3ZlcyB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzIGZyb21cbiAgICAgKiBub2RlIG5hbWVzLCB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHBhcnNlVHJhY2tOYW1lKCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOb2RlIG5hbWUgdG8gYmUgc2FuaXRpemVkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNhbml0aXplTm9kZU5hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FuaXRpemVOb2RlTmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9cXHMvZywgJ18nKS5yZXBsYWNlKF9yZXNlcnZlZFJlLCAnJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlVHJhY2tOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlVHJhY2tOYW1lKHRyYWNrTmFtZSkge1xuICAgICAgdmFyIG1hdGNoZXMgPSBfdHJhY2tSZS5leGVjKHRyYWNrTmFtZSk7XG5cbiAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHlCaW5kaW5nOiBDYW5ub3QgcGFyc2UgdHJhY2tOYW1lOiAnICsgdHJhY2tOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdHMgPSB7XG4gICAgICAgIC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbIDEgXSwgLy8gKHRzY2h3KSBjdXJyZW50bHkgdW51c2VkXG4gICAgICAgIG5vZGVOYW1lOiBtYXRjaGVzWzJdLFxuICAgICAgICBvYmplY3ROYW1lOiBtYXRjaGVzWzNdLFxuICAgICAgICBvYmplY3RJbmRleDogbWF0Y2hlc1s0XSxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBtYXRjaGVzWzVdLFxuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICBwcm9wZXJ0eUluZGV4OiBtYXRjaGVzWzZdXG4gICAgICB9O1xuICAgICAgdmFyIGxhc3REb3QgPSByZXN1bHRzLm5vZGVOYW1lICYmIHJlc3VsdHMubm9kZU5hbWUubGFzdEluZGV4T2YoJy4nKTtcblxuICAgICAgaWYgKGxhc3REb3QgIT09IHVuZGVmaW5lZCAmJiBsYXN0RG90ICE9PSAtMSkge1xuICAgICAgICB2YXIgb2JqZWN0TmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKGxhc3REb3QgKyAxKTsgLy8gT2JqZWN0IG5hbWVzIG11c3QgYmUgY2hlY2tlZCBhZ2FpbnN0IGFuIGFsbG93bGlzdC4gT3RoZXJ3aXNlLCB0aGVyZVxuICAgICAgICAvLyBpcyBubyB3YXkgdG8gcGFyc2UgJ2Zvby5iYXIuYmF6JzogJ2JheicgbXVzdCBiZSBhIHByb3BlcnR5LCBidXRcbiAgICAgICAgLy8gJ2JhcicgY291bGQgYmUgdGhlIG9iamVjdE5hbWUsIG9yIHBhcnQgb2YgYSBub2RlTmFtZSAod2hpY2ggY2FuXG4gICAgICAgIC8vIGluY2x1ZGUgJy4nIGNoYXJhY3RlcnMpLlxuXG4gICAgICAgIGlmIChfc3VwcG9ydGVkT2JqZWN0TmFtZXMuaW5kZXhPZihvYmplY3ROYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXN1bHRzLm5vZGVOYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoMCwgbGFzdERvdCk7XG4gICAgICAgICAgcmVzdWx0cy5vYmplY3ROYW1lID0gb2JqZWN0TmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTm9kZShyb290LCBub2RlTmFtZSkge1xuICAgICAgaWYgKG5vZGVOYW1lID09PSB1bmRlZmluZWQgfHwgbm9kZU5hbWUgPT09ICcnIHx8IG5vZGVOYW1lID09PSAnLicgfHwgbm9kZU5hbWUgPT09IC0xIHx8IG5vZGVOYW1lID09PSByb290Lm5hbWUgfHwgbm9kZU5hbWUgPT09IHJvb3QudXVpZCkge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgIH0gLy8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXG5cblxuICAgICAgaWYgKHJvb3Quc2tlbGV0b24pIHtcbiAgICAgICAgdmFyIGJvbmUgPSByb290LnNrZWxldG9uLmdldEJvbmVCeU5hbWUobm9kZU5hbWUpO1xuXG4gICAgICAgIGlmIChib25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYm9uZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXG5cblxuICAgICAgaWYgKHJvb3QuY2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHNlYXJjaE5vZGVTdWJ0cmVlID0gZnVuY3Rpb24gc2VhcmNoTm9kZVN1YnRyZWUoY2hpbGRyZW4pIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTMzMCA9IDA7IF9pMzMwIDwgY2hpbGRyZW4ubGVuZ3RoOyBfaTMzMCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5bX2kzMzBdO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLm5hbWUgPT09IG5vZGVOYW1lIHx8IGNoaWxkTm9kZS51dWlkID09PSBub2RlTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VhcmNoTm9kZVN1YnRyZWUoY2hpbGROb2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUocm9vdC5jaGlsZHJlbik7XG5cbiAgICAgICAgaWYgKHN1YlRyZWVOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIHN1YlRyZWVOb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQcm9wZXJ0eUJpbmRpbmc7XG59KCk7XG5cblByb3BlcnR5QmluZGluZy5Db21wb3NpdGUgPSBDb21wb3NpdGU7XG5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLkJpbmRpbmdUeXBlID0ge1xuICBEaXJlY3Q6IDAsXG4gIEVudGlyZUFycmF5OiAxLFxuICBBcnJheUVsZW1lbnQ6IDIsXG4gIEhhc0Zyb21Ub0FycmF5OiAzXG59O1xuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5WZXJzaW9uaW5nID0ge1xuICBOb25lOiAwLFxuICBOZWVkc1VwZGF0ZTogMSxcbiAgTWF0cml4V29ybGROZWVkc1VwZGF0ZTogMlxufTtcblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuR2V0dGVyQnlCaW5kaW5nVHlwZSA9IFtQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9kaXJlY3QsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX2FycmF5LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9nZXRWYWx1ZV9hcnJheUVsZW1lbnQsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX2dldFZhbHVlX3RvQXJyYXldO1xuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZyA9IFtbLy8gRGlyZWN0XG5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9kaXJlY3QsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2RpcmVjdF9zZXROZWVkc1VwZGF0ZSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGVdLCBbLy8gRW50aXJlQXJyYXlcblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheV9zZXROZWVkc1VwZGF0ZSwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV0sIFsvLyBBcnJheUVsZW1lbnRcblByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2FycmF5RWxlbWVudCwgUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE5lZWRzVXBkYXRlLCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZV0sIFsvLyBIYXNUb0Zyb21BcnJheVxuUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5fc2V0VmFsdWVfZnJvbUFycmF5LCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLl9zZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUsIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuX3NldFZhbHVlX2Zyb21BcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlXV07XG4vKipcbiAqXG4gKiBBIGdyb3VwIG9mIG9iamVjdHMgdGhhdCByZWNlaXZlcyBhIHNoYXJlZCBhbmltYXRpb24gc3RhdGUuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogIC0gQWRkIG9iamVjdHMgeW91IHdvdWxkIG90aGVyd2lzZSBwYXNzIGFzICdyb290JyB0byB0aGVcbiAqICAgIGNvbnN0cnVjdG9yIG9yIHRoZSAuY2xpcEFjdGlvbiBtZXRob2Qgb2YgQW5pbWF0aW9uTWl4ZXIuXG4gKlxuICogIC0gSW5zdGVhZCBwYXNzIHRoaXMgb2JqZWN0IGFzICdyb290Jy5cbiAqXG4gKiAgLSBZb3UgY2FuIGFsc28gYWRkIGFuZCByZW1vdmUgb2JqZWN0cyBsYXRlciB3aGVuIHRoZSBtaXhlclxuICogICAgaXMgcnVubmluZy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgIE9iamVjdHMgb2YgdGhpcyBjbGFzcyBhcHBlYXIgYXMgb25lIG9iamVjdCB0byB0aGUgbWl4ZXIsXG4gKiAgICBzbyBjYWNoZSBjb250cm9sIG9mIHRoZSBpbmRpdmlkdWFsIG9iamVjdHMgbXVzdCBiZSBkb25lXG4gKiAgICBvbiB0aGUgZ3JvdXAuXG4gKlxuICogTGltaXRhdGlvbjpcbiAqXG4gKiAgLSBUaGUgYW5pbWF0ZWQgcHJvcGVydGllcyBtdXN0IGJlIGNvbXBhdGlibGUgYW1vbmcgdGhlXG4gKiAgICBhbGwgb2JqZWN0cyBpbiB0aGUgZ3JvdXAuXG4gKlxuICogIC0gQSBzaW5nbGUgcHJvcGVydHkgY2FuIGVpdGhlciBiZSBjb250cm9sbGVkIHRocm91Z2ggYVxuICogICAgdGFyZ2V0IGdyb3VwIG9yIGRpcmVjdGx5LCBidXQgbm90IGJvdGguXG4gKi9cblxudmFyIEFuaW1hdGlvbk9iamVjdEdyb3VwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9uT2JqZWN0R3JvdXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuaW1hdGlvbk9iamVjdEdyb3VwKTtcblxuICAgIHRoaXMuaXNBbmltYXRpb25PYmplY3RHcm91cCA9IHRydWU7XG4gICAgdGhpcy51dWlkID0gZ2VuZXJhdGVVVUlEKCk7IC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xuXG4gICAgdGhpcy5fb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5uQ2FjaGVkT2JqZWN0c18gPSAwOyAvLyB0aHJlc2hvbGRcbiAgICAvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcblxuICAgIHZhciBpbmRpY2VzID0ge307XG4gICAgdGhpcy5faW5kaWNlc0J5VVVJRCA9IGluZGljZXM7IC8vIGZvciBib29ra2VlcGluZ1xuXG4gICAgZm9yICh2YXIgX2kzMzEgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgX2kzMzEgIT09IG47ICsrX2kzMzEpIHtcbiAgICAgIGluZGljZXNbYXJndW1lbnRzW19pMzMxXS51dWlkXSA9IF9pMzMxO1xuICAgIH1cblxuICAgIHRoaXMuX3BhdGhzID0gW107IC8vIGluc2lkZTogc3RyaW5nXG5cbiAgICB0aGlzLl9wYXJzZWRQYXRocyA9IFtdOyAvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XG5cbiAgICB0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyBpbnNpZGU6IEFycmF5PCBQcm9wZXJ0eUJpbmRpbmcgPlxuXG4gICAgdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoID0ge307IC8vIGluc2lkZTogaW5kaWNlcyBpbiB0aGVzZSBhcnJheXNcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgIG9iamVjdHM6IHtcbiAgICAgICAgZ2V0IHRvdGFsKCkge1xuICAgICAgICAgIHJldHVybiBzY29wZS5fb2JqZWN0cy5sZW5ndGg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0IGluVXNlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsIC0gc2NvcGUubkNhY2hlZE9iamVjdHNfO1xuICAgICAgICB9XG5cbiAgICAgIH0sXG5cbiAgICAgIGdldCBiaW5kaW5nc1Blck9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFuaW1hdGlvbk9iamVjdEdyb3VwLCBbe1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICAgIGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuICAgICAgICAgIHBhdGhzID0gdGhpcy5fcGF0aHMsXG4gICAgICAgICAgcGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcbiAgICAgICAgICBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuICAgICAgICAgIG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcbiAgICAgIHZhciBrbm93bk9iamVjdCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICBuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XG5cbiAgICAgIGZvciAodmFyIF9pMzMyID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IF9pMzMyICE9PSBuOyArK19pMzMyKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBhcmd1bWVudHNbX2kzMzJdLFxuICAgICAgICAgICAgdXVpZCA9IG9iamVjdC51dWlkO1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRpY2VzQnlVVUlEW3V1aWRdO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdW5rbm93biBvYmplY3QgLT4gYWRkIGl0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXG4gICAgICAgICAgaW5kZXggPSBuT2JqZWN0cysrO1xuICAgICAgICAgIGluZGljZXNCeVVVSURbdXVpZF0gPSBpbmRleDtcbiAgICAgICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuICAgICAgICAgICAgYmluZGluZ3Nbal0ucHVzaChuZXcgUHJvcGVydHlCaW5kaW5nKG9iamVjdCwgcGF0aHNbal0sIHBhcnNlZFBhdGhzW2pdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgbkNhY2hlZE9iamVjdHMpIHtcbiAgICAgICAgICBrbm93bk9iamVjdCA9IG9iamVjdHNbaW5kZXhdOyAvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxuXG4gICAgICAgICAgdmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLW5DYWNoZWRPYmplY3RzLFxuICAgICAgICAgICAgICBsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1tmaXJzdEFjdGl2ZUluZGV4XTtcbiAgICAgICAgICBpbmRpY2VzQnlVVUlEW2xhc3RDYWNoZWRPYmplY3QudXVpZF0gPSBpbmRleDtcbiAgICAgICAgICBvYmplY3RzW2luZGV4XSA9IGxhc3RDYWNoZWRPYmplY3Q7XG4gICAgICAgICAgaW5kaWNlc0J5VVVJRFt1dWlkXSA9IGZpcnN0QWN0aXZlSW5kZXg7XG4gICAgICAgICAgb2JqZWN0c1tmaXJzdEFjdGl2ZUluZGV4XSA9IG9iamVjdDsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG4gICAgICAgICAgZm9yICh2YXIgX2oxNiA9IDAsIF9tMiA9IG5CaW5kaW5nczsgX2oxNiAhPT0gX20yOyArK19qMTYpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1tfajE2XSxcbiAgICAgICAgICAgICAgICBsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoW2ZpcnN0QWN0aXZlSW5kZXhdO1xuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbaW5kZXhdO1xuICAgICAgICAgICAgYmluZGluZ3NGb3JQYXRoW2luZGV4XSA9IGxhc3RDYWNoZWQ7XG5cbiAgICAgICAgICAgIGlmIChiaW5kaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXG4gICAgICAgICAgICAgIC8vIGZvciBvYmplY3RzIHRoYXQgYXJlIGNhY2hlZCwgdGhlIGJpbmRpbmcgbWF5XG4gICAgICAgICAgICAgIC8vIG9yIG1heSBub3QgZXhpc3RcbiAgICAgICAgICAgICAgYmluZGluZyA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcob2JqZWN0LCBwYXRoc1tfajE2XSwgcGFyc2VkUGF0aHNbX2oxNl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiaW5kaW5nc0ZvclBhdGhbZmlyc3RBY3RpdmVJbmRleF0gPSBiaW5kaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3RzW2luZGV4XSAhPT0ga25vd25PYmplY3QpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5BbmltYXRpb25PYmplY3RHcm91cDogRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEICcgKyAnZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBpbmZyYXN0cnVjdHVyZSB3aGVuIHJlbG9hZGluZyBzY2VuZXMuJyk7XG4gICAgICAgIH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxuXG4gICAgICB9IC8vIGZvciBhcmd1bWVudHNcblxuXG4gICAgICB0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICAgIGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuICAgICAgICAgIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG4gICAgICAgICAgbkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuICAgICAgdmFyIG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c187XG5cbiAgICAgIGZvciAodmFyIF9pMzMzID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IF9pMzMzICE9PSBuOyArK19pMzMzKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBhcmd1bWVudHNbX2kzMzNdLFxuICAgICAgICAgICAgdXVpZCA9IG9iamVjdC51dWlkLFxuICAgICAgICAgICAgaW5kZXggPSBpbmRpY2VzQnlVVUlEW3V1aWRdO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID49IG5DYWNoZWRPYmplY3RzKSB7XG4gICAgICAgICAgLy8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxuICAgICAgICAgIHZhciBsYXN0Q2FjaGVkSW5kZXggPSBuQ2FjaGVkT2JqZWN0cysrLFxuICAgICAgICAgICAgICBmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbbGFzdENhY2hlZEluZGV4XTtcbiAgICAgICAgICBpbmRpY2VzQnlVVUlEW2ZpcnN0QWN0aXZlT2JqZWN0LnV1aWRdID0gaW5kZXg7XG4gICAgICAgICAgb2JqZWN0c1tpbmRleF0gPSBmaXJzdEFjdGl2ZU9iamVjdDtcbiAgICAgICAgICBpbmRpY2VzQnlVVUlEW3V1aWRdID0gbGFzdENhY2hlZEluZGV4O1xuICAgICAgICAgIG9iamVjdHNbbGFzdENhY2hlZEluZGV4XSA9IG9iamVjdDsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsraikge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzW2pdLFxuICAgICAgICAgICAgICAgIGZpcnN0QWN0aXZlID0gYmluZGluZ3NGb3JQYXRoW2xhc3RDYWNoZWRJbmRleF0sXG4gICAgICAgICAgICAgICAgYmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFtpbmRleF07XG4gICAgICAgICAgICBiaW5kaW5nc0ZvclBhdGhbaW5kZXhdID0gZmlyc3RBY3RpdmU7XG4gICAgICAgICAgICBiaW5kaW5nc0ZvclBhdGhbbGFzdENhY2hlZEluZGV4XSA9IGJpbmRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBhcmd1bWVudHNcblxuXG4gICAgICB0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuICAgIH0gLy8gcmVtb3ZlICYgZm9yZ2V0XG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmNhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuY2FjaGUoKSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgICAgICAgaW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG4gICAgICAgICAgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICAgICAgICBuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG4gICAgICB2YXIgbkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcbiAgICAgICAgICBuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBfaTMzNCA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBfaTMzNCAhPT0gbjsgKytfaTMzNCkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gYXJndW1lbnRzW19pMzM0XSxcbiAgICAgICAgICAgIHV1aWQgPSBvYmplY3QudXVpZCxcbiAgICAgICAgICAgIGluZGV4ID0gaW5kaWNlc0J5VVVJRFt1dWlkXTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSBpbmRpY2VzQnlVVUlEW3V1aWRdO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgbkNhY2hlZE9iamVjdHMpIHtcbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBjYWNoZWQsIHNocmluayB0aGUgQ0FDSEVEIHJlZ2lvblxuICAgICAgICAgICAgdmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLW5DYWNoZWRPYmplY3RzLFxuICAgICAgICAgICAgICAgIGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzW2ZpcnN0QWN0aXZlSW5kZXhdLFxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IC0tbk9iamVjdHMsXG4gICAgICAgICAgICAgICAgbGFzdE9iamVjdCA9IG9iamVjdHNbbGFzdEluZGV4XTsgLy8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2VcblxuICAgICAgICAgICAgaW5kaWNlc0J5VVVJRFtsYXN0Q2FjaGVkT2JqZWN0LnV1aWRdID0gaW5kZXg7XG4gICAgICAgICAgICBvYmplY3RzW2luZGV4XSA9IGxhc3RDYWNoZWRPYmplY3Q7IC8vIGxhc3Qgb2JqZWN0IGdvZXMgdG8gdGhlIGFjdGl2YXRlZCBzbG90IGFuZCBwb3BcblxuICAgICAgICAgICAgaW5kaWNlc0J5VVVJRFtsYXN0T2JqZWN0LnV1aWRdID0gZmlyc3RBY3RpdmVJbmRleDtcbiAgICAgICAgICAgIG9iamVjdHNbZmlyc3RBY3RpdmVJbmRleF0gPSBsYXN0T2JqZWN0O1xuICAgICAgICAgICAgb2JqZWN0cy5wb3AoKTsgLy8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKytqKSB7XG4gICAgICAgICAgICAgIHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1tqXSxcbiAgICAgICAgICAgICAgICAgIGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbZmlyc3RBY3RpdmVJbmRleF0sXG4gICAgICAgICAgICAgICAgICBsYXN0ID0gYmluZGluZ3NGb3JQYXRoW2xhc3RJbmRleF07XG4gICAgICAgICAgICAgIGJpbmRpbmdzRm9yUGF0aFtpbmRleF0gPSBsYXN0Q2FjaGVkO1xuICAgICAgICAgICAgICBiaW5kaW5nc0ZvclBhdGhbZmlyc3RBY3RpdmVJbmRleF0gPSBsYXN0O1xuICAgICAgICAgICAgICBiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcbiAgICAgICAgICAgIHZhciBfbGFzdEluZGV4ID0gLS1uT2JqZWN0cyxcbiAgICAgICAgICAgICAgICBfbGFzdE9iamVjdCA9IG9iamVjdHNbX2xhc3RJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChfbGFzdEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICBpbmRpY2VzQnlVVUlEW19sYXN0T2JqZWN0LnV1aWRdID0gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iamVjdHNbaW5kZXhdID0gX2xhc3RPYmplY3Q7XG4gICAgICAgICAgICBvYmplY3RzLnBvcCgpOyAvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cbiAgICAgICAgICAgIGZvciAodmFyIF9qMTcgPSAwLCBfbTMgPSBuQmluZGluZ3M7IF9qMTcgIT09IF9tMzsgKytfajE3KSB7XG4gICAgICAgICAgICAgIHZhciBfYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbX2oxN107XG4gICAgICAgICAgICAgIF9iaW5kaW5nc0ZvclBhdGhbaW5kZXhdID0gX2JpbmRpbmdzRm9yUGF0aFtfbGFzdEluZGV4XTtcblxuICAgICAgICAgICAgICBfYmluZGluZ3NGb3JQYXRoLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gY2FjaGVkIG9yIGFjdGl2ZVxuXG4gICAgICAgIH0gLy8gaWYgb2JqZWN0IGlzIGtub3duXG5cbiAgICAgIH0gLy8gZm9yIGFyZ3VtZW50c1xuXG5cbiAgICAgIHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XG4gICAgfSAvLyBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBieSBiZWZyaWVuZGVkIFByb3BlcnR5QmluZGluZy5Db21wb3NpdGU6XG5cbiAgfSwge1xuICAgIGtleTogXCJzdWJzY3JpYmVfXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZV8ocGF0aCwgcGFyc2VkUGF0aCkge1xuICAgICAgLy8gcmV0dXJucyBhbiBhcnJheSBvZiBiaW5kaW5ncyBmb3IgdGhlIGdpdmVuIHBhdGggdGhhdCBpcyBjaGFuZ2VkXG4gICAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRhaW5lZCBvYmplY3RzIGluIHRoZSBncm91cFxuICAgICAgdmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGg7XG4gICAgICB2YXIgaW5kZXggPSBpbmRpY2VzQnlQYXRoW3BhdGhdO1xuICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG4gICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkgcmV0dXJuIGJpbmRpbmdzW2luZGV4XTtcbiAgICAgIHZhciBwYXRocyA9IHRoaXMuX3BhdGhzLFxuICAgICAgICAgIHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXG4gICAgICAgICAgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgICAgICAgbk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcbiAgICAgICAgICBuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuICAgICAgICAgIGJpbmRpbmdzRm9yUGF0aCA9IG5ldyBBcnJheShuT2JqZWN0cyk7XG4gICAgICBpbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcbiAgICAgIGluZGljZXNCeVBhdGhbcGF0aF0gPSBpbmRleDtcbiAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICBwYXJzZWRQYXRocy5wdXNoKHBhcnNlZFBhdGgpO1xuICAgICAgYmluZGluZ3MucHVzaChiaW5kaW5nc0ZvclBhdGgpO1xuXG4gICAgICBmb3IgKHZhciBfaTMzNSA9IG5DYWNoZWRPYmplY3RzLCBuID0gb2JqZWN0cy5sZW5ndGg7IF9pMzM1ICE9PSBuOyArK19pMzM1KSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBvYmplY3RzW19pMzM1XTtcbiAgICAgICAgYmluZGluZ3NGb3JQYXRoW19pMzM1XSA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcob2JqZWN0LCBwYXRoLCBwYXJzZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmRpbmdzRm9yUGF0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zdWJzY3JpYmVfXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlXyhwYXRoKSB7XG4gICAgICAvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXG4gICAgICAvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcbiAgICAgIHZhciBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxuICAgICAgICAgIGluZGV4ID0gaW5kaWNlc0J5UGF0aFtwYXRoXTtcblxuICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXG4gICAgICAgICAgICBwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuICAgICAgICAgICAgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICAgICAgICAgIGxhc3RCaW5kaW5nc0luZGV4ID0gYmluZGluZ3MubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzW2xhc3RCaW5kaW5nc0luZGV4XSxcbiAgICAgICAgICAgIGxhc3RCaW5kaW5nc1BhdGggPSBwYXRoW2xhc3RCaW5kaW5nc0luZGV4XTtcbiAgICAgICAgaW5kaWNlc0J5UGF0aFtsYXN0QmluZGluZ3NQYXRoXSA9IGluZGV4O1xuICAgICAgICBiaW5kaW5nc1tpbmRleF0gPSBsYXN0QmluZGluZ3M7XG4gICAgICAgIGJpbmRpbmdzLnBvcCgpO1xuICAgICAgICBwYXJzZWRQYXRoc1tpbmRleF0gPSBwYXJzZWRQYXRoc1tsYXN0QmluZGluZ3NJbmRleF07XG4gICAgICAgIHBhcnNlZFBhdGhzLnBvcCgpO1xuICAgICAgICBwYXRoc1tpbmRleF0gPSBwYXRoc1tsYXN0QmluZGluZ3NJbmRleF07XG4gICAgICAgIHBhdGhzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbmltYXRpb25PYmplY3RHcm91cDtcbn0oKTtcblxudmFyIEFuaW1hdGlvbkFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbkFjdGlvbihtaXhlciwgY2xpcCkge1xuICAgIHZhciBsb2NhbFJvb3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgdmFyIGJsZW5kTW9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogY2xpcC5ibGVuZE1vZGU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5pbWF0aW9uQWN0aW9uKTtcblxuICAgIHRoaXMuX21peGVyID0gbWl4ZXI7XG4gICAgdGhpcy5fY2xpcCA9IGNsaXA7XG4gICAgdGhpcy5fbG9jYWxSb290ID0gbG9jYWxSb290O1xuICAgIHRoaXMuYmxlbmRNb2RlID0gYmxlbmRNb2RlO1xuICAgIHZhciB0cmFja3MgPSBjbGlwLnRyYWNrcyxcbiAgICAgICAgblRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXG4gICAgICAgIGludGVycG9sYW50cyA9IG5ldyBBcnJheShuVHJhY2tzKTtcbiAgICB2YXIgaW50ZXJwb2xhbnRTZXR0aW5ncyA9IHtcbiAgICAgIGVuZGluZ1N0YXJ0OiBaZXJvQ3VydmF0dXJlRW5kaW5nLFxuICAgICAgZW5kaW5nRW5kOiBaZXJvQ3VydmF0dXJlRW5kaW5nXG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pMzM2ID0gMDsgX2kzMzYgIT09IG5UcmFja3M7ICsrX2kzMzYpIHtcbiAgICAgIHZhciBpbnRlcnBvbGFudCA9IHRyYWNrc1tfaTMzNl0uY3JlYXRlSW50ZXJwb2xhbnQobnVsbCk7XG5cbiAgICAgIGludGVycG9sYW50c1tfaTMzNl0gPSBpbnRlcnBvbGFudDtcbiAgICAgIGludGVycG9sYW50LnNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcbiAgICB9XG5cbiAgICB0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcbiAgICB0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7IC8vIGJvdW5kIGJ5IHRoZSBtaXhlclxuICAgIC8vIGluc2lkZTogUHJvcGVydHlNaXhlciAobWFuYWdlZCBieSB0aGUgbWl4ZXIpXG5cbiAgICB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzID0gbmV3IEFycmF5KG5UcmFja3MpO1xuICAgIHRoaXMuX2NhY2hlSW5kZXggPSBudWxsOyAvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cbiAgICB0aGlzLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDsgLy8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuXG4gICAgdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xuICAgIHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcbiAgICB0aGlzLmxvb3AgPSBMb29wUmVwZWF0O1xuICAgIHRoaXMuX2xvb3BDb3VudCA9IC0xOyAvLyBnbG9iYWwgbWl4ZXIgdGltZSB3aGVuIHRoZSBhY3Rpb24gaXMgdG8gYmUgc3RhcnRlZFxuICAgIC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxuXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gc2NhbGVkIGxvY2FsIHRpbWUgb2YgdGhlIGFjdGlvblxuICAgIC8vIGdldHMgY2xhbXBlZCBvciB3cmFwcGVkIHRvIDAuLmNsaXAuZHVyYXRpb24gYWNjb3JkaW5nIHRvIGxvb3BcblxuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy50aW1lU2NhbGUgPSAxO1xuICAgIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IDE7XG4gICAgdGhpcy53ZWlnaHQgPSAxO1xuICAgIHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XG4gICAgdGhpcy5yZXBldGl0aW9ucyA9IEluZmluaXR5OyAvLyBuby4gb2YgcmVwZXRpdGlvbnMgd2hlbiBsb29waW5nXG5cbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlOyAvLyB0cnVlIC0+IHplcm8gZWZmZWN0aXZlIHRpbWUgc2NhbGVcblxuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7IC8vIGZhbHNlIC0+IHplcm8gZWZmZWN0aXZlIHdlaWdodFxuXG4gICAgdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCA9IGZhbHNlOyAvLyBrZWVwIGZlZWRpbmcgdGhlIGxhc3QgZnJhbWU/XG5cbiAgICB0aGlzLnplcm9TbG9wZUF0U3RhcnQgPSB0cnVlOyAvLyBmb3Igc21vb3RoIGludGVycG9sYXRpb24gdy9vIHNlcGFyYXRlXG5cbiAgICB0aGlzLnplcm9TbG9wZUF0RW5kID0gdHJ1ZTsgLy8gY2xpcHMgZm9yIHN0YXJ0LCBsb29wIGFuZCBlbmRcbiAgfSAvLyBTdGF0ZSAmIFNjaGVkdWxpbmdcblxuXG4gIF9jcmVhdGVDbGFzcyhBbmltYXRpb25BY3Rpb24sIFt7XG4gICAga2V5OiBcInBsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgIHRoaXMuX21peGVyLl9hY3RpdmF0ZUFjdGlvbih0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuX21peGVyLl9kZWFjdGl2YXRlQWN0aW9uKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy50aW1lID0gMDsgLy8gcmVzdGFydCBjbGlwXG5cbiAgICAgIHRoaXMuX2xvb3BDb3VudCA9IC0xOyAvLyBmb3JnZXQgcHJldmlvdXMgbG9vcHNcblxuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gZm9yZ2V0IHNjaGVkdWxpbmdcblxuICAgICAgcmV0dXJuIHRoaXMuc3RvcEZhZGluZygpLnN0b3BXYXJwaW5nKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUnVubmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1J1bm5pbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmFibGVkICYmICF0aGlzLnBhdXNlZCAmJiB0aGlzLnRpbWVTY2FsZSAhPT0gMCAmJiB0aGlzLl9zdGFydFRpbWUgPT09IG51bGwgJiYgdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKHRoaXMpO1xuICAgIH0gLy8gcmV0dXJuIHRydWUgd2hlbiBwbGF5IGhhcyBiZWVuIGNhbGxlZFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTY2hlZHVsZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTY2hlZHVsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0QXQodGltZSkge1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRMb29wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExvb3AobW9kZSwgcmVwZXRpdGlvbnMpIHtcbiAgICAgIHRoaXMubG9vcCA9IG1vZGU7XG4gICAgICB0aGlzLnJlcGV0aXRpb25zID0gcmVwZXRpdGlvbnM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIFdlaWdodFxuICAgIC8vIHNldCB0aGUgd2VpZ2h0IHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgZmFkaW5nXG4gICAgLy8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXG4gICAgLy8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RWZmZWN0aXZlV2VpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEVmZmVjdGl2ZVdlaWdodCh3ZWlnaHQpIHtcbiAgICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0OyAvLyBub3RlOiBzYW1lIGxvZ2ljIGFzIHdoZW4gdXBkYXRlZCBhdCBydW50aW1lXG5cbiAgICAgIHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XG4gICAgICByZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCk7XG4gICAgfSAvLyByZXR1cm4gdGhlIHdlaWdodCBjb25zaWRlcmluZyBmYWRpbmcgYW5kIC5lbmFibGVkXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZmZlY3RpdmVXZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWZmZWN0aXZlV2VpZ2h0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmFkZUluXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhZGVJbihkdXJhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKGR1cmF0aW9uLCAwLCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmFkZU91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWRlT3V0KGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoZHVyYXRpb24sIDEsIDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcm9zc0ZhZGVGcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyb3NzRmFkZUZyb20oZmFkZU91dEFjdGlvbiwgZHVyYXRpb24sIHdhcnApIHtcbiAgICAgIGZhZGVPdXRBY3Rpb24uZmFkZU91dChkdXJhdGlvbik7XG4gICAgICB0aGlzLmZhZGVJbihkdXJhdGlvbik7XG5cbiAgICAgIGlmICh3YXJwKSB7XG4gICAgICAgIHZhciBmYWRlSW5EdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXG4gICAgICAgICAgICBmYWRlT3V0RHVyYXRpb24gPSBmYWRlT3V0QWN0aW9uLl9jbGlwLmR1cmF0aW9uLFxuICAgICAgICAgICAgc3RhcnRFbmRSYXRpbyA9IGZhZGVPdXREdXJhdGlvbiAvIGZhZGVJbkR1cmF0aW9uLFxuICAgICAgICAgICAgZW5kU3RhcnRSYXRpbyA9IGZhZGVJbkR1cmF0aW9uIC8gZmFkZU91dER1cmF0aW9uO1xuICAgICAgICBmYWRlT3V0QWN0aW9uLndhcnAoMS4wLCBzdGFydEVuZFJhdGlvLCBkdXJhdGlvbik7XG4gICAgICAgIHRoaXMud2FycChlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyb3NzRmFkZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyb3NzRmFkZVRvKGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnApIHtcbiAgICAgIHJldHVybiBmYWRlSW5BY3Rpb24uY3Jvc3NGYWRlRnJvbSh0aGlzLCBkdXJhdGlvbiwgd2FycCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BGYWRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcEZhZGluZygpIHtcbiAgICAgIHZhciB3ZWlnaHRJbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG4gICAgICBpZiAod2VpZ2h0SW50ZXJwb2xhbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCh3ZWlnaHRJbnRlcnBvbGFudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gVGltZSBTY2FsZSBDb250cm9sXG4gICAgLy8gc2V0IHRoZSB0aW1lIHNjYWxlIHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgd2FycGluZ1xuICAgIC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXG4gICAgLy8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5wYXVzZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRFZmZlY3RpdmVUaW1lU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RWZmZWN0aXZlVGltZVNjYWxlKHRpbWVTY2FsZSkge1xuICAgICAgdGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG4gICAgICB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aGlzLnBhdXNlZCA/IDAgOiB0aW1lU2NhbGU7XG4gICAgICByZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuICAgIH0gLy8gcmV0dXJuIHRoZSB0aW1lIHNjYWxlIGNvbnNpZGVyaW5nIHdhcnBpbmcgYW5kIC5wYXVzZWRcblxuICB9LCB7XG4gICAga2V5OiBcImdldEVmZmVjdGl2ZVRpbWVTY2FsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZmZlY3RpdmVUaW1lU2NhbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREdXJhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgdGhpcy50aW1lU2NhbGUgPSB0aGlzLl9jbGlwLmR1cmF0aW9uIC8gZHVyYXRpb247XG4gICAgICByZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzeW5jV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jV2l0aChhY3Rpb24pIHtcbiAgICAgIHRoaXMudGltZSA9IGFjdGlvbi50aW1lO1xuICAgICAgdGhpcy50aW1lU2NhbGUgPSBhY3Rpb24udGltZVNjYWxlO1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFsdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYWx0KGR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy53YXJwKHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSwgMCwgZHVyYXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3YXJwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhcnAoc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24pIHtcbiAgICAgIHZhciBtaXhlciA9IHRoaXMuX21peGVyLFxuICAgICAgICAgIG5vdyA9IG1peGVyLnRpbWUsXG4gICAgICAgICAgdGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG4gICAgICB2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuICAgICAgaWYgKGludGVycG9sYW50ID09PSBudWxsKSB7XG4gICAgICAgIGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcbiAgICAgICAgdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxuICAgICAgICAgIHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcbiAgICAgIHRpbWVzWzBdID0gbm93O1xuICAgICAgdGltZXNbMV0gPSBub3cgKyBkdXJhdGlvbjtcbiAgICAgIHZhbHVlc1swXSA9IHN0YXJ0VGltZVNjYWxlIC8gdGltZVNjYWxlO1xuICAgICAgdmFsdWVzWzFdID0gZW5kVGltZVNjYWxlIC8gdGltZVNjYWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0b3BXYXJwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BXYXJwaW5nKCkge1xuICAgICAgdmFyIHRpbWVTY2FsZUludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cbiAgICAgIGlmICh0aW1lU2NhbGVJbnRlcnBvbGFudCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KHRpbWVTY2FsZUludGVycG9sYW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBPYmplY3QgQWNjZXNzb3JzXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaXhlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNaXhlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taXhlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2xpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGlwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NsaXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJvb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2NhbFJvb3QgfHwgdGhpcy5fbWl4ZXIuX3Jvb3Q7XG4gICAgfSAvLyBJbnRlcm5hXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUodGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXgpIHtcbiAgICAgIC8vIGNhbGxlZCBieSB0aGUgbWl4ZXJcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIC8vIGNhbGwgLl91cGRhdGVXZWlnaHQoKSB0byB1cGRhdGUgLl9lZmZlY3RpdmVXZWlnaHRcbiAgICAgICAgdGhpcy5fdXBkYXRlV2VpZ2h0KHRpbWUpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcblxuICAgICAgaWYgKHN0YXJ0VGltZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBjaGVjayBmb3Igc2NoZWR1bGVkIHN0YXJ0IG9mIGFjdGlvblxuICAgICAgICB2YXIgdGltZVJ1bm5pbmcgPSAodGltZSAtIHN0YXJ0VGltZSkgKiB0aW1lRGlyZWN0aW9uO1xuXG4gICAgICAgIGlmICh0aW1lUnVubmluZyA8IDAgfHwgdGltZURpcmVjdGlvbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjsgLy8geWV0IHRvIGNvbWUgLyBkb24ndCBkZWNpZGUgd2hlbiBkZWx0YSA9IDBcbiAgICAgICAgfSAvLyBzdGFydFxuXG5cbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbnVsbDsgLy8gdW5zY2hlZHVsZVxuXG4gICAgICAgIGRlbHRhVGltZSA9IHRpbWVEaXJlY3Rpb24gKiB0aW1lUnVubmluZztcbiAgICAgIH0gLy8gYXBwbHkgdGltZSBzY2FsZSBhbmQgYWR2YW5jZSB0aW1lXG5cblxuICAgICAgZGVsdGFUaW1lICo9IHRoaXMuX3VwZGF0ZVRpbWVTY2FsZSh0aW1lKTtcblxuICAgICAgdmFyIGNsaXBUaW1lID0gdGhpcy5fdXBkYXRlVGltZShkZWx0YVRpbWUpOyAvLyBub3RlOiBfdXBkYXRlVGltZSBtYXkgZGlzYWJsZSB0aGUgYWN0aW9uIHJlc3VsdGluZyBpblxuICAgICAgLy8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXG5cblxuICAgICAgdmFyIHdlaWdodCA9IHRoaXMuX3VwZGF0ZVdlaWdodCh0aW1lKTtcblxuICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgdmFyIGludGVycG9sYW50cyA9IHRoaXMuX2ludGVycG9sYW50cztcbiAgICAgICAgdmFyIHByb3BlcnR5TWl4ZXJzID0gdGhpcy5fcHJvcGVydHlCaW5kaW5ncztcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuYmxlbmRNb2RlKSB7XG4gICAgICAgICAgY2FzZSBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZTpcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgaiAhPT0gbTsgKytqKSB7XG4gICAgICAgICAgICAgIGludGVycG9sYW50c1tqXS5ldmFsdWF0ZShjbGlwVGltZSk7XG4gICAgICAgICAgICAgIHByb3BlcnR5TWl4ZXJzW2pdLmFjY3VtdWxhdGVBZGRpdGl2ZSh3ZWlnaHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBmb3IgKHZhciBfajE4ID0gMCwgX200ID0gaW50ZXJwb2xhbnRzLmxlbmd0aDsgX2oxOCAhPT0gX200OyArK19qMTgpIHtcbiAgICAgICAgICAgICAgaW50ZXJwb2xhbnRzW19qMThdLmV2YWx1YXRlKGNsaXBUaW1lKTtcblxuICAgICAgICAgICAgICBwcm9wZXJ0eU1peGVyc1tfajE4XS5hY2N1bXVsYXRlKGFjY3VJbmRleCwgd2VpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVXZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVdlaWdodCh0aW1lKSB7XG4gICAgICB2YXIgd2VpZ2h0ID0gMDtcblxuICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICB3ZWlnaHQgPSB0aGlzLndlaWdodDtcbiAgICAgICAgdmFyIGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cbiAgICAgICAgaWYgKGludGVycG9sYW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSh0aW1lKVswXTtcbiAgICAgICAgICB3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuICAgICAgICAgIGlmICh0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWzFdKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BGYWRpbmcoKTtcblxuICAgICAgICAgICAgaWYgKGludGVycG9sYW50VmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gZmFkZWQgb3V0LCBkaXNhYmxlXG4gICAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XG4gICAgICByZXR1cm4gd2VpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlVGltZVNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVUaW1lU2NhbGUodGltZSkge1xuICAgICAgdmFyIHRpbWVTY2FsZSA9IDA7XG5cbiAgICAgIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgdGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG4gICAgICAgIHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXG4gICAgICAgIGlmIChpbnRlcnBvbGFudCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUodGltZSlbMF07XG4gICAgICAgICAgdGltZVNjYWxlICo9IGludGVycG9sYW50VmFsdWU7XG5cbiAgICAgICAgICBpZiAodGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sxXSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wV2FycGluZygpO1xuXG4gICAgICAgICAgICBpZiAodGltZVNjYWxlID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIG1vdGlvbiBoYXMgaGFsdGVkLCBwYXVzZVxuICAgICAgICAgICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB3YXJwIGRvbmUgLSBhcHBseSBmaW5hbCB0aW1lIHNjYWxlXG4gICAgICAgICAgICAgIHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aW1lU2NhbGU7XG4gICAgICByZXR1cm4gdGltZVNjYWxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlVGltZShkZWx0YVRpbWUpIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb247XG4gICAgICB2YXIgbG9vcCA9IHRoaXMubG9vcDtcbiAgICAgIHZhciB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xuICAgICAgdmFyIGxvb3BDb3VudCA9IHRoaXMuX2xvb3BDb3VudDtcbiAgICAgIHZhciBwaW5nUG9uZyA9IGxvb3AgPT09IExvb3BQaW5nUG9uZztcblxuICAgICAgaWYgKGRlbHRhVGltZSA9PT0gMCkge1xuICAgICAgICBpZiAobG9vcENvdW50ID09PSAtMSkgcmV0dXJuIHRpbWU7XG4gICAgICAgIHJldHVybiBwaW5nUG9uZyAmJiAobG9vcENvdW50ICYgMSkgPT09IDEgPyBkdXJhdGlvbiAtIHRpbWUgOiB0aW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9vcCA9PT0gTG9vcE9uY2UpIHtcbiAgICAgICAgaWYgKGxvb3BDb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBqdXN0IHN0YXJ0ZWRcbiAgICAgICAgICB0aGlzLl9sb29wQ291bnQgPSAwO1xuXG4gICAgICAgICAgdGhpcy5fc2V0RW5kaW5ncyh0cnVlLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVfc3RvcDoge1xuICAgICAgICAgIGlmICh0aW1lID49IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aW1lID0gZHVyYXRpb247XG4gICAgICAgICAgfSBlbHNlIGlmICh0aW1lIDwgMCkge1xuICAgICAgICAgICAgdGltZSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgICAgICBicmVhayBoYW5kbGVfc3RvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jbGFtcFdoZW5GaW5pc2hlZCkgdGhpcy5wYXVzZWQgPSB0cnVlO2Vsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50aW1lID0gdGltZTtcblxuICAgICAgICAgIHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ2ZpbmlzaGVkJyxcbiAgICAgICAgICAgIGFjdGlvbjogdGhpcyxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZGVsdGFUaW1lIDwgMCA/IC0xIDogMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXBldGl0aXZlIFJlcGVhdCBvciBQaW5nUG9uZ1xuICAgICAgICBpZiAobG9vcENvdW50ID09PSAtMSkge1xuICAgICAgICAgIC8vIGp1c3Qgc3RhcnRlZFxuICAgICAgICAgIGlmIChkZWx0YVRpbWUgPj0gMCkge1xuICAgICAgICAgICAgbG9vcENvdW50ID0gMDtcblxuICAgICAgICAgICAgdGhpcy5fc2V0RW5kaW5ncyh0cnVlLCB0aGlzLnJlcGV0aXRpb25zID09PSAwLCBwaW5nUG9uZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdoZW4gbG9vcGluZyBpbiByZXZlcnNlIGRpcmVjdGlvbiwgdGhlIGluaXRpYWxcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb24gdGhyb3VnaCB6ZXJvIGNvdW50cyBhcyBhIHJlcGV0aXRpb24sXG4gICAgICAgICAgICAvLyBzbyBsZWF2ZSBsb29wQ291bnQgYXQgLTFcbiAgICAgICAgICAgIHRoaXMuX3NldEVuZGluZ3ModGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwKSB7XG4gICAgICAgICAgLy8gd3JhcCBhcm91bmRcbiAgICAgICAgICB2YXIgbG9vcERlbHRhID0gTWF0aC5mbG9vcih0aW1lIC8gZHVyYXRpb24pOyAvLyBzaWduZWRcblxuICAgICAgICAgIHRpbWUgLT0gZHVyYXRpb24gKiBsb29wRGVsdGE7XG4gICAgICAgICAgbG9vcENvdW50ICs9IE1hdGguYWJzKGxvb3BEZWx0YSk7XG4gICAgICAgICAgdmFyIHBlbmRpbmcgPSB0aGlzLnJlcGV0aXRpb25zIC0gbG9vcENvdW50O1xuXG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xuICAgICAgICAgICAgLy8gaGF2ZSB0byBzdG9wIChzd2l0Y2ggc3RhdGUsIGNsYW1wIHRpbWUsIGZpcmUgZXZlbnQpXG4gICAgICAgICAgICBpZiAodGhpcy5jbGFtcFdoZW5GaW5pc2hlZCkgdGhpcy5wYXVzZWQgPSB0cnVlO2Vsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aW1lID0gZGVsdGFUaW1lID4gMCA/IGR1cmF0aW9uIDogMDtcbiAgICAgICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG5cbiAgICAgICAgICAgIHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICB0eXBlOiAnZmluaXNoZWQnLFxuICAgICAgICAgICAgICBhY3Rpb246IHRoaXMsXG4gICAgICAgICAgICAgIGRpcmVjdGlvbjogZGVsdGFUaW1lID4gMCA/IDEgOiAtMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGtlZXAgcnVubmluZ1xuICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gZW50ZXJpbmcgdGhlIGxhc3Qgcm91bmRcbiAgICAgICAgICAgICAgdmFyIGF0U3RhcnQgPSBkZWx0YVRpbWUgPCAwO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3NldEVuZGluZ3MoYXRTdGFydCwgIWF0U3RhcnQsIHBpbmdQb25nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldEVuZGluZ3MoZmFsc2UsIGZhbHNlLCBwaW5nUG9uZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcbiAgICAgICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG5cbiAgICAgICAgICAgIHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICB0eXBlOiAnbG9vcCcsXG4gICAgICAgICAgICAgIGFjdGlvbjogdGhpcyxcbiAgICAgICAgICAgICAgbG9vcERlbHRhOiBsb29wRGVsdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBpbmdQb25nICYmIChsb29wQ291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgIC8vIGludmVydCB0aW1lIGZvciB0aGUgXCJwb25nIHJvdW5kXCJcbiAgICAgICAgICByZXR1cm4gZHVyYXRpb24gLSB0aW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0RW5kaW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0RW5kaW5ncyhhdFN0YXJ0LCBhdEVuZCwgcGluZ1BvbmcpIHtcbiAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3M7XG5cbiAgICAgIGlmIChwaW5nUG9uZykge1xuICAgICAgICBzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFplcm9TbG9wZUVuZGluZztcbiAgICAgICAgc2V0dGluZ3MuZW5kaW5nRW5kID0gWmVyb1Nsb3BlRW5kaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXNzdW1pbmcgZm9yIExvb3BPbmNlIGF0U3RhcnQgPT0gYXRFbmQgPT0gdHJ1ZVxuICAgICAgICBpZiAoYXRTdGFydCkge1xuICAgICAgICAgIHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gdGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFdyYXBBcm91bmRFbmRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXRFbmQpIHtcbiAgICAgICAgICBzZXR0aW5ncy5lbmRpbmdFbmQgPSB0aGlzLnplcm9TbG9wZUF0RW5kID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0aW5ncy5lbmRpbmdFbmQgPSBXcmFwQXJvdW5kRW5kaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zY2hlZHVsZUZhZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2NoZWR1bGVGYWRpbmcoZHVyYXRpb24sIHdlaWdodE5vdywgd2VpZ2h0VGhlbikge1xuICAgICAgdmFyIG1peGVyID0gdGhpcy5fbWl4ZXIsXG4gICAgICAgICAgbm93ID0gbWl4ZXIudGltZTtcbiAgICAgIHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xuXG4gICAgICBpZiAoaW50ZXJwb2xhbnQgPT09IG51bGwpIHtcbiAgICAgICAgaW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xuICAgICAgICB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG4gICAgICAgICAgdmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xuICAgICAgdGltZXNbMF0gPSBub3c7XG4gICAgICB2YWx1ZXNbMF0gPSB3ZWlnaHROb3c7XG4gICAgICB0aW1lc1sxXSA9IG5vdyArIGR1cmF0aW9uO1xuICAgICAgdmFsdWVzWzFdID0gd2VpZ2h0VGhlbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbmltYXRpb25BY3Rpb247XG59KCk7XG5cbnZhciBfY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlciA9IC8qQF9fUFVSRV9fKi9uZXcgRmxvYXQzMkFycmF5KDEpO1xuXG52YXIgQW5pbWF0aW9uTWl4ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudERpc3BhdGNoZXI3KSB7XG4gIF9pbmhlcml0cyhBbmltYXRpb25NaXhlciwgX0V2ZW50RGlzcGF0Y2hlcjcpO1xuXG4gIHZhciBfc3VwZXIxMzkgPSBfY3JlYXRlU3VwZXIoQW5pbWF0aW9uTWl4ZXIpO1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGlvbk1peGVyKHJvb3QpIHtcbiAgICB2YXIgX3RoaXMxMTI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQW5pbWF0aW9uTWl4ZXIpO1xuXG4gICAgX3RoaXMxMTIgPSBfc3VwZXIxMzkuY2FsbCh0aGlzKTtcbiAgICBfdGhpczExMi5fcm9vdCA9IHJvb3Q7XG5cbiAgICBfdGhpczExMi5faW5pdE1lbW9yeU1hbmFnZXIoKTtcblxuICAgIF90aGlzMTEyLl9hY2N1SW5kZXggPSAwO1xuICAgIF90aGlzMTEyLnRpbWUgPSAwO1xuICAgIF90aGlzMTEyLnRpbWVTY2FsZSA9IDEuMDtcbiAgICByZXR1cm4gX3RoaXMxMTI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQW5pbWF0aW9uTWl4ZXIsIFt7XG4gICAga2V5OiBcIl9iaW5kQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kQWN0aW9uKGFjdGlvbiwgcHJvdG90eXBlQWN0aW9uKSB7XG4gICAgICB2YXIgcm9vdCA9IGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QsXG4gICAgICAgICAgdHJhY2tzID0gYWN0aW9uLl9jbGlwLnRyYWNrcyxcbiAgICAgICAgICBuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcbiAgICAgICAgICBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncyxcbiAgICAgICAgICBpbnRlcnBvbGFudHMgPSBhY3Rpb24uX2ludGVycG9sYW50cyxcbiAgICAgICAgICByb290VXVpZCA9IHJvb3QudXVpZCxcbiAgICAgICAgICBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZTtcbiAgICAgIHZhciBiaW5kaW5nc0J5TmFtZSA9IGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXTtcblxuICAgICAgaWYgKGJpbmRpbmdzQnlOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmluZGluZ3NCeU5hbWUgPSB7fTtcbiAgICAgICAgYmluZGluZ3NCeVJvb3Rbcm9vdFV1aWRdID0gYmluZGluZ3NCeU5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMzM3ID0gMDsgX2kzMzcgIT09IG5UcmFja3M7ICsrX2kzMzcpIHtcbiAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW19pMzM3XSxcbiAgICAgICAgICAgIHRyYWNrTmFtZSA9IHRyYWNrLm5hbWU7XG4gICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ3NCeU5hbWVbdHJhY2tOYW1lXTtcblxuICAgICAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgKytiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xuICAgICAgICAgIGJpbmRpbmdzW19pMzM3XSA9IGJpbmRpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmluZGluZyA9IGJpbmRpbmdzW19pMzM3XTtcblxuICAgICAgICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGV4aXN0aW5nIGJpbmRpbmcsIG1ha2Ugc3VyZSB0aGUgY2FjaGUga25vd3NcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLl9jYWNoZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICsrYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblxuICAgICAgICAgICAgICB0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5fcHJvcGVydHlCaW5kaW5nc1tfaTMzN10uYmluZGluZy5wYXJzZWRQYXRoO1xuICAgICAgICAgIGJpbmRpbmcgPSBuZXcgUHJvcGVydHlNaXhlcihQcm9wZXJ0eUJpbmRpbmcuY3JlYXRlKHJvb3QsIHRyYWNrTmFtZSwgcGF0aCksIHRyYWNrLlZhbHVlVHlwZU5hbWUsIHRyYWNrLmdldFZhbHVlU2l6ZSgpKTtcbiAgICAgICAgICArK2JpbmRpbmcucmVmZXJlbmNlQ291bnQ7XG5cbiAgICAgICAgICB0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSk7XG5cbiAgICAgICAgICBiaW5kaW5nc1tfaTMzN10gPSBiaW5kaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJwb2xhbnRzW19pMzM3XS5yZXN1bHRCdWZmZXIgPSBiaW5kaW5nLmJ1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FjdGl2YXRlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hY3RpdmF0ZUFjdGlvbihhY3Rpb24pIHtcbiAgICAgIGlmICghdGhpcy5faXNBY3RpdmVBY3Rpb24oYWN0aW9uKSkge1xuICAgICAgICBpZiAoYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gdGhpcyBhY3Rpb24gaGFzIGJlZW4gZm9yZ290dGVuIGJ5IHRoZSBjYWNoZSwgYnV0IHRoZSB1c2VyXG4gICAgICAgICAgLy8gYXBwZWFycyB0byBiZSBzdGlsbCB1c2luZyBpdCAtPiByZWJpbmRcbiAgICAgICAgICB2YXIgcm9vdFV1aWQgPSAoYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCkudXVpZCxcbiAgICAgICAgICAgICAgY2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcbiAgICAgICAgICAgICAgYWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblxuICAgICAgICAgIHRoaXMuX2JpbmRBY3Rpb24oYWN0aW9uLCBhY3Rpb25zRm9yQ2xpcCAmJiBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbMF0pO1xuXG4gICAgICAgICAgdGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzOyAvLyBpbmNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG5cbiAgICAgICAgZm9yICh2YXIgX2kzMzggPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBfaTMzOCAhPT0gbjsgKytfaTMzOCkge1xuICAgICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ3NbX2kzMzhdO1xuXG4gICAgICAgICAgaWYgKGJpbmRpbmcudXNlQ291bnQrKyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fbGVuZEJpbmRpbmcoYmluZGluZyk7XG5cbiAgICAgICAgICAgIGJpbmRpbmcuc2F2ZU9yaWdpbmFsU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sZW5kQWN0aW9uKGFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWFjdGl2YXRlQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWFjdGl2YXRlQWN0aW9uKGFjdGlvbikge1xuICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlQWN0aW9uKGFjdGlvbikpIHtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzOyAvLyBkZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG5cbiAgICAgICAgZm9yICh2YXIgX2kzMzkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBfaTMzOSAhPT0gbjsgKytfaTMzOSkge1xuICAgICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ3NbX2kzMzldO1xuXG4gICAgICAgICAgaWYgKC0tYmluZGluZy51c2VDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgYmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xuXG4gICAgICAgICAgICB0aGlzLl90YWtlQmFja0JpbmRpbmcoYmluZGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGFrZUJhY2tBY3Rpb24oYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IC8vIE1lbW9yeSBtYW5hZ2VyXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdE1lbW9yeU1hbmFnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRNZW1vcnlNYW5hZ2VyKCkge1xuICAgICAgdGhpcy5fYWN0aW9ucyA9IFtdOyAvLyAnbkFjdGl2ZUFjdGlvbnMnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcblxuICAgICAgdGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xuICAgICAgdGhpcy5fYWN0aW9uc0J5Q2xpcCA9IHt9OyAvLyBpbnNpZGU6XG4gICAgICAvLyB7XG4gICAgICAvLyBcdGtub3duQWN0aW9uczogQXJyYXk8IEFuaW1hdGlvbkFjdGlvbiA+IC0gdXNlZCBhcyBwcm90b3R5cGVzXG4gICAgICAvLyBcdGFjdGlvbkJ5Um9vdDogQW5pbWF0aW9uQWN0aW9uIC0gbG9va3VwXG4gICAgICAvLyB9XG5cbiAgICAgIHRoaXMuX2JpbmRpbmdzID0gW107IC8vICduQWN0aXZlQmluZGluZ3MnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcblxuICAgICAgdGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcbiAgICAgIHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XG5cbiAgICAgIHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXG5cbiAgICAgIHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzID0gMDtcbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgICBhY3Rpb25zOiB7XG4gICAgICAgICAgZ2V0IHRvdGFsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0IGluVXNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlLl9uQWN0aXZlQWN0aW9ucztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcbiAgICAgICAgYmluZGluZ3M6IHtcbiAgICAgICAgICBnZXQgdG90YWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgZ2V0IGluVXNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3BlLl9uQWN0aXZlQmluZGluZ3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRyb2xJbnRlcnBvbGFudHM6IHtcbiAgICAgICAgICBnZXQgdG90YWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBnZXQgaW5Vc2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGUuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gLy8gTWVtb3J5IG1hbmFnZW1lbnQgZm9yIEFuaW1hdGlvbkFjdGlvbiBvYmplY3RzXG5cbiAgfSwge1xuICAgIGtleTogXCJfaXNBY3RpdmVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQWN0aXZlQWN0aW9uKGFjdGlvbikge1xuICAgICAgdmFyIGluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuICAgICAgcmV0dXJuIGluZGV4ICE9PSBudWxsICYmIGluZGV4IDwgdGhpcy5fbkFjdGl2ZUFjdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRJbmFjdGl2ZUFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkSW5hY3RpdmVBY3Rpb24oYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQpIHtcbiAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcbiAgICAgICAgICBhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcDtcbiAgICAgIHZhciBhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXG4gICAgICBpZiAoYWN0aW9uc0ZvckNsaXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhY3Rpb25zRm9yQ2xpcCA9IHtcbiAgICAgICAgICBrbm93bkFjdGlvbnM6IFthY3Rpb25dLFxuICAgICAgICAgIGFjdGlvbkJ5Um9vdDoge31cbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gMDtcbiAgICAgICAgYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF0gPSBhY3Rpb25zRm9yQ2xpcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG4gICAgICAgIGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGtub3duQWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGFjdGlvbi5fY2FjaGVJbmRleCA9IGFjdGlvbnMubGVuZ3RoO1xuICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3Rbcm9vdFV1aWRdID0gYWN0aW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlSW5hY3RpdmVBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZUluYWN0aXZlQWN0aW9uKGFjdGlvbikge1xuICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuICAgICAgICAgIGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbYWN0aW9ucy5sZW5ndGggLSAxXSxcbiAgICAgICAgICBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuICAgICAgbGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcbiAgICAgIGFjdGlvbnNbY2FjaGVJbmRleF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG4gICAgICBhY3Rpb25zLnBvcCgpO1xuICAgICAgYWN0aW9uLl9jYWNoZUluZGV4ID0gbnVsbDtcbiAgICAgIHZhciBjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxuICAgICAgICAgIGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuICAgICAgICAgIGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF0sXG4gICAgICAgICAga25vd25BY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucyxcbiAgICAgICAgICBsYXN0S25vd25BY3Rpb24gPSBrbm93bkFjdGlvbnNGb3JDbGlwW2tub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgYnlDbGlwQ2FjaGVJbmRleCA9IGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleDtcbiAgICAgIGxhc3RLbm93bkFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGJ5Q2xpcENhY2hlSW5kZXg7XG4gICAgICBrbm93bkFjdGlvbnNGb3JDbGlwW2J5Q2xpcENhY2hlSW5kZXhdID0gbGFzdEtub3duQWN0aW9uO1xuICAgICAga25vd25BY3Rpb25zRm9yQ2xpcC5wb3AoKTtcbiAgICAgIGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG4gICAgICB2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxuICAgICAgICAgIHJvb3RVdWlkID0gKGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QpLnV1aWQ7XG4gICAgICBkZWxldGUgYWN0aW9uQnlSb290W3Jvb3RVdWlkXTtcblxuICAgICAgaWYgKGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbihhY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbihhY3Rpb24pIHtcbiAgICAgIHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcblxuICAgICAgZm9yICh2YXIgX2kzNDAgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBfaTM0MCAhPT0gbjsgKytfaTM0MCkge1xuICAgICAgICB2YXIgYmluZGluZyA9IGJpbmRpbmdzW19pMzQwXTtcblxuICAgICAgICBpZiAoLS1iaW5kaW5nLnJlZmVyZW5jZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9sZW5kQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sZW5kQWN0aW9uKGFjdGlvbikge1xuICAgICAgLy8gWyBhY3RpdmUgYWN0aW9ucyB8ICBpbmFjdGl2ZSBhY3Rpb25zICBdXG4gICAgICAvLyBbICBhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cbiAgICAgIC8vICAgICAgICAgICAgICAgICBzICAgICAgICBhXG4gICAgICAvLyAgICAgICAgICAgICAgICAgIDwtc3dhcC0+XG4gICAgICAvLyAgICAgICAgICAgICAgICAgYSAgICAgICAgc1xuICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuICAgICAgICAgIHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcbiAgICAgICAgICBsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQWN0aW9ucysrLFxuICAgICAgICAgIGZpcnN0SW5hY3RpdmVBY3Rpb24gPSBhY3Rpb25zW2xhc3RBY3RpdmVJbmRleF07XG4gICAgICBhY3Rpb24uX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG4gICAgICBhY3Rpb25zW2xhc3RBY3RpdmVJbmRleF0gPSBhY3Rpb247XG4gICAgICBmaXJzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuICAgICAgYWN0aW9uc1twcmV2SW5kZXhdID0gZmlyc3RJbmFjdGl2ZUFjdGlvbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Rha2VCYWNrQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90YWtlQmFja0FjdGlvbihhY3Rpb24pIHtcbiAgICAgIC8vIFsgIGFjdGl2ZSBhY3Rpb25zICB8IGluYWN0aXZlIGFjdGlvbnMgXVxuICAgICAgLy8gWyBhY3RpdmUgYWN0aW9ucyB8PCBpbmFjdGl2ZSBhY3Rpb25zICBdXG4gICAgICAvLyAgICAgICAgYSAgICAgICAgc1xuICAgICAgLy8gICAgICAgICA8LXN3YXAtPlxuICAgICAgLy8gICAgICAgIHMgICAgICAgIGFcbiAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcbiAgICAgICAgICBwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXG4gICAgICAgICAgZmlyc3RJbmFjdGl2ZUluZGV4ID0gLS10aGlzLl9uQWN0aXZlQWN0aW9ucyxcbiAgICAgICAgICBsYXN0QWN0aXZlQWN0aW9uID0gYWN0aW9uc1tmaXJzdEluYWN0aXZlSW5kZXhdO1xuICAgICAgYWN0aW9uLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuICAgICAgYWN0aW9uc1tmaXJzdEluYWN0aXZlSW5kZXhdID0gYWN0aW9uO1xuICAgICAgbGFzdEFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIGFjdGlvbnNbcHJldkluZGV4XSA9IGxhc3RBY3RpdmVBY3Rpb247XG4gICAgfSAvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkSW5hY3RpdmVCaW5kaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRJbmFjdGl2ZUJpbmRpbmcoYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSkge1xuICAgICAgdmFyIGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuICAgICAgICAgIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG4gICAgICB2YXIgYmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXTtcblxuICAgICAgaWYgKGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBiaW5kaW5nQnlOYW1lID0ge307XG4gICAgICAgIGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXSA9IGJpbmRpbmdCeU5hbWU7XG4gICAgICB9XG5cbiAgICAgIGJpbmRpbmdCeU5hbWVbdHJhY2tOYW1lXSA9IGJpbmRpbmc7XG4gICAgICBiaW5kaW5nLl9jYWNoZUluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuICAgICAgYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUluYWN0aXZlQmluZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKGJpbmRpbmcpIHtcbiAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuICAgICAgICAgIHByb3BCaW5kaW5nID0gYmluZGluZy5iaW5kaW5nLFxuICAgICAgICAgIHJvb3RVdWlkID0gcHJvcEJpbmRpbmcucm9vdE5vZGUudXVpZCxcbiAgICAgICAgICB0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxuICAgICAgICAgIGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuICAgICAgICAgIGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFtyb290VXVpZF0sXG4gICAgICAgICAgbGFzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzW2JpbmRpbmdzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIGNhY2hlSW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4O1xuICAgICAgbGFzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XG4gICAgICBiaW5kaW5nc1tjYWNoZUluZGV4XSA9IGxhc3RJbmFjdGl2ZUJpbmRpbmc7XG4gICAgICBiaW5kaW5ncy5wb3AoKTtcbiAgICAgIGRlbGV0ZSBiaW5kaW5nQnlOYW1lW3RyYWNrTmFtZV07XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhiaW5kaW5nQnlOYW1lKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2xlbmRCaW5kaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sZW5kQmluZGluZyhiaW5kaW5nKSB7XG4gICAgICB2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICAgICAgICBwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuICAgICAgICAgIGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncysrLFxuICAgICAgICAgIGZpcnN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbbGFzdEFjdGl2ZUluZGV4XTtcbiAgICAgIGJpbmRpbmcuX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG4gICAgICBiaW5kaW5nc1tsYXN0QWN0aXZlSW5kZXhdID0gYmluZGluZztcbiAgICAgIGZpcnN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuICAgICAgYmluZGluZ3NbcHJldkluZGV4XSA9IGZpcnN0SW5hY3RpdmVCaW5kaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdGFrZUJhY2tCaW5kaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90YWtlQmFja0JpbmRpbmcoYmluZGluZykge1xuICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG4gICAgICAgICAgcHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcbiAgICAgICAgICBmaXJzdEluYWN0aXZlSW5kZXggPSAtLXRoaXMuX25BY3RpdmVCaW5kaW5ncyxcbiAgICAgICAgICBsYXN0QWN0aXZlQmluZGluZyA9IGJpbmRpbmdzW2ZpcnN0SW5hY3RpdmVJbmRleF07XG4gICAgICBiaW5kaW5nLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuICAgICAgYmluZGluZ3NbZmlyc3RJbmFjdGl2ZUluZGV4XSA9IGJpbmRpbmc7XG4gICAgICBsYXN0QWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIGJpbmRpbmdzW3ByZXZJbmRleF0gPSBsYXN0QWN0aXZlQmluZGluZztcbiAgICB9IC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXG5cbiAgfSwge1xuICAgIGtleTogXCJfbGVuZENvbnRyb2xJbnRlcnBvbGFudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpIHtcbiAgICAgIHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxuICAgICAgICAgIGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzKys7XG4gICAgICB2YXIgaW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbbGFzdEFjdGl2ZUluZGV4XTtcblxuICAgICAgaWYgKGludGVycG9sYW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW50ZXJwb2xhbnQgPSBuZXcgTGluZWFySW50ZXJwb2xhbnQobmV3IEZsb2F0MzJBcnJheSgyKSwgbmV3IEZsb2F0MzJBcnJheSgyKSwgMSwgX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIpO1xuICAgICAgICBpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG4gICAgICAgIGludGVycG9sYW50c1tsYXN0QWN0aXZlSW5kZXhdID0gaW50ZXJwb2xhbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnRlcnBvbGFudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudChpbnRlcnBvbGFudCkge1xuICAgICAgdmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG4gICAgICAgICAgcHJldkluZGV4ID0gaW50ZXJwb2xhbnQuX19jYWNoZUluZGV4LFxuICAgICAgICAgIGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMsXG4gICAgICAgICAgbGFzdEFjdGl2ZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzW2ZpcnN0SW5hY3RpdmVJbmRleF07XG4gICAgICBpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XG4gICAgICBpbnRlcnBvbGFudHNbZmlyc3RJbmFjdGl2ZUluZGV4XSA9IGludGVycG9sYW50O1xuICAgICAgbGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIGludGVycG9sYW50c1twcmV2SW5kZXhdID0gbGFzdEFjdGl2ZUludGVycG9sYW50O1xuICAgIH0gLy8gcmV0dXJuIGFuIGFjdGlvbiBmb3IgYSBjbGlwIG9wdGlvbmFsbHkgdXNpbmcgYSBjdXN0b20gcm9vdCB0YXJnZXRcbiAgICAvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcbiAgICAvLyBwcmV2aW91c2x5IHVua25vd24gY2xpcC9yb290IGNvbWJpbmF0aW9uIGlzIHNwZWNpZmllZClcblxuICB9LCB7XG4gICAga2V5OiBcImNsaXBBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xpcEFjdGlvbihjbGlwLCBvcHRpb25hbFJvb3QsIGJsZW5kTW9kZSkge1xuICAgICAgdmFyIHJvb3QgPSBvcHRpb25hbFJvb3QgfHwgdGhpcy5fcm9vdCxcbiAgICAgICAgICByb290VXVpZCA9IHJvb3QudXVpZDtcbiAgICAgIHZhciBjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID8gQW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKHJvb3QsIGNsaXApIDogY2xpcDtcbiAgICAgIHZhciBjbGlwVXVpZCA9IGNsaXBPYmplY3QgIT09IG51bGwgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwO1xuICAgICAgdmFyIGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFtjbGlwVXVpZF07XG4gICAgICB2YXIgcHJvdG90eXBlQWN0aW9uID0gbnVsbDtcblxuICAgICAgaWYgKGJsZW5kTW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChjbGlwT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgYmxlbmRNb2RlID0gY2xpcE9iamVjdC5ibGVuZE1vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxlbmRNb2RlID0gTm9ybWFsQW5pbWF0aW9uQmxlbmRNb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBleGlzdGluZ0FjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFtyb290VXVpZF07XG5cbiAgICAgICAgaWYgKGV4aXN0aW5nQWN0aW9uICE9PSB1bmRlZmluZWQgJiYgZXhpc3RpbmdBY3Rpb24uYmxlbmRNb2RlID09PSBibGVuZE1vZGUpIHtcbiAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBY3Rpb247XG4gICAgICAgIH0gLy8gd2Uga25vdyB0aGUgY2xpcCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBwYXJzZSBhbGxcbiAgICAgICAgLy8gdGhlIGJpbmRpbmdzIGFnYWluIGJ1dCBjYW4ganVzdCBjb3B5XG5cblxuICAgICAgICBwcm90b3R5cGVBY3Rpb24gPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbMF07IC8vIGFsc28sIHRha2UgdGhlIGNsaXAgZnJvbSB0aGUgcHJvdG90eXBlIGFjdGlvblxuXG4gICAgICAgIGlmIChjbGlwT2JqZWN0ID09PSBudWxsKSBjbGlwT2JqZWN0ID0gcHJvdG90eXBlQWN0aW9uLl9jbGlwO1xuICAgICAgfSAvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xuXG5cbiAgICAgIGlmIChjbGlwT2JqZWN0ID09PSBudWxsKSByZXR1cm4gbnVsbDsgLy8gYWxsb2NhdGUgYWxsIHJlc291cmNlcyByZXF1aXJlZCB0byBydW4gaXRcblxuICAgICAgdmFyIG5ld0FjdGlvbiA9IG5ldyBBbmltYXRpb25BY3Rpb24odGhpcywgY2xpcE9iamVjdCwgb3B0aW9uYWxSb290LCBibGVuZE1vZGUpO1xuXG4gICAgICB0aGlzLl9iaW5kQWN0aW9uKG5ld0FjdGlvbiwgcHJvdG90eXBlQWN0aW9uKTsgLy8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcblxuXG4gICAgICB0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbihuZXdBY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCk7XG5cbiAgICAgIHJldHVybiBuZXdBY3Rpb247XG4gICAgfSAvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXG5cbiAgfSwge1xuICAgIGtleTogXCJleGlzdGluZ0FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGlzdGluZ0FjdGlvbihjbGlwLCBvcHRpb25hbFJvb3QpIHtcbiAgICAgIHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG4gICAgICAgICAgcm9vdFV1aWQgPSByb290LnV1aWQsXG4gICAgICAgICAgY2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/IEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZShyb290LCBjbGlwKSA6IGNsaXAsXG4gICAgICAgICAgY2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcbiAgICAgICAgICBhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbY2xpcFV1aWRdO1xuXG4gICAgICBpZiAoYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290W3Jvb3RVdWlkXSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGRlYWN0aXZhdGVzIGFsbCBwcmV2aW91c2x5IHNjaGVkdWxlZCBhY3Rpb25zXG5cbiAgfSwge1xuICAgIGtleTogXCJzdG9wQWxsQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BBbGxBY3Rpb24oKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG4gICAgICAgICAgbkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblxuICAgICAgZm9yICh2YXIgX2kzNDEgPSBuQWN0aW9ucyAtIDE7IF9pMzQxID49IDA7IC0tX2kzNDEpIHtcbiAgICAgICAgYWN0aW9uc1tfaTM0MV0uc3RvcCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIGFkdmFuY2UgdGhlIHRpbWUgYW5kIHVwZGF0ZSBhcHBseSB0aGUgYW5pbWF0aW9uXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGRlbHRhVGltZSkge1xuICAgICAgZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xuICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuICAgICAgICAgIG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG4gICAgICAgICAgdGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXG4gICAgICAgICAgdGltZURpcmVjdGlvbiA9IE1hdGguc2lnbihkZWx0YVRpbWUpLFxuICAgICAgICAgIGFjY3VJbmRleCA9IHRoaXMuX2FjY3VJbmRleCBePSAxOyAvLyBydW4gYWN0aXZlIGFjdGlvbnNcblxuICAgICAgZm9yICh2YXIgX2kzNDIgPSAwOyBfaTM0MiAhPT0gbkFjdGlvbnM7ICsrX2kzNDIpIHtcbiAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNbX2kzNDJdO1xuXG4gICAgICAgIGFjdGlvbi5fdXBkYXRlKHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4KTtcbiAgICAgIH0gLy8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblxuICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG4gICAgICAgICAgbkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG4gICAgICBmb3IgKHZhciBfaTM0MyA9IDA7IF9pMzQzICE9PSBuQmluZGluZ3M7ICsrX2kzNDMpIHtcbiAgICAgICAgYmluZGluZ3NbX2kzNDNdLmFwcGx5KGFjY3VJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gQWxsb3dzIHlvdSB0byBzZWVrIHRvIGEgc3BlY2lmaWMgdGltZSBpbiBhbiBhbmltYXRpb24uXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUaW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRpbWUodGltZUluU2Vjb25kcykge1xuICAgICAgdGhpcy50aW1lID0gMDsgLy8gWmVybyBvdXQgdGltZSBhdHRyaWJ1dGUgZm9yIEFuaW1hdGlvbk1peGVyIG9iamVjdDtcblxuICAgICAgZm9yICh2YXIgX2kzNDQgPSAwOyBfaTM0NCA8IHRoaXMuX2FjdGlvbnMubGVuZ3RoOyBfaTM0NCsrKSB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnNbX2kzNDRdLnRpbWUgPSAwOyAvLyBaZXJvIG91dCB0aW1lIGF0dHJpYnV0ZSBmb3IgYWxsIGFzc29jaWF0ZWQgQW5pbWF0aW9uQWN0aW9uIG9iamVjdHMuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSh0aW1lSW5TZWNvbmRzKTsgLy8gVXBkYXRlIHVzZWQgdG8gc2V0IGV4YWN0IHRpbWUuIFJldHVybnMgXCJ0aGlzXCIgQW5pbWF0aW9uTWl4ZXIgb2JqZWN0LlxuICAgIH0gLy8gcmV0dXJuIHRoaXMgbWl4ZXIncyByb290IHRhcmdldCBvYmplY3RcblxuICB9LCB7XG4gICAga2V5OiBcImdldFJvb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290O1xuICAgIH0gLy8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmNhY2hlQ2xpcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmNhY2hlQ2xpcChjbGlwKSB7XG4gICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG4gICAgICAgICAgY2xpcFV1aWQgPSBjbGlwLnV1aWQsXG4gICAgICAgICAgYWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXG4gICAgICAgICAgYWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcblxuICAgICAgaWYgKGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxuICAgICAgICAvLyBpdGVyYXRpb24gc3RhdGUgYW5kIGFsc28gcmVxdWlyZSB1cGRhdGluZyB0aGUgc3RhdGUgd2UgY2FuXG4gICAgICAgIC8vIGp1c3QgdGhyb3cgYXdheVxuICAgICAgICB2YXIgYWN0aW9uc1RvUmVtb3ZlID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zO1xuXG4gICAgICAgIGZvciAodmFyIF9pMzQ1ID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IF9pMzQ1ICE9PSBuOyArK19pMzQ1KSB7XG4gICAgICAgICAgdmFyIGFjdGlvbiA9IGFjdGlvbnNUb1JlbW92ZVtfaTM0NV07XG5cbiAgICAgICAgICB0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKGFjdGlvbik7XG5cbiAgICAgICAgICB2YXIgY2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcbiAgICAgICAgICAgICAgbGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1thY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG4gICAgICAgICAgYWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcbiAgICAgICAgICBsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuICAgICAgICAgIGFjdGlvbnNbY2FjaGVJbmRleF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG4gICAgICAgICAgYWN0aW9ucy5wb3AoKTtcblxuICAgICAgICAgIHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBhY3Rpb25zQnlDbGlwW2NsaXBVdWlkXTtcbiAgICAgIH1cbiAgICB9IC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgcm9vdCB0YXJnZXQgb2JqZWN0XG5cbiAgfSwge1xuICAgIGtleTogXCJ1bmNhY2hlUm9vdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmNhY2hlUm9vdChyb290KSB7XG4gICAgICB2YXIgcm9vdFV1aWQgPSByb290LnV1aWQsXG4gICAgICAgICAgYWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cbiAgICAgIGZvciAodmFyIGNsaXBVdWlkIGluIGFjdGlvbnNCeUNsaXApIHtcbiAgICAgICAgdmFyIGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNCeUNsaXBbY2xpcFV1aWRdLmFjdGlvbkJ5Um9vdCxcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbkJ5Um9vdFtyb290VXVpZF07XG5cbiAgICAgICAgaWYgKGFjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fZGVhY3RpdmF0ZUFjdGlvbihhY3Rpb24pO1xuXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG4gICAgICAgICAgYmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290W3Jvb3RVdWlkXTtcblxuICAgICAgaWYgKGJpbmRpbmdCeU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSkge1xuICAgICAgICAgIHZhciBiaW5kaW5nID0gYmluZGluZ0J5TmFtZVt0cmFja05hbWVdO1xuICAgICAgICAgIGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcblxuICAgICAgICAgIHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyhiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gcmVtb3ZlIGEgdGFyZ2V0ZWQgY2xpcCBmcm9tIHRoZSBjYWNoZVxuXG4gIH0sIHtcbiAgICBrZXk6IFwidW5jYWNoZUFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmNhY2hlQWN0aW9uKGNsaXAsIG9wdGlvbmFsUm9vdCkge1xuICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oY2xpcCwgb3B0aW9uYWxSb290KTtcblxuICAgICAgaWYgKGFjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKGFjdGlvbik7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5pbWF0aW9uTWl4ZXI7XG59KEV2ZW50RGlzcGF0Y2hlcik7XG5cbnZhciBVbmlmb3JtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVW5pZm9ybSh2YWx1ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVbmlmb3JtKTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLlVuaWZvcm06IFR5cGUgcGFyYW1ldGVyIGlzIG5vIGxvbmdlciBuZWVkZWQuJyk7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVW5pZm9ybSwgW3tcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IFVuaWZvcm0odGhpcy52YWx1ZS5jbG9uZSA9PT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUuY2xvbmUoKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFVuaWZvcm07XG59KCk7XG5cbnZhciBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0ludGVybGVhdmVkQnVmZmVyKSB7XG4gIF9pbmhlcml0cyhJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciwgX0ludGVybGVhdmVkQnVmZmVyKTtcblxuICB2YXIgX3N1cGVyMTQwID0gX2NyZWF0ZVN1cGVyKEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKTtcblxuICBmdW5jdGlvbiBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcihhcnJheSwgc3RyaWRlKSB7XG4gICAgdmFyIF90aGlzMTEzO1xuXG4gICAgdmFyIG1lc2hQZXJBdHRyaWJ1dGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIpO1xuXG4gICAgX3RoaXMxMTMgPSBfc3VwZXIxNDAuY2FsbCh0aGlzLCBhcnJheSwgc3RyaWRlKTtcbiAgICBfdGhpczExMy5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcbiAgICBfdGhpczExMy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZTtcbiAgICByZXR1cm4gX3RoaXMxMTM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSk7XG5cbiAgICAgIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKGRhdGEpIHtcbiAgICAgIHZhciBpYiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSksIFwiY2xvbmVcIiwgdGhpcykuY2FsbCh0aGlzLCBkYXRhKTtcblxuICAgICAgaWIubWVzaFBlckF0dHJpYnV0ZSA9IHRoaXMubWVzaFBlckF0dHJpYnV0ZTtcbiAgICAgIHJldHVybiBpYjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTihkYXRhKSB7XG4gICAgICB2YXIganNvbiA9IF9nZXQoX2dldFByb3RvdHlwZU9mKEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSksIFwidG9KU09OXCIsIHRoaXMpLmNhbGwodGhpcywgZGF0YSk7XG5cbiAgICAgIGpzb24uaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IHRydWU7XG4gICAgICBqc29uLm1lc2hQZXJBdHRyaWJ1dGUgPSB0aGlzLm1lc2hQZXJBdHRyaWJ1dGU7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI7XG59KEludGVybGVhdmVkQnVmZmVyKTtcblxudmFyIEdMQnVmZmVyQXR0cmlidXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR0xCdWZmZXJBdHRyaWJ1dGUoYnVmZmVyLCB0eXBlLCBpdGVtU2l6ZSwgZWxlbWVudFNpemUsIGNvdW50KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdMQnVmZmVyQXR0cmlidXRlKTtcblxuICAgIHRoaXMuaXNHTEJ1ZmZlckF0dHJpYnV0ZSA9IHRydWU7XG4gICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IGVsZW1lbnRTaXplO1xuICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICB0aGlzLnZlcnNpb24gPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdMQnVmZmVyQXR0cmlidXRlLCBbe1xuICAgIGtleTogXCJuZWVkc1VwZGF0ZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHRydWUpIHRoaXMudmVyc2lvbisrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QnVmZmVyKGJ1ZmZlcikge1xuICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUeXBlKHR5cGUsIGVsZW1lbnRTaXplKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5lbGVtZW50U2l6ZSA9IGVsZW1lbnRTaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEl0ZW1TaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEl0ZW1TaXplKGl0ZW1TaXplKSB7XG4gICAgICB0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q291bnQoY291bnQpIHtcbiAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHTEJ1ZmZlckF0dHJpYnV0ZTtcbn0oKTtcblxudmFyIFJheWNhc3RlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJheWNhc3RlcihvcmlnaW4sIGRpcmVjdGlvbikge1xuICAgIHZhciBuZWFyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgIHZhciBmYXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IEluZmluaXR5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJheWNhc3Rlcik7XG5cbiAgICB0aGlzLnJheSA9IG5ldyBSYXkob3JpZ2luLCBkaXJlY3Rpb24pOyAvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxuXG4gICAgdGhpcy5uZWFyID0gbmVhcjtcbiAgICB0aGlzLmZhciA9IGZhcjtcbiAgICB0aGlzLmNhbWVyYSA9IG51bGw7XG4gICAgdGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XG4gICAgdGhpcy5wYXJhbXMgPSB7XG4gICAgICBNZXNoOiB7fSxcbiAgICAgIExpbmU6IHtcbiAgICAgICAgdGhyZXNob2xkOiAxXG4gICAgICB9LFxuICAgICAgTE9EOiB7fSxcbiAgICAgIFBvaW50czoge1xuICAgICAgICB0aHJlc2hvbGQ6IDFcbiAgICAgIH0sXG4gICAgICBTcHJpdGU6IHt9XG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYXljYXN0ZXIsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3JpZ2luLCBkaXJlY3Rpb24pIHtcbiAgICAgIC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG4gICAgICB0aGlzLnJheS5zZXQob3JpZ2luLCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tQ2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21DYW1lcmEoY29vcmRzLCBjYW1lcmEpIHtcbiAgICAgIGlmIChjYW1lcmEuaXNQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICB0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKGNhbWVyYS5tYXRyaXhXb3JsZCk7XG4gICAgICAgIHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoY29vcmRzLngsIGNvb3Jkcy55LCAwLjUpLnVucHJvamVjdChjYW1lcmEpLnN1Yih0aGlzLnJheS5vcmlnaW4pLm5vcm1hbGl6ZSgpO1xuICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXQoY29vcmRzLngsIGNvb3Jkcy55LCAoY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyKSAvIChjYW1lcmEubmVhciAtIGNhbWVyYS5mYXIpKS51bnByb2plY3QoY2FtZXJhKTsgLy8gc2V0IG9yaWdpbiBpbiBwbGFuZSBvZiBjYW1lcmFcblxuICAgICAgICB0aGlzLnJheS5kaXJlY3Rpb24uc2V0KDAsIDAsIC0xKS50cmFuc2Zvcm1EaXJlY3Rpb24oY2FtZXJhLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlOiAnICsgY2FtZXJhLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KG9iamVjdCkge1xuICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBpbnRlcnNlY3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcblxuICAgICAgX2ludGVyc2VjdE9iamVjdChvYmplY3QsIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSk7XG5cbiAgICAgIGludGVyc2VjdHMuc29ydChhc2NTb3J0KTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RPYmplY3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdE9iamVjdHMob2JqZWN0cykge1xuICAgICAgdmFyIHJlY3Vyc2l2ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBpbnRlcnNlY3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBbXTtcblxuICAgICAgZm9yICh2YXIgX2kzNDYgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IF9pMzQ2IDwgbDsgX2kzNDYrKykge1xuICAgICAgICBfaW50ZXJzZWN0T2JqZWN0KG9iamVjdHNbX2kzNDZdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUpO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnNlY3RzLnNvcnQoYXNjU29ydCk7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmF5Y2FzdGVyO1xufSgpO1xuXG5mdW5jdGlvbiBhc2NTb3J0KGEsIGIpIHtcbiAgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJzZWN0T2JqZWN0KG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUpIHtcbiAgaWYgKG9iamVjdC5sYXllcnMudGVzdChyYXljYXN0ZXIubGF5ZXJzKSkge1xuICAgIG9iamVjdC5yYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cyk7XG4gIH1cblxuICBpZiAocmVjdXJzaXZlID09PSB0cnVlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgX2kzNDcgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBfaTM0NyA8IGw7IF9pMzQ3KyspIHtcbiAgICAgIF9pbnRlcnNlY3RPYmplY3QoY2hpbGRyZW5bX2kzNDddLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxuICpcbiAqIFRoZSBwb2xhciBhbmdsZSAocGhpKSBpcyBtZWFzdXJlZCBmcm9tIHRoZSBwb3NpdGl2ZSB5LWF4aXMuIFRoZSBwb3NpdGl2ZSB5LWF4aXMgaXMgdXAuXG4gKiBUaGUgYXppbXV0aGFsIGFuZ2xlICh0aGV0YSkgaXMgbWVhc3VyZWQgZnJvbSB0aGUgcG9zaXRpdmUgei1heGlzLlxuICovXG5cblxudmFyIFNwaGVyaWNhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNwaGVyaWNhbCgpIHtcbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIHZhciBwaGkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIHRoZXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwaGVyaWNhbCk7XG5cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB0aGlzLnBoaSA9IHBoaTsgLy8gcG9sYXIgYW5nbGVcblxuICAgIHRoaXMudGhldGEgPSB0aGV0YTsgLy8gYXppbXV0aGFsIGFuZ2xlXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTcGhlcmljYWwsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQocmFkaXVzLCBwaGksIHRoZXRhKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgIHRoaXMucGhpID0gcGhpO1xuICAgICAgdGhpcy50aGV0YSA9IHRoZXRhO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShvdGhlcikge1xuICAgICAgdGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XG4gICAgICB0aGlzLnBoaSA9IG90aGVyLnBoaTtcbiAgICAgIHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZW4gRVBTIGFuZCBQSS1FUFNcblxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VTYWZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VTYWZlKCkge1xuICAgICAgdmFyIEVQUyA9IDAuMDAwMDAxO1xuICAgICAgdGhpcy5waGkgPSBNYXRoLm1heChFUFMsIE1hdGgubWluKE1hdGguUEkgLSBFUFMsIHRoaXMucGhpKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbVZlY3RvcjNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVZlY3RvcjModikge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbUNhcnRlc2lhbkNvb3Jkcyh2LngsIHYueSwgdi56KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbUNhcnRlc2lhbkNvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHgsIHksIHopIHtcbiAgICAgIHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG5cbiAgICAgIGlmICh0aGlzLnJhZGl1cyA9PT0gMCkge1xuICAgICAgICB0aGlzLnRoZXRhID0gMDtcbiAgICAgICAgdGhpcy5waGkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aGV0YSA9IE1hdGguYXRhbjIoeCwgeik7XG4gICAgICAgIHRoaXMucGhpID0gTWF0aC5hY29zKGNsYW1wKHkgLyB0aGlzLnJhZGl1cywgLTEsIDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BoZXJpY2FsO1xufSgpO1xuLyoqXG4gKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N5bGluZHJpY2FsX2Nvb3JkaW5hdGVfc3lzdGVtXG4gKi9cblxuXG52YXIgQ3lsaW5kcmljYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDeWxpbmRyaWNhbCgpIHtcbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgIHZhciB0aGV0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDeWxpbmRyaWNhbCk7XG5cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1czsgLy8gZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luIHRvIGEgcG9pbnQgaW4gdGhlIHgteiBwbGFuZVxuXG4gICAgdGhpcy50aGV0YSA9IHRoZXRhOyAvLyBjb3VudGVyY2xvY2t3aXNlIGFuZ2xlIGluIHRoZSB4LXogcGxhbmUgbWVhc3VyZWQgaW4gcmFkaWFucyBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXNcblxuICAgIHRoaXMueSA9IHk7IC8vIGhlaWdodCBhYm92ZSB0aGUgeC16IHBsYW5lXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDeWxpbmRyaWNhbCwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChyYWRpdXMsIHRoZXRhLCB5KSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgIHRoaXMudGhldGEgPSB0aGV0YTtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KG90aGVyKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcbiAgICAgIHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcbiAgICAgIHRoaXMueSA9IG90aGVyLnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbVZlY3RvcjNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVZlY3RvcjModikge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbUNhcnRlc2lhbkNvb3Jkcyh2LngsIHYueSwgdi56KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RnJvbUNhcnRlc2lhbkNvb3Jkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGcm9tQ2FydGVzaWFuQ29vcmRzKHgsIHksIHopIHtcbiAgICAgIHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KHggKiB4ICsgeiAqIHopO1xuICAgICAgdGhpcy50aGV0YSA9IE1hdGguYXRhbjIoeCwgeik7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ3lsaW5kcmljYWw7XG59KCk7XG5cbnZhciBfdmVjdG9yJDQgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjIoKTtcblxudmFyIEJveDIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCb3gyKCkge1xuICAgIHZhciBtaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBWZWN0b3IyKCtJbmZpbml0eSwgK0luZmluaXR5KTtcbiAgICB2YXIgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBuZXcgVmVjdG9yMigtSW5maW5pdHksIC1JbmZpbml0eSk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94Mik7XG5cbiAgICB0aGlzLmlzQm94MiA9IHRydWU7XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQm94MiwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChtaW4sIG1heCkge1xuICAgICAgdGhpcy5taW4uY29weShtaW4pO1xuICAgICAgdGhpcy5tYXguY29weShtYXgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZyb21Qb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RnJvbVBvaW50cyhwb2ludHMpIHtcbiAgICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICAgIGZvciAodmFyIF9pMzQ4ID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBfaTM0OCA8IGlsOyBfaTM0OCsrKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kQnlQb2ludChwb2ludHNbX2kzNDhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEZyb21DZW50ZXJBbmRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21DZW50ZXJBbmRTaXplKGNlbnRlciwgc2l6ZSkge1xuICAgICAgdmFyIGhhbGZTaXplID0gX3ZlY3RvciQ0LmNvcHkoc2l6ZSkubXVsdGlwbHlTY2FsYXIoMC41KTtcblxuICAgICAgdGhpcy5taW4uY29weShjZW50ZXIpLnN1YihoYWxmU2l6ZSk7XG4gICAgICB0aGlzLm1heC5jb3B5KGNlbnRlcikuYWRkKGhhbGZTaXplKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShib3gpIHtcbiAgICAgIHRoaXMubWluLmNvcHkoYm94Lm1pbik7XG4gICAgICB0aGlzLm1heC5jb3B5KGJveC5tYXgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1ha2VFbXB0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYWtlRW1wdHkoKSB7XG4gICAgICB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9ICtJbmZpbml0eTtcbiAgICAgIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLUluZmluaXR5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG4gICAgICByZXR1cm4gdGhpcy5tYXgueCA8IHRoaXMubWluLnggfHwgdGhpcy5tYXgueSA8IHRoaXMubWluLnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDZW50ZXIodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KDAsIDApIDogdGFyZ2V0LmFkZFZlY3RvcnModGhpcy5taW4sIHRoaXMubWF4KS5tdWx0aXBseVNjYWxhcigwLjUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpemUodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0YXJnZXQuc2V0KDAsIDApIDogdGFyZ2V0LnN1YlZlY3RvcnModGhpcy5tYXgsIHRoaXMubWluKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwYW5kQnlQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRCeVBvaW50KHBvaW50KSB7XG4gICAgICB0aGlzLm1pbi5taW4ocG9pbnQpO1xuICAgICAgdGhpcy5tYXgubWF4KHBvaW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleHBhbmRCeVZlY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRCeVZlY3Rvcih2ZWN0b3IpIHtcbiAgICAgIHRoaXMubWluLnN1Yih2ZWN0b3IpO1xuICAgICAgdGhpcy5tYXguYWRkKHZlY3Rvcik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhwYW5kQnlTY2FsYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhwYW5kQnlTY2FsYXIoc2NhbGFyKSB7XG4gICAgICB0aGlzLm1pbi5hZGRTY2FsYXIoLXNjYWxhcik7XG4gICAgICB0aGlzLm1heC5hZGRTY2FsYXIoc2NhbGFyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250YWluc1BvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgIHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fCBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGFpbnNCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNCb3goYm94KSB7XG4gICAgICByZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiYgdGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4Lnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhcmFtZXRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJhbWV0ZXIocG9pbnQsIHRhcmdldCkge1xuICAgICAgLy8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcbiAgICAgIC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG4gICAgICByZXR1cm4gdGFyZ2V0LnNldCgocG9pbnQueCAtIHRoaXMubWluLngpIC8gKHRoaXMubWF4LnggLSB0aGlzLm1pbi54KSwgKHBvaW50LnkgLSB0aGlzLm1pbi55KSAvICh0aGlzLm1heC55IC0gdGhpcy5taW4ueSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RzQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdHNCb3goYm94KSB7XG4gICAgICAvLyB1c2luZyA0IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9uc1xuICAgICAgcmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsYW1wUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xhbXBQb2ludChwb2ludCwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmNvcHkocG9pbnQpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciBjbGFtcGVkUG9pbnQgPSBfdmVjdG9yJDQuY29weShwb2ludCkuY2xhbXAodGhpcy5taW4sIHRoaXMubWF4KTtcblxuICAgICAgcmV0dXJuIGNsYW1wZWRQb2ludC5zdWIocG9pbnQpLmxlbmd0aCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnNlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJzZWN0KGJveCkge1xuICAgICAgdGhpcy5taW4ubWF4KGJveC5taW4pO1xuICAgICAgdGhpcy5tYXgubWluKGJveC5tYXgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuaW9uKGJveCkge1xuICAgICAgdGhpcy5taW4ubWluKGJveC5taW4pO1xuICAgICAgdGhpcy5tYXgubWF4KGJveC5tYXgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2xhdGUob2Zmc2V0KSB7XG4gICAgICB0aGlzLm1pbi5hZGQob2Zmc2V0KTtcbiAgICAgIHRoaXMubWF4LmFkZChvZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMoYm94KSB7XG4gICAgICByZXR1cm4gYm94Lm1pbi5lcXVhbHModGhpcy5taW4pICYmIGJveC5tYXguZXF1YWxzKHRoaXMubWF4KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm94Mjtcbn0oKTtcblxudmFyIF9zdGFydFAgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9zdGFydEVuZCA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgTGluZTMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5lMygpIHtcbiAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBWZWN0b3IzKCk7XG4gICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjMoKTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5lMyk7XG5cbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGluZTMsIFt7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoc3RhcnQsIGVuZCkge1xuICAgICAgdGhpcy5zdGFydC5jb3B5KHN0YXJ0KTtcbiAgICAgIHRoaXMuZW5kLmNvcHkoZW5kKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkobGluZSkge1xuICAgICAgdGhpcy5zdGFydC5jb3B5KGxpbmUuc3RhcnQpO1xuICAgICAgdGhpcy5lbmQuY29weShsaW5lLmVuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENlbnRlcih0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0YXJnZXQuYWRkVmVjdG9ycyh0aGlzLnN0YXJ0LCB0aGlzLmVuZCkubXVsdGlwbHlTY2FsYXIoMC41KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsdGEodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LnN1YlZlY3RvcnModGhpcy5lbmQsIHRoaXMuc3RhcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVNxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlU3EoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCh0aGlzLmVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyh0aGlzLmVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0KHQsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsdGEodGFyZ2V0KS5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy5zdGFydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcihwb2ludCwgY2xhbXBUb0xpbmUpIHtcbiAgICAgIF9zdGFydFAuc3ViVmVjdG9ycyhwb2ludCwgdGhpcy5zdGFydCk7XG5cbiAgICAgIF9zdGFydEVuZC5zdWJWZWN0b3JzKHRoaXMuZW5kLCB0aGlzLnN0YXJ0KTtcblxuICAgICAgdmFyIHN0YXJ0RW5kMiA9IF9zdGFydEVuZC5kb3QoX3N0YXJ0RW5kKTtcblxuICAgICAgdmFyIHN0YXJ0RW5kX3N0YXJ0UCA9IF9zdGFydEVuZC5kb3QoX3N0YXJ0UCk7XG5cbiAgICAgIHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG4gICAgICBpZiAoY2xhbXBUb0xpbmUpIHtcbiAgICAgICAgdCA9IGNsYW1wKHQsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VzdFBvaW50VG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KHBvaW50LCBjbGFtcFRvTGluZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcihwb2ludCwgY2xhbXBUb0xpbmUpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVsdGEodGFyZ2V0KS5tdWx0aXBseVNjYWxhcih0KS5hZGQodGhpcy5zdGFydCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5TWF0cml4NFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseU1hdHJpeDQobWF0cml4KSB7XG4gICAgICB0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgdGhpcy5lbmQuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXF1YWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyhsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZS5zdGFydC5lcXVhbHModGhpcy5zdGFydCkgJiYgbGluZS5lbmQuZXF1YWxzKHRoaXMuZW5kKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lMztcbn0oKTtcblxudmFyIF92ZWN0b3IkMyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgU3BvdExpZ2h0SGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqZWN0M0QxNCkge1xuICBfaW5oZXJpdHMoU3BvdExpZ2h0SGVscGVyLCBfT2JqZWN0M0QxNCk7XG5cbiAgdmFyIF9zdXBlcjE0MSA9IF9jcmVhdGVTdXBlcihTcG90TGlnaHRIZWxwZXIpO1xuXG4gIGZ1bmN0aW9uIFNwb3RMaWdodEhlbHBlcihsaWdodCwgY29sb3IpIHtcbiAgICB2YXIgX3RoaXMxMTQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BvdExpZ2h0SGVscGVyKTtcblxuICAgIF90aGlzMTE0ID0gX3N1cGVyMTQxLmNhbGwodGhpcyk7XG4gICAgX3RoaXMxMTQubGlnaHQgPSBsaWdodDtcblxuICAgIF90aGlzMTE0LmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICBfdGhpczExNC5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgICBfdGhpczExNC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgX3RoaXMxMTQuY29sb3IgPSBjb2xvcjtcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICB2YXIgcG9zaXRpb25zID0gWzAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEsIDAsIDEsIDAsIDAsIDAsIC0xLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAxLCAwLCAwLCAwLCAwLCAtMSwgMV07XG5cbiAgICBmb3IgKHZhciBfaTM0OSA9IDAsIGogPSAxLCBsID0gMzI7IF9pMzQ5IDwgbDsgX2kzNDkrKywgaisrKSB7XG4gICAgICB2YXIgcDEgPSBfaTM0OSAvIGwgKiBNYXRoLlBJICogMjtcbiAgICAgIHZhciBwMiA9IGogLyBsICogTWF0aC5QSSAqIDI7XG4gICAgICBwb3NpdGlvbnMucHVzaChNYXRoLmNvcyhwMSksIE1hdGguc2luKHAxKSwgMSwgTWF0aC5jb3MocDIpLCBNYXRoLnNpbihwMiksIDEpO1xuICAgIH1cblxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKTtcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgICAgZm9nOiBmYWxzZSxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgX3RoaXMxMTQuY29uZSA9IG5ldyBMaW5lU2VnbWVudHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblxuICAgIF90aGlzMTE0LmFkZChfdGhpczExNC5jb25lKTtcblxuICAgIF90aGlzMTE0LnVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIF90aGlzMTE0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNwb3RMaWdodEhlbHBlciwgW3tcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICB2YXIgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDtcbiAgICAgIHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4odGhpcy5saWdodC5hbmdsZSk7XG4gICAgICB0aGlzLmNvbmUuc2NhbGUuc2V0KGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoKTtcblxuICAgICAgX3ZlY3RvciQzLnNldEZyb21NYXRyaXhQb3NpdGlvbih0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCk7XG5cbiAgICAgIHRoaXMuY29uZS5sb29rQXQoX3ZlY3RvciQzKTtcblxuICAgICAgaWYgKHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNwb3RMaWdodEhlbHBlcjtcbn0oT2JqZWN0M0QpO1xuXG52YXIgX3ZlY3RvciQyID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfYm9uZU1hdHJpeCA9IC8qQF9fUFVSRV9fKi9uZXcgTWF0cml4NCgpO1xuXG52YXIgX21hdHJpeFdvcmxkSW52ID0gLypAX19QVVJFX18qL25ldyBNYXRyaXg0KCk7XG5cbnZhciBTa2VsZXRvbkhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpbmVTZWdtZW50cykge1xuICBfaW5oZXJpdHMoU2tlbGV0b25IZWxwZXIsIF9MaW5lU2VnbWVudHMpO1xuXG4gIHZhciBfc3VwZXIxNDIgPSBfY3JlYXRlU3VwZXIoU2tlbGV0b25IZWxwZXIpO1xuXG4gIGZ1bmN0aW9uIFNrZWxldG9uSGVscGVyKG9iamVjdCkge1xuICAgIHZhciBfdGhpczExNTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTa2VsZXRvbkhlbHBlcik7XG5cbiAgICB2YXIgYm9uZXMgPSBnZXRCb25lTGlzdChvYmplY3QpO1xuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICB2YXIgY29sb3IxID0gbmV3IENvbG9yKDAsIDAsIDEpO1xuICAgIHZhciBjb2xvcjIgPSBuZXcgQ29sb3IoMCwgMSwgMCk7XG5cbiAgICBmb3IgKHZhciBfaTM1MCA9IDA7IF9pMzUwIDwgYm9uZXMubGVuZ3RoOyBfaTM1MCsrKSB7XG4gICAgICB2YXIgYm9uZSA9IGJvbmVzW19pMzUwXTtcblxuICAgICAgaWYgKGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSkge1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKDAsIDAsIDApO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKDAsIDAsIDApO1xuICAgICAgICBjb2xvcnMucHVzaChjb2xvcjEuciwgY29sb3IxLmcsIGNvbG9yMS5iKTtcbiAgICAgICAgY29sb3JzLnB1c2goY29sb3IyLnIsIGNvbG9yMi5nLCBjb2xvcjIuYik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG4gICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZSxcbiAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXMxMTUgPSBfc3VwZXIxNDIuY2FsbCh0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgIF90aGlzMTE1LmlzU2tlbGV0b25IZWxwZXIgPSB0cnVlO1xuICAgIF90aGlzMTE1LnR5cGUgPSAnU2tlbGV0b25IZWxwZXInO1xuICAgIF90aGlzMTE1LnJvb3QgPSBvYmplY3Q7XG4gICAgX3RoaXMxMTUuYm9uZXMgPSBib25lcztcbiAgICBfdGhpczExNS5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gICAgX3RoaXMxMTUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpczExNTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTa2VsZXRvbkhlbHBlciwgW3tcbiAgICBrZXk6IFwidXBkYXRlTWF0cml4V29ybGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcbiAgICAgIHZhciBib25lcyA9IHRoaXMuYm9uZXM7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXG4gICAgICBfbWF0cml4V29ybGRJbnYuY29weSh0aGlzLnJvb3QubWF0cml4V29ybGQpLmludmVydCgpO1xuXG4gICAgICBmb3IgKHZhciBfaTM1MSA9IDAsIGogPSAwOyBfaTM1MSA8IGJvbmVzLmxlbmd0aDsgX2kzNTErKykge1xuICAgICAgICB2YXIgYm9uZSA9IGJvbmVzW19pMzUxXTtcblxuICAgICAgICBpZiAoYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lKSB7XG4gICAgICAgICAgX2JvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhfbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQpO1xuXG4gICAgICAgICAgX3ZlY3RvciQyLnNldEZyb21NYXRyaXhQb3NpdGlvbihfYm9uZU1hdHJpeCk7XG5cbiAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooaiwgX3ZlY3RvciQyLngsIF92ZWN0b3IkMi55LCBfdmVjdG9yJDIueik7XG5cbiAgICAgICAgICBfYm9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKF9tYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQpO1xuXG4gICAgICAgICAgX3ZlY3RvciQyLnNldEZyb21NYXRyaXhQb3NpdGlvbihfYm9uZU1hdHJpeCk7XG5cbiAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooaiArIDEsIF92ZWN0b3IkMi54LCBfdmVjdG9yJDIueSwgX3ZlY3RvciQyLnopO1xuICAgICAgICAgIGogKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUpLCBcInVwZGF0ZU1hdHJpeFdvcmxkXCIsIHRoaXMpLmNhbGwodGhpcywgZm9yY2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTa2VsZXRvbkhlbHBlcjtcbn0oTGluZVNlZ21lbnRzKTtcblxuZnVuY3Rpb24gZ2V0Qm9uZUxpc3Qob2JqZWN0KSB7XG4gIHZhciBib25lTGlzdCA9IFtdO1xuXG4gIGlmIChvYmplY3QuaXNCb25lID09PSB0cnVlKSB7XG4gICAgYm9uZUxpc3QucHVzaChvYmplY3QpO1xuICB9XG5cbiAgZm9yICh2YXIgX2kzNTIgPSAwOyBfaTM1MiA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IF9pMzUyKyspIHtcbiAgICBib25lTGlzdC5wdXNoLmFwcGx5KGJvbmVMaXN0LCBnZXRCb25lTGlzdChvYmplY3QuY2hpbGRyZW5bX2kzNTJdKSk7XG4gIH1cblxuICByZXR1cm4gYm9uZUxpc3Q7XG59XG5cbnZhciBQb2ludExpZ2h0SGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWVzaDMpIHtcbiAgX2luaGVyaXRzKFBvaW50TGlnaHRIZWxwZXIsIF9NZXNoMyk7XG5cbiAgdmFyIF9zdXBlcjE0MyA9IF9jcmVhdGVTdXBlcihQb2ludExpZ2h0SGVscGVyKTtcblxuICBmdW5jdGlvbiBQb2ludExpZ2h0SGVscGVyKGxpZ2h0LCBzcGhlcmVTaXplLCBjb2xvcikge1xuICAgIHZhciBfdGhpczExNjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2ludExpZ2h0SGVscGVyKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBTcGhlcmVHZW9tZXRyeShzcGhlcmVTaXplLCA0LCAyKTtcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgZm9nOiBmYWxzZSxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgX3RoaXMxMTYgPSBfc3VwZXIxNDMuY2FsbCh0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgIF90aGlzMTE2LmxpZ2h0ID0gbGlnaHQ7XG5cbiAgICBfdGhpczExNi5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgX3RoaXMxMTYuY29sb3IgPSBjb2xvcjtcbiAgICBfdGhpczExNi50eXBlID0gJ1BvaW50TGlnaHRIZWxwZXInO1xuICAgIF90aGlzMTE2Lm1hdHJpeCA9IF90aGlzMTE2LmxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIF90aGlzMTE2Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIF90aGlzMTE2LnVwZGF0ZSgpO1xuICAgIC8qXG4gICAgLy8gVE9ETzogZGVsZXRlIHRoaXMgY29tbWVudD9cbiAgICBjb25zdCBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcbiAgICBjb25zdCBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcbiAgICB0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XG4gICAgdGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcbiAgICBjb25zdCBkID0gbGlnaHQuZGlzdGFuY2U7XG4gICAgaWYgKCBkID09PSAwLjAgKSB7XG4gICAgXHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgXHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG4gICAgfVxuICAgIHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcbiAgICAqL1xuXG5cbiAgICByZXR1cm4gX3RoaXMxMTY7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9pbnRMaWdodEhlbHBlciwgW3tcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5jb2xvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcik7XG4gICAgICB9XG4gICAgICAvKlxuICAgICAgY29uc3QgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XG4gICAgICBcdGlmICggZCA9PT0gMC4wICkge1xuICAgICAgXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICBcdH0gZWxzZSB7XG4gICAgICBcdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuICAgICAgXHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG4gICAgICBcdH1cbiAgICAgICovXG5cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9pbnRMaWdodEhlbHBlcjtcbn0oTWVzaCk7XG5cbnZhciBfdmVjdG9yJDEgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF9jb2xvcjEgPSAvKkBfX1BVUkVfXyovbmV3IENvbG9yKCk7XG5cbnZhciBfY29sb3IyID0gLypAX19QVVJFX18qL25ldyBDb2xvcigpO1xuXG52YXIgSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfT2JqZWN0M0QxNSkge1xuICBfaW5oZXJpdHMoSGVtaXNwaGVyZUxpZ2h0SGVscGVyLCBfT2JqZWN0M0QxNSk7XG5cbiAgdmFyIF9zdXBlcjE0NCA9IF9jcmVhdGVTdXBlcihIZW1pc3BoZXJlTGlnaHRIZWxwZXIpO1xuXG4gIGZ1bmN0aW9uIEhlbWlzcGhlcmVMaWdodEhlbHBlcihsaWdodCwgc2l6ZSwgY29sb3IpIHtcbiAgICB2YXIgX3RoaXMxMTc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVtaXNwaGVyZUxpZ2h0SGVscGVyKTtcblxuICAgIF90aGlzMTE3ID0gX3N1cGVyMTQ0LmNhbGwodGhpcyk7XG4gICAgX3RoaXMxMTcubGlnaHQgPSBsaWdodDtcblxuICAgIF90aGlzMTE3LmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICBfdGhpczExNy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgICBfdGhpczExNy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgX3RoaXMxMTcuY29sb3IgPSBjb2xvcjtcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgT2N0YWhlZHJvbkdlb21ldHJ5KHNpemUpO1xuICAgIGdlb21ldHJ5LnJvdGF0ZVkoTWF0aC5QSSAqIDAuNSk7XG4gICAgX3RoaXMxMTcubWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgICAgZm9nOiBmYWxzZSxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgaWYgKF90aGlzMTE3LmNvbG9yID09PSB1bmRlZmluZWQpIF90aGlzMTE3Lm1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uLmNvdW50ICogMyk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7XG5cbiAgICBfdGhpczExNy5hZGQobmV3IE1lc2goZ2VvbWV0cnksIF90aGlzMTE3Lm1hdGVyaWFsKSk7XG5cbiAgICBfdGhpczExNy51cGRhdGUoKTtcblxuICAgIHJldHVybiBfdGhpczExNztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhIZW1pc3BoZXJlTGlnaHRIZWxwZXIsIFt7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5bMF0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5jaGlsZHJlblswXS5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgbWVzaCA9IHRoaXMuY2hpbGRyZW5bMF07XG5cbiAgICAgIGlmICh0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5jb2xvci5zZXQodGhpcy5jb2xvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29sb3JzID0gbWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG5cbiAgICAgICAgX2NvbG9yMS5jb3B5KHRoaXMubGlnaHQuY29sb3IpO1xuXG4gICAgICAgIF9jb2xvcjIuY29weSh0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yKTtcblxuICAgICAgICBmb3IgKHZhciBfaTM1MyA9IDAsIGwgPSBjb2xvcnMuY291bnQ7IF9pMzUzIDwgbDsgX2kzNTMrKykge1xuICAgICAgICAgIHZhciBjb2xvciA9IF9pMzUzIDwgbCAvIDIgPyBfY29sb3IxIDogX2NvbG9yMjtcbiAgICAgICAgICBjb2xvcnMuc2V0WFlaKF9pMzUzLCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIG1lc2gubG9va0F0KF92ZWN0b3IkMS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC5tYXRyaXhXb3JsZCkubmVnYXRlKCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZW1pc3BoZXJlTGlnaHRIZWxwZXI7XG59KE9iamVjdDNEKTtcblxudmFyIEdyaWRIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaW5lU2VnbWVudHMyKSB7XG4gIF9pbmhlcml0cyhHcmlkSGVscGVyLCBfTGluZVNlZ21lbnRzMik7XG5cbiAgdmFyIF9zdXBlcjE0NSA9IF9jcmVhdGVTdXBlcihHcmlkSGVscGVyKTtcblxuICBmdW5jdGlvbiBHcmlkSGVscGVyKCkge1xuICAgIHZhciBfdGhpczExODtcblxuICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxMDtcbiAgICB2YXIgZGl2aXNpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxMDtcbiAgICB2YXIgY29sb3IxID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAweDQ0NDQ0NDtcbiAgICB2YXIgY29sb3IyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAweDg4ODg4ODtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHcmlkSGVscGVyKTtcblxuICAgIGNvbG9yMSA9IG5ldyBDb2xvcihjb2xvcjEpO1xuICAgIGNvbG9yMiA9IG5ldyBDb2xvcihjb2xvcjIpO1xuICAgIHZhciBjZW50ZXIgPSBkaXZpc2lvbnMgLyAyO1xuICAgIHZhciBzdGVwID0gc2l6ZSAvIGRpdmlzaW9ucztcbiAgICB2YXIgaGFsZlNpemUgPSBzaXplIC8gMjtcbiAgICB2YXIgdmVydGljZXMgPSBbXSxcbiAgICAgICAgY29sb3JzID0gW107XG5cbiAgICBmb3IgKHZhciBfaTM1NCA9IDAsIGogPSAwLCBrID0gLWhhbGZTaXplOyBfaTM1NCA8PSBkaXZpc2lvbnM7IF9pMzU0KyssIGsgKz0gc3RlcCkge1xuICAgICAgdmVydGljZXMucHVzaCgtaGFsZlNpemUsIDAsIGssIGhhbGZTaXplLCAwLCBrKTtcbiAgICAgIHZlcnRpY2VzLnB1c2goaywgMCwgLWhhbGZTaXplLCBrLCAwLCBoYWxmU2l6ZSk7XG4gICAgICB2YXIgY29sb3IgPSBfaTM1NCA9PT0gY2VudGVyID8gY29sb3IxIDogY29sb3IyO1xuICAgICAgY29sb3IudG9BcnJheShjb2xvcnMsIGopO1xuICAgICAgaiArPSAzO1xuICAgICAgY29sb3IudG9BcnJheShjb2xvcnMsIGopO1xuICAgICAgaiArPSAzO1xuICAgICAgY29sb3IudG9BcnJheShjb2xvcnMsIGopO1xuICAgICAgaiArPSAzO1xuICAgICAgY29sb3IudG9BcnJheShjb2xvcnMsIGopO1xuICAgICAgaiArPSAzO1xuICAgIH1cblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgICAgdmVydGV4Q29sb3JzOiB0cnVlLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2VcbiAgICB9KTtcbiAgICBfdGhpczExOCA9IF9zdXBlcjE0NS5jYWxsKHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgX3RoaXMxMTgudHlwZSA9ICdHcmlkSGVscGVyJztcbiAgICByZXR1cm4gX3RoaXMxMTg7XG4gIH1cblxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEdyaWRIZWxwZXIpO1xufShMaW5lU2VnbWVudHMpO1xuXG52YXIgUG9sYXJHcmlkSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGluZVNlZ21lbnRzMykge1xuICBfaW5oZXJpdHMoUG9sYXJHcmlkSGVscGVyLCBfTGluZVNlZ21lbnRzMyk7XG5cbiAgdmFyIF9zdXBlcjE0NiA9IF9jcmVhdGVTdXBlcihQb2xhckdyaWRIZWxwZXIpO1xuXG4gIGZ1bmN0aW9uIFBvbGFyR3JpZEhlbHBlcigpIHtcbiAgICB2YXIgX3RoaXMxMTk7XG5cbiAgICB2YXIgcmFkaXVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxMDtcbiAgICB2YXIgcmFkaWFscyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTY7XG4gICAgdmFyIGNpcmNsZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDg7XG4gICAgdmFyIGRpdmlzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogNjQ7XG4gICAgdmFyIGNvbG9yMSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMHg0NDQ0NDQ7XG4gICAgdmFyIGNvbG9yMiA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMHg4ODg4ODg7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9sYXJHcmlkSGVscGVyKTtcblxuICAgIGNvbG9yMSA9IG5ldyBDb2xvcihjb2xvcjEpO1xuICAgIGNvbG9yMiA9IG5ldyBDb2xvcihjb2xvcjIpO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBjb2xvcnMgPSBbXTsgLy8gY3JlYXRlIHRoZSByYWRpYWxzXG5cbiAgICBmb3IgKHZhciBfaTM1NSA9IDA7IF9pMzU1IDw9IHJhZGlhbHM7IF9pMzU1KyspIHtcbiAgICAgIHZhciB2ID0gX2kzNTUgLyByYWRpYWxzICogKE1hdGguUEkgKiAyKTtcbiAgICAgIHZhciB4ID0gTWF0aC5zaW4odikgKiByYWRpdXM7XG4gICAgICB2YXIgeiA9IE1hdGguY29zKHYpICogcmFkaXVzO1xuICAgICAgdmVydGljZXMucHVzaCgwLCAwLCAwKTtcbiAgICAgIHZlcnRpY2VzLnB1c2goeCwgMCwgeik7XG4gICAgICB2YXIgY29sb3IgPSBfaTM1NSAmIDEgPyBjb2xvcjEgOiBjb2xvcjI7XG4gICAgICBjb2xvcnMucHVzaChjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKTtcbiAgICAgIGNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgIH0gLy8gY3JlYXRlIHRoZSBjaXJjbGVzXG5cblxuICAgIGZvciAodmFyIF9pMzU2ID0gMDsgX2kzNTYgPD0gY2lyY2xlczsgX2kzNTYrKykge1xuICAgICAgdmFyIF9jb2xvciA9IF9pMzU2ICYgMSA/IGNvbG9yMSA6IGNvbG9yMjtcblxuICAgICAgdmFyIHIgPSByYWRpdXMgLSByYWRpdXMgLyBjaXJjbGVzICogX2kzNTY7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGl2aXNpb25zOyBqKyspIHtcbiAgICAgICAgLy8gZmlyc3QgdmVydGV4XG4gICAgICAgIHZhciBfdiA9IGogLyBkaXZpc2lvbnMgKiAoTWF0aC5QSSAqIDIpO1xuXG4gICAgICAgIHZhciBfeDEyID0gTWF0aC5zaW4oX3YpICogcjtcblxuICAgICAgICB2YXIgX3ozID0gTWF0aC5jb3MoX3YpICogcjtcblxuICAgICAgICB2ZXJ0aWNlcy5wdXNoKF94MTIsIDAsIF96Myk7XG4gICAgICAgIGNvbG9ycy5wdXNoKF9jb2xvci5yLCBfY29sb3IuZywgX2NvbG9yLmIpOyAvLyBzZWNvbmQgdmVydGV4XG5cbiAgICAgICAgX3YgPSAoaiArIDEpIC8gZGl2aXNpb25zICogKE1hdGguUEkgKiAyKTtcbiAgICAgICAgX3gxMiA9IE1hdGguc2luKF92KSAqIHI7XG4gICAgICAgIF96MyA9IE1hdGguY29zKF92KSAqIHI7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goX3gxMiwgMCwgX3ozKTtcbiAgICAgICAgY29sb3JzLnB1c2goX2NvbG9yLnIsIF9jb2xvci5nLCBfY29sb3IuYik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG4gICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIF90aGlzMTE5ID0gX3N1cGVyMTQ2LmNhbGwodGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICBfdGhpczExOS50eXBlID0gJ1BvbGFyR3JpZEhlbHBlcic7XG4gICAgcmV0dXJuIF90aGlzMTE5O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQb2xhckdyaWRIZWxwZXIpO1xufShMaW5lU2VnbWVudHMpO1xuXG52YXIgX3YxID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfdjIgPSAvKkBfX1BVUkVfXyovbmV3IFZlY3RvcjMoKTtcblxudmFyIF92MyA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX09iamVjdDNEMTYpIHtcbiAgX2luaGVyaXRzKERpcmVjdGlvbmFsTGlnaHRIZWxwZXIsIF9PYmplY3QzRDE2KTtcblxuICB2YXIgX3N1cGVyMTQ3ID0gX2NyZWF0ZVN1cGVyKERpcmVjdGlvbmFsTGlnaHRIZWxwZXIpO1xuXG4gIGZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIobGlnaHQsIHNpemUsIGNvbG9yKSB7XG4gICAgdmFyIF90aGlzMTIwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIpO1xuXG4gICAgX3RoaXMxMjAgPSBfc3VwZXIxNDcuY2FsbCh0aGlzKTtcbiAgICBfdGhpczEyMC5saWdodCA9IGxpZ2h0O1xuXG4gICAgX3RoaXMxMjAubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIF90aGlzMTIwLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIF90aGlzMTIwLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICBfdGhpczEyMC5jb2xvciA9IGNvbG9yO1xuICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHNpemUgPSAxO1xuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShbLXNpemUsIHNpemUsIDAsIHNpemUsIHNpemUsIDAsIHNpemUsIC1zaXplLCAwLCAtc2l6ZSwgLXNpemUsIDAsIC1zaXplLCBzaXplLCAwXSwgMykpO1xuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG4gICAgICBmb2c6IGZhbHNlLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2VcbiAgICB9KTtcbiAgICBfdGhpczEyMC5saWdodFBsYW5lID0gbmV3IExpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcblxuICAgIF90aGlzMTIwLmFkZChfdGhpczEyMC5saWdodFBsYW5lKTtcblxuICAgIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKFswLCAwLCAwLCAwLCAwLCAxXSwgMykpO1xuICAgIF90aGlzMTIwLnRhcmdldExpbmUgPSBuZXcgTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuXG4gICAgX3RoaXMxMjAuYWRkKF90aGlzMTIwLnRhcmdldExpbmUpO1xuXG4gICAgX3RoaXMxMjAudXBkYXRlKCk7XG5cbiAgICByZXR1cm4gX3RoaXMxMjA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGlyZWN0aW9uYWxMaWdodEhlbHBlciwgW3tcbiAgICBrZXk6IFwiZGlzcG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgdGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIF92MS5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC5tYXRyaXhXb3JsZCk7XG5cbiAgICAgIF92Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24odGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQpO1xuXG4gICAgICBfdjMuc3ViVmVjdG9ycyhfdjIsIF92MSk7XG5cbiAgICAgIHRoaXMubGlnaHRQbGFuZS5sb29rQXQoX3YyKTtcblxuICAgICAgaWYgKHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuICAgICAgICB0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KHRoaXMuY29sb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcik7XG4gICAgICAgIHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRhcmdldExpbmUubG9va0F0KF92Mik7XG4gICAgICB0aGlzLnRhcmdldExpbmUuc2NhbGUueiA9IF92My5sZW5ndGgoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcbn0oT2JqZWN0M0QpO1xuXG52YXIgX3ZlY3RvciA9IC8qQF9fUFVSRV9fKi9uZXcgVmVjdG9yMygpO1xuXG52YXIgX2NhbWVyYSA9IC8qQF9fUFVSRV9fKi9uZXcgQ2FtZXJhKCk7XG4vKipcbiAqXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcbiAqXHQtIHN1aXRhYmxlIGZvciBmYXN0IHVwZGF0ZXNcbiAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxuICpcdFx0aHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2xpZ2h0Z2wuanMvYmxvYi9tYXN0ZXIvdGVzdHMvc2hhZG93bWFwLmh0bWxcbiAqL1xuXG5cbnZhciBDYW1lcmFIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaW5lU2VnbWVudHM0KSB7XG4gIF9pbmhlcml0cyhDYW1lcmFIZWxwZXIsIF9MaW5lU2VnbWVudHM0KTtcblxuICB2YXIgX3N1cGVyMTQ4ID0gX2NyZWF0ZVN1cGVyKENhbWVyYUhlbHBlcik7XG5cbiAgZnVuY3Rpb24gQ2FtZXJhSGVscGVyKGNhbWVyYSkge1xuICAgIHZhciBfdGhpczEyMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW1lcmFIZWxwZXIpO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgdmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgIHZhciBwb2ludE1hcCA9IHt9OyAvLyBjb2xvcnNcblxuICAgIHZhciBjb2xvckZydXN0dW0gPSBuZXcgQ29sb3IoMHhmZmFhMDApO1xuICAgIHZhciBjb2xvckNvbmUgPSBuZXcgQ29sb3IoMHhmZjAwMDApO1xuICAgIHZhciBjb2xvclVwID0gbmV3IENvbG9yKDB4MDBhYWZmKTtcbiAgICB2YXIgY29sb3JUYXJnZXQgPSBuZXcgQ29sb3IoMHhmZmZmZmYpO1xuICAgIHZhciBjb2xvckNyb3NzID0gbmV3IENvbG9yKDB4MzMzMzMzKTsgLy8gbmVhclxuXG4gICAgYWRkTGluZSgnbjEnLCAnbjInLCBjb2xvckZydXN0dW0pO1xuICAgIGFkZExpbmUoJ24yJywgJ240JywgY29sb3JGcnVzdHVtKTtcbiAgICBhZGRMaW5lKCduNCcsICduMycsIGNvbG9yRnJ1c3R1bSk7XG4gICAgYWRkTGluZSgnbjMnLCAnbjEnLCBjb2xvckZydXN0dW0pOyAvLyBmYXJcblxuICAgIGFkZExpbmUoJ2YxJywgJ2YyJywgY29sb3JGcnVzdHVtKTtcbiAgICBhZGRMaW5lKCdmMicsICdmNCcsIGNvbG9yRnJ1c3R1bSk7XG4gICAgYWRkTGluZSgnZjQnLCAnZjMnLCBjb2xvckZydXN0dW0pO1xuICAgIGFkZExpbmUoJ2YzJywgJ2YxJywgY29sb3JGcnVzdHVtKTsgLy8gc2lkZXNcblxuICAgIGFkZExpbmUoJ24xJywgJ2YxJywgY29sb3JGcnVzdHVtKTtcbiAgICBhZGRMaW5lKCduMicsICdmMicsIGNvbG9yRnJ1c3R1bSk7XG4gICAgYWRkTGluZSgnbjMnLCAnZjMnLCBjb2xvckZydXN0dW0pO1xuICAgIGFkZExpbmUoJ240JywgJ2Y0JywgY29sb3JGcnVzdHVtKTsgLy8gY29uZVxuXG4gICAgYWRkTGluZSgncCcsICduMScsIGNvbG9yQ29uZSk7XG4gICAgYWRkTGluZSgncCcsICduMicsIGNvbG9yQ29uZSk7XG4gICAgYWRkTGluZSgncCcsICduMycsIGNvbG9yQ29uZSk7XG4gICAgYWRkTGluZSgncCcsICduNCcsIGNvbG9yQ29uZSk7IC8vIHVwXG5cbiAgICBhZGRMaW5lKCd1MScsICd1MicsIGNvbG9yVXApO1xuICAgIGFkZExpbmUoJ3UyJywgJ3UzJywgY29sb3JVcCk7XG4gICAgYWRkTGluZSgndTMnLCAndTEnLCBjb2xvclVwKTsgLy8gdGFyZ2V0XG5cbiAgICBhZGRMaW5lKCdjJywgJ3QnLCBjb2xvclRhcmdldCk7XG4gICAgYWRkTGluZSgncCcsICdjJywgY29sb3JDcm9zcyk7IC8vIGNyb3NzXG5cbiAgICBhZGRMaW5lKCdjbjEnLCAnY24yJywgY29sb3JDcm9zcyk7XG4gICAgYWRkTGluZSgnY24zJywgJ2NuNCcsIGNvbG9yQ3Jvc3MpO1xuICAgIGFkZExpbmUoJ2NmMScsICdjZjInLCBjb2xvckNyb3NzKTtcbiAgICBhZGRMaW5lKCdjZjMnLCAnY2Y0JywgY29sb3JDcm9zcyk7XG5cbiAgICBmdW5jdGlvbiBhZGRMaW5lKGEsIGIsIGNvbG9yKSB7XG4gICAgICBhZGRQb2ludChhLCBjb2xvcik7XG4gICAgICBhZGRQb2ludChiLCBjb2xvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUG9pbnQoaWQsIGNvbG9yKSB7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKDAsIDAsIDApO1xuICAgICAgY29sb3JzLnB1c2goY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG5cbiAgICAgIGlmIChwb2ludE1hcFtpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludE1hcFtpZF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgcG9pbnRNYXBbaWRdLnB1c2godmVydGljZXMubGVuZ3RoIC8gMyAtIDEpO1xuICAgIH1cblxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh2ZXJ0aWNlcywgMykpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcbiAgICBfdGhpczEyMSA9IF9zdXBlcjE0OC5jYWxsKHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgX3RoaXMxMjEudHlwZSA9ICdDYW1lcmFIZWxwZXInO1xuICAgIF90aGlzMTIxLmNhbWVyYSA9IGNhbWVyYTtcbiAgICBpZiAoX3RoaXMxMjEuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgpIF90aGlzMTIxLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgX3RoaXMxMjEubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xuICAgIF90aGlzMTIxLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICBfdGhpczEyMS5wb2ludE1hcCA9IHBvaW50TWFwO1xuXG4gICAgX3RoaXMxMjEudXBkYXRlKCk7XG5cbiAgICByZXR1cm4gX3RoaXMxMjE7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2FtZXJhSGVscGVyLCBbe1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgIHZhciBwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XG4gICAgICB2YXIgdyA9IDEsXG4gICAgICAgICAgaCA9IDE7IC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXggaW52ZXJzZVxuICAgICAgLy8gd29ybGQgbWF0cml4IG11c3QgYmUgaWRlbnRpdHlcblxuICAgICAgX2NhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5jb3B5KHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKTsgLy8gY2VudGVyIC8gdGFyZ2V0XG5cblxuICAgICAgc2V0UG9pbnQoJ2MnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIDAsIC0xKTtcbiAgICAgIHNldFBvaW50KCd0JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAwLCAwLCAxKTsgLy8gbmVhclxuXG4gICAgICBzZXRQb2ludCgnbjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCAtaCwgLTEpO1xuICAgICAgc2V0UG9pbnQoJ24yJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCAtaCwgLTEpO1xuICAgICAgc2V0UG9pbnQoJ24zJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtdywgaCwgLTEpO1xuICAgICAgc2V0UG9pbnQoJ240JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCBoLCAtMSk7IC8vIGZhclxuXG4gICAgICBzZXRQb2ludCgnZjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCAtaCwgMSk7XG4gICAgICBzZXRQb2ludCgnZjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIC1oLCAxKTtcbiAgICAgIHNldFBvaW50KCdmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgLXcsIGgsIDEpO1xuICAgICAgc2V0UG9pbnQoJ2Y0JywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3LCBoLCAxKTsgLy8gdXBcblxuICAgICAgc2V0UG9pbnQoJ3UxJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCB3ICogMC43LCBoICogMS4xLCAtMSk7XG4gICAgICBzZXRQb2ludCgndTInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13ICogMC43LCBoICogMS4xLCAtMSk7XG4gICAgICBzZXRQb2ludCgndTMnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGggKiAyLCAtMSk7IC8vIGNyb3NzXG5cbiAgICAgIHNldFBvaW50KCdjZjEnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIC13LCAwLCAxKTtcbiAgICAgIHNldFBvaW50KCdjZjInLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIHcsIDAsIDEpO1xuICAgICAgc2V0UG9pbnQoJ2NmMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLWgsIDEpO1xuICAgICAgc2V0UG9pbnQoJ2NmNCcsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgaCwgMSk7XG4gICAgICBzZXRQb2ludCgnY24xJywgcG9pbnRNYXAsIGdlb21ldHJ5LCBfY2FtZXJhLCAtdywgMCwgLTEpO1xuICAgICAgc2V0UG9pbnQoJ2NuMicsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgdywgMCwgLTEpO1xuICAgICAgc2V0UG9pbnQoJ2NuMycsIHBvaW50TWFwLCBnZW9tZXRyeSwgX2NhbWVyYSwgMCwgLWgsIC0xKTtcbiAgICAgIHNldFBvaW50KCdjbjQnLCBwb2ludE1hcCwgZ2VvbWV0cnksIF9jYW1lcmEsIDAsIGgsIC0xKTtcbiAgICAgIGdlb21ldHJ5LmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbWVyYUhlbHBlcjtcbn0oTGluZVNlZ21lbnRzKTtcblxuZnVuY3Rpb24gc2V0UG9pbnQocG9pbnQsIHBvaW50TWFwLCBnZW9tZXRyeSwgY2FtZXJhLCB4LCB5LCB6KSB7XG4gIF92ZWN0b3Iuc2V0KHgsIHksIHopLnVucHJvamVjdChjYW1lcmEpO1xuXG4gIHZhciBwb2ludHMgPSBwb2ludE1hcFtwb2ludF07XG5cbiAgaWYgKHBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXG4gICAgZm9yICh2YXIgX2kzNTcgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgX2kzNTcgPCBsOyBfaTM1NysrKSB7XG4gICAgICBwb3NpdGlvbi5zZXRYWVoocG9pbnRzW19pMzU3XSwgX3ZlY3Rvci54LCBfdmVjdG9yLnksIF92ZWN0b3Iueik7XG4gICAgfVxuICB9XG59XG5cbnZhciBfYm94ID0gLypAX19QVVJFX18qL25ldyBCb3gzKCk7XG5cbnZhciBCb3hIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaW5lU2VnbWVudHM1KSB7XG4gIF9pbmhlcml0cyhCb3hIZWxwZXIsIF9MaW5lU2VnbWVudHM1KTtcblxuICB2YXIgX3N1cGVyMTQ5ID0gX2NyZWF0ZVN1cGVyKEJveEhlbHBlcik7XG5cbiAgZnVuY3Rpb24gQm94SGVscGVyKG9iamVjdCkge1xuICAgIHZhciBfdGhpczEyMjtcblxuICAgIHZhciBjb2xvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMHhmZmZmMDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQm94SGVscGVyKTtcblxuICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3XSk7XG4gICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoOCAqIDMpO1xuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoaW5kaWNlcywgMSkpO1xuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpO1xuICAgIF90aGlzMTIyID0gX3N1cGVyMTQ5LmNhbGwodGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZVxuICAgIH0pKTtcbiAgICBfdGhpczEyMi5vYmplY3QgPSBvYmplY3Q7XG4gICAgX3RoaXMxMjIudHlwZSA9ICdCb3hIZWxwZXInO1xuICAgIF90aGlzMTIyLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIF90aGlzMTIyLnVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIF90aGlzMTIyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJveEhlbHBlciwgW3tcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkJveEhlbHBlcjogLnVwZGF0ZSgpIGhhcyBubyBsb25nZXIgYXJndW1lbnRzLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vYmplY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfYm94LnNldEZyb21PYmplY3QodGhpcy5vYmplY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2JveC5pc0VtcHR5KCkpIHJldHVybjtcbiAgICAgIHZhciBtaW4gPSBfYm94Lm1pbjtcbiAgICAgIHZhciBtYXggPSBfYm94Lm1heDtcbiAgICAgIC8qXG4gICAgICBcdDVfX19fNFxuICAgICAgMS9fX18wL3xcbiAgICAgIHwgNl9ffF83XG4gICAgICAyL19fXzMvXG4gICAgICBcdDA6IG1heC54LCBtYXgueSwgbWF4LnpcbiAgICAgIDE6IG1pbi54LCBtYXgueSwgbWF4LnpcbiAgICAgIDI6IG1pbi54LCBtaW4ueSwgbWF4LnpcbiAgICAgIDM6IG1heC54LCBtaW4ueSwgbWF4LnpcbiAgICAgIDQ6IG1heC54LCBtYXgueSwgbWluLnpcbiAgICAgIDU6IG1pbi54LCBtYXgueSwgbWluLnpcbiAgICAgIDY6IG1pbi54LCBtaW4ueSwgbWluLnpcbiAgICAgIDc6IG1heC54LCBtaW4ueSwgbWluLnpcbiAgICAgICovXG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgIHZhciBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xuICAgICAgYXJyYXlbMF0gPSBtYXgueDtcbiAgICAgIGFycmF5WzFdID0gbWF4Lnk7XG4gICAgICBhcnJheVsyXSA9IG1heC56O1xuICAgICAgYXJyYXlbM10gPSBtaW4ueDtcbiAgICAgIGFycmF5WzRdID0gbWF4Lnk7XG4gICAgICBhcnJheVs1XSA9IG1heC56O1xuICAgICAgYXJyYXlbNl0gPSBtaW4ueDtcbiAgICAgIGFycmF5WzddID0gbWluLnk7XG4gICAgICBhcnJheVs4XSA9IG1heC56O1xuICAgICAgYXJyYXlbOV0gPSBtYXgueDtcbiAgICAgIGFycmF5WzEwXSA9IG1pbi55O1xuICAgICAgYXJyYXlbMTFdID0gbWF4Lno7XG4gICAgICBhcnJheVsxMl0gPSBtYXgueDtcbiAgICAgIGFycmF5WzEzXSA9IG1heC55O1xuICAgICAgYXJyYXlbMTRdID0gbWluLno7XG4gICAgICBhcnJheVsxNV0gPSBtaW4ueDtcbiAgICAgIGFycmF5WzE2XSA9IG1heC55O1xuICAgICAgYXJyYXlbMTddID0gbWluLno7XG4gICAgICBhcnJheVsxOF0gPSBtaW4ueDtcbiAgICAgIGFycmF5WzE5XSA9IG1pbi55O1xuICAgICAgYXJyYXlbMjBdID0gbWluLno7XG4gICAgICBhcnJheVsyMV0gPSBtYXgueDtcbiAgICAgIGFycmF5WzIyXSA9IG1pbi55O1xuICAgICAgYXJyYXlbMjNdID0gbWluLno7XG4gICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tT2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgcmVjdXJzaXZlKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihCb3hIZWxwZXIucHJvdG90eXBlKSwgXCJjb3B5XCIsIHRoaXMpLmNhbGwodGhpcywgc291cmNlLCByZWN1cnNpdmUpO1xuXG4gICAgICB0aGlzLm9iamVjdCA9IHNvdXJjZS5vYmplY3Q7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm94SGVscGVyO1xufShMaW5lU2VnbWVudHMpO1xuXG52YXIgQm94M0hlbHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpbmVTZWdtZW50czYpIHtcbiAgX2luaGVyaXRzKEJveDNIZWxwZXIsIF9MaW5lU2VnbWVudHM2KTtcblxuICB2YXIgX3N1cGVyMTUwID0gX2NyZWF0ZVN1cGVyKEJveDNIZWxwZXIpO1xuXG4gIGZ1bmN0aW9uIEJveDNIZWxwZXIoYm94KSB7XG4gICAgdmFyIF90aGlzMTIzO1xuXG4gICAgdmFyIGNvbG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAweGZmZmYwMDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCb3gzSGVscGVyKTtcblxuICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3XSk7XG4gICAgdmFyIHBvc2l0aW9ucyA9IFsxLCAxLCAxLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgMSwgMSwgMSwgLTEsIC0xLCAxLCAtMSwgLTEsIC0xLCAtMSwgMSwgLTEsIC0xXTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeS5zZXRJbmRleChuZXcgQnVmZmVyQXR0cmlidXRlKGluZGljZXMsIDEpKTtcbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG4gICAgX3RoaXMxMjMgPSBfc3VwZXIxNTAuY2FsbCh0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlXG4gICAgfSkpO1xuICAgIF90aGlzMTIzLmJveCA9IGJveDtcbiAgICBfdGhpczEyMy50eXBlID0gJ0JveDNIZWxwZXInO1xuXG4gICAgX3RoaXMxMjMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICByZXR1cm4gX3RoaXMxMjM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQm94M0hlbHBlciwgW3tcbiAgICBrZXk6IFwidXBkYXRlTWF0cml4V29ybGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcbiAgICAgIHZhciBib3ggPSB0aGlzLmJveDtcbiAgICAgIGlmIChib3guaXNFbXB0eSgpKSByZXR1cm47XG4gICAgICBib3guZ2V0Q2VudGVyKHRoaXMucG9zaXRpb24pO1xuICAgICAgYm94LmdldFNpemUodGhpcy5zY2FsZSk7XG4gICAgICB0aGlzLnNjYWxlLm11bHRpcGx5U2NhbGFyKDAuNSk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEJveDNIZWxwZXIucHJvdG90eXBlKSwgXCJ1cGRhdGVNYXRyaXhXb3JsZFwiLCB0aGlzKS5jYWxsKHRoaXMsIGZvcmNlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm94M0hlbHBlcjtcbn0oTGluZVNlZ21lbnRzKTtcblxudmFyIFBsYW5lSGVscGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTGluZTMpIHtcbiAgX2luaGVyaXRzKFBsYW5lSGVscGVyLCBfTGluZTMpO1xuXG4gIHZhciBfc3VwZXIxNTEgPSBfY3JlYXRlU3VwZXIoUGxhbmVIZWxwZXIpO1xuXG4gIGZ1bmN0aW9uIFBsYW5lSGVscGVyKHBsYW5lKSB7XG4gICAgdmFyIF90aGlzMTI0O1xuXG4gICAgdmFyIHNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgdmFyIGhleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMHhmZmZmMDA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhbmVIZWxwZXIpO1xuXG4gICAgdmFyIGNvbG9yID0gaGV4O1xuICAgIHZhciBwb3NpdGlvbnMgPSBbMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIDEsIDEsIDEsIC0xLCAxLCAxLCAtMSwgLTEsIDEsIDEsIC0xLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAwLCAwLCAwXTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSk7XG4gICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG4gICAgX3RoaXMxMjQgPSBfc3VwZXIxNTEuY2FsbCh0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlXG4gICAgfSkpO1xuICAgIF90aGlzMTI0LnR5cGUgPSAnUGxhbmVIZWxwZXInO1xuICAgIF90aGlzMTI0LnBsYW5lID0gcGxhbmU7XG4gICAgX3RoaXMxMjQuc2l6ZSA9IHNpemU7XG4gICAgdmFyIHBvc2l0aW9uczIgPSBbMSwgMSwgMSwgLTEsIDEsIDEsIC0xLCAtMSwgMSwgMSwgMSwgMSwgLTEsIC0xLCAxLCAxLCAtMSwgMV07XG4gICAgdmFyIGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGdlb21ldHJ5Mi5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zMiwgMykpO1xuICAgIGdlb21ldHJ5Mi5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIF90aGlzMTI0LmFkZChuZXcgTWVzaChnZW9tZXRyeTIsIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogY29sb3IsXG4gICAgICBvcGFjaXR5OiAwLjIsXG4gICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2VcbiAgICB9KSkpO1xuXG4gICAgcmV0dXJuIF90aGlzMTI0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBsYW5lSGVscGVyLCBbe1xuICAgIGtleTogXCJ1cGRhdGVNYXRyaXhXb3JsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuICAgICAgdmFyIHNjYWxlID0gLXRoaXMucGxhbmUuY29uc3RhbnQ7XG4gICAgICBpZiAoTWF0aC5hYnMoc2NhbGUpIDwgMWUtOCkgc2NhbGUgPSAxZS04OyAvLyBzaWduIGRvZXMgbm90IG1hdHRlclxuXG4gICAgICB0aGlzLnNjYWxlLnNldCgwLjUgKiB0aGlzLnNpemUsIDAuNSAqIHRoaXMuc2l6ZSwgc2NhbGUpO1xuICAgICAgdGhpcy5jaGlsZHJlblswXS5tYXRlcmlhbC5zaWRlID0gc2NhbGUgPCAwID8gQmFja1NpZGUgOiBGcm9udFNpZGU7IC8vIHJlbmRlcmVyIGZsaXBzIHNpZGUgd2hlbiBkZXRlcm1pbmFudCA8IDA7IGZsaXBwaW5nIG5vdCB3YW50ZWQgaGVyZVxuXG4gICAgICB0aGlzLmxvb2tBdCh0aGlzLnBsYW5lLm5vcm1hbCk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFBsYW5lSGVscGVyLnByb3RvdHlwZSksIFwidXBkYXRlTWF0cml4V29ybGRcIiwgdGhpcykuY2FsbCh0aGlzLCBmb3JjZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBsYW5lSGVscGVyO1xufShMaW5lKTtcblxudmFyIF9heGlzID0gLypAX19QVVJFX18qL25ldyBWZWN0b3IzKCk7XG5cbnZhciBfbGluZUdlb21ldHJ5LCBfY29uZUdlb21ldHJ5O1xuXG52YXIgQXJyb3dIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9PYmplY3QzRDE3KSB7XG4gIF9pbmhlcml0cyhBcnJvd0hlbHBlciwgX09iamVjdDNEMTcpO1xuXG4gIHZhciBfc3VwZXIxNTIgPSBfY3JlYXRlU3VwZXIoQXJyb3dIZWxwZXIpO1xuXG4gIC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcbiAgZnVuY3Rpb24gQXJyb3dIZWxwZXIoKSB7XG4gICAgdmFyIF90aGlzMTI1O1xuXG4gICAgdmFyIGRpciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbmV3IFZlY3RvcjMoMCwgMCwgMSk7XG4gICAgdmFyIG9yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbmV3IFZlY3RvcjMoMCwgMCwgMCk7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICB2YXIgY29sb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDB4ZmZmZjAwO1xuICAgIHZhciBoZWFkTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBsZW5ndGggKiAwLjI7XG4gICAgdmFyIGhlYWRXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogaGVhZExlbmd0aCAqIDAuMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcnJvd0hlbHBlcik7XG5cbiAgICBfdGhpczEyNSA9IF9zdXBlcjE1Mi5jYWxsKHRoaXMpO1xuICAgIF90aGlzMTI1LnR5cGUgPSAnQXJyb3dIZWxwZXInO1xuXG4gICAgaWYgKF9saW5lR2VvbWV0cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX2xpbmVHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgICBfbGluZUdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShbMCwgMCwgMCwgMCwgMSwgMF0sIDMpKTtcblxuICAgICAgX2NvbmVHZW9tZXRyeSA9IG5ldyBDeWxpbmRlckdlb21ldHJ5KDAsIDAuNSwgMSwgNSwgMSk7XG5cbiAgICAgIF9jb25lR2VvbWV0cnkudHJhbnNsYXRlKDAsIC0wLjUsIDApO1xuICAgIH1cblxuICAgIF90aGlzMTI1LnBvc2l0aW9uLmNvcHkob3JpZ2luKTtcblxuICAgIF90aGlzMTI1LmxpbmUgPSBuZXcgTGluZShfbGluZUdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgdG9uZU1hcHBlZDogZmFsc2VcbiAgICB9KSk7XG4gICAgX3RoaXMxMjUubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBfdGhpczEyNS5hZGQoX3RoaXMxMjUubGluZSk7XG5cbiAgICBfdGhpczEyNS5jb25lID0gbmV3IE1lc2goX2NvbmVHZW9tZXRyeSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIHRvbmVNYXBwZWQ6IGZhbHNlXG4gICAgfSkpO1xuICAgIF90aGlzMTI1LmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgX3RoaXMxMjUuYWRkKF90aGlzMTI1LmNvbmUpO1xuXG4gICAgX3RoaXMxMjUuc2V0RGlyZWN0aW9uKGRpcik7XG5cbiAgICBfdGhpczEyNS5zZXRMZW5ndGgobGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGgpO1xuXG4gICAgcmV0dXJuIF90aGlzMTI1O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFycm93SGVscGVyLCBbe1xuICAgIGtleTogXCJzZXREaXJlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGlyZWN0aW9uKGRpcikge1xuICAgICAgLy8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuICAgICAgaWYgKGRpci55ID4gMC45OTk5OSkge1xuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0KDAsIDAsIDAsIDEpO1xuICAgICAgfSBlbHNlIGlmIChkaXIueSA8IC0wLjk5OTk5KSB7XG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoMSwgMCwgMCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYXhpcy5zZXQoZGlyLnosIDAsIC1kaXIueCkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdmFyIHJhZGlhbnMgPSBNYXRoLmFjb3MoZGlyLnkpO1xuICAgICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShfYXhpcywgcmFkaWFucyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgICB2YXIgaGVhZExlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbGVuZ3RoICogMC4yO1xuICAgICAgdmFyIGhlYWRXaWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogaGVhZExlbmd0aCAqIDAuMjtcbiAgICAgIHRoaXMubGluZS5zY2FsZS5zZXQoMSwgTWF0aC5tYXgoMC4wMDAxLCBsZW5ndGggLSBoZWFkTGVuZ3RoKSwgMSk7IC8vIHNlZSAjMTc0NThcblxuICAgICAgdGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgdGhpcy5jb25lLnNjYWxlLnNldChoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCk7XG4gICAgICB0aGlzLmNvbmUucG9zaXRpb24ueSA9IGxlbmd0aDtcbiAgICAgIHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29sb3IoY29sb3IpIHtcbiAgICAgIHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXQoY29sb3IpO1xuICAgICAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldChjb2xvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShzb3VyY2UpIHtcbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKEFycm93SGVscGVyLnByb3RvdHlwZSksIFwiY29weVwiLCB0aGlzKS5jYWxsKHRoaXMsIHNvdXJjZSwgZmFsc2UpO1xuXG4gICAgICB0aGlzLmxpbmUuY29weShzb3VyY2UubGluZSk7XG4gICAgICB0aGlzLmNvbmUuY29weShzb3VyY2UuY29uZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXJyb3dIZWxwZXI7XG59KE9iamVjdDNEKTtcblxudmFyIEF4ZXNIZWxwZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9MaW5lU2VnbWVudHM3KSB7XG4gIF9pbmhlcml0cyhBeGVzSGVscGVyLCBfTGluZVNlZ21lbnRzNyk7XG5cbiAgdmFyIF9zdXBlcjE1MyA9IF9jcmVhdGVTdXBlcihBeGVzSGVscGVyKTtcblxuICBmdW5jdGlvbiBBeGVzSGVscGVyKCkge1xuICAgIHZhciBfdGhpczEyNjtcblxuICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF4ZXNIZWxwZXIpO1xuXG4gICAgdmFyIHZlcnRpY2VzID0gWzAsIDAsIDAsIHNpemUsIDAsIDAsIDAsIDAsIDAsIDAsIHNpemUsIDAsIDAsIDAsIDAsIDAsIDAsIHNpemVdO1xuICAgIHZhciBjb2xvcnMgPSBbMSwgMCwgMCwgMSwgMC42LCAwLCAwLCAxLCAwLCAwLjYsIDEsIDAsIDAsIDAsIDEsIDAsIDAuNiwgMV07XG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKHZlcnRpY2VzLCAzKSk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7XG4gICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXG4gICAgICB0b25lTWFwcGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIF90aGlzMTI2ID0gX3N1cGVyMTUzLmNhbGwodGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICBfdGhpczEyNi50eXBlID0gJ0F4ZXNIZWxwZXInO1xuICAgIHJldHVybiBfdGhpczEyNjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBeGVzSGVscGVyLCBbe1xuICAgIGtleTogXCJzZXRDb2xvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29sb3JzKHhBeGlzQ29sb3IsIHlBeGlzQ29sb3IsIHpBeGlzQ29sb3IpIHtcbiAgICAgIHZhciBjb2xvciA9IG5ldyBDb2xvcigpO1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5O1xuICAgICAgY29sb3Iuc2V0KHhBeGlzQ29sb3IpO1xuICAgICAgY29sb3IudG9BcnJheShhcnJheSwgMCk7XG4gICAgICBjb2xvci50b0FycmF5KGFycmF5LCAzKTtcbiAgICAgIGNvbG9yLnNldCh5QXhpc0NvbG9yKTtcbiAgICAgIGNvbG9yLnRvQXJyYXkoYXJyYXksIDYpO1xuICAgICAgY29sb3IudG9BcnJheShhcnJheSwgOSk7XG4gICAgICBjb2xvci5zZXQoekF4aXNDb2xvcik7XG4gICAgICBjb2xvci50b0FycmF5KGFycmF5LCAxMik7XG4gICAgICBjb2xvci50b0FycmF5KGFycmF5LCAxNSk7XG4gICAgICB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF4ZXNIZWxwZXI7XG59KExpbmVTZWdtZW50cyk7XG5cbnZhciBTaGFwZVBhdGggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGFwZVBhdGgoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYXBlUGF0aCk7XG5cbiAgICB0aGlzLnR5cGUgPSAnU2hhcGVQYXRoJztcbiAgICB0aGlzLmNvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgdGhpcy5zdWJQYXRocyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNoYXBlUGF0aCwgW3tcbiAgICBrZXk6IFwibW92ZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbyh4LCB5KSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBhdGgoKTtcbiAgICAgIHRoaXMuc3ViUGF0aHMucHVzaCh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAgIHRoaXMuY3VycmVudFBhdGgubW92ZVRvKHgsIHkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpbmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lVG8oeCwgeSkge1xuICAgICAgdGhpcy5jdXJyZW50UGF0aC5saW5lVG8oeCwgeSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicXVhZHJhdGljQ3VydmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWFkcmF0aWNDdXJ2ZVRvKGFDUHgsIGFDUHksIGFYLCBhWSkge1xuICAgICAgdGhpcy5jdXJyZW50UGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKGFDUHgsIGFDUHksIGFYLCBhWSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmV6aWVyQ3VydmVUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZXppZXJDdXJ2ZVRvKGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkpIHtcbiAgICAgIHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyhhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzcGxpbmVUaHJ1XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGluZVRocnUocHRzKSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYXRoLnNwbGluZVRocnUocHRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1NoYXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1NoYXBlcyhpc0NDVywgbm9Ib2xlcykge1xuICAgICAgZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKGluU3VicGF0aHMpIHtcbiAgICAgICAgdmFyIHNoYXBlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9pMzU4ID0gMCwgbCA9IGluU3VicGF0aHMubGVuZ3RoOyBfaTM1OCA8IGw7IF9pMzU4KyspIHtcbiAgICAgICAgICB2YXIgX3RtcFBhdGggPSBpblN1YnBhdGhzW19pMzU4XTtcblxuICAgICAgICAgIHZhciBfdG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcblxuICAgICAgICAgIF90bXBTaGFwZS5jdXJ2ZXMgPSBfdG1wUGF0aC5jdXJ2ZXM7XG4gICAgICAgICAgc2hhcGVzLnB1c2goX3RtcFNoYXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFwZXM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKGluUHQsIGluUG9seWdvbikge1xuICAgICAgICB2YXIgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7IC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXG4gICAgICAgIC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2VcbiAgICAgICAgLy8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxuICAgICAgICAvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxuXG4gICAgICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHErKykge1xuICAgICAgICAgIHZhciBlZGdlTG93UHQgPSBpblBvbHlnb25bcF07XG4gICAgICAgICAgdmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bcV07XG4gICAgICAgICAgdmFyIGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xuICAgICAgICAgIHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuICAgICAgICAgIGlmIChNYXRoLmFicyhlZGdlRHkpID4gTnVtYmVyLkVQU0lMT04pIHtcbiAgICAgICAgICAgIC8vIG5vdCBwYXJhbGxlbFxuICAgICAgICAgICAgaWYgKGVkZ2VEeSA8IDApIHtcbiAgICAgICAgICAgICAgZWRnZUxvd1B0ID0gaW5Qb2x5Z29uW3FdO1xuICAgICAgICAgICAgICBlZGdlRHggPSAtZWRnZUR4O1xuICAgICAgICAgICAgICBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uW3BdO1xuICAgICAgICAgICAgICBlZGdlRHkgPSAtZWRnZUR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5QdC55IDwgZWRnZUxvd1B0LnkgfHwgaW5QdC55ID4gZWRnZUhpZ2hQdC55KSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKGluUHQueSA9PT0gZWRnZUxvd1B0LnkpIHtcbiAgICAgICAgICAgICAgaWYgKGluUHQueCA9PT0gZWRnZUxvd1B0LngpIHJldHVybiB0cnVlOyAvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuICAgICAgICAgICAgICAvLyBjb250aW51ZTtcdFx0XHRcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqIChpblB0LnggLSBlZGdlTG93UHQueCkgLSBlZGdlRHggKiAoaW5QdC55IC0gZWRnZUxvd1B0LnkpO1xuICAgICAgICAgICAgICBpZiAocGVycEVkZ2UgPT09IDApIHJldHVybiB0cnVlOyAvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXG4gICAgICAgICAgICAgIGlmIChwZXJwRWRnZSA8IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlOyAvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG4gICAgICAgICAgICBpZiAoaW5QdC55ICE9PSBlZGdlTG93UHQueSkgY29udGludWU7IC8vIHBhcmFsbGVsXG4gICAgICAgICAgICAvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcblxuICAgICAgICAgICAgaWYgKGVkZ2VIaWdoUHQueCA8PSBpblB0LnggJiYgaW5QdC54IDw9IGVkZ2VMb3dQdC54IHx8IGVkZ2VMb3dQdC54IDw9IGluUHQueCAmJiBpblB0LnggPD0gZWRnZUhpZ2hQdC54KSByZXR1cm4gdHJ1ZTsgLy8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXG4gICAgICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDbG9ja1dpc2UgPSBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xuICAgICAgdmFyIHN1YlBhdGhzID0gdGhpcy5zdWJQYXRocztcbiAgICAgIGlmIChzdWJQYXRocy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChub0hvbGVzID09PSB0cnVlKSByZXR1cm4gdG9TaGFwZXNOb0hvbGVzKHN1YlBhdGhzKTtcbiAgICAgIHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGU7XG4gICAgICB2YXIgc2hhcGVzID0gW107XG5cbiAgICAgIGlmIChzdWJQYXRocy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdG1wUGF0aCA9IHN1YlBhdGhzWzBdO1xuICAgICAgICB0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xuICAgICAgICB0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcbiAgICAgICAgc2hhcGVzLnB1c2godG1wU2hhcGUpO1xuICAgICAgICByZXR1cm4gc2hhcGVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG9sZXNGaXJzdCA9ICFpc0Nsb2NrV2lzZShzdWJQYXRoc1swXS5nZXRQb2ludHMoKSk7XG4gICAgICBob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7IC8vIGNvbnNvbGUubG9nKFwiSG9sZXMgZmlyc3RcIiwgaG9sZXNGaXJzdCk7XG5cbiAgICAgIHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XG4gICAgICB2YXIgbmV3U2hhcGVzID0gW107XG4gICAgICB2YXIgbmV3U2hhcGVIb2xlcyA9IFtdO1xuICAgICAgdmFyIG1haW5JZHggPSAwO1xuICAgICAgdmFyIHRtcFBvaW50cztcbiAgICAgIG5ld1NoYXBlc1ttYWluSWR4XSA9IHVuZGVmaW5lZDtcbiAgICAgIG5ld1NoYXBlSG9sZXNbbWFpbklkeF0gPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kzNTkgPSAwLCBsID0gc3ViUGF0aHMubGVuZ3RoOyBfaTM1OSA8IGw7IF9pMzU5KyspIHtcbiAgICAgICAgdG1wUGF0aCA9IHN1YlBhdGhzW19pMzU5XTtcbiAgICAgICAgdG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcbiAgICAgICAgc29saWQgPSBpc0Nsb2NrV2lzZSh0bXBQb2ludHMpO1xuICAgICAgICBzb2xpZCA9IGlzQ0NXID8gIXNvbGlkIDogc29saWQ7XG5cbiAgICAgICAgaWYgKHNvbGlkKSB7XG4gICAgICAgICAgaWYgKCFob2xlc0ZpcnN0ICYmIG5ld1NoYXBlc1ttYWluSWR4XSkgbWFpbklkeCsrO1xuICAgICAgICAgIG5ld1NoYXBlc1ttYWluSWR4XSA9IHtcbiAgICAgICAgICAgIHM6IG5ldyBTaGFwZSgpLFxuICAgICAgICAgICAgcDogdG1wUG9pbnRzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdTaGFwZXNbbWFpbklkeF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcbiAgICAgICAgICBpZiAoaG9sZXNGaXJzdCkgbWFpbklkeCsrO1xuICAgICAgICAgIG5ld1NoYXBlSG9sZXNbbWFpbklkeF0gPSBbXTsgLy9jb25zb2xlLmxvZygnY3cnLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTaGFwZUhvbGVzW21haW5JZHhdLnB1c2goe1xuICAgICAgICAgICAgaDogdG1wUGF0aCxcbiAgICAgICAgICAgIHA6IHRtcFBvaW50c1swXVxuICAgICAgICAgIH0pOyAvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBvbmx5IEhvbGVzPyAtPiBwcm9iYWJseSBhbGwgU2hhcGVzIHdpdGggd3Jvbmcgb3JpZW50YXRpb25cblxuXG4gICAgICBpZiAoIW5ld1NoYXBlc1swXSkgcmV0dXJuIHRvU2hhcGVzTm9Ib2xlcyhzdWJQYXRocyk7XG5cbiAgICAgIGlmIChuZXdTaGFwZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgYW1iaWd1b3VzID0gZmFsc2U7XG4gICAgICAgIHZhciB0b0NoYW5nZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCsrKSB7XG4gICAgICAgICAgYmV0dGVyU2hhcGVIb2xlc1tzSWR4XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX3NJZHggPSAwLCBfc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IF9zSWR4IDwgX3NMZW47IF9zSWR4KyspIHtcbiAgICAgICAgICB2YXIgc2hvID0gbmV3U2hhcGVIb2xlc1tfc0lkeF07XG5cbiAgICAgICAgICBmb3IgKHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHgrKykge1xuICAgICAgICAgICAgdmFyIGhvID0gc2hvW2hJZHhdO1xuICAgICAgICAgICAgdmFyIGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCsrKSB7XG4gICAgICAgICAgICAgIGlmIChpc1BvaW50SW5zaWRlUG9seWdvbihoby5wLCBuZXdTaGFwZXNbczJJZHhdLnApKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9zSWR4ICE9PSBzMklkeCkgdG9DaGFuZ2UrKztcblxuICAgICAgICAgICAgICAgIGlmIChob2xlX3VuYXNzaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgYmV0dGVyU2hhcGVIb2xlc1tzMklkeF0ucHVzaChobyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGFtYmlndW91cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChob2xlX3VuYXNzaWduZWQpIHtcbiAgICAgICAgICAgICAgYmV0dGVyU2hhcGVIb2xlc1tfc0lkeF0ucHVzaChobyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvQ2hhbmdlID4gMCAmJiBhbWJpZ3VvdXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgbmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRtcEhvbGVzO1xuXG4gICAgICBmb3IgKHZhciBfaTM2MCA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgX2kzNjAgPCBpbDsgX2kzNjArKykge1xuICAgICAgICB0bXBTaGFwZSA9IG5ld1NoYXBlc1tfaTM2MF0ucztcbiAgICAgICAgc2hhcGVzLnB1c2godG1wU2hhcGUpO1xuICAgICAgICB0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbX2kzNjBdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICB0bXBTaGFwZS5ob2xlcy5wdXNoKHRtcEhvbGVzW2pdLmgpO1xuICAgICAgICB9XG4gICAgICB9IC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xuXG5cbiAgICAgIHJldHVybiBzaGFwZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoYXBlUGF0aDtcbn0oKTsgLy8gRmFzdCBIYWxmIEZsb2F0IENvbnZlcnNpb25zLCBodHRwOi8vd3d3LmZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXG5cblxudmFyIERhdGFVdGlscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFVdGlscygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVV0aWxzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEYXRhVXRpbHMsIG51bGwsIFt7XG4gICAga2V5OiBcInRvSGFsZkZsb2F0XCIsXG4gICAgdmFsdWU6IC8vIGZsb2F0MzIgdG8gZmxvYXQxNlxuICAgIGZ1bmN0aW9uIHRvSGFsZkZsb2F0KHZhbCkge1xuICAgICAgaWYgKE1hdGguYWJzKHZhbCkgPiA2NTUwNCkgY29uc29sZS53YXJuKCdUSFJFRS5EYXRhVXRpbHMudG9IYWxmRmxvYXQoKTogVmFsdWUgb3V0IG9mIHJhbmdlLicpO1xuICAgICAgdmFsID0gY2xhbXAodmFsLCAtNjU1MDQsIDY1NTA0KTtcbiAgICAgIF9mbG9hdFZpZXdbMF0gPSB2YWw7XG4gICAgICB2YXIgZiA9IF91aW50MzJWaWV3WzBdO1xuICAgICAgdmFyIGUgPSBmID4+IDIzICYgMHgxZmY7XG4gICAgICByZXR1cm4gX2Jhc2VUYWJsZVtlXSArICgoZiAmIDB4MDA3ZmZmZmYpID4+IF9zaGlmdFRhYmxlW2VdKTtcbiAgICB9IC8vIGZsb2F0MTYgdG8gZmxvYXQzMlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbUhhbGZGbG9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSGFsZkZsb2F0KHZhbCkge1xuICAgICAgdmFyIG0gPSB2YWwgPj4gMTA7XG4gICAgICBfdWludDMyVmlld1swXSA9IF9tYW50aXNzYVRhYmxlW19vZmZzZXRUYWJsZVttXSArICh2YWwgJiAweDNmZildICsgX2V4cG9uZW50VGFibGVbbV07XG4gICAgICByZXR1cm4gX2Zsb2F0Vmlld1swXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGF0YVV0aWxzO1xufSgpOyAvLyBmbG9hdDMyIHRvIGZsb2F0MTYgaGVscGVyc1xuXG5cbnZhciBfYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuXG52YXIgX2Zsb2F0VmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoX2J1ZmZlcik7XG5cbnZhciBfdWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheShfYnVmZmVyKTtcblxudmFyIF9iYXNlVGFibGUgPSBuZXcgVWludDMyQXJyYXkoNTEyKTtcblxudmFyIF9zaGlmdFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KDUxMik7XG5cbmZvciAodmFyIF9pMzYxID0gMDsgX2kzNjEgPCAyNTY7ICsrX2kzNjEpIHtcbiAgdmFyIGUgPSBfaTM2MSAtIDEyNzsgLy8gdmVyeSBzbWFsbCBudW1iZXIgKDAsIC0wKVxuXG4gIGlmIChlIDwgLTI3KSB7XG4gICAgX2Jhc2VUYWJsZVtfaTM2MV0gPSAweDAwMDA7XG4gICAgX2Jhc2VUYWJsZVtfaTM2MSB8IDB4MTAwXSA9IDB4ODAwMDtcbiAgICBfc2hpZnRUYWJsZVtfaTM2MV0gPSAyNDtcbiAgICBfc2hpZnRUYWJsZVtfaTM2MSB8IDB4MTAwXSA9IDI0OyAvLyBzbWFsbCBudW1iZXIgKGRlbm9ybSlcbiAgfSBlbHNlIGlmIChlIDwgLTE0KSB7XG4gICAgX2Jhc2VUYWJsZVtfaTM2MV0gPSAweDA0MDAgPj4gLWUgLSAxNDtcbiAgICBfYmFzZVRhYmxlW19pMzYxIHwgMHgxMDBdID0gMHgwNDAwID4+IC1lIC0gMTQgfCAweDgwMDA7XG4gICAgX3NoaWZ0VGFibGVbX2kzNjFdID0gLWUgLSAxO1xuICAgIF9zaGlmdFRhYmxlW19pMzYxIHwgMHgxMDBdID0gLWUgLSAxOyAvLyBub3JtYWwgbnVtYmVyXG4gIH0gZWxzZSBpZiAoZSA8PSAxNSkge1xuICAgIF9iYXNlVGFibGVbX2kzNjFdID0gZSArIDE1IDw8IDEwO1xuICAgIF9iYXNlVGFibGVbX2kzNjEgfCAweDEwMF0gPSBlICsgMTUgPDwgMTAgfCAweDgwMDA7XG4gICAgX3NoaWZ0VGFibGVbX2kzNjFdID0gMTM7XG4gICAgX3NoaWZ0VGFibGVbX2kzNjEgfCAweDEwMF0gPSAxMzsgLy8gbGFyZ2UgbnVtYmVyIChJbmZpbml0eSwgLUluZmluaXR5KVxuICB9IGVsc2UgaWYgKGUgPCAxMjgpIHtcbiAgICBfYmFzZVRhYmxlW19pMzYxXSA9IDB4N2MwMDtcbiAgICBfYmFzZVRhYmxlW19pMzYxIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgIF9zaGlmdFRhYmxlW19pMzYxXSA9IDI0O1xuICAgIF9zaGlmdFRhYmxlW19pMzYxIHwgMHgxMDBdID0gMjQ7IC8vIHN0YXkgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBfYmFzZVRhYmxlW19pMzYxXSA9IDB4N2MwMDtcbiAgICBfYmFzZVRhYmxlW19pMzYxIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgIF9zaGlmdFRhYmxlW19pMzYxXSA9IDEzO1xuICAgIF9zaGlmdFRhYmxlW19pMzYxIHwgMHgxMDBdID0gMTM7XG4gIH1cbn0gLy8gZmxvYXQxNiB0byBmbG9hdDMyIGhlbHBlcnNcblxuXG52YXIgX21hbnRpc3NhVGFibGUgPSBuZXcgVWludDMyQXJyYXkoMjA0OCk7XG5cbnZhciBfZXhwb25lbnRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5cbnZhciBfb2Zmc2V0VGFibGUgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuXG5mb3IgKHZhciBfaTM2MiA9IDE7IF9pMzYyIDwgMTAyNDsgKytfaTM2Mikge1xuICB2YXIgbSA9IF9pMzYyIDw8IDEzOyAvLyB6ZXJvIHBhZCBtYW50aXNzYSBiaXRzXG5cbiAgdmFyIF9lID0gMDsgLy8gemVybyBleHBvbmVudFxuICAvLyBub3JtYWxpemVkXG5cbiAgd2hpbGUgKChtICYgMHgwMDgwMDAwMCkgPT09IDApIHtcbiAgICBtIDw8PSAxO1xuICAgIF9lIC09IDB4MDA4MDAwMDA7IC8vIGRlY3JlbWVudCBleHBvbmVudFxuICB9XG5cbiAgbSAmPSB+MHgwMDgwMDAwMDsgLy8gY2xlYXIgbGVhZGluZyAxIGJpdFxuXG4gIF9lICs9IDB4Mzg4MDAwMDA7IC8vIGFkanVzdCBiaWFzXG5cbiAgX21hbnRpc3NhVGFibGVbX2kzNjJdID0gbSB8IF9lO1xufVxuXG5mb3IgKHZhciBfaTM2MyA9IDEwMjQ7IF9pMzYzIDwgMjA0ODsgKytfaTM2Mykge1xuICBfbWFudGlzc2FUYWJsZVtfaTM2M10gPSAweDM4MDAwMDAwICsgKF9pMzYzIC0gMTAyNCA8PCAxMyk7XG59XG5cbmZvciAodmFyIF9pMzY0ID0gMTsgX2kzNjQgPCAzMTsgKytfaTM2NCkge1xuICBfZXhwb25lbnRUYWJsZVtfaTM2NF0gPSBfaTM2NCA8PCAyMztcbn1cblxuX2V4cG9uZW50VGFibGVbMzFdID0gMHg0NzgwMDAwMDtcbl9leHBvbmVudFRhYmxlWzMyXSA9IDB4ODAwMDAwMDA7XG5cbmZvciAodmFyIF9pMzY1ID0gMzM7IF9pMzY1IDwgNjM7ICsrX2kzNjUpIHtcbiAgX2V4cG9uZW50VGFibGVbX2kzNjVdID0gMHg4MDAwMDAwMCArIChfaTM2NSAtIDMyIDw8IDIzKTtcbn1cblxuX2V4cG9uZW50VGFibGVbNjNdID0gMHhjNzgwMDAwMDtcblxuZm9yICh2YXIgX2kzNjYgPSAxOyBfaTM2NiA8IDY0OyArK19pMzY2KSB7XG4gIGlmIChfaTM2NiAhPT0gMzIpIHtcbiAgICBfb2Zmc2V0VGFibGVbX2kzNjZdID0gMTAyNDtcbiAgfVxufSAvLyByMTMzLCBjNWJiNTQzNDU1NWEzYzNkZGQ3ODQ5NDRhMGExMjRmOTk2ZmM3MjFiXG5cblxudmFyIFBhcmFtZXRyaWNHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckdlb21ldHJ5MTcpIHtcbiAgX2luaGVyaXRzKFBhcmFtZXRyaWNHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5MTcpO1xuXG4gIHZhciBfc3VwZXIxNTQgPSBfY3JlYXRlU3VwZXIoUGFyYW1ldHJpY0dlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBQYXJhbWV0cmljR2VvbWV0cnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcmFtZXRyaWNHZW9tZXRyeSk7XG5cbiAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzbS9nZW9tZXRyaWVzL1BhcmFtZXRyaWNHZW9tZXRyeS5qcycpO1xuICAgIHJldHVybiBfc3VwZXIxNTQuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUGFyYW1ldHJpY0dlb21ldHJ5KTtcbn0oQnVmZmVyR2VvbWV0cnkpOyAvLyByMTMzLCBlYjU4ZmYxNTMxMTkwOTBkM2JiYjI0NDc0ZWEwZmZjNDBjNzBkYzkyXG5cblxudmFyIFRleHRHZW9tZXRyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0J1ZmZlckdlb21ldHJ5MTgpIHtcbiAgX2luaGVyaXRzKFRleHRHZW9tZXRyeSwgX0J1ZmZlckdlb21ldHJ5MTgpO1xuXG4gIHZhciBfc3VwZXIxNTUgPSBfY3JlYXRlU3VwZXIoVGV4dEdlb21ldHJ5KTtcblxuICBmdW5jdGlvbiBUZXh0R2VvbWV0cnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRHZW9tZXRyeSk7XG5cbiAgICBjb25zb2xlLmVycm9yKCdUSFJFRS5UZXh0R2VvbWV0cnkgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzbS9nZW9tZXRyaWVzL1RleHRHZW9tZXRyeS5qcycpO1xuICAgIHJldHVybiBfc3VwZXIxNTUuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVGV4dEdlb21ldHJ5KTtcbn0oQnVmZmVyR2VvbWV0cnkpOyAvLyByMTMzLCBlYjU4ZmYxNTMxMTkwOTBkM2JiYjI0NDc0ZWEwZmZjNDBjNzBkYzkyXG5cblxuZnVuY3Rpb24gRm9udExvYWRlcigpIHtcbiAgY29uc29sZS5lcnJvcignVEhSRUUuRm9udExvYWRlciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanNtL2xvYWRlcnMvRm9udExvYWRlci5qcycpO1xufSAvLyByMTMzLCBlYjU4ZmYxNTMxMTkwOTBkM2JiYjI0NDc0ZWEwZmZjNDBjNzBkYzkyXG5cblxuZnVuY3Rpb24gRm9udCgpIHtcbiAgY29uc29sZS5lcnJvcignVEhSRUUuRm9udCBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanNtL2xvYWRlcnMvRm9udExvYWRlci5qcycpO1xufSAvLyByMTM0LCBkNjVlMGFmMDY2NDRmZTVhODRhNmZjMGUzNzJmNDMxOGY5NWEwNGMwXG5cblxuZnVuY3Rpb24gSW1tZWRpYXRlUmVuZGVyT2JqZWN0KCkge1xuICBjb25zb2xlLmVycm9yKCdUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgaGFzIGJlZW4gcmVtb3ZlZC4nKTtcbn0gLy8gcjEzOCwgNDhiMDVkMzUwMGFjYzA4NGRmNTBiZTliNGM5MDc4MWFkOWI4Y2IxN1xuXG5cbnZhciBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfV2ViR0xSZW5kZXJUYXJnZXQ1KSB7XG4gIF9pbmhlcml0cyhXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0LCBfV2ViR0xSZW5kZXJUYXJnZXQ1KTtcblxuICB2YXIgX3N1cGVyMTU2ID0gX2NyZWF0ZVN1cGVyKFdlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQpO1xuXG4gIGZ1bmN0aW9uIFdlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpczEyNztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KTtcblxuICAgIGNvbnNvbGUuZXJyb3IoJ1RIUkVFLldlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGEgbm9ybWFsIHJlbmRlciB0YXJnZXQgYW5kIHNldCB0aGUgXCJzYW1wbGVzXCIgcHJvcGVydHkgdG8gZ3JlYXRlciAwIHRvIGVuYWJsZSBtdWx0aXNhbXBsaW5nLicpO1xuICAgIF90aGlzMTI3ID0gX3N1cGVyMTU2LmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgX3RoaXMxMjcuc2FtcGxlcyA9IDQ7XG4gICAgcmV0dXJuIF90aGlzMTI3O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhXZWJHTE11bHRpc2FtcGxlUmVuZGVyVGFyZ2V0KTtcbn0oV2ViR0xSZW5kZXJUYXJnZXQpOyAvLyByMTM4LCBmOWNkOWNhYjAzYjdiNjQyNDRlMzA0OTAwYTNhMmVlYWEzYTU4OGNlXG5cblxudmFyIERhdGFUZXh0dXJlMkRBcnJheSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RhdGFBcnJheVRleHR1cmUpIHtcbiAgX2luaGVyaXRzKERhdGFUZXh0dXJlMkRBcnJheSwgX0RhdGFBcnJheVRleHR1cmUpO1xuXG4gIHZhciBfc3VwZXIxNTcgPSBfY3JlYXRlU3VwZXIoRGF0YVRleHR1cmUyREFycmF5KTtcblxuICBmdW5jdGlvbiBEYXRhVGV4dHVyZTJEQXJyYXkoZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YVRleHR1cmUyREFycmF5KTtcblxuICAgIGNvbnNvbGUud2FybignVEhSRUUuRGF0YVRleHR1cmUyREFycmF5IGhhcyBiZWVuIHJlbmFtZWQgdG8gRGF0YUFycmF5VGV4dHVyZS4nKTtcbiAgICByZXR1cm4gX3N1cGVyMTU3LmNhbGwodGhpcywgZGF0YSwgd2lkdGgsIGhlaWdodCwgZGVwdGgpO1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEYXRhVGV4dHVyZTJEQXJyYXkpO1xufShEYXRhQXJyYXlUZXh0dXJlKTsgLy8gcjEzOCwgZjljZDljYWIwM2I3YjY0MjQ0ZTMwNDkwMGEzYTJlZWFhM2E1ODhjZVxuXG5cbnZhciBEYXRhVGV4dHVyZTNEID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRGF0YTNEVGV4dHVyZSkge1xuICBfaW5oZXJpdHMoRGF0YVRleHR1cmUzRCwgX0RhdGEzRFRleHR1cmUpO1xuXG4gIHZhciBfc3VwZXIxNTggPSBfY3JlYXRlU3VwZXIoRGF0YVRleHR1cmUzRCk7XG5cbiAgZnVuY3Rpb24gRGF0YVRleHR1cmUzRChkYXRhLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRhVGV4dHVyZTNEKTtcblxuICAgIGNvbnNvbGUud2FybignVEhSRUUuRGF0YVRleHR1cmUzRCBoYXMgYmVlbiByZW5hbWVkIHRvIERhdGEzRFRleHR1cmUuJyk7XG4gICAgcmV0dXJuIF9zdXBlcjE1OC5jYWxsKHRoaXMsIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoKTtcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGF0YVRleHR1cmUzRCk7XG59KERhdGEzRFRleHR1cmUpO1xuXG5pZiAodHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgX19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdyZWdpc3RlcicsIHtcbiAgICBkZXRhaWw6IHtcbiAgICAgIHJldmlzaW9uOiBSRVZJU0lPTlxuICAgIH1cbiAgfSkpO1xufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHdpbmRvdy5fX1RIUkVFX18pIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IE11bHRpcGxlIGluc3RhbmNlcyBvZiBUaHJlZS5qcyBiZWluZyBpbXBvcnRlZC4nKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuX19USFJFRV9fID0gUkVWSVNJT047XG4gIH1cbn1cblxuZXhwb3J0IHsgQUNFU0ZpbG1pY1RvbmVNYXBwaW5nLCBBZGRFcXVhdGlvbiwgQWRkT3BlcmF0aW9uLCBBZGRpdGl2ZUFuaW1hdGlvbkJsZW5kTW9kZSwgQWRkaXRpdmVCbGVuZGluZywgQWxwaGFGb3JtYXQsIEFsd2F5c0RlcHRoLCBBbHdheXNTdGVuY2lsRnVuYywgQW1iaWVudExpZ2h0LCBBbWJpZW50TGlnaHRQcm9iZSwgQW5pbWF0aW9uQ2xpcCwgQW5pbWF0aW9uTG9hZGVyLCBBbmltYXRpb25NaXhlciwgQW5pbWF0aW9uT2JqZWN0R3JvdXAsIEFuaW1hdGlvblV0aWxzLCBBcmNDdXJ2ZSwgQXJyYXlDYW1lcmEsIEFycm93SGVscGVyLCBBdWRpbywgQXVkaW9BbmFseXNlciwgQXVkaW9Db250ZXh0LCBBdWRpb0xpc3RlbmVyLCBBdWRpb0xvYWRlciwgQXhlc0hlbHBlciwgQmFja1NpZGUsIEJhc2ljRGVwdGhQYWNraW5nLCBCYXNpY1NoYWRvd01hcCwgQm9uZSwgQm9vbGVhbktleWZyYW1lVHJhY2ssIEJveDIsIEJveDMsIEJveDNIZWxwZXIsIEJveEdlb21ldHJ5IGFzIEJveEJ1ZmZlckdlb21ldHJ5LCBCb3hHZW9tZXRyeSwgQm94SGVscGVyLCBCdWZmZXJBdHRyaWJ1dGUsIEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJHZW9tZXRyeUxvYWRlciwgQnl0ZVR5cGUsIENhY2hlLCBDYW1lcmEsIENhbWVyYUhlbHBlciwgQ2FudmFzVGV4dHVyZSwgQ2Fwc3VsZUdlb21ldHJ5IGFzIENhcHN1bGVCdWZmZXJHZW9tZXRyeSwgQ2Fwc3VsZUdlb21ldHJ5LCBDYXRtdWxsUm9tQ3VydmUzLCBDaW5lb25Ub25lTWFwcGluZywgQ2lyY2xlR2VvbWV0cnkgYXMgQ2lyY2xlQnVmZmVyR2VvbWV0cnksIENpcmNsZUdlb21ldHJ5LCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBDbG9jaywgQ29sb3IsIENvbG9yS2V5ZnJhbWVUcmFjaywgQ29sb3JNYW5hZ2VtZW50LCBDb21wcmVzc2VkVGV4dHVyZSwgQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsIENvbmVHZW9tZXRyeSBhcyBDb25lQnVmZmVyR2VvbWV0cnksIENvbmVHZW9tZXRyeSwgQ3ViZUNhbWVyYSwgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsIEN1YmVUZXh0dXJlLCBDdWJlVGV4dHVyZUxvYWRlciwgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcsIEN1YmljQmV6aWVyQ3VydmUsIEN1YmljQmV6aWVyQ3VydmUzLCBDdWJpY0ludGVycG9sYW50LCBDdWxsRmFjZUJhY2ssIEN1bGxGYWNlRnJvbnQsIEN1bGxGYWNlRnJvbnRCYWNrLCBDdWxsRmFjZU5vbmUsIEN1cnZlLCBDdXJ2ZVBhdGgsIEN1c3RvbUJsZW5kaW5nLCBDdXN0b21Ub25lTWFwcGluZywgQ3lsaW5kZXJHZW9tZXRyeSBhcyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LCBDeWxpbmRlckdlb21ldHJ5LCBDeWxpbmRyaWNhbCwgRGF0YTNEVGV4dHVyZSwgRGF0YUFycmF5VGV4dHVyZSwgRGF0YVRleHR1cmUsIERhdGFUZXh0dXJlMkRBcnJheSwgRGF0YVRleHR1cmUzRCwgRGF0YVRleHR1cmVMb2FkZXIsIERhdGFVdGlscywgRGVjcmVtZW50U3RlbmNpbE9wLCBEZWNyZW1lbnRXcmFwU3RlbmNpbE9wLCBEZWZhdWx0TG9hZGluZ01hbmFnZXIsIERlcHRoRm9ybWF0LCBEZXB0aFN0ZW5jaWxGb3JtYXQsIERlcHRoVGV4dHVyZSwgRGlyZWN0aW9uYWxMaWdodCwgRGlyZWN0aW9uYWxMaWdodEhlbHBlciwgRGlzY3JldGVJbnRlcnBvbGFudCwgRG9kZWNhaGVkcm9uR2VvbWV0cnkgYXMgRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnksIERvZGVjYWhlZHJvbkdlb21ldHJ5LCBEb3VibGVTaWRlLCBEc3RBbHBoYUZhY3RvciwgRHN0Q29sb3JGYWN0b3IsIER5bmFtaWNDb3B5VXNhZ2UsIER5bmFtaWNEcmF3VXNhZ2UsIER5bmFtaWNSZWFkVXNhZ2UsIEVkZ2VzR2VvbWV0cnksIEVsbGlwc2VDdXJ2ZSwgRXF1YWxEZXB0aCwgRXF1YWxTdGVuY2lsRnVuYywgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLCBFdWxlciwgRXZlbnREaXNwYXRjaGVyLCBFeHRydWRlR2VvbWV0cnkgYXMgRXh0cnVkZUJ1ZmZlckdlb21ldHJ5LCBFeHRydWRlR2VvbWV0cnksIEZpbGVMb2FkZXIsIEZsYXRTaGFkaW5nLCBGbG9hdDE2QnVmZmVyQXR0cmlidXRlLCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLCBGbG9hdDY0QnVmZmVyQXR0cmlidXRlLCBGbG9hdFR5cGUsIEZvZywgRm9nRXhwMiwgRm9udCwgRm9udExvYWRlciwgRnJhbWVidWZmZXJUZXh0dXJlLCBGcm9udFNpZGUsIEZydXN0dW0sIEdMQnVmZmVyQXR0cmlidXRlLCBHTFNMMSwgR0xTTDMsIEdyZWF0ZXJEZXB0aCwgR3JlYXRlckVxdWFsRGVwdGgsIEdyZWF0ZXJFcXVhbFN0ZW5jaWxGdW5jLCBHcmVhdGVyU3RlbmNpbEZ1bmMsIEdyaWRIZWxwZXIsIEdyb3VwLCBIYWxmRmxvYXRUeXBlLCBIZW1pc3BoZXJlTGlnaHQsIEhlbWlzcGhlcmVMaWdodEhlbHBlciwgSGVtaXNwaGVyZUxpZ2h0UHJvYmUsIEljb3NhaGVkcm9uR2VvbWV0cnkgYXMgSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSwgSWNvc2FoZWRyb25HZW9tZXRyeSwgSW1hZ2VCaXRtYXBMb2FkZXIsIEltYWdlTG9hZGVyLCBJbWFnZVV0aWxzLCBJbW1lZGlhdGVSZW5kZXJPYmplY3QsIEluY3JlbWVudFN0ZW5jaWxPcCwgSW5jcmVtZW50V3JhcFN0ZW5jaWxPcCwgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSwgSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIsIEluc3RhbmNlZE1lc2gsIEludDE2QnVmZmVyQXR0cmlidXRlLCBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSwgSW50OEJ1ZmZlckF0dHJpYnV0ZSwgSW50VHlwZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBJbnRlcnBvbGFudCwgSW50ZXJwb2xhdGVEaXNjcmV0ZSwgSW50ZXJwb2xhdGVMaW5lYXIsIEludGVycG9sYXRlU21vb3RoLCBJbnZlcnRTdGVuY2lsT3AsIEtlZXBTdGVuY2lsT3AsIEtleWZyYW1lVHJhY2ssIExPRCwgTGF0aGVHZW9tZXRyeSBhcyBMYXRoZUJ1ZmZlckdlb21ldHJ5LCBMYXRoZUdlb21ldHJ5LCBMYXllcnMsIExlc3NEZXB0aCwgTGVzc0VxdWFsRGVwdGgsIExlc3NFcXVhbFN0ZW5jaWxGdW5jLCBMZXNzU3RlbmNpbEZ1bmMsIExpZ2h0LCBMaWdodFByb2JlLCBMaW5lLCBMaW5lMywgTGluZUJhc2ljTWF0ZXJpYWwsIExpbmVDdXJ2ZSwgTGluZUN1cnZlMywgTGluZURhc2hlZE1hdGVyaWFsLCBMaW5lTG9vcCwgTGluZVNlZ21lbnRzLCBMaW5lYXJFbmNvZGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJJbnRlcnBvbGFudCwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsIExpbmVhclNSR0JDb2xvclNwYWNlLCBMaW5lYXJUb25lTWFwcGluZywgTG9hZGVyLCBMb2FkZXJVdGlscywgTG9hZGluZ01hbmFnZXIsIExvb3BPbmNlLCBMb29wUGluZ1BvbmcsIExvb3BSZXBlYXQsIEx1bWluYW5jZUFscGhhRm9ybWF0LCBMdW1pbmFuY2VGb3JtYXQsIE1PVVNFLCBNYXRlcmlhbCwgTWF0ZXJpYWxMb2FkZXIsIE1hdGhVdGlscywgTWF0cml4MywgTWF0cml4NCwgTWF4RXF1YXRpb24sIE1lc2gsIE1lc2hCYXNpY01hdGVyaWFsLCBNZXNoRGVwdGhNYXRlcmlhbCwgTWVzaERpc3RhbmNlTWF0ZXJpYWwsIE1lc2hMYW1iZXJ0TWF0ZXJpYWwsIE1lc2hNYXRjYXBNYXRlcmlhbCwgTWVzaE5vcm1hbE1hdGVyaWFsLCBNZXNoUGhvbmdNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBNZXNoVG9vbk1hdGVyaWFsLCBNaW5FcXVhdGlvbiwgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgTWl4T3BlcmF0aW9uLCBNdWx0aXBseUJsZW5kaW5nLCBNdWx0aXBseU9wZXJhdGlvbiwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciwgTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZXZlckRlcHRoLCBOZXZlclN0ZW5jaWxGdW5jLCBOb0JsZW5kaW5nLCBOb0NvbG9yU3BhY2UsIE5vVG9uZU1hcHBpbmcsIE5vcm1hbEFuaW1hdGlvbkJsZW5kTW9kZSwgTm9ybWFsQmxlbmRpbmcsIE5vdEVxdWFsRGVwdGgsIE5vdEVxdWFsU3RlbmNpbEZ1bmMsIE51bWJlcktleWZyYW1lVHJhY2ssIE9iamVjdDNELCBPYmplY3RMb2FkZXIsIE9iamVjdFNwYWNlTm9ybWFsTWFwLCBPY3RhaGVkcm9uR2VvbWV0cnkgYXMgT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5LCBPY3RhaGVkcm9uR2VvbWV0cnksIE9uZUZhY3RvciwgT25lTWludXNEc3RBbHBoYUZhY3RvciwgT25lTWludXNEc3RDb2xvckZhY3RvciwgT25lTWludXNTcmNBbHBoYUZhY3RvciwgT25lTWludXNTcmNDb2xvckZhY3RvciwgT3J0aG9ncmFwaGljQ2FtZXJhLCBQQ0ZTaGFkb3dNYXAsIFBDRlNvZnRTaGFkb3dNYXAsIFBNUkVNR2VuZXJhdG9yLCBQYXJhbWV0cmljR2VvbWV0cnksIFBhdGgsIFBlcnNwZWN0aXZlQ2FtZXJhLCBQbGFuZSwgUGxhbmVHZW9tZXRyeSBhcyBQbGFuZUJ1ZmZlckdlb21ldHJ5LCBQbGFuZUdlb21ldHJ5LCBQbGFuZUhlbHBlciwgUG9pbnRMaWdodCwgUG9pbnRMaWdodEhlbHBlciwgUG9pbnRzLCBQb2ludHNNYXRlcmlhbCwgUG9sYXJHcmlkSGVscGVyLCBQb2x5aGVkcm9uR2VvbWV0cnkgYXMgUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LCBQb2x5aGVkcm9uR2VvbWV0cnksIFBvc2l0aW9uYWxBdWRpbywgUHJvcGVydHlCaW5kaW5nLCBQcm9wZXJ0eU1peGVyLCBRdWFkcmF0aWNCZXppZXJDdXJ2ZSwgUXVhZHJhdGljQmV6aWVyQ3VydmUzLCBRdWF0ZXJuaW9uLCBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LCBSRVZJU0lPTiwgUkdCQURlcHRoUGFja2luZywgUkdCQUZvcm1hdCwgUkdCQUludGVnZXJGb3JtYXQsIFJHQkFfQVNUQ18xMHgxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMHg1X0Zvcm1hdCwgUkdCQV9BU1RDXzEweDZfRm9ybWF0LCBSR0JBX0FTVENfMTB4OF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMF9Gb3JtYXQsIFJHQkFfQVNUQ18xMngxMl9Gb3JtYXQsIFJHQkFfQVNUQ180eDRfRm9ybWF0LCBSR0JBX0FTVENfNXg0X0Zvcm1hdCwgUkdCQV9BU1RDXzV4NV9Gb3JtYXQsIFJHQkFfQVNUQ182eDVfRm9ybWF0LCBSR0JBX0FTVENfNng2X0Zvcm1hdCwgUkdCQV9BU1RDXzh4NV9Gb3JtYXQsIFJHQkFfQVNUQ184eDZfRm9ybWF0LCBSR0JBX0FTVENfOHg4X0Zvcm1hdCwgUkdCQV9CUFRDX0Zvcm1hdCwgUkdCQV9FVEMyX0VBQ19Gb3JtYXQsIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0LCBSR0JBX1MzVENfRFhUMV9Gb3JtYXQsIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCwgUkdCQV9TM1RDX0RYVDVfRm9ybWF0LCBSR0JGb3JtYXQsIFJHQl9FVEMxX0Zvcm1hdCwgUkdCX0VUQzJfRm9ybWF0LCBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCwgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQsIFJHQl9TM1RDX0RYVDFfRm9ybWF0LCBSR0Zvcm1hdCwgUkdJbnRlZ2VyRm9ybWF0LCBSYXdTaGFkZXJNYXRlcmlhbCwgUmF5LCBSYXljYXN0ZXIsIFJlY3RBcmVhTGlnaHQsIFJlZEZvcm1hdCwgUmVkSW50ZWdlckZvcm1hdCwgUmVpbmhhcmRUb25lTWFwcGluZywgUmVwZWF0V3JhcHBpbmcsIFJlcGxhY2VTdGVuY2lsT3AsIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uLCBSaW5nR2VvbWV0cnkgYXMgUmluZ0J1ZmZlckdlb21ldHJ5LCBSaW5nR2VvbWV0cnksIFNSR0JDb2xvclNwYWNlLCBTY2VuZSwgU2hhZGVyQ2h1bmssIFNoYWRlckxpYiwgU2hhZGVyTWF0ZXJpYWwsIFNoYWRvd01hdGVyaWFsLCBTaGFwZSwgU2hhcGVHZW9tZXRyeSBhcyBTaGFwZUJ1ZmZlckdlb21ldHJ5LCBTaGFwZUdlb21ldHJ5LCBTaGFwZVBhdGgsIFNoYXBlVXRpbHMsIFNob3J0VHlwZSwgU2tlbGV0b24sIFNrZWxldG9uSGVscGVyLCBTa2lubmVkTWVzaCwgU21vb3RoU2hhZGluZywgU291cmNlLCBTcGhlcmUsIFNwaGVyZUdlb21ldHJ5IGFzIFNwaGVyZUJ1ZmZlckdlb21ldHJ5LCBTcGhlcmVHZW9tZXRyeSwgU3BoZXJpY2FsLCBTcGhlcmljYWxIYXJtb25pY3MzLCBTcGxpbmVDdXJ2ZSwgU3BvdExpZ2h0LCBTcG90TGlnaHRIZWxwZXIsIFNwcml0ZSwgU3ByaXRlTWF0ZXJpYWwsIFNyY0FscGhhRmFjdG9yLCBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yLCBTcmNDb2xvckZhY3RvciwgU3RhdGljQ29weVVzYWdlLCBTdGF0aWNEcmF3VXNhZ2UsIFN0YXRpY1JlYWRVc2FnZSwgU3RlcmVvQ2FtZXJhLCBTdHJlYW1Db3B5VXNhZ2UsIFN0cmVhbURyYXdVc2FnZSwgU3RyZWFtUmVhZFVzYWdlLCBTdHJpbmdLZXlmcmFtZVRyYWNrLCBTdWJ0cmFjdEVxdWF0aW9uLCBTdWJ0cmFjdGl2ZUJsZW5kaW5nLCBUT1VDSCwgVGFuZ2VudFNwYWNlTm9ybWFsTWFwLCBUZXRyYWhlZHJvbkdlb21ldHJ5IGFzIFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnksIFRldHJhaGVkcm9uR2VvbWV0cnksIFRleHRHZW9tZXRyeSwgVGV4dHVyZSwgVGV4dHVyZUxvYWRlciwgVG9ydXNHZW9tZXRyeSBhcyBUb3J1c0J1ZmZlckdlb21ldHJ5LCBUb3J1c0dlb21ldHJ5LCBUb3J1c0tub3RHZW9tZXRyeSBhcyBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSwgVG9ydXNLbm90R2VvbWV0cnksIFRyaWFuZ2xlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFRyaWFuZ2xlc0RyYXdNb2RlLCBUdWJlR2VvbWV0cnkgYXMgVHViZUJ1ZmZlckdlb21ldHJ5LCBUdWJlR2VvbWV0cnksIFVWTWFwcGluZywgVWludDE2QnVmZmVyQXR0cmlidXRlLCBVaW50MzJCdWZmZXJBdHRyaWJ1dGUsIFVpbnQ4QnVmZmVyQXR0cmlidXRlLCBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUsIFVuaWZvcm0sIFVuaWZvcm1zTGliLCBVbmlmb3Jtc1V0aWxzLCBVbnNpZ25lZEJ5dGVUeXBlLCBVbnNpZ25lZEludDI0OFR5cGUsIFVuc2lnbmVkSW50VHlwZSwgVW5zaWduZWRTaG9ydDQ0NDRUeXBlLCBVbnNpZ25lZFNob3J0NTU1MVR5cGUsIFVuc2lnbmVkU2hvcnRUeXBlLCBWU01TaGFkb3dNYXAsIFZlY3RvcjIsIFZlY3RvcjMsIFZlY3RvcjQsIFZlY3RvcktleWZyYW1lVHJhY2ssIFZpZGVvVGV4dHVyZSwgV2ViR0wxUmVuZGVyZXIsIFdlYkdMM0RSZW5kZXJUYXJnZXQsIFdlYkdMQXJyYXlSZW5kZXJUYXJnZXQsIFdlYkdMQ3ViZVJlbmRlclRhcmdldCwgV2ViR0xNdWx0aXBsZVJlbmRlclRhcmdldHMsIFdlYkdMTXVsdGlzYW1wbGVSZW5kZXJUYXJnZXQsIFdlYkdMUmVuZGVyVGFyZ2V0LCBXZWJHTFJlbmRlcmVyLCBXZWJHTFV0aWxzLCBXaXJlZnJhbWVHZW9tZXRyeSwgV3JhcEFyb3VuZEVuZGluZywgWmVyb0N1cnZhdHVyZUVuZGluZywgWmVyb0ZhY3RvciwgWmVyb1Nsb3BlRW5kaW5nLCBaZXJvU3RlbmNpbE9wLCBfU1JHQkFGb3JtYXQsIHNSR0JFbmNvZGluZyB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3456\n')}}]);